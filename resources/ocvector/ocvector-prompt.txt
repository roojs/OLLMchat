You are analyzing {language} code. The code below is written in the {language} programming language. Extract structured information from this {language} code for semantic search indexing.

## CRITICAL REQUIREMENTS - ACCURACY IS PARAMOUNT

**EXTRACTION PROCESS - FOLLOW THESE STEPS:**

1. **FIRST: Scan the code line-by-line** to identify what actually exists
2. **SECOND: For each element you find**, verify it is a complete declaration/definition (not a call, reference, or partial name)
3. **THIRD: Only then** extract the element's details

**DO NOT HALLUCINATE OR INVENT CODE ELEMENTS:**
- Extract ONLY elements that actually exist in the provided code
- Do NOT invent, infer, or assume methods, functions, or properties that are not explicitly present
- Do NOT add methods from standard libraries or frameworks unless they are explicitly imported and used in the code
- If an element is not clearly visible in the code, do NOT include it
- Verify each element's name and signature match exactly what appears in the code at the specified line numbers
- When in doubt, exclude the element rather than include a potentially incorrect one

**VERIFICATION REQUIREMENTS:**
- Before including any element, verify it exists verbatim in the code
- Line numbers must point to the actual declaration/definition of the element (not where it's called or referenced)
- Signatures must match exactly what appears in the code
- Element names must be exact matches to what is written in the source code
- Do NOT infer methods that "should" exist based on patterns or conventions
- Do NOT include methods that are only called but not defined in this file

**WHAT TO EXCLUDE:**
- Methods that are only called (e.g., `obj.someMethod()`) but not defined in the code
- Methods from imported libraries that aren't explicitly shown in the code
- Methods that "should" exist based on class patterns but aren't actually present
- Properties that are only referenced but not declared

**REMEMBER:** It is better to miss a real element than to include a hallucinated one. Accuracy over completeness. If you cannot see the complete declaration/definition in the code, do NOT include it.

## OUTPUT REQUIREMENTS
- Output ONLY valid JSON matching the provided schema
- No explanatory text, markdown, or additional commentary
- Ensure all JSON is properly formatted and escaped

## ANALYSIS INSTRUCTIONS

### FILE-LEVEL INFORMATION
- Write a concise one-paragraph summary of the file's purpose
- List all import/using/include statements with their line numbers

### FOR EACH CODE ELEMENT

**IMPORTANT:** Only extract elements where you can see the COMPLETE declaration or definition in the code. Do not extract elements that are only referenced or called.

Extract the following for each class, function, method, property, field, struct, interface, enum, namespace, constructor, delegate, signal, constant, and other significant elements that are DECLARED or DEFINED in the code:

**Identification:**
- Element type (class, method, property, etc.)
- Name
- Access modifier (public, private, protected, etc.)
- Exact line numbers (start and end, 1-indexed)
- Complete signature/declaration

**Documentation:**
- Clear description of what the element does and its purpose
- Extract documentation comments if present

**For Functions/Methods:**
- Parameters: names and types
- Return type (use "void" or "None" for no return)

**For Classes/Structs:**
- Properties/fields: names, types, and accessors (get/set/init)
- Include all properties, fields, methods, and nested types as separate elements

**Relationships:**
- Inheritance (extends, implements)
- Type usage in parameters, returns, or properties
- Method/function calls within the element
- External module dependencies

## SPECIAL CASES

- **Properties**: Include as separate elements with property-type "property"
- **Fields**: Include as separate elements with property-type "field"
- **Constructors**: Include as separate elements with property-type "constructor"
- **Nested types**: Include as separate elements

## QUALITY CHECKS

Before outputting JSON, verify:
1. All required fields are present
2. Line numbers are accurate and 1-indexed
3. Descriptions are informative but concise
4. JSON is valid and properly structured
5. Each element's name and signature appear verbatim in the code at the specified lines

## EXAMPLES - WHAT TO DO AND NOT DO

**CORRECT:** If you see `public void processData(string input) { ... }` at line 42, extract it as a method.

**INCORRECT:** If you see `obj.processData(data)` at line 50 (a method call), do NOT extract `processData` as a method unless you also see its definition in the code.

**CORRECT:** If you see `public class MyClass { ... }` at lines 10-20, extract it as a class.

**INCORRECT:** If you see `MyClass obj = new MyClass()` (instantiation), do NOT extract `MyClass` unless you see its definition in this file.

**REMEMBER:** Only extract what is DECLARED or DEFINED, not what is CALLED or REFERENCED.

Format the response as JSON matching this schema:
{
    "summary": "overall file summary",
    "imports": [
        {"module": "module_name", "line": 1}
    ],
    "elements": [
        {
            "property-type": "class|function|method|property|field|struct|interface|enum|namespace|constructor|delegate|signal|constant",
            "name": "element_name",
            "access-modifier": "public|private|protected|internal|package|default",
            "start-line": number,
            "end-line": number,
            "signature": "full declaration",
            "description": "what it does",
            "parameters": [
                {"name": "param1", "argument-type": "string"}
            ],
            "return-type": "return_type",
            "properties": [
                {"name": "prop1", "value-type": "string", "accessors": ["get", "set"]}
            ],
            "dependencies": [
                {"relationship-type": "inherits", "target": "BaseClass"}
            ]
        }
    ]
}

Code:
{code}
