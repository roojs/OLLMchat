/*
 * Copyright (C) 2025 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMvector
{
	/**
	 * Represents vector metadata stored in SQL database.
	 * 
	 * Maps vector_id (from FAISS) to code location information. This class
	 * provides the link between vector embeddings in FAISS and actual code
	 * locations in source files. Used by both the indexing pipeline (to store
	 * metadata) and search operations (to retrieve code snippets).
	 * 
	 * The class uses SQ.Query for database operations and provides methods
	 * for querying metadata by file_id, element_type, and other filters.
	 * 
	 * == Usage Example ==
	 * 
	 * {{{
	 * // Initialize database schema
	 * VectorMetadata.initDB(sql_db);
	 * 
	 * // Create metadata entry
	 * var metadata = new VectorMetadata() {
	 *     vector_id = 123,
	 *     file_id = file.id,
	 *     start_line = 10,
	 *     end_line = 25,
	 *     element_type = "method",
	 *     element_name = "process_data"
	 * };
	 * metadata.insert(sql_db);
	 * 
	 * // Query metadata
	 * var query = VectorMetadata.query(sql_db);
	 * var results = query.select("SELECT * FROM vector_metadata WHERE file_id = $file_id");
	 * }}}
	 */
	public class VectorMetadata : Object
	{
		/**
		 * ID property for database operations (PRIMARY KEY, auto-increment).
		 * Used by SQ.Query.updateById/deleteId for database operations.
		 * This is automatically generated by the database and should not be set manually.
		 */
		public int64 id { get; set; default = 0; }
		
		/**
		 * Vector ID from FAISS index.
		 * This is the actual property used throughout the codebase for vector operations.
		 * This is separate from the database id and represents the FAISS vector index.
		 */
		public int64 vector_id { get; set; default = 0; }
		
		/**
		 * File ID (references OLLMfiles.File.id).
		 */
		public int64 file_id { get; set; default = 0; }
		
		/**
		 * Starting line number (1-indexed).
		 */
		public int start_line { get; set; default = 0; }
		
		/**
		 * Ending line number (1-indexed).
		 */
		public int end_line { get; set; default = 0; }
		
		/**
		 * Element type (e.g., "class", "method", "function", "property", etc.).
		 */
		public string element_type { get; set; default = ""; }
		
		/**
		 * Element name (e.g., "DatabaseManager", "execute_query", etc.).
		 */
		public string element_name { get; set; default = ""; }
		
		/**
		 * Starting line number of documentation block (1-indexed, optional).
		 * Not stored in database - used for analysis only.
		 * Use -1 to indicate no documentation.
		 */
		public int codedoc_start { get; set; default = -1; }
		
		/**
		 * Ending line number of documentation block (1-indexed, optional).
		 * Not stored in database - used for analysis only.
		 * Use -1 to indicate no documentation.
		 */
		public int codedoc_end { get; set; default = -1; }
		
		/**
		 * Element signature (e.g., "public async void parse() throws GLib.Error").
		 * Not stored in database - used for analysis only.
		 */
		public string signature { get; set; default = ""; }
		
		/**
		 * Namespace that contains this element (e.g., "OLLMvector.Indexing").
		 * Not stored in database - used for analysis only.
		 */
		public string namespace { get; set; default = ""; }
		
		/**
		 * Parent class/struct/interface that contains this element (e.g., "Tree").
		 * Not stored in database - used for analysis only.
		 */
		public string parent_class { get; set; default = ""; }
		
		/**
		 * One-line description generated by LLM analysis.
		 * Stored in database for future rebuild operations.
		 * Empty string if LLM analysis was skipped (e.g., for simple properties, enum types without docs).
		 */
		public string description { get; set; default = ""; }
		
		/**
		 * Constructor.
		 */
		public VectorMetadata()
		{
		}
		
		/**
		 * Initialize database table for vector_metadata objects.
		 */
		public static void initDB(SQ.Database db)
		{
			string errmsg;
			// Note: Foreign key constraint removed - file_id references OLLMfiles.File.id
			// but the exact table name/structure may vary. The relationship is maintained
			// at the application level.
			var query = "CREATE TABLE IF NOT EXISTS vector_metadata (" +
				"id INTEGER PRIMARY KEY AUTOINCREMENT, " +
				"vector_id INTEGER NOT NULL, " +
				"file_id INTEGER NOT NULL, " +
				"start_line INTEGER NOT NULL, " +
				"end_line INTEGER NOT NULL, " +
				"element_type TEXT NOT NULL, " +
				"element_name TEXT NOT NULL, " +
				"description TEXT NOT NULL DEFAULT ''" +
				");";
			if (Sqlite.OK != db.db.exec(query, null, out errmsg)) {
				GLib.warning("Failed to create vector_metadata table: %s", db.db.errmsg());
			}
			
			// Create indexes for efficient lookups
			if (Sqlite.OK != db.db.exec(
				"CREATE INDEX IF NOT EXISTS idx_vector_metadata_file_id ON vector_metadata(file_id);",
				null,
				out errmsg
			)) {
				GLib.warning("Failed to create index: %s", db.db.errmsg());
			}
			if (Sqlite.OK != db.db.exec(
				"CREATE INDEX IF NOT EXISTS idx_vector_metadata_vector_id ON vector_metadata(vector_id);",
				null,
				out errmsg
			)) {
				GLib.warning("Failed to create index: %s", db.db.errmsg());
			}
		}
		
		/**
		 * Create a query object for vector_metadata table.
		 * 
		 * @param db The database instance
		 * @return A configured Query object ready to use
		 */
		public static SQ.Query<VectorMetadata> query(SQ.Database db)
		{
			return new SQ.Query<VectorMetadata>(db, "vector_metadata");
		}
		
		/**
		 * Save this VectorMetadata to the database.
		 * 
		 * @param db The database instance
		 * @param sync Whether to sync database to disk after save
		 */
		public void saveToDB(SQ.Database db, bool sync = false)
		{
			var sq = VectorMetadata.query(db);
			if (this.id <= 0) {
				// Insert new record - id will be auto-generated by database
				this.id = sq.insert(this);
			} else {
				// Update existing record
				sq.updateById(this);
			}
			
			// Backup in-memory database to disk only if sync is true
			if (sync) {
				db.backupDB();
			}
		}
		
		/**
		 * Remove this VectorMetadata from the database.
		 * 
		 * @param db The database instance
		 */
		public void removeFromDB(SQ.Database db)
		{
			if (this.id <= 0) {
				return;
			}
			VectorMetadata.query(db).deleteId(this.id);
		}
		
		/**
		 * Generic lookup method for vector metadata.
		 * 
		 * @param db The database instance
		 * @param key The column name to search (e.g., "id", "vector_id", "file_id")
		 * @param value The value to search for
		 * @return VectorMetadata object, or null if not found
		 */
		public static VectorMetadata? lookup(
			SQ.Database db,
			string key,
			int64 value
		)
		{
			var results = new Gee.ArrayList<VectorMetadata>();
			VectorMetadata.query(db).select("WHERE " + key + " = " + value.to_string(), results);
			if (results.size > 0) {
				return results[0];
			}
			return null;
		}
		
		/**
		 * Lookup metadata for multiple vector_ids (for search results).
		 * 
		 * @param db The database instance
		 * @param vector_ids Array of vector IDs to lookup
		 * @return List of VectorMetadata objects, ordered by id
		 */
		public static Gee.ArrayList<VectorMetadata> lookup_vectors(
			SQ.Database db,
			int64[] vector_ids
		)
		{
			if (vector_ids.length == 0) {
				return new Gee.ArrayList<VectorMetadata>();
			}
			
			// Build WHERE clause with OR conditions
			var conditions = new Gee.ArrayList<string>();
			for (int i = 0; i < vector_ids.length; i++) {
				conditions.add("vector_id = " + vector_ids[i].to_string());
			}
			
			var results = new Gee.ArrayList<VectorMetadata>();
			VectorMetadata.query(db).select(
				"WHERE " + string.joinv(" OR ", conditions.to_array()),
				results
			);
			return results;
		}
		
		/**
		 * Get all vector_ids from the metadata table.
		 * 
		 * @param db The database instance
		 * @return Set of all vector_ids that have metadata entries
		 */
		public static Gee.HashSet<int64?> get_all_vector_ids(SQ.Database db)
		{
			var results = new Gee.ArrayList<VectorMetadata>();
			VectorMetadata.query(db).select("", results);
			
			var vector_ids = new Gee.HashSet<int64?>();
			foreach (var metadata in results) {
				vector_ids.add(metadata.vector_id);
			}
			return vector_ids;
		}
		
		/**
		 * Resets the vector database.
		 * 
		 * Deletes the FAISS vector database file (if it exists), deletes all vector metadata,
		 * and resets all file scan dates to -1.
		 * 
		 * @param sql_db The SQLite database
		 * @param vector_db_path Path to the FAISS vector database file
		 */
		public static void reset_database(SQ.Database sql_db, string vector_db_path) throws GLib.Error
		{
			// Delete FAISS vector database file (ignore if doesn't exist)
			var vector_db_file = GLib.File.new_for_path(vector_db_path);
			if (vector_db_file.query_exists()) {
				vector_db_file.delete();
			}
			
			// Delete metadata and reset scan dates
			sql_db.exec("DELETE FROM vector_metadata");
			sql_db.exec("UPDATE filebase SET last_vector_scan = -1 WHERE base_type = 'f'");
			
			// Sync database to disk after reset
			sql_db.backupDB();
		}
		
		/**
		 * Remove vector_metadata entries for all deleted files.
		 * 
		 * Uses a bulk DELETE query to efficiently remove all vector_metadata entries
		 * that reference deleted files. Only removes metadata for files (base_type = 'f'),
		 * not folders.
		 * 
		 * Called automatically via DeleteManager.on_cleanup signal after
		 * DeleteManager.cleanup() completes.
		 * 
		 * Can also be called on startup or periodically to ensure consistency.
		 * 
		 * @param db The database instance
		 */
		public static async void cleanup_all_deleted(SQ.Database db)
		{
			// Bulk DELETE query: remove all vector_metadata entries for deleted files
			// Only delete metadata for files (base_type = 'f'), not folders
			var delete_query = "DELETE FROM vector_metadata WHERE file_id IN (" +
				"SELECT id FROM filebase WHERE delete_id > 0 AND base_type = 'f'" +
				")";
			
			string errmsg;
			if (Sqlite.OK != db.db.exec(delete_query, null, out errmsg)) {
				GLib.warning("VectorMetadata.cleanup_all_deleted: Failed to delete metadata: %s", errmsg);
				return;
			}
			
			// Sync database to disk after cleanup
			db.backupDB();
		}
	}
}
