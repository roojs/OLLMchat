# Table support Phase 6: BlockMap parser (1.10.6)

Part of the phased implementation for markdown table support; see **1.8.2-table-support-current-design.md** for the overall design and phase order. Depends on **1.10.5-DONE-calling-code-types.md** (Parser calling code).

Code in this plan follows **.cursor/rules/CODING_STANDARDS.md** (no one-use temporaries or trivial aliases; `this.` for instance members; `GLib.` prefix; brace style; no character loops; regex for separator check).

---

## Goal

Implement table detection in **BlockMap** so that a line starting with `|` is only treated as a table after we have 3 full lines ending with `|`. Add `"|"` = TABLE to the marker map; in `peek()`, add a branch for `matched_block == TABLE`: return -1 until we have 3 full lines ending with `|`; then set `byte_length` to those 3 lines (including newlines) and return; else return 0 so the content is treated as regular formatting.

## File

`libocmarkdown/BlockMap.vala`

---

## 1. Add TABLE to the static marker map

**Location:** Inside the `static construct` block, in the same `mp[...] = ...` section as other block markers (e.g. after the blockquote entries, before the closing `}` of `static construct`).

**Code to add:**

```vala
// Table: | at line start (validated in peek() with 3-line rule)
mp["|"] = FormatType.TABLE;
```

**Exact insertion point:** After the last blockquote line (e.g. `mp["> > > > > > "] = FormatType.BLOCKQUOTE;`) and before the closing `}` of `static construct`. So after line 108 (`mp["> > > > > > "] = FormatType.BLOCKQUOTE;`), add the two lines above.

---

## 2. Add TABLE branch in `peek()`

**Location:** In `peek()`, after the existing branches for fenced code and CONTINUE_LIST, and before the final `return result;`. So after the closing `}` of the `if (matched_block == FormatType.CONTINUE_LIST)` block (around line 183) and before `return result;` (line 185).

**Behaviour (progressive verification):**

- When `base.eat()` has already matched `"|"` at `chunk_pos`, we have `matched_block == FormatType.TABLE` and `byte_length == 1`. We must not return that immediately; we validate progressively so we can reject or “need more” as soon as possible.
- **Split:** `rest = chunk.substring(chunk_pos)`, `lines = rest.split("\n")`.
- **If `lines.length < 1`:** No content yet → return -1 (need more).
- **Trim:** When checking start/end and separator, use the **trimmed** (stripped) line so leading/trailing whitespace is allowed (e.g. `  | a |  ` is accepted).
- **If `lines.length < 2`:** We only have line 1.
  - Check trimmed line 1 starts with `|` and ends with `|`. If not → return 0 (not a table).
  - We need more (no line 2 yet) → return -1 unless `is_end_of_chunks`, then return 0.
- **If `lines.length >= 2`:** We have line 1 and at least partial line 2.
  - Check trimmed line 1 starts and ends with `|`. If not → return 0.
  - If trimmed line 2 is not `""`, check it starts with `|`. If not → return 0.
  - If `lines.length < 3` → need more → return -1 unless `is_end_of_chunks`, then return 0.
- **If `lines.length >= 3`:** We have 3 full lines. Do full check:
  - Each of trimmed lines 1–3 must start with `|` and end with `|`; trimmed line 2 must contain only allowed separator chars (regex on **whole** line; no substring). If any check fails → return 0.
  - Set `byte_length` to the byte length of the 3 lines including the third newline (raw lines, not trimmed), and return 1.

**Separator check (line 2):**
- Trimmed line 2 must start with `|` and end with `|` (already checked above).
- **Permissive:** Check the **whole** trimmed line contains only: space, pipe `|`, hyphen `-`, colon `:`.
- Regex: `^[- |:]*$` (whole line; hyphen first in class so no escaping). No substring — match the full line.
- Reject if the line contains any other character (e.g. letters). Examples: `| --- |`, `||`, `|  |`, `|:---:|---:|` all allowed; `| x |` rejected.
- Implementation: match trimmed line 2 against the regex (no character loop, no substring); see concrete code.

**Byte offsets and newlines:**
- Use byte positions only (Vala `string` / `substring` are byte-based).
- Find newlines: `chunk.index_of_char('\n', start_pos)`.
- Newline byte length: `chunk.get_char(newline_pos).to_string().length` (same as fenced-code branch; handles multi-byte).
- "Length of 3 lines including newlines" = byte distance from `chunk_pos` to the byte after the third `\n`.

---

## 3. Concrete Vala code for the TABLE branch

Insert the following block after the CONTINUE_LIST block and before `return result;` in `peek()`.

```vala
// TABLE: need 3 full lines (header, separator, first body row); verify progressively
if (matched_block == FormatType.TABLE) {
	var rest = chunk.substring(chunk_pos);
	var lines = rest.split("\n");
	if (lines.length < 1) {
		return -1;
	}
	// Line 1 must start and end with | (trim for generosity)
	if (!lines[0].strip().has_prefix("|") || !lines[0].strip().has_suffix("|")) {
		return 0;
	}
	if (lines.length < 2) {
		if (is_end_of_chunks) {
			return 0;
		}
		return -1;
	}
	// We have at least partial line 2; if any content after trim, it must start with |
	if (lines[1].strip() != "" && !lines[1].strip().has_prefix("|")) {
		return 0;
	}
	if (lines.length < 3) {
		if (is_end_of_chunks) {
			return 0;
		}
		return -1;
	}
	// Full check: all three (trimmed) start/end with |; line 2 is separator
	if (!lines[1].strip().has_suffix("|")
			|| !lines[2].strip().has_prefix("|")
			|| !lines[2].strip().has_suffix("|")) {
		return 0;
	}
	// Line 2 (whole trimmed line): only space, |, -, : allowed; permissive, no substring
	try {
		if (!(new GLib.Regex("^[- |:]*$").match(lines[1].strip()))) {
			return 0;
		}
	} catch (GLib.RegexError e) {
		return 0;
	}
	// byte_length = 3 lines including newlines (support multi-byte newline)
	var nl_byte_len = rest.length > lines[0].length
		? rest.get_char(lines[0].length).to_string().length
		: 1;
	byte_length = lines[0].length + nl_byte_len
		+ lines[1].length + nl_byte_len
		+ lines[2].length + nl_byte_len;
	return 1;
}
```

**Notes:**

- **Progressive verification:** Split first; then reject or “need more” as soon as we can. `< 1` line → need more; `< 2` lines → check line 1 start/end `|`, then need more; `>= 2` lines → check line 1 and, if trimmed line 2 != `""`, that line 2 starts with `|`; `< 3` → need more; `>= 3` → full check (all three start/end `|`, line 2 separator regex), then set `byte_length` and return 1.
- **Trim:** All start/end and separator checks use the **trimmed** (stripped) line so leading/trailing whitespace is allowed. `byte_length` still uses raw line lengths (consumed bytes include any leading/trailing space).
- No character loop: line division uses `split("\n")`; separator check uses regex `^[- |:]*$` on the **whole** trimmed line 2 (only space, `|`, `-`, `:`; no substring).
- Whenever we “need more” and `is_end_of_chunks` is true, we return 0 (not a table).
- `byte_length` = sum of the 3 line byte lengths plus 3× newline byte length (newline length from the character at `rest[lines[0].length]` to support multi-byte newlines). The parser advances `chunk_pos` by that amount.

---

## 4. Summary of changes

| Item | Location | Change |
|------|----------|--------|
| Static map | `BlockMap.vala` `static construct` | Add `mp["|"] = FormatType.TABLE;` after blockquote entries. |
| TABLE branch in `peek()` | `BlockMap.vala` `peek()` | After CONTINUE_LIST block, before `return result;`, add the TABLE block above: split, then progressive verification (&lt; 1 → -1; &lt; 2 → check line 1 start/end `|` then -1/0; ≥ 2 → check line 1 and if line 2 != "" then line 2 starts with `|`; &lt; 3 → -1/0; ≥ 3 → full check and set `byte_length`, return 1 or 0). |

No other files need to change for this phase. The parser already handles `matched_block == FormatType.TABLE` and uses `byte_length` to consume the 3-line block (see 1.10.5).

---

## 5. Edge cases

- **&lt; 1 line:** Return -1 (need more).
- **Line 1 does not start or end with `|`:** Return 0 as soon as we have line 1 (progressive verification).
- **Partial line 2 present and does not start with `|`:** Return 0 as soon as we have any line 2 content (e.g. `| a |\nfoo` → 0).
- **End of chunk before 3 full lines:** Return -1 so more data can be supplied; if `is_end_of_chunks` is true, return 0 (not a table).
- **Line 2 or 3 does not end with `|`:** Return 0 (full check when we have 3 lines).
- **Line 2 has other characters (e.g. letters):** Return 0; only space, `|`, `-`, and `:` are allowed in the separator line (whole-line regex).
- **Minimal / empty-looking line 2:** e.g. `||`, `|  |`, `|-|`, `|  ---  |` are all allowed (only allowed chars); `| x |` is rejected (invalid character).
