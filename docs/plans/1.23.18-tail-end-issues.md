# 1.23.18 Tail-end issues - remaining tasks

**Parent:** 1.23.18. **Source:** Moved from 1.23.14-outstanding (remaining work after §1–6 and reference resolution are done).

**Coding standards:** `.cursor/rules/CODING_STANDARDS.md`. All concrete code below follows that checklist (brace placement, `this.`, no string build in loops, no one-line if, no nullable/random null checks where avoidable, line breaking, etc.).

---

## 1. Task naming and output references (critical) — **DONE**

- **When:** Assign names **as soon as the initial plan is created** (after parse_task_list), and again whenever the task list is updated (e.g. after task list iteration). Include **all** tasks, including not-yet-approved ones, so issue messages can refer to them (e.g. "Task 'Research 2': invalid skill").
- **Format:** **skill_name + " " + number** (e.g. `MySkill 1`, `Research 2`). Number is assignment order at that pass (1, 2, 3…); **need not be sequential** after the LLM edits the list (e.g. if the LLM deletes a task, gaps are fine — "Research 1" and "Research 3" is ok). If a task has no skill, use **"Task " + number**. Store on task (Details task_data "Name") so it is stable and referrable.
- **Output reference format:** To refer to a task's output we use **`#{slug}-{number}-results`** where slug = skill name with non-ascii replaced by `-` and lowercased, number = same as in task name. Example: `#my-skill-1-results`. **reference_content** (or the resolver) must resolve `#slug-number-results` to that task's result content.
- **Implementation:** **DONE.** Details.fill_name(int i); List.fill_names(); ResultParser calls this.runner.task_list.fill_names() after goals_summary_md.

---

## 2. validate_reference_targets - #anchor validation — **DONE**

- **validate_references()** (Details): validates href *form* only; does not fetch content.
- **Supported hrefs:** `#anchor`, `http(s)://...`, absolute path. (We use `#task-name-results` for task output; no `output:taskname`.)
- **Validated:** Rejected if href is not one of `#...`, `http(s)://...`, or absolute path. Absolute path must exist on disk. `#anchor`: task-output `#slug-N-results` via **list.has_slug(name_slug)**; document anchors via **user_request.headings.has_key(anchor)**.
- **http(s)://:** TODO — placeholder only; see **1.23.20**. #ast on files → 1.23.20.
- **Implementation:** DONE. Details: **slug()**, **validate_references()** (no arg; uses **this.runner.task_list.has_slug()**). List: **has_slug()**. ResultParser: builds onto **runner.task_list**; **fill_names()** then loop steps/children calling **validate_references()**; **task_list** getter returns **runner.task_list**.

---

## 3. Naming / other

- List: **run_until_user_approval** (line 105) → align with plan **run_until_writer**; add **has_writer_tasks** (or has_tasks_requiring_approval per 1.23.14-existing-skill-code-updates).
- PromptTemplate, Factory, Manager, Definition, prompt format: per 1.23.14 main plan and 1.23.17.

---

## 4. project_description (low priority) — **DONE**

- **task_creation** and **Details.refine()** pass **project_description** from active_project when set; see 1.23.14-existing-skill-code-updates (task_creation sample).
- **VectorMetadata location:** **VectorMetadata** lives in **OLLMfiles.SQT.VectorMetadata** (libocfiles / SQT), so **Folder.project_description()** uses it without circular dependency.
- **Source of data:** ocvector (ProjectAnalysis) writes the project-level summary to **vector_metadata** with `element_type = 'project'`, `file_id = root_folder.id`; Folder queries via **OLLMfiles.SQT.VectorMetadata.query(db).select(where, results)**.
- **Wiring (liboccoder):** Inline at fill: **active_project == null ? "" : active_project.project_description()** in **task_creation**, **Details.refine()**; **run_task_list_iteration()** to use same when implemented.
- **Implementation:** DONE. Folder: **project_description()**; Runner task_creation and Details.refine() fill project_description from active_project.

---

## 5. Markdown block types in output

**Goal:** Every headed block is explicitly markdown (unfenced) or code (fenced + language).

We have **two places** that output these blocks. Below: what each does **now**, and what we **want**.

---

### Part A — Template placeholders (tpl.header)

**Used when:** Filling skill prompts in Runner.task_creation() and Details.refine().

| File     | Block heading            | Content is    | Current          | Want                    |
|----------|---------------------------|---------------|------------------|-------------------------|
| Runner   | User Prompt               | user text     | fenced, no lang  | **fenced** (could be anything) |
| Runner   | Environment               | env string    | unfenced         | unfenced                |
| Runner   | Current File - path       | file contents | fenced, no lang  | fenced + lang           |
| Runner   | Previous Proposal         | text          | fenced, no lang  | unfenced markdown; header + section (see note below) |
| Runner   | Previous Proposal Issues  | text          | fenced, no lang  | unfenced markdown       |
| Details  | Issues with the current call | issues text | fenced, no lang  | unfenced markdown       |
| Details  | Task                      | task markdown | fenced, no lang  | unfenced markdown       |
| Details  | Current File - path       | file contents | fenced, no lang  | fenced + lang           |

Optional: **tpl.header_file(title, File)** for the two "Current File" rows (code + lang from file.language).

**Previous Proposal note:** Wrap with a header (e.g. "This was your previous proposal") and section delimiters. If content can contain `---`, don't use that as delimiter (or use a different one). Template keys TBD: e.g. previous_proposal_head / start / end (DEFAULT or "").

---

### Part B — Reference blocks (Details only, not template)

**Used when:** Building reference content for refine and executor (reference_contents), and tool call blocks (reference_block).

**Where links come from:** Task "References" section. Each link is either `#anchor` (e.g. #project-description) or an absolute file path.

| Link type    | How we get content now                     | Content is | Current          | Want               |
|--------------|--------------------------------------------|------------|------------------|--------------------|
| #anchor      | Runner.reference_content(href) → doc section | markdown   | fenced, no lang  | markdown unfenced  |
| file path    | get file, get_contents()                    | code       | fenced, no lang  | code + lang        |
| tool call    | reference_block("Tool call X", json)        | JSON       | fenced, no lang  | fenced, type **json** |
| tool output  | reference_block("Tool call X Output", text)  | text       | fenced, no lang  | fenced, type **text** |

**What tool call / tool output is:** Executor precursor. When a task runs tools, we send reference content + each tool call (name + JSON) and its output as headed blocks to the LLM. So this **is** part of our output — per-task execution context (Details.executor_precursor() → post_evaluate fill). Not task list iteration output.

**Tool output types:** For now, tool output = fenced with type "text". Handling **known** tool output types (when a tool declares or we know the output type) → bump to **post-testing changes** (1.23.20 or similar).

**Current code:** reference_contents() uses reference_link_contents(link, contents) for both #anchor and file path (same format). reference_block() for tool call/output.

**Want:** In reference_contents(), branch: #anchor → unfenced markdown; file path → new reference_file(link, File) (code + lang). reference_block: fenced with type (tool call → json, tool output → text).

---

### Proposed API (covers all types)

Three methods:

| Method | Signature | Use |
|--------|-----------|-----|
| **header_raw** | (heading, body) | ## + body, no fence. Unfenced markdown. |
| **header_file** | (heading, File) | ## + fenced code block; language from file.language. |
| **header_fenced** | (heading, body, type) | ## + fenced block with type (e.g. "text", "json", "markdown", "vala"). |

**Constraint:** Exactly **3 methods on tpl**, **3 methods on Details**. No helpers; all logic inside those 6 methods.

**Naming (same on both):** **header_raw**, **header_file**, **header_fenced**.  
**tpl (PromptTemplate):** those 3 — used for template fills (Runner, Details.refine()).  
**Details:** those 3 — used for reference contents and executor precursor. Same names; Details has its own implementation (custom heading lines for reference blocks). No helpers; no calls from Details to tpl for reference blocks.

---

### Concrete code proposal (for approval)

**1. PromptTemplate — 3 methods only (liboccoder/Skill/PromptTemplate.vala)**

Add after existing `header()` (keep until migration done; then remove). No other helpers or static methods.

```vala
/** ## heading + body, no fence. Unfenced markdown. No output when body is empty. */
public string header_raw(string heading, string body)
{
	if (body == "") {
		return "";
	}
	return "## " + heading.strip() + "\n\n" + body + "\n\n";
}

/** ## heading + fenced code block. Uses file.language (FileBase; set by detect_language()). Exception: we do output the header (and empty block if needed) when file content is empty. Caller must not pass null file. */
public string header_file(string heading, OLLMfiles.File file)
{
	var body = file.get_contents(200);
	var fence = (body.index_of("\n```") >= 0 || body.has_prefix("```")) ? "~~~~" : "```";
	return "## " + heading.strip() + "\n\n"
		+ fence
		+ (file.language != "" ? file.language + "\n" : "\n")
		+ body + "\n"
		+ fence + "\n\n";
}

/** ## heading + fenced block with type (e.g. "text", "json", "vala"). No output when body is empty. */
public string header_fenced(string heading, string body, string type = "")
{
	if (body == "") {
		return "";
	}
	var fence = (body.index_of("\n```") >= 0 || body.has_prefix("```")) ? "~~~~" : "```";
	return "## " + heading.strip() + "\n\n"
		+ fence
		+ (type != "" ? type + "\n" : "\n")
		+ body + "\n"
		+ fence + "\n\n";
}
```

**2. Runner — task_creation() fill (liboccoder/Skill/Runner.vala)**

Replace `tpl.fill(...)` placeholder values:

```vala
tpl.fill(
	"user_prompt", tpl.header_fenced("User Prompt", user_prompt, "text"),
	"environment", tpl.header_raw("Environment", this.env()),
	"project_description", (this.sr_factory.project_manager.active_project == null
			? "" : this.sr_factory.project_manager.active_project.project_description()),
	"current_file", file == null ? "" : tpl.header_file("Current File - " + file.path, file),
	"open_files", open_files_list,
	"previous_proposal", previous_proposal == "" ? "" : tpl.header_raw("Previous Proposal", previous_proposal),
	"previous_proposal_issues", previous_proposal_issues == "" ? "" : tpl.header_raw("Previous Proposal Issues", previous_proposal_issues),
	"skill_catalog", this.sr_factory.skill_manager.to_markdown());
```

**3. Details — refine() fill (liboccoder/Task/Details.vala)**

Replace `tpl.fill(...)` placeholder values:

```vala
"issues", tpl.header_raw("Issues with the current call", this.result_parser.issues),
"task_data", tpl.header_raw("Task", this.to_markdown(MarkdownPhase.REFINEMENT)),
// ... environment, project_description unchanged ...
"current_file", file == null ? "" : tpl.header_file("Current File - " + file.path, file),
"task_reference_contents", this.reference_contents(),
// ...
```

**4. Details — 3 methods only, same approved names: header_raw, header_file, header_fenced (liboccoder/Task/Details.vala)**

Add three methods; no helpers. All fence logic inside these. header_file takes OLLMfiles.File (same as tpl); content and language from file. Signatures take `line` (full heading line, e.g. "Reference information for ..." or "### Tool call X") so Details can build reference-style blocks.

```vala
/** Line + unfenced body. Use for reference #anchor. */
private string header_raw(string line, string body)
{
	if (body == "") {
		return "";
	}
	return line + "\n\n" + body + "\n\n";
}

/** Line + fenced body; content and language from file. Use for reference file path. Exception: we do output the header (and empty block if needed) when content is empty. */
private string header_file(string line, OLLMfiles.File file)
{
	var content = file.get_contents(0);
	var fence = (content.index_of("\n```") >= 0 || content.has_prefix("```")) ? "~~~~" : "```";
	return line + "\n\n"
		+ fence
		+ (file.language != "" ? file.language + "\n" : "\n")
		+ content + "\n"
		+ fence + "\n\n";
}

/** Line + fenced body with type (e.g. "json", "text"). Use for tool call/output. */
private string header_fenced(string line, string body, string type = "")
{
	if (body == "") {
		return "";
	}
	var fence = (body.index_of("\n```") >= 0 || body.has_prefix("```")) ? "~~~~" : "```";
	return line + "\n\n"
		+ fence
		+ (type != "" ? type + "\n" : "\n")
		+ body + "\n"
		+ fence + "\n\n";
}
```

**5. Details — reference_contents() and executor_precursor()**

reference_contents() uses only this.header_raw() and this.header_file(). executor_precursor() uses only this.reference_contents() and this.header_fenced(). Remove reference_link_contents and reference_block().

```vala
private string reference_contents()
{
	string[] parts = {};
	foreach (var link in this.reference_targets) {
		if (!GLib.Path.is_absolute(link.href)) {
			var content = this.runner.reference_content(link.href);
			if (content != "") {
				parts += this.header_raw(
					"Reference information for " + link.title + "\n\nThe contents of " + link.href,
					content);
			}
			continue;
		}
		var found = this.runner.sr_factory.project_manager.get_file_from_active_project(link.href);
		if (found == null) {
			found = new OLLMfiles.File.new_fake(this.runner.sr_factory.project_manager, link.href);
		}
		this.runner.sr_factory.project_manager.buffer_provider.create_buffer(found);
		parts += this.header_file(
			"Reference information for " + link.title + "\n\nThe contents of " + link.href,
			found);
	}
	return string.joinv("", parts);
}

private string executor_precursor()
{
	string[] parts = {};
	parts += this.reference_contents();
	foreach (var e in this.tool_outputs.entries) {
		var json = Json.gobject_to_data(this.tool_calls.get(e.key), null);
		if (json != "") {
			parts += this.header_fenced("### Tool call " + e.key, json, "json");
		}
		if (e.value != "") {
			parts += this.header_fenced("### Tool call " + e.key + " Output", e.value, "text");
		}
	}
	return string.joinv("", parts);
}
```

Remove **reference_link_contents** and **reference_block()**.

---

### Action (short)

- **tpl / Details:** Implement header_raw, header_file, header_fenced; migrate call sites and reference_contents/reference_block to these. Previous Proposal: add header + section (keys TBD).
- **reference_contents():** #anchor → this.header_raw(line, content); file path → this.header_file(line, found). executor_precursor: this.header_fenced(line, body, "json") / this.header_fenced(line, body, "text").

---

## 6. Task list iteration - code vs prompts (policy)

- **Policy:** Only **prompts** (e.g. `resources/skill-prompts/*.md`) and **filename references** to them (gresources, docs, template keys) are modified unless code changes are explicitly requested or added to this plan.
- **Current state:** Prompt file is **task_list_iteration.md**; Runner calls **run_task_list_iteration()** as a stub after each round. Implementation is specified in §7 below.

---

## 7. Task list iteration - implementation (to implement)

Implement **run_task_list_iteration()** and supporting types so that after each round of task execution the Runner sends the current task list (with completed outputs in precursor) to the LLM using **task_list_iteration.md**, then replaces **this.task_list** with the parsed response.

**List (Task/List.vala):**
- Add property: **goals_summary_md** (string, default ""). Runner holds the original prompt; context lives in task References. Parser requires only three sections (see below).
- Add **to_markdown()**: returns only `## Tasks` and task sections. Runner builds current_task_list = original prompt + goals_summary_md + list.to_markdown().

**ResultParser (Task/ResultParser.vala):**
- In **parse_task_list()**, require only **original-prompt**, **goals-summary**, **tasks**. Remove **general-information-for-all-tasks** from the code entirely (it was never used). After building steps, set only:
  - `task_list.goals_summary_md = document.headings.get("goals-summary").to_markdown_with_content();`
  Do not set original_prompt_md or general_information_md on the list (Runner holds the prompt).

**Details (Task/Details.vala):**
- Add **to_markdown_for_list()**: returns task as bullet list (same as coarse_task_markdown: What is needed, Skill, References, Expected output). When **exec_done** and **result** non-empty, append `\n- **Output** ` plus result as a single line (e.g. result.strip().replace("\n", " ")). Used by List.to_markdown().

**Runner (Skill/Runner.vala) - run_task_list_iteration():**
- If **this.task_list == null** return.
- Build **precursor_with_completed_outputs**: for each task in task_list (steps → children) where **exec_done** and **result != ""**, append a headed block e.g. `### Completed task output N` and the task result text.
- Load template **task_list_iteration.md**; fill: **skill_catalog**, **current_task_list** (header "Current task list" + task_list.to_markdown(), no code block), **environment**, **project_description** (""), **precursor_with_completed_outputs** (header "Outputs from completed tasks" when non-empty), **previous_proposal_issues** (header "Issues with the tasks" when non-empty).
- Send system + user messages; get response; **ResultParser(this, response).parse_task_list()**; if **parser.issues == ""** and **parser.task_list.validate_skills() == ""**, set **this.task_list = parser.task_list** and return.
- Otherwise set previous_proposal_issues = parser.issues and retry (e.g. up to 5 times). On final failure add_message "Task list iteration: could not get valid task list after 5 tries."

---

## 8. Task data and to_markdown (refinement retry, 1.23.12, 1.23.17) — **DONE**

**Reframe:** Do not pass a "previous refinement section". Pass **task data**: we update the task (task_data, code_blocks, tools) from refinement output; on retry we send the **current task data** (as markdown) plus issues so the LLM can rectify. The prompt does not ask for "your previous output" - it asks for corrected output given "Issues with the current call" and "Current task data".

### 9.1 Task phases and what we output

| Phase | When | Content |
|-------|------|--------|
| **Creation** | Initial from task creation | Coarse: Name (optional), What is needed, Skill, References, Expected output. |
| **Output for refinement** | Input to refiner | Same as creation; add **Name** if missing (e.g. from skill + index) so downstream can reference. |
| **After parse refinement** | Parser updates task | We update task_data (update_props), code_blocks, tools/tool_calls - no separate "refined area". |
| **Output for refinement (fix)** | Retry refinement | **Current task data** in refinement shape: ## Task (list from task_data) + ## Tool Calls (fenced JSON blocks). One generic **to_markdown(phase)** can produce this. |
| **Output for execution** | Executor precursor | Reference contents + tool call (name + id + JSON) + tool output per call so the executor knows where each output came from. Use to_markdown(EXECUTION) for the ## Tool Calls part, or keep executor_precursor() building that from this.tools + tool_outputs. |
| **Output for execution iteration** | - | Same as execution (no separate phase). |
| **Output for task_list_iteration** | List serialisation | No tool calls or tool output; include **summary content** (result). Coarse task + when exec_done append **Output** single-line result. (Already specified in §7 as to_markdown_for_list().) |

**DONE.** Details: MarkdownPhase enum, to_markdown(phase), refine() fill (issues + task_data, no previous_output). ResultParser: invalid tool blocks → parser issues with raw block; parse_task_list() three sections only, goals_summary_md on list. List: goals_summary_md, to_markdown(). task_refinement.md: {issues}, {task_data}; task_list_iteration: general information removed. Runner: run_task_list_iteration() stub. See git history for code.
