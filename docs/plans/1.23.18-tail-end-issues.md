# 1.23.18 Tail-end issues - remaining tasks

**Parent:** 1.23.18. **Source:** Moved from 1.23.14-outstanding (remaining work after §1–6 and reference resolution are done).

**Coding standards:** `.cursor/rules/CODING_STANDARDS.md`.

---

## 1. Task naming and output references (critical)

- **When:** On initial task list creation and whenever the task list is later updated.
- **Assign a name to each task.** Normal format: **skill_name + " " + number** (e.g. `MySkill 1`, `MySkill 2`). Store on task (e.g. Details) so it is stable and referrable.
- **Output reference format:** To refer to a task's output we use **`#{slug}-{number}-results`** where:
  - **slug** = skill name with non-ascii replaced by `-` and lowercased (e.g. "My Skill" → `my-skill`).
  - **number** = task index/number (same as in task name).
  - Example: `#my-skill-1-results`, `#my-skill-2-results`.
- This is the **'output'** reference we use: when References say `output:…` or a ref points at another task's results, the target is this anchor. **reference_content** (or the resolver) must resolve `#slug-number-results` to that task's result content (e.g. from user_request or stored task outputs).

---

## 2. validate_reference_targets - #anchor validation

- **validate_reference_targets()** (Details): Currently validates href forms (#, output:, http, absolute path exists); does not fetch content.
- **FIXME:** Validate #anchor format and existence (e.g. anchor present in user_request or known task-output anchors).

---

## 3. validate_task_list_reference_lengths (low priority)

- **Runner method.** Per-task resolved reference content length (same as Details); if any over max return issues string. send_async would append to parser.issues and retry. Deferred from main 1.23.14 flow.

---

## 4. Naming / other

- List: **run_until_user_approval** (line 105) → align with plan **run_until_writer**; add **has_writer_tasks** (or has_tasks_requiring_approval per 1.23.14-existing-skill-code-updates).
- PromptTemplate, Factory, Manager, Definition, prompt format: per 1.23.14 main plan and 1.23.17.

---

## 5. project_description (low priority)

- **task_creation** and **Details.refine()** currently pass **project_description** as `""`. When OLLMfiles.Folder (or active_project) has a summary/catalog API, fill from active_project; see 1.23.14-existing-skill-code-updates (task_creation sample).

---

## 6. Markdown block types in output

- **Markdown blocks we output need types** (e.g. markdown vs code, and code language when applicable). Ensure generated content uses explicit block types (e.g. fenced code with language tag, or explicit markdown vs code) so rendering and tooling can handle them correctly.

---

## 7. Task list iteration - code vs prompts (policy)

- **Policy:** Only **prompts** (e.g. `resources/skill-prompts/*.md`) and **filename references** to them (gresources, docs, template keys) are modified unless code changes are explicitly requested or added to this plan.
- **Current state:** Prompt file is **task_list_iteration.md**; Runner calls **run_task_list_iteration()** as a stub after each round. Implementation is specified in §8 below.

---

## 8. Task list iteration - implementation (to implement)

Implement **run_task_list_iteration()** and supporting types so that after each round of task execution the Runner sends the current task list (with completed outputs in precursor) to the LLM using **task_list_iteration.md**, then replaces **this.task_list** with the parsed response.

**List (Task/List.vala):**
- Add property: **goals_summary_md** (string, default ""). Runner holds the original prompt; context lives in task References. Parser requires only three sections (see below).
- Add **to_markdown()**: returns only `## Tasks` and task sections. Runner builds current_task_list = original prompt + goals_summary_md + list.to_markdown().

**ResultParser (Task/ResultParser.vala):**
- In **parse_task_list()**, require only **original-prompt**, **goals-summary**, **tasks**. Remove **general-information-for-all-tasks** from the code entirely (it was never used). After building steps, set only:
  - `task_list.goals_summary_md = document.headings.get("goals-summary").to_markdown_with_content();`
  Do not set original_prompt_md or general_information_md on the list (Runner holds the prompt).

**Details (Task/Details.vala):**
- Add **to_markdown_for_list()**: returns task as bullet list (same as coarse_task_markdown: What is needed, Skill, References, Expected output). When **exec_done** and **result** non-empty, append `\n- **Output** ` plus result as a single line (e.g. result.strip().replace("\n", " ")). Used by List.to_markdown().

**Runner (Skill/Runner.vala) - run_task_list_iteration():**
- If **this.task_list == null** return.
- Build **precursor_with_completed_outputs**: for each task in task_list (steps → children) where **exec_done** and **result != ""**, append a headed block e.g. `### Completed task output N` and the task result text.
- Load template **task_list_iteration.md**; fill: **skill_catalog**, **current_task_list** (header "Current task list" + task_list.to_markdown(), no code block), **environment**, **project_description** (""), **precursor_with_completed_outputs** (header "Outputs from completed tasks" when non-empty), **previous_proposal_issues** (header "Issues with the tasks" when non-empty).
- Send system + user messages; get response; **ResultParser(this, response).parse_task_list()**; if **parser.issues == ""** and **parser.task_list.validate_skills() == ""**, set **this.task_list = parser.task_list** and return.
- Otherwise set previous_proposal_issues = parser.issues and retry (e.g. up to 5 times). On final failure add_message "Task list iteration: could not get valid task list after 5 tries."

---

## 9. Task data and to_markdown (refinement retry, 1.23.12, 1.23.17)

**Reframe:** Do not pass a "previous refinement section". Pass **task data**: we update the task (task_data, code_blocks, tools) from refinement output; on retry we send the **current task data** (as markdown) plus issues so the LLM can rectify. The prompt does not ask for "your previous output" - it asks for corrected output given "Issues with the current call" and "Current task data".

### 9.1 Task phases and what we output

| Phase | When | Content |
|-------|------|--------|
| **Creation** | Initial from task creation | Coarse: Name (optional), What is needed, Skill, References, Expected output. |
| **Output for refinement** | Input to refiner | Same as creation; add **Name** if missing (e.g. from skill + index) so downstream can reference. |
| **After parse refinement** | Parser updates task | We update task_data (update_props), code_blocks, tools/tool_calls - no separate "refined area". |
| **Output for refinement (fix)** | Retry refinement | **Current task data** in refinement shape: ## Task (list from task_data) + ## Tool Calls (fenced JSON blocks). One generic **to_markdown(phase)** can produce this. |
| **Output for execution** | Executor precursor | Reference contents + tool call (name + id + JSON) + tool output per call so the executor knows where each output came from. Use to_markdown(EXECUTION) for the ## Tool Calls part, or keep executor_precursor() building that from this.tools + tool_outputs. |
| **Output for execution iteration** | - | Same as execution (no separate phase). |
| **Output for task_list_iteration** | List serialisation | No tool calls or tool output; include **summary content** (result). Coarse task + when exec_done append **Output** single-line result. (Already specified in §8 as to_markdown_for_list().) |

### 9.2 Concrete code (follow CODING_STANDARDS.md)

**Ready to implement:** All code changes below are specified as code blocks or one-liners. Gaps that were filled: (1) to_markdown: add ## Tool Calls only when phase is REFINEMENT or EXECUTION and tools exist (condition kept). (2) Invalid tool blocks: append to parser `this.issues` in ResultParser.extract_refinement() with raw block (code block added). (3) parse_task_list: required sections and goals_summary_md assignment (code block added). (4) List needs property `goals_summary_md` (§8). **tpl.header()** returns "" when body is empty, so refine() fill always uses `tpl.header("Issues with the current call", this.result_parser.issues)` with no conditional. Dependency: §8 (List.to_markdown, goals_summary_md, run_task_list_iteration) can be implemented with §9.

**Details (Task/Details.vala) - phase enum:**

```vala
public enum MarkdownPhase
{
	COARSE,
	REFINEMENT,
	LIST,
	EXECUTION
}
```

**Details - to_markdown(phase):** This method does not add section headings (e.g. `## Task`); that applies only when the result is used for the refinement/planning phase - the caller adds the header.

```vala
public string to_markdown(MarkdownPhase phase)
{
	string[] order = {
		"Name",
		"What is needed",
		"Skill",
		"References",
		"Expected output",
		"Output"
	};
	var ret = "";
	for (var i = 0; i < order.length; i++) {
		var key = order[i];
		switch (key) {
			case "Output":
				if (phase != MarkdownPhase.LIST || !this.exec_done || this.result == "") {
					continue;
				}
				ret += "- **Output** " + this.result.replace("\n", " ") + "\n";
				continue;
			default:
				if (!this.task_data.has_key(key)) {
					continue;
				}
				break;
		}
		ret += "- **" + key + "** " + this.task_data.get(key).to_markdown() + "\n";
	}
	// Include ## Tool Calls for REFINEMENT (retry) and EXECUTION (executor needs to know where each output came from). Omit section when no tools.
	if (phase != MarkdownPhase.REFINEMENT && phase != MarkdownPhase.EXECUTION && this.tools.size == 0) {
		return ret;
	}
	ret += "\n## Tool Calls\n\n";
	foreach (var tool in this.tools) {
		var obj = new Json.Object();
		obj.set_string_member("name", tool.name);
		if (tool.tool_call != null && tool.tool_call.id != "") {
			obj.set_string_member("id", tool.tool_call.id);
		}
		if (tool.arguments != null) {
			obj.set_object_member("arguments", tool.arguments);
		}
		var node = new Json.Node(Json.NodeType.OBJECT);
		node.set_object(obj);
		var gen = new Json.Generator();
		gen.set_root(node);
		ret += "```json\n" + gen.to_data(null) + "\n```\n\n";
	}
	return ret;
}
```

**Details - coarse_task_markdown():** Replace body with `return this.to_markdown(MarkdownPhase.COARSE);`

**Invalid tool call blocks in error output:** We only output valid content in task_data (to_markdown(REFINEMENT)). For invalid or failed blocks, append to **parser** issues (result_parser.issues) so the retry sees them; include the raw code block in that message. No separate storage for raw tool calls. In **ResultParser.extract_refinement()**, when `tool.parse(block)` or `tool.validate()` fails, append to `this.issues` (not task.issues) with the tool message plus raw block:

```vala
// When !tool.parse(block):
this.issues += "\n" + tool.issues + " Raw block:\n```json\n" + block.to_markdown() + "\n```\n";
continue;
// When !tool.validate() (after parse succeeded):
this.issues += "\n" + tool.issues + " Raw block:\n```json\n" + block.to_markdown() + "\n```\n";
continue;
```

**Details - refine() fill:** (1) issues = tpl.header("Issues with the current call", result_parser.issues). **tpl.header() returns "" when body is empty**, so the issues block is omitted on first attempt without a conditional. (2) task_data = tpl.header("Task", to_markdown(REFINEMENT)) (valid content only).

```vala
messages.add(new OLLMchat.Message("user", tpl.fill(
	"issues", tpl.header("Issues with the current call", this.result_parser.issues),
	"task_data", tpl.header("Task", this.to_markdown(MarkdownPhase.REFINEMENT)),
	"environment", this.runner.env(),
	"project_description", "",
	"current_file", file == null ? "" : tpl.header("Current File - " + file.path, file.get_contents(200)),
	"task_reference_contents", this.reference_contents(),
	"skill_details", definition.full_content)));
```

**Details - refine() loop:** Remove the `previous_output` variable and any assignment from `response_text`; do not pass previous output. Retry uses current task data (from to_markdown(REFINEMENT)) plus issues only.

**List (Task/List.vala) - to_markdown() per §8:** Returns only `## Tasks` and task sections. Runner assembles lead content (original prompt from Runner, goals_summary_md from list) when building current_task_list.

```vala
public string to_markdown()
{
	var out = "## Tasks\n\n";
	var section = 0;
	foreach (var step in this.steps) {
		section++;
		out += "### Task section " + section.to_string() + "\n\n";
		foreach (var t in step.children) {
			out += t.to_markdown(MarkdownPhase.LIST) + "\n\n";
		}
	}
	return out;
}
```

**ResultParser.parse_task_list() - what we store on list:** The original prompt stays on the **Runner**. **Goals/summary** is stored on the list for task list iteration. **General information for all tasks** was never used; remove it from the code and prompts entirely.

- **Code:** In **parse_task_list()**, require only `"original-prompt"`, `"goals-summary"`, `"tasks"`. Delete `"general-information-for-all-tasks"` from the required-headings check and do not reference it anywhere. After building steps, set only `task_list.goals_summary_md`. Do not set original_prompt_md or general_information_md on the list.
- **Prompts:** In **task_list_iteration.md** (and any other prompt that mentions it), remove the "General information for all tasks" section heading, structure description, and all references. Required structure is: Original prompt, Goals / summary, Tasks (and optionally "Issues with the tasks" when rectifying).

```vala
// In parse_task_list(): require only these three sections (remove general-information-for-all-tasks).
foreach (var key in new string[] { "original-prompt", "goals-summary", "tasks" }) {
	if (!this.document.headings.has_key(key)) {
		this.issues += "\n" + "Top-level structure: the response must contain these ## sections in order: Original prompt, Goals / summary, Tasks. Missing or misnamed: \"" + key + "\".";
		return;
	}
}
// ... build task_list and steps as now ...

// After the loop that builds steps, set only:
this.task_list.goals_summary_md = this.document.headings.get("goals-summary").to_markdown_with_content();
```

**List (Task/List.vala):** Add property `public string goals_summary_md { get; set; default = ""; }` (see §8).

### 9.3 Concrete prompt template changes

**task_refinement.md - "What you receive" bullet (replace previous output wording):**

```markdown
- **Issues with the current call / Current task data:** When this section is present, the previous attempt had problems. Below are the **issues** and the **current task data** (Task section and Tool Calls). Rectify and produce corrected output.
```

**task_refinement.md - template body:** Variable issues block. Use a single placeholder **{issues}** (not {issues/start}…{issues/end}: that syntax is for optional *fixed* content—DEFAULT keeps text between markers, value replaces the span—not for variable content). Fill passes the full block when present (e.g. header + body) or "" when empty.

```markdown
{issues}

{task_data}

## Task reference contents
```

- issues: always tpl.header("Issues with the current call", result_parser.issues). header() returns "" when body is empty, so the section is omitted on first attempt.
- task_data: always tpl.header("Task", to_markdown(REFINEMENT)). "Task" = whatever the system template says for that section.

**Current template (user section) vs plan – conformity:**

| Current | Plan | Action |
|--------|------|--------|
| `## The task you are refining` then `{coarse_task}` | Single block `{task_data}` (header + to_markdown(REFINEMENT)) | Remove the fixed heading; use `{task_data}` so the section title comes from fill. |
| `{previous_output_issues}` | Merged into `{issues}` | Replace with single `{issues}` (fill = header + issues or ""). |
| `{previous_output}` | No separate block; invalid/raw content goes *inside* issues text | Remove placeholder; code puts raw blocks in result_parser.issues when parse fails. |
| `{environment}` … `{skill_details}` | Unchanged | Keep as-is. |

So the user section should be: `{issues}` then `{task_data}` then `## Task reference contents` and the rest. No `{coarse_task}`, `{previous_output_issues}`, or `{previous_output}`.

**Headlines – avoid duplicates:**

- **Convention:** For any placeholder filled with `tpl.header(title, content)`, the template must **not** add its own `##` heading above that placeholder, or we get duplicate headings. The heading is supplied by the fill.
- **Optional blocks:** `tpl.header(title, body)` returns `""` when body is empty, so the fill can always use `tpl.header(...)` for optional sections (e.g. issues, current_file); no conditional needed.
- **task_refinement.md (user section):** Template has no heading above `{issues}` or `{task_data}` (we removed "## The task you are refining"). Template keeps fixed `## Task reference contents` and `## Skill Details`; the fill does not add those. Fill adds: "## Task" (inside task_data), "## Issues with the current call" (inside issues when non-empty), "## Current File - path" (for current_file when present). So no duplicate headlines.
- **task_creation_initial.md / task_list_iteration.md:** No template headings around the filled placeholders; headings come from the fill (`tpl.header(...)`). Conformant.

### 9.4 Summary

- **No task_data_rectify.** Use header + content: (1) issues = header("Issues with the current call", result_parser.issues), optional block. (2) task_data = header("Task", to_markdown(REFINEMENT)) only.
- **Single to_markdown(phase):** COARSE, REFINEMENT, LIST. refine() fill: issues (optional), task_data (header + to_markdown(REFINEMENT)).
- **Prompt:** task_refinement.md: single placeholder {issues} (fill = full block or ""); {task_data} = header + to_markdown(REFINEMENT).
- **Code:** Details.to_markdown(phase); refine() passes issues and task_data; List.to_markdown() uses Details.to_markdown(LIST) per §8.
- **Invalid blocks in issues:** Only output valid content in task_data. When a tool call block fails parse/validate, append the raw block to the issue message so the LLM sees what it output and the error; no separate raw storage.
