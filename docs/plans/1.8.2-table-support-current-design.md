# Table Support Within Current Parser Design (1.8.2)

## Context

Current parser design: Parser is a single class; block state is `current_block` (FormatType); block detection is `blockmap.peek()` at line start; we have **MarkerMap**, **FormatMap**, **BlockMap**, and **ListMap**. Handlers are `handle_block_result`, `handle_fence_result`, `handle_format_result`, etc.

This plan describes **what is involved in supporting tables** within that design: state, BlockMap.peek() changes, and how table parsing plugs into the existing Parser flow.

---

## 1. Do we need a new state?

**Yes – but only in the sense we already have it.**

- **Block-level state**: We already have `FormatType.TABLE`. Using it as `current_block` is enough to mean “we are inside a table block.”
- **Sub-state within the table**: Tables have structure: header row → alignment row → body rows. We need to track:
  - Which row we’re on (header / alignment / body).
  - Column count (for consistency and alignment).
  - Per-column alignment (left/center/right) from the alignment row.

So:

- **No new FormatType** – TABLE is sufficient.
- **New state variables** (in Parser or in a dedicated helper):
  - Phase: header / alignment / body (e.g. `TablePhase` enum or `table_row_index`).
  - `table_column_count: int` (and optionally `alignments: Gee.ArrayList<TableAlignment>`).

This fits the existing pattern: fenced code uses `current_block` + no extra phase; tables use `current_block == TABLE` + a small amount of phase/column state.

---

## 2. Where does table detection live?

Current maps:

- **MarkerMap** (base): matches a **prefix** at a position from a fixed set of string markers (`#`, `##`, `- `, `` ``` ``, etc.) via `eat()`.
- **BlockMap**: wraps `eat()` and adds **line-based** rules for fenced code (need newline + optional lang) and CONTINUE_LIST (delegate to ListMap).
- **FormatMap** / **ListMap**: same prefix-matching idea.

Table detection is a bit different:

- A pipe at **line start** is a block-level cue (we only check at `at_line_start`). However, we need the **same line** to contain at least one more `|` (e.g. `| cell | cell |` or `| --- |`) before we can treat it as a table row. So in practice we still need to look at the rest of the line (or confirm another `|` on the same line); that follow-up is line-based, not prefix-based.
- Adding `"|"` to BlockMap would match "pipe at line start"; we'd still need to confirm another `|` on the same line before treating it as a table row.

So:

- **Do** add table detection to **BlockMap.peek()**: add `"|"` to the block marker map as TABLE; in `peek()`, add a branch for `matched_block == TABLE` (keep returning -1 until we have 3 full lines ending with `|`; then TABLE and byte_length = those 3 lines; else → 0). See section 3.0.
- **Row/cell parsing** (splitting row into cells, alignment row, etc.) stays in Parser when `current_block == TABLE`, or in an optional small helper. Detection is entirely in BlockMap.peek().

---

## 3. How tables fit into the current design

**Core strategy:** Eat all lines that start with `|`. At end of line, decide: either **return the line to the parser** (don’t advance past it, clear table state, let the main loop re-process it as normal block/paragraph) or **process it** as a table row (header, alignment, or body). So we always consume “line starting with `|`” first; only at newline do we commit to “this was a table row” or “this wasn’t a table, give it back.”

### 3.0 Table detection in BlockMap.peek()

Add table detection **inside BlockMap.peek()**. We **do not** confirm a table on the first line; we keep returning **-1 (need more characters)** until we have the **end of the 3rd line** (header, separator, first body row). Only then do we treat it as a table block.

- **At any point** while waiting for the 3rd line ending with `|`, we can declare it's not a table (return 0) and pass back to the parser so the content is read as regular formatting (paragraph, etc.).
- **If we get `|` at line start** and we **don't have a newline yet** in the chunk:
  - → return **-1 (need more characters)**.
- **Once we have newline(s)**:
  - Get **line 1** (from `chunk_pos` to first newline).
    - If it doesn't end with `|` → return 0 (not a table; pass back to regular formatting).
    - We have line 1 but need line 2 → return **-1 (need more)**.
  - Get **line 2**.
    - If it doesn't end with `|` (or doesn't look like separator) → return 0 (not a table).
    - We need line 3 → return **-1 (need more)**.
  - Once we have the **end of the 3rd line** (third newline):
    - If line 3 ends with `|` → set `matched_block = TABLE`, `byte_length` = all 3 lines (including newlines), and return so the caller consumes the block.
    - If line 3 doesn't end with `|` → return 0 (not a table).
- **handle_block_result** receives TABLE with `byte_length` = 3 lines:
  - Set `current_block = TABLE` and **pass the consumed 3-line block into handle_table_line** (see 3.1a).
  - Subsequent lines (4th, 5th, …) are consumed one at a time when `current_block == TABLE` and passed to handle_table_line.

Implementation: add `"|"` to BlockMap's marker map as TABLE. In `peek()`, add a branch for `matched_block == TABLE`: scan for 3 lines (each starting with `|`, ending with `|`); if we don't have 3 full lines yet, return -1; if we have 3 lines and the 3rd ends with `|`, set `byte_length` to those 3 lines (including newlines) and return; if any line fails the check, return 0.

### 3.1a handle_table_line and callback sequence

**All rows are handled by line** so the code stays consistent: **handle_table_line** takes **one line** (one row) at a time. When we first get TABLE from blockmap we have a 3-line block: split it into 3 lines and call **handle_table_line(line)** three times (line 1 = header, line 2 = separator, line 3 = first body row). When we're already in a table and get the next line (4th, 5th, …), we call **handle_table_line(line)** once with that line. Same per-line path for every row.

Inside **handle_block_result**, when `matched_block == TABLE`, split the consumed 3-line block into three single lines and call **handle_table_line(line)** for each (or pass the block and have handle_table_line iterate over lines internally – either way, the logic inside is "process one line"). That method drives the renderer callbacks:

- **on_block(table start?)** – see below; we may not emit table start until we have the 3rd row.
- **on_block(tr start)** – table row start.
- **on_block(table cell start, align)** – cell start; **align** from column map (-1 left, 0 center, 1 right). Parser builds column→align hashmap when parsing line 2 (separator).
- Run cell contents through **formatmap.eat()** and the same format handlers (got_format / do_format / handle_format_result) as paragraph text.
- **on_block(table cell end, align)** – cell end (pass same align for symmetry).
- … repeat for other cells in the row …
- **on_block(tr end)** – table row end.

**We can't actually start the table until we have the 3rd row:** we must eat line 1 (header row) and line 2 (separator/alignment row) first. Only when we see the 3rd line (first body row with `|`) do we know we have a valid table and can emit **on_table(start)** (and then emit header row, alignment info, and body rows). So:

- **Line 1** (header): consume and store; don't emit table start yet.
- **Line 2** (separator): consume, parse alignment into **column→align hashmap** (e.g. `:---` left, `:---:` center, `---:` right → -1, 0, 1); don't emit table start yet.
- **Line 3** (first body row): NOW emit on_table(start), then emit header row (tr + hcells with align per column from hashmap), then this row (tr + cells with align per column). **Subsequent rows (4th, 5th, …)**: same path – each is one line; we call handle_table_line(line) once per line (tr start → cells with format.eat() and align from hashmap → tr end).

### 3.1 Detection (entering a table)

- **When**: At line start, when `current_block == FormatType.NONE`.
- **Where**: Inside **blockmap.peek()** (see 3.0). No separate table check; BlockMap returns TABLE when it sees `|` at line start and the line (once we have it) ends with `|`. handle_block_result sets current_block = TABLE and passes the 3-line block to handle_table_line (see 3.1a); subsequent lines (4th, 5th, …) are passed to handle_table_line one at a time (see 3.2).

Tables are line-based, so we need to see at least one full line (or up to newline). If the chunk doesn’t contain a newline and we’re not at end of chunks, we may need to buffer and return “need more data” (same pattern as fenced code / other block detection).

### 3.2 When we’re already in a table (`current_block == TABLE`)

- **At line start**: Get the rest of the line (up to newline) – **one full row**. If it's a table row (line ends with `|`), pass that **single line** to **handle_table_line(line)** (same per-line path as for the initial 3 rows: tr start → cells with format.eat() → tr end). Advance `chunk_pos` past the line.  
  - **No** (line doesn't look like a table row): Table ends. Call `do_block(false, FormatType.TABLE)`, set `current_block = FormatType.NONE`, don't advance past this line so the main loop re-runs.
- **Not at line start**: We're in the middle of a cell; the per-line logic inside handle_table_line (or the cell-parsing path) runs cell content through formatmap.eat() and format handlers.

### 3.3 add() order, newline handling, and flags

**Does add()'s newline detection interfere?** No, as long as we do two things:

1. **When waiting for the 3rd line** (we haven't set `current_block = TABLE` yet): We only call `blockmap.peek()` when `at_line_start` is true. If BlockMap returns -1 (need more), we set `leftover_chunk` and **return from add() without advancing `chunk_pos`**. So we never consume the newline in that iteration – the newline stays in the chunk for the next call. No extra flag is needed for "waiting for table"; we only set `current_block = TABLE` after we have 3 lines.

2. **When we're already in a table** (`current_block == TABLE`): We must **check `current_block == TABLE` before** calling `blockmap.peek()` at line start. Otherwise the next line (e.g. 4th row `| e | f|`) would go through `blockmap.peek()`, which would try to match TABLE again (need 3 lines), get -1, and incorrectly set `leftover_chunk` instead of passing the line to handle_table_line. So in add(), at line start: **if `current_block == TABLE`**, handle the line as a table line (get rest of line, pass to handle_table_line or end table); **else** call `blockmap.peek()`. No extra flag – we use `current_block == TABLE` to branch.

### 3.4 Newline / handle_line_break

- When `current_block == FormatType.FENCED_CODE_*`, we do **not** end the block on every newline; we only end on closing fence.
- For tables, same idea: **do not** end the block on every newline. In `handle_line_break`, when `current_block == FormatType.TABLE`, we should **not** call `do_block(false, TABLE)` and clear `current_block`. We only end the table when we see a **non-table line** at line start (see 3.2). So `handle_line_break` gets a branch: if `current_block == TABLE`, emit newline (or handle in table logic), set `at_line_start = true`, advance; else current behaviour (flush text, end block, emit newline).

### 3.5 do_block and renderer

- In `do_block()`, add a case for `FormatType.TABLE`:
  - `do_block(true, TABLE)` – table start is emitted from **handle_table_line** when we have the 3rd row (see 3.1a), not here.
  - `do_block(false, TABLE)` → e.g. `renderer.on_table(false)` when the table ends (non-table line).
- Renderer API: see section 6 (Renderer interface).

### 3.6 Cell content and inline formatting

- Cell content can use the **same inline formatting** as paragraph text: formatmap.eat() for bold, italic, code, etc. So either:
  - Table row parser returns “cell text” spans and we run the same format-handling loop we use for paragraph over each cell, or
  - We have a shared “parse inline format in this span” helper used by both paragraph and table cell handling.
- No new FormatMap or new map is required for cell content; reuse `formatmap` and existing `handle_format_result` / `got_format` / `do_format` path (possibly factored so it can be called for a substring/cell).

---

## 4. Summary: what’s involved

| Piece | What |
|-------|------|
| **State** | Use existing `FormatType.TABLE` as `current_block`. Add small sub-state: table phase (header/alignment/body), column count, optional alignments. |
| **Row/cell parsing** | In Parser when current_block == TABLE (or optional small helper). Detection is in BlockMap.peek(), not a separate map.
| **Parser changes** | (1) handle_block_result: when TABLE, split 3-line block into 3 lines and call **handle_table_line(line)** three times. (2) handle_table_line(line): one line per call for every row; buffers line 1 and 2; on line 3 emits on_table(start), then header row, alignment, body row; same per-line path for rows 4+. (3) When `current_block == TABLE`: at line start, get one line and pass to handle_table_line(line) or leave table. (4) handle_line_break: do not end TABLE on newline. (5) do_block(false, TABLE) when table ends. |
| **Architecture** | All logic stays in Parser + BlockMap.peek(); no sub-parsers. |
| **BlockMap** | Add TABLE to BlockMap.peek(): marker map gets `"|"` = TABLE; in peek(), branch for matched_block == TABLE (return -1 until we have 3 full lines ending with `|`; then TABLE, byte_length = 3 lines; else → 0). See 3.0.

---

## 5. Files to add or touch

- **Modify**: `libocmarkdown/BlockMap.vala` – add `"|"` = TABLE to marker map; in `peek()`, add branch for TABLE (return -1 until we have 3 full lines ending with `|`; then TABLE, byte_length = those 3 lines; else → 0).
- **Modify**: `libocmarkdown/Parser.vala` – table state; in handle_block_result, when TABLE pass line to **handle_table_line**; implement handle_table_line (buffer header/separator, emit table start on 3rd row, tr/cell callbacks, format.eat() for cells); handle_line_break branch for TABLE; do_block(false, TABLE) when table ends.
- **Optional**: small helper for row/cell/alignment parsing (or keep in Parser).
- **Modify**: `libocmarkdown/meson.build` (and `docs/meson.build` if needed) – only if adding a new helper file.
- **RenderBase / renderers**: add table API (see section 6); implement per phased plan below.

---

## 6. Renderer interface

Add to **RenderBase** (and implement in HTML, Dummy, and markdowngtk renderers):

- **on_table(bool start)** – table start (true) or table end (false).
- **on_table_row(bool start)** – table row (tr) start or end.
- **on_table_hcell(bool start, int align)** – header cell start or end (first row only). **align**: -1 = left (default), 0 = center, 1 = right.
- **on_table_cell(bool start, int align)** – body cell start or end. **align**: -1 = left (default), 0 = center, 1 = right.

Parser parses the separator line (line 2) and builds a **hashmap**: column index → align (-1/0/1). Parser passes **align** on each cell callback (on_table_hcell and on_table_cell). Cell content is sent via the same path as paragraph text (format handlers: on_text, on_strong, on_em, etc.) between cell start and cell end.

---

## 7. Phased implementation

Implement in this order so each phase builds on the previous and can be tested. Each phase has its own plan file:

| Phase | Plan file | Summary |
|-------|-----------|---------|
| **1.10.1** | [1.10.1-DONE-renderer-interface.md](1.10.1-DONE-renderer-interface.md) | Add table methods to RenderBase (on_table, on_table_row, on_table_hcell, on_table_cell). |
| **1.10.2** | [1.10.2-DONE-html-dummy.md](1.10.2-DONE-html-dummy.md) | Add simple support in HtmlRender and DummyRenderer (HTML tags / log). |
| **1.10.3** | [1.10.3-gtk-renderer.md](1.10.3-gtk-renderer.md) | Add support in markdowngtk Render (Gtk.Grid, Table, cell content, insertion). |
| **1.10.4** | [1.10.4-table-handling.md](1.10.4-table-handling.md) | Implement handle_table_line(line) in Parser (buffer header/separator, emit callbacks, format.eat() for cells). |
| **1.10.5** | [1.10.5-calling-code-types.md](1.10.5-calling-code-types.md) | handle_block_result TABLE case; add() TABLE branch; handle_line_break and do_block for TABLE. |
| **1.10.6** | [1.10.6-blockmap-parser.md](1.10.6-blockmap-parser.md) | Table detection in BlockMap.peek() (3 lines ending with \|; return -1 / 0). |

---

