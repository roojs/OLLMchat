# 2.6.1.11. File Deletion Handling

## Overview

Implement proper handling of deleted files across the system. When files are deleted, they are removed from the filesystem, but their database records remain with `delete_id > 0` pointing to the FileHistory deletion record. This allows for cleanup operations, UI updates, and potential restoration. The system needs to track deleted files, clean up references, and ensure scanning methods ignore deleted files.

## Status

â³ **PLANNING** - Design phase.

## Prerequisites

- Phase 1 (2.6.1.1) must be completed
- Phase 2 (2.6.1.2) must be completed
- Phase 3 (2.6.1.3) must be completed
- Phase 4 (2.6.1.4) must be completed
- Phase 10 (2.6.1.10) must be completed (overlay scanning)
- See main plan: `2.6.1-code-exec-improvements.md` for overlay details

## Goals

1. Add `delete_id` column to FileBase class and database schema (points to FileHistory.id where change_type="deleted")
2. Link deleted files to their FileHistory deletion record
3. Implement cleanup methods for database references
4. Implement cleanup methods for in-memory data structures
5. Update scanning methods to ignore deleted files when loading from database (WHERE delete_id = 0)
6. Support sourceview editor notification via `notify::delete_id` property signal (only editor monitors signals, other UI updates automatically via ListModel changes)
7. Determine which data structures should contain deleted files and which should not

## Analysis: What Stores Files and Are They Affected?

### Database Storage

**`filebase` table:**
- **Purpose**: Primary storage for all FileBase objects (File, Folder, FileAlias)
- **Should contain deleted files?**: **YES** - database records persist with `delete_id` pointing to FileHistory
- **Rationale**: Database references remain even after files are deleted from filesystem. The `delete_id` column points to the FileHistory record where `change_type="deleted"`, providing a direct link to deletion information (timestamp, agent, etc.). The actual file is removed from disk, but the database record is kept.
- **Action**: Add `delete_id` column (INT64, foreign key to file_history.id), keep deleted file records in table (they are not removed from database). `delete_id = 0` means file is not deleted, `delete_id > 0` points to the deletion record.

**`file_history` table:**
- **Purpose**: Tracks file changes (added, modified, deleted)
- **Should contain deleted files?**: **YES** - already does via `change_type="deleted"`
- **Rationale**: Historical record of deletions, `filebase_id=0` for deleted files
- **Action**: No changes needed - already handles deletions correctly

**`vector_metadata` table:**
- **Purpose**: Maps vector IDs to file locations
- **Should contain deleted files?**: **NO** - references should be cleaned up
- **Rationale**: Vector metadata for deleted files is useless and should be removed
- **Action**: Add cleanup method to remove vector_metadata entries for deleted files

### In-Memory Storage

**`ProjectFiles` (flat list for dropdowns/search):**
- **Purpose**: Flat list of ProjectFile objects for UI dropdowns and search
- **Should contain deleted files?**: **NO** - UI should not show deleted files
- **Rationale**: Users shouldn't see deleted files in dropdowns or search results
- **Action**: Remove deleted files from ProjectFiles when `delete_id` is set (> 0)
- **Implementation**: Explicit cleanup calls remove from list (ListModel automatically notifies bound UI components). Only sourceview editor monitors `notify::delete_id` signal directly.

**`FolderFiles` (hierarchical tree structure):**
- **Purpose**: Hierarchical list of FileBase objects in Folder.children for tree views
- **Should contain deleted files?**: **NO** - UI should not show deleted files in tree
- **Rationale**: Tree views should not display deleted files
- **Action**: Remove deleted files from Folder.children when `delete_id` is set (> 0)
- **Implementation**: Watch `notify::delete_id` signal and remove from children list when `delete_id > 0`

**`ProjectManager.file_cache` (HashMap path => FileBase):**
- **Purpose**: Quick lookup cache for FileBase objects by path
- **Should contain deleted files?**: **MAYBE** - temporarily for cleanup, then remove
- **Rationale**: May need deleted files in cache temporarily for cleanup operations
- **Action**: Remove from cache during cleanup phase, or keep until cleanup completes
- **Implementation**: Cleanup method removes deleted files from cache (where `delete_id > 0`)

### External References

**VectorMetadata references:**
- **Purpose**: Vector search metadata references files via `file_id`
- **Should contain deleted files?**: **NO** - should be cleaned up
- **Rationale**: Vector metadata for deleted files is useless
- **Action**: Add cleanup method to remove vector_metadata entries where file_id references deleted files

**FileHistory references:**
- **Purpose**: Historical record of file changes
- **Should contain deleted files?**: **YES** - already does correctly
- **Rationale**: Historical record should persist, uses `filebase_id=0` for deleted files
- **Action**: No changes needed

## Implementation Details

### Database Schema Changes

**Add `delete_id` column to `filebase` table:**

```sql
ALTER TABLE filebase ADD COLUMN delete_id INT64 NOT NULL DEFAULT 0;
```

**Migration:**
- Add column with default value 0 (not deleted)
- Existing files remain with `delete_id = 0` (not deleted)
- New files default to `delete_id = 0` (not deleted)
- `delete_id > 0` means file is deleted and points to `file_history.id` where `change_type="deleted"`
- `delete_id = 0` means file is not deleted

### FileBase Class Changes

**Add `delete_id` property:**

```vala
/**
 * Reference to FileHistory record where this file was deleted.
 * 
 * If delete_id = 0, the file is not deleted.
 * If delete_id > 0, the file is deleted and delete_id points to file_history.id
 * where change_type="deleted".
 * 
 * Deleted files are flagged rather than immediately removed from database,
 * allowing for cleanup operations and UI updates. Files with delete_id > 0
 * should be excluded from UI lists and scanning operations.
 * 
 * Provides direct link to deletion information (timestamp, agent, etc.)
 * via the FileHistory record.
 */
public int64 delete_id { get; set; default = 0; }
```

**Property notification:**
- Emits `notify::delete_id` signal when value changes
- UI components can watch this signal to update their lists

**Database operations:**
- `saveToDB()`: Save `delete_id` to database
- `copy_db_fields_to()`: Copy `delete_id` when updating
- `init_db()`: Add `delete_id` column to CREATE TABLE statement

### DeleteManager Class

**New class: `DeleteManager`**

Centralizes all file deletion logic. Handles filesystem deletion, FileHistory backup creation, database updates, and cleanup operations.

**Location**: `libocfiles/DeleteManager.vala`

**Constructor:**
```vala
public DeleteManager(ProjectManager manager)
{
    this.manager = manager;
}
```

**Main method:**
```vala
/**
 * Delete a file or folder.
 * 
 * Routes to appropriate handler based on file type.
 * 
 * @param filebase The FileBase object to delete (File, Folder, or FileAlias)
 */
public async void remove(FileBase filebase)
{
    if (filebase is Folder) {
        yield this.remove_folder((Folder)filebase);
        return;
    }
    
    // Handle File and FileAlias the same way (both are files, just different types)
    yield this.remove_file(filebase);
}
```


**DeleteManager.remove_file():**

```vala
/**
 * Delete a file or file alias from filesystem and create FileHistory record.
 * 
 * Handles:
 * 1. Create FileHistory record with backup (must be done before deletion)
 * 2. Delete file/symlink from filesystem (actual file removal)
 * 3. Set delete_id in database
 * 
 * Note: Cleanup from lists (ProjectFiles, FolderFiles) is done separately
 * by calling ProjectFiles.cleanup_deleted() and FolderFiles.cleanup_deleted()
 * Signal emission for VectorMetadata cleanup happens during cleanup, not here.
 * 
 * @param filebase The FileBase object to delete (File or FileAlias)
 */
private async void remove_file(FileBase filebase)
{
    // 1. Create FileHistory record with backup (must be done BEFORE deletion)
    // FileHistory.commit() creates a backup copy of the file
    var history = new FileHistory() {
        path = filebase.path,
        filebase_id = filebase.id,
        change_type = "deleted",
        base_type = filebase.base_type,
        timestamp = get_current_timestamp(),
        // ... other fields
    };
    yield history.commit(this.manager.db);
    
    // 2. Delete from filesystem (actual file/symlink removal)
    var gfile = GLib.File.new_for_path(filebase.path);
    try {
        yield gfile.delete_async();
    } catch (GLib.Error e) {
        GLib.warning("Failed to delete file %s: %s", filebase.path, e.message);
    }
    
    // 3. Link database record to FileHistory deletion record
    filebase.delete_id = history.id;
    filebase.saveToDB(this.manager.db, null, false);
    
    // Note: Signal emission happens during cleanup 
	//  (in ProjectFiles.cleanup_deleted() / FolderFiles.cleanup_deleted())
}
```

**DeleteManager.remove_folder():**

```vala
/**
 * Delete a folder from filesystem and create FileHistory record.
 * 
 * Handles:
 * 1. Create FileHistory record with backup (must be done before deletion)
 * 2. Recursively delete folder and all contents from filesystem
 * 3. Set delete_id in database
 * 
 * Note: Cleanup from lists (ProjectFiles, FolderFiles) is done separately
 * by calling ProjectFiles.cleanup_deleted() and FolderFiles.cleanup_deleted()
 * Signal emission for VectorMetadata cleanup happens during cleanup, not here.
 * 
 * @param folder The Folder object to delete
 */
private async void remove_folder(Folder folder)
{
    // 1. Create FileHistory record with backup (must be done BEFORE deletion)
    // FileHistory.commit() creates a backup copy of the folder
    var history = new FileHistory() {
        path = folder.path,
        filebase_id = folder.id,
        change_type = "deleted",
        base_type = folder.base_type,
        timestamp = get_current_timestamp(),
        // ... other fields
    };
    yield history.commit(this.manager.db);
    
    // 2. Recursively delete all children first (files and subfolders)
    // Make a copy of children list since we'll be modifying the original
    var children_copy = new Gee.ArrayList<FileBase>();
    foreach (var child in folder.children.items) {
        children_copy.add(child);
    }
    
    // Recursively delete each child
    foreach (var child in children_copy) {
        if (child is Folder) {
            yield this.remove_folder((Folder)child);
        } else {
            yield this.remove_file(child);
        }
    }
    
    // 3. Delete the folder itself from filesystem (after all children are deleted)
    var gfile = GLib.File.new_for_path(folder.path);
    try {
        yield gfile.delete_async();
    } catch (GLib.Error e) {
        GLib.warning("Failed to delete folder %s: %s", folder.path, e.message);
    }
    
    // 4. Link database record to FileHistory deletion record
    folder.delete_id = history.id;
    folder.saveToDB(this.manager.db, null, false);
    
    // Note: Signal emission happens during cleanup (in FolderFiles.cleanup_deleted())
}
```

**ProjectManager Integration:**

```vala
// In ProjectManager constructor
public ProjectManager(SQ.Database? db = null)
{
    this.db = db;
    if (this.db != null) {
        FileBase.init_db(this.db);
        FileHistory.init_db(this.db);
    }
    this.git_provider.initialize();
    
    // Create DeleteManager instance
    this.delete_manager = new DeleteManager(this);
}

// In ProjectManager class
public DeleteManager delete_manager { get; private set; }

// Note: No delete_file() convenience method needed
// Callers make two separate calls:
// 1. manager.delete_manager.remove(filebase) - handles deletion (filesystem + FileHistory + database)
// 2. manager.delete_manager.cleanup() - handles cleanup (in-memory lists for all projects)
```

### Deletion Flow

**When a file is deleted (e.g., in Scan.handle_remove()):**

```vala
// Step 1: Delete file/folder (filesystem + FileHistory + database)
// DeleteManager handles: filesystem deletion, FileHistory backup creation, database update (delete_id)
yield manager.delete_manager.remove(filebase);

// Step 2: Cleanup from in-memory lists (separate operation, caller's responsibility)
// Cleanup all projects (handles all projects that might have deleted files)
yield manager.delete_manager.cleanup();

// cleanup() handles:
// - Removing from ProjectFiles lists (for all projects)
// - Removing from FolderFiles lists (recursively for all folders in all projects)
// - Emits on_cleanup signal after cleanup is complete (for bulk VectorMetadata cleanup)
```

**DeleteManager.remove() routes to:**
- `remove_file()` - for File and FileAlias objects (handled identically)
- `remove_folder()` - for Folder objects

**Each handler (deletion phase):**
1. Creates FileHistory record with backup (via FileHistory.commit()) - must be done BEFORE deletion
2. Deletes from filesystem (actual file/folder removal)
3. Sets `delete_id = history.id` in database

**Note:** DeleteManager does NOT handle cleanup. Cleanup is the caller's responsibility.

**Cleanup phase (caller's responsibility):**
- Call `DeleteManager.cleanup()` to clean up all projects
- This calls `project.project_files.cleanup_deleted()` and `project.children.cleanup_deleted()` for all projects
- `FolderFiles.cleanup_deleted()` recursively cleans up deleted folders before removing them
- After cleanup is complete, `DeleteManager.cleanup()` emits `on_cleanup` signal
- Tools (e.g., CodebaseSearchTool) listen to this signal to perform bulk VectorMetadata cleanup
- NOT emitted during deletion - only after cleanup is complete

### Removal Methods

**ProjectFiles.cleanup_deleted():**

```vala
/**
 * Cleanup deleted files from ProjectFiles list and child_map.
 * 
 * This is a list-level cleanup operation that removes items from a single list.
 * Iterates through items and removes any ProjectFile where file.delete_id > 0.
 * Batches removals to minimize signal emissions. Since GLib.ListModel.items_changed
 * only supports one contiguous range per signal, this emits one broad signal
 * indicating all items from the first deletion position changed.
 * 
 * This should be called after files are flagged as deleted (during cleanup phase).
 */
public async void cleanup_deleted()
{
    var lowest_removed_index = -1;
    var removed_count = 0;
    
    // Iterate backwards for safe removal (highest to lowest index)
    for (var i = (int)this.items.size - 1; i >= 0; i--) {
        var project_file = this.items.get(i);
        if (project_file.file.delete_id == 0) {
            continue;  // Skip non-deleted files
        }
        
        // Remove from array and child_map immediately
        this.items.remove_at(i);
        this.child_map.unset(project_file.file.path);
        removed_count++;
        lowest_removed_index = i;  // Track lowest index (will be last one found)
    }
    
    if (removed_count == 0) {
        return; // Nothing to remove
    }
    
    // Emit single items_changed signal for the range
    // GLib.ListModel.items_changed only supports one contiguous range per signal
    // For sparse (non-contiguous) deletions, we emit one broad signal:
    // "from lowest_removed_index, removed N items" 
    // This tells UI to refresh from that position onwards
    // Less precise than multiple signals but correct and efficient
    this.items_changed((uint)lowest_removed_index, (uint)removed_count, 0);
    
    // Note: VectorMetadata cleanup happens via DeleteManager.on_cleanup signal
    // (emitted by DeleteManager.cleanup() after all cleanup is complete)
}
```

**FolderFiles.cleanup_deleted():**

```vala
/**
 * Cleanup deleted files from FolderFiles list and child_map.
 * 
 * Recursively handles cleanup: if a deleted item is a Folder, it recursively
 * cleans up that folder's children before removing it from this list.
 * 
 * Iterates through items and removes any FileBase where delete_id > 0.
 * Batches removals to minimize signal emissions.
 * This should be called after files are flagged as deleted (during cleanup phase).
 */
public async void cleanup_deleted()
{
    var lowest_removed_index = -1;
    var removed_count = 0;
    
    // Iterate backwards for safe removal (highest to lowest index)
    for (var i = (int)this.items.size - 1; i >= 0; i--) {
        var filebase = this.items.get(i);
        if (filebase.delete_id == 0) {
            continue;  // Skip non-deleted files
        }
        
        // If this is a deleted folder, recursively clean up its children first
        if (filebase is Folder) {
            var folder = (Folder)filebase;
            yield folder.children.cleanup_deleted();  // Recursive cleanup
        }
        
        // Remove from array and child_map immediately
        this.items.remove_at(i);
        this.child_map.unset(GLib.Path.get_basename(filebase.path));
        removed_count++;
        lowest_removed_index = i;  // Track lowest index (will be last one found)
    }
    
    if (removed_count == 0) {
        return; // Nothing to remove
    }
    
    // Emit single items_changed signal for the range
    // GLib.ListModel.items_changed only supports one contiguous range per signal
    // For sparse (non-contiguous) deletions, we emit one broad signal:
    // "from lowest_removed_index, removed N items" 
    // This tells UI to refresh from that position onwards
    // Less precise than multiple signals but correct and efficient
    this.items_changed((uint)lowest_removed_index, (uint)removed_count, 0);
    
    // Note: VectorMetadata cleanup happens via DeleteManager.on_cleanup signal
    // (emitted by DeleteManager.cleanup() after all cleanup is complete)
}
```

**Note on Cleanup:**

Cleanup from in-memory lists is handled by calling `DeleteManager.cleanup()`:

```vala
// After deleting files, call cleanup on all projects
yield manager.delete_manager.cleanup();

// This handles:
// - Removing from ProjectFiles lists (for all projects)
// - Removing from FolderFiles lists (recursively for all folders in all projects)
// - Signal emission for VectorMetadata cleanup (happens during list cleanup)
```

**VectorMetadata Signal Handler (in CodebaseSearchTool constructor):**

```vala
// In CodebaseSearchTool constructor (libocvector/Tool/CodebaseSearchTool.vala)
// CodebaseSearchTool has access to project_manager
// 
// Note: BackgroundScan does NOT need to know about deletions.
// When processing the queue, it already handles missing files gracefully
// (skips them if not found in project_files.child_map).
// The on_cleanup signal is for bulk VectorMetadata cleanup.

public CodebaseSearchTool(...)
{
    // ... existing constructor code ...
    var project_manager = this.project_manager;
    
    // Connect to DeleteManager.on_cleanup signal for bulk VectorMetadata cleanup
    this.project_manager.delete_manager.on_cleanup.connect(() => {
        // Bulk cleanup: remove all vector_metadata entries for deleted files
        VectorMetadata.cleanup_all_deleted.begin(this.project_manager.db);
    });
}
```

**VectorMetadata.cleanup_all_deleted():**

```vala
/**
 * Remove vector_metadata entries for all deleted files.
 * 
 * Uses a bulk DELETE query to efficiently remove all vector_metadata entries
 * that reference deleted files. Only removes metadata for files (base_type = 'f'),
 * not folders.
 * 
 * Called automatically via DeleteManager.on_cleanup signal after
 * DeleteManager.cleanup() completes.
 * 
 * Can also be called on startup or periodically to ensure consistency.
 */
public static async void cleanup_all_deleted(SQ.Database db)
{
    // Bulk DELETE query: remove all vector_metadata entries for deleted files
    // Only delete metadata for files (base_type = 'f'), not folders
    var delete_query = "DELETE FROM vector_metadata WHERE file_id IN (" +
        "SELECT id FROM filebase WHERE delete_id > 0 AND base_type = 'f'" +
        ")";
    // Execute delete query
    db.exec(delete_query);
}
```

**Indexer.index_file() - Check delete_id Before Saving:**

```vala
// In libocvector/Indexing/Indexer.vala
// After scanning completes, check if file was deleted before saving

public async bool index_file(OLLMfiles.File file, bool force = false) throws GLib.Error
{
    // ... existing scanning logic ...
    
    // After scanning completes (before saveToDB):
    // 1. Fetch filebase from database again to check current delete_id
    var query = FileBase.query(this.sql_db, this.worker_project_manager);
    var check_file = new Gee.ArrayList<FileBase>();
    yield query.select_async("WHERE id = " + file.id.to_string(), check_file);
    
    // 2. Check if file was deleted during scan or no longer exists
    if (check_file.size == 0) {
        // File not found in database - may have been deleted, skip update
        GLib.debug("Indexer: Skipping saveToDB for file '%s' (not found in database)", file.path);
        return true;  // Return success but don't update database
    }
    
    var db_file = check_file.get(0);
    if (db_file.delete_id > 0) {
        // File was deleted - skip database update
        GLib.debug("Indexer: Skipping saveToDB for deleted file '%s' (delete_id=%lld)", 
            file.path, db_file.delete_id);
        return true;  // Return success but don't update database
    }
    
    // 3. File not deleted - proceed with normal save
    file.last_vector_scan = new DateTime.now_local().to_unix();
    file.saveToDB(this.sql_db, null, false);
    
    // ... rest of method ...
}
```

**Note**: This check happens after scanning completes but before saving to the database. If a file was deleted while it was queued or being processed, we avoid updating its metadata.

### Scanning Methods: Ignore Deleted Files

**Folder.load_files_from_db():**

Update `load_children()` method to exclude deleted files:

```vala
// In load_children() method, update WHERE clause:
yield query.select_async("WHERE (" + 
    string.joinv(" OR ", path_conds) + ") AND id NOT IN (" + 
    string.joinv(", ", seen_ids.to_array()) + ") AND delete_id = 0", new_files);
```

**ProjectManager.load_projects_from_db():**

Update query to exclude deleted projects:

```vala
yield query.select_async("WHERE is_project = 1 AND delete_id = 0", projects_list);
```

**All database queries that load files:**

Add `AND delete_id = 0` condition to WHERE clauses:
- `Folder.load_children()` - already covered above
- `ProjectManager.load_projects_from_db()` - already covered above
- Any other queries that load FileBase objects from database

### UI Notification (Signal Monitoring)

**Note**: Only the sourceview editor needs to monitor `notify::delete_id` signals. Other UI components (FileDropdown, tree views) automatically update when files are removed from ProjectFiles/FolderFiles lists via explicit cleanup calls, since they're bound to those ListModels.

**SourceView Editor watching `notify::delete_id`:**

```vala
// In SourceView/FileBuffer component (only UI component that monitors signals)
// This is needed because the editor might have a file open that gets deleted
file.notify["delete-id"].connect(() => {
    if (file.delete_id > 0) {
        // Handle file deletion in editor
        // - Clear buffer contents (current behavior)
        // - Show "file deleted" indicator
        // - Disable editing
        // - Optionally close tab
        // Can access deletion info via: file.delete_id -> FileHistory record
        // 
        // Future: When sourceview can handle diffs, it will show the original file
        // content as red deleted (like a diff view showing deleted lines)
    }
});
```

**Other UI Components (Automatic Updates):**

```vala
// FileDropdown, tree views, etc. don't need to monitor signals
// They're bound to ProjectFiles/FolderFiles ListModels
// When cleanup_deleted() removes items from those lists,
// the ListModel automatically emits items_changed signals
// UI components bound to the ListModel will update automatically
```

**Non-UI Code (Using DeleteManager):**

```vala
// In Scan.handle_remove() or other deletion code
// The caller makes TWO separate calls:

// Step 1: Delete file/folder (filesystem + FileHistory + database)
// DeleteManager handles: filesystem deletion, FileHistory backup creation, database update (delete_id)
yield manager.delete_manager.remove(filebase);

// Step 2: Cleanup from in-memory lists (separate operation, caller's responsibility)
// Cleanup all projects (handles all projects that might have deleted files)
yield manager.delete_manager.cleanup();

// cleanup() methods handle:
// - Removing from ProjectFiles/FolderFiles lists (recursively for all subfolders in all projects)
// - Emitting items_changed signals (batched)
// - Emitting on_cleanup signal after cleanup is complete (for bulk VectorMetadata cleanup)
// UI components bound to ListModels will update automatically
```

## Files to Create/Modify

### New Files
- `libocfiles/DeleteManager.vala` - Manager class for handling file deletions (handles filesystem deletion, FileHistory backups, database updates, cleanup)

### Files to Modify
- `libocfiles/ProjectManager.vala` - Add `delete_manager` property, initialize in constructor
- `libocfiles/FileBase.vala` - Add `delete_id` property and database column
- `libocfiles/ProjectFiles.vala` - Add `cleanup_deleted()` method (for bulk cleanup)
- `libocfiles/FolderFiles.vala` - Add `cleanup_deleted()` method (for bulk cleanup)
- `libocvector/VectorMetadata.vala` - Add `cleanup_deleted()` and `cleanup_deleted()` methods
- `liboctools/RunCommand/Scan.vala` - Update `handle_remove()` to use `manager.delete_manager.remove()`
- `libocfiles/ProjectFiles.vala` - Update `remove_complete()` to use `manager.delete_manager.remove()`
- `libocfiles/Folder.vala` - Update `load_children()` to exclude deleted files (`AND delete_id = 0`)
- `libocfiles/ProjectManager.vala` - Update `load_projects_from_db()` to exclude deleted projects (`AND delete_id = 0`)
- `liboccoder/GtkSourceFileBuffer.vala` or similar - Add `notify::delete-id` signal handler in sourceview editor

## Implementation Phases

### Phase 1: Add delete_id Column and Support

- [ ] Add `delete_id` property to FileBase class (int64, default = 0)
- [ ] Add `delete_id` column to database schema (init_db and migration)
- [ ] Update `saveToDB()` to save `delete_id` to database
- [ ] Update `copy_db_fields_to()` to copy `delete_id` when updating
- [ ] Update `Folder.load_children()` to exclude deleted files (`AND delete_id = 0`)
- [ ] Update `ProjectManager.load_projects_from_db()` to exclude deleted projects (`AND delete_id = 0`)
- [ ] Review all database queries that load files and add `AND delete_id = 0` condition
- [ ] Update `Indexer.index_file()` to check `delete_id` before saving scan date:
  - After scanning completes, fetch filebase from database using `file.id` (query `WHERE id = ?`)
  - Check if `delete_id > 0` in the fetched record
  - If deleted or not found, skip `saveToDB()` call (don't update metadata for deleted files)
  - If not deleted, proceed with `saveToDB()` as normal
  - This prevents updating metadata for files that were deleted during the scan
- [ ] Test database migration with existing databases
- [ ] Test scanning methods ignore deleted files

### Phase 2: Create DeleteManager (Basic Structure)

- [ ] Create `DeleteManager` class in `libocfiles/DeleteManager.vala`
- [ ] Add `delete_manager` property to ProjectManager
- [ ] Initialize `delete_manager` in ProjectManager constructor
- [ ] Add `DeleteManager.on_cleanup()` signal
- [ ] Implement basic `DeleteManager.remove()` method (routes to `remove_file()` or `remove_folder()`)
- [ ] Implement basic `DeleteManager.remove_file()` method (placeholder - not yet used)
- [ ] Implement basic `DeleteManager.remove_folder()` method (placeholder - not yet used)
- [ ] Implement basic `DeleteManager.cleanup()` method (placeholder - not yet used)
- [ ] Emit `on_cleanup()` signal in DeleteManager.cleanup() after cleanup is complete
- [ ] Ensure code compiles (DeleteManager exists but not yet integrated)

### Phase 3: Implement Deletion and Cleanup Integration

- [ ] Implement `DeleteManager.remove_file()` fully:
  - Create FileHistory record with backup (must be done BEFORE deletion)
  - Delete from filesystem (actual file/symlink removal)
  - Set `delete_id = history.id` in database
- [ ] Implement `DeleteManager.remove_folder()` fully (recursive):
  - Create FileHistory record with backup (must be done BEFORE deletion)
  - Recursively delete all children first (files and subfolders)
  - Delete the folder itself from filesystem (after all children are deleted)
  - Set `delete_id = history.id` in database
- [ ] Implement `ProjectFiles.cleanup_deleted()` (check `delete_id > 0`) - for bulk cleanup
- [ ] Implement `FolderFiles.cleanup_deleted()` (check `delete_id > 0`) - for bulk cleanup
- [ ] Update `FolderFiles.cleanup_deleted()` to recursively clean up deleted folders before removing them
- [ ] Implement `DeleteManager.cleanup()` method fully (iterates through all projects and cleans them up)
- [ ] Implement `VectorMetadata.cleanup_all_deleted(SQ.Database db)` (bulk cleanup using DELETE query)
- [ ] Connect CodebaseSearchTool to `DeleteManager.on_cleanup` signal for VectorMetadata cleanup
- [ ] Integrate deletion calls in Scan.handle_remove() or appropriate location
- [ ] Test deletion flow with overlay scanning
- [ ] Test cleanup methods

### Phase 4: Implement Editor Notification

- [ ] Add `notify::delete_id` signal handler in FileBuffer/editor components
- [ ] When `delete_id > 0`, clear buffer contents (current behavior)
- [ ] Show "file deleted" indicator
- [ ] Disable editing
- [ ] Remove buffer clearing from `Scan.handle_remove()` - editor will handle it via `notify::delete_id` signal
- [ ] Test editor updates when files are deleted
- [ ] Note: Future enhancement - when sourceview can handle diffs, show original file content as red deleted

### Phase 6: Database Record Retention and Optional Cleanup

- [ ] **Policy Decision**: Database records are NOT removed by default - they remain with `delete_id > 0`
- [ ] Document that database records persist for history and potential restoration
- [ ] Consider adding query methods to find deleted files if restoration is needed
- [ ] **Optional**: Extend `FileHistory.cleanup_old_backups()` to also clean up database records for deleted files

**Existing FileHistory.cleanup_old_backups() Method:**

**What it currently does:**
- Static async method in FileHistory class
- Throttling: Only runs once per day (checks `last_cleanup_timestamp`)
- Enumerates cache directory: `~/.cache/ollmchat/edited/` using `enumerate_children_async()`
- Finds old backup files: Files older than 7 days (hardcoded cutoff_timestamp = now - 7 days)
- Deletes backup files from disk: Uses `delete_async()` to remove old backup files
- Logs results: Reports how many files were deleted
- **Does NOT touch database**: Only cleans up files on disk, doesn't remove database records
- **No config access**: Static method, doesn't have access to Config2

**What needs to be added for database cleanup:**

**1. Add Config2 property:**
- Add `files.max_deleted_days` property to Config2 class (default: 30 days)
- Add doc comments similar to ModelUsage and Options properties
- Note: May move to separate files config later, but put in Config2 for now

**2. Add FileHistory.unlink() method:**
- Add non-async method: `public void unlink()`
- If `backup_path` is empty, return early (do nothing)
- Use `GLib.FileUtils.unlink(backup_path)` to delete the backup file from disk
- No error handling needed (FileUtils.unlink handles errors silently)

**3. Extend cleanup_old_backups() method:**
- Change signature: `public static async void cleanup_old_backups(SQ.Database db, Config2 config)`
- Make db and config2 non-nullable (required parameters)
- Use `config.files.max_deleted_days` for cutoff (default: 30 days)
- After cleaning up old backup files from disk, also clean up database records:
  
  **Step 1: Select FileHistory records older than max_deleted_days**
  - Query: `SELECT * FROM file_history WHERE timestamp < cutoff_timestamp`
  - cutoff_timestamp = now - max_deleted_days days
  - Get all old FileHistory records regardless of change_type (added, modified, deleted)
  - No need to filter columns - runs infrequently and data is cleared after run
  - Query populates an array/list of FileHistory objects (backup_path values are in these objects for Step 3)
  
  **Step 2: Delete database records**
  - Run DELETE queries using subqueries (no need to collect IDs):
    1. `DELETE FROM filebase WHERE delete_id IN (SELECT id FROM file_history WHERE timestamp < cutoff_timestamp)`
    2. `DELETE FROM file_history WHERE timestamp < cutoff_timestamp`
  - This deletes:
    - filebase records for deleted files (where delete_id points to old FileHistory records)
    - All old FileHistory records (added, modified, deleted - no filtering by change_type needed)
  - Do this right after fetching records (before deleting files from disk)
  
  **Step 3: Delete backup files from disk**
  - Iterate through FileHistory objects from the array/list populated in Step 1
  - For each FileHistory object, access `backup_path` property
  - For each backup_path (where not empty), call `FileHistory.unlink()` or use `GLib.FileUtils.unlink(backup_path)` directly
  - This happens after database records are deleted, but we already have the FileHistory objects in the array from Step 1
  
- **Note**: vector_metadata cleanup is already handled by DeleteManager.on_cleanup signal, so we don't need to deal with that here

**Key points:**
- Keep it simple: Select FileHistory records, delete backup files, then delete database records
- Use same throttling mechanism (once per day)
- db and config are required parameters (non-nullable)
- Use subqueries in DELETE statements directly (no need to collect IDs)
- FileHistory.unlink() handles backup file deletion (non-async, uses FileUtils.unlink)

## Testing

### Test Scenarios

1. **Basic deletion:**
   - Delete a file via overlay scanning
   - Verify `delete_id > 0` is set in database (points to FileHistory.id)
   - Verify FileHistory record is created with `change_type="deleted"`
   - Verify `filebase.delete_id` matches FileHistory.id
   - Verify file is removed from ProjectFiles
   - Verify file is removed from Folder.children

2. **Cleanup operations:**
   - Flag multiple files as deleted
   - Run `manager.delete_manager.cleanup()`
   - Verify files removed from all in-memory structures (ProjectFiles, FolderFiles) across all projects
   - Verify vector_metadata entries removed
   - Verify file_cache cleaned up

3. **Scanning ignores deleted files:**
   - Set `delete_id > 0` for a file in database (pointing to FileHistory record)
   - Run `load_files_from_db()`
   - Verify deleted file is not loaded (query includes `AND delete_id = 0`)
   - Verify deleted file does not appear in UI lists

4. **UI notification:**
   - Open a file in sourceview editor
   - Delete the file (create FileHistory record, set `delete_id = history.id`)
   - Verify sourceview editor receives `notify::delete_id` signal and updates (buffer cleared, indicator shown)
   - Verify FileDropdown updates automatically (file removed from ProjectFiles, ListModel emits items_changed)
   - Verify tree views update automatically (file removed from FolderFiles, ListModel emits items_changed)
   - Verify can access deletion info via FileHistory record
   - Verify explicit cleanup calls work (ProjectFiles, FolderFiles cleanup methods)

5. **Multiple deletions:**
   - Delete multiple files in one operation
   - Verify all are flagged correctly
   - Verify cleanup handles all deletions
   - Verify UI updates correctly

### Test Execution

1. Build project: `meson compile -C build`
2. Run existing tests: `./tests/test-bubble.sh`
3. Add new tests for deletion handling
4. Test database migration with existing databases
5. Test cleanup methods with various scenarios

## Notes

- **Filesystem vs Database**: Files are deleted from the filesystem (actual file removal), but database records remain with `delete_id > 0` pointing to the FileHistory deletion record. The database reference is NOT removed.
- **Database Policy**: Database records persist indefinitely with `delete_id > 0` for history, FileHistory references, and potential restoration. They are not removed from the database.
- **delete_id Design**: The `delete_id` column provides a direct foreign key link to the FileHistory record where `change_type="deleted"`. This provides access to deletion timestamp, agent, and other metadata. `delete_id = 0` means not deleted, `delete_id > 0` means deleted.
- **Cleanup Scope**: Cleanup removes deleted files from in-memory structures (ProjectFiles, FolderFiles) but NOT from the database. VectorMetadata cleanup happens via signal emission during list cleanup. file_cache cleanup can be handled separately if needed.
- **Cleanup Timing**: Cleanup runs via explicit method calls after deletion (not via signals). Can be called immediately or scheduled (e.g., on idle, on startup, periodically).
- **Signal Monitoring**: Only UI components monitor `notify::delete_id` signals. Non-UI code (ProjectFiles, FolderFiles, etc.) does not watch signals - they use explicit removal method calls to avoid too many signal handlers.
- **Signal Batching**: `cleanup_deleted()` methods batch removals to minimize signal emissions. Since `GLib.ListModel.items_changed` only supports one contiguous range per signal call, for sparse (non-contiguous) deletions we emit one broad signal indicating all items from the first deletion position changed. This is less precise than multiple signals but more efficient and still correct. The UI will refresh the affected range.
- **UI Updates**: UI components bound to ListModels update automatically when `items_changed` signal is emitted. Only the sourceview editor monitors `notify::delete_id` signals directly.
- **Scanning Performance**: Adding `AND delete_id = 0` to queries should have minimal performance impact (indexed column).
- **Vector Metadata**: Vector metadata for deleted files is removed via `DeleteManager.on_cleanup` signal. The signal is emitted by `DeleteManager.cleanup()` after all cleanup is complete. CodebaseSearchTool (in libocvector) listens to this signal (via `project_manager.delete_manager.on_cleanup`) and calls `VectorMetadata.cleanup_all_deleted()` which performs a bulk DELETE query: `DELETE FROM vector_metadata WHERE file_id IN (SELECT id FROM filebase WHERE delete_id > 0 AND base_type = 'f')`. This avoids circular dependency since libocfiles cannot depend on libocvector.
- **BackgroundScan**: BackgroundScan does NOT need to know about deletions. It runs in a separate thread with its own ProjectManager instance (`worker_project_manager`) and separate memory store. It is triggered by `file_contents_changed` signal when files are saved (Window connects to this signal and calls `background_scan.scanFile()`). BackgroundScan uses a queue (`Gee.ArrayQueue<BackgroundScanItem>`) to handle multiple files - each `scanFile()` call adds an item to the queue, and `startQueue()` processes them sequentially (with a `queue_processing` guard to prevent multiple concurrent loops). When processing the file queue, it reloads projects from the database (via `set_active_project_and_load()` which calls `load_files_from_db()`). Since `load_children()` will exclude deleted files (`AND delete_id = 0`), deleted files won't be in `project_files.child_map` when BackgroundScan tries to process them. BackgroundScan already handles missing files gracefully (skips them if not found, line 465-467). We should NOT trigger `file_contents_changed` for deleted files - that signal is for content changes, not deletions.
- **BackgroundScan Database Updates**: After BackgroundScan completes indexing a file, it updates `file.last_vector_scan` and calls `file.saveToDB()`. However, if the file was deleted during the scan (while it was queued or being processed), we should not update the database. Therefore, `Indexer.index_file()` should check `delete_id` before saving: after scanning, fetch the filebase from the database again (using `file.id`) and check if `delete_id > 0`. If the file is deleted, skip the `saveToDB()` call. This prevents updating metadata for deleted files.
- **FileHistory Link**: The `delete_id` provides a direct link to deletion information, making it easy to query when/how a file was deleted.

## Migration Notes

- **Database Migration**: Existing databases will have `delete_id = 0` for all files (default value, meaning not deleted).
- **Backward Compatibility**: Old code that doesn't check `delete_id` will still work, but may load deleted files.
- **Gradual Rollout**: Can implement `delete_id` column first, then add cleanup, then add scanning filters.
- **FileHistory**: No changes needed - already handles deletions correctly with `filebase_id = 0`. The `delete_id` links back to the FileHistory record.
- **Database Records**: Deleted files remain in database with `delete_id > 0` pointing to FileHistory - they are not removed from the `filebase` table.
- **Foreign Key**: `delete_id` is a foreign key to `file_history.id` where `change_type="deleted"`. This provides direct access to deletion metadata.

## Future Considerations

- **Deleted Files View**: Consider adding a UI view to show deleted files (for review or restoration).
- **Restoration**: Consider adding ability to restore deleted files:
  - Set `delete_id = 0` in database (clear deletion flag)
  - Restore file from backup (FileHistory.backup_path, accessed via `delete_id`)
  - Re-add to in-memory structures (ProjectFiles, FolderFiles)
- **FileHistory Access**: Consider adding helper method to get FileHistory deletion record:
  ```vala
  public FileHistory? get_deletion_history(SQ.Database db) {
      if (this.delete_id == 0) return null;
      // Query FileHistory by id = this.delete_id
  }
  ```
- **Permanent Deletion**: If needed, consider adding a "permanent delete" operation that removes database records, but this is not the default behavior.
- **Cleanup Scheduling**: Consider adding scheduled cleanup of in-memory structures (e.g., on startup) to ensure consistency.
- **Bulk Operations**: Consider optimizing cleanup for large numbers of deleted files.
- **Database Queries**: Consider adding query methods to find deleted files (e.g., `SELECT * FROM filebase WHERE delete_id > 0`) for restoration UI. Can join with FileHistory to get deletion details.
