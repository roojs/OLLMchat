# 2.19. OLLMchat CLI for Agents

## Status

⏳ **PLANNING** - Detailed analysis complete, implementation pending

## Coding Standards Checklist

Before implementing, verify this plan adheres to the coding standards in `.cursor/rules/CODING_STANDARDS.md`:

- ✅ **Nullable types**: Plan avoids nullable types where possible (project_manager is nullable but required for agent tools, validated explicitly; project_path is nullable which is appropriate)
- ✅ **Null checks**: Plan only includes null checks where explicitly required (validating --project with --agent-tool, checking project_path before use)
- ✅ **String interpolation**: Plan uses `@"..."` only for multi-line usage/help text (correct usage per standards)
- ✅ **Temporary variables**: Plan avoids one-use temporaries (all inlined: `available` inlined in error message, `tool` inlined in execute call, `agent` inlined as `session.agent.chat()`, `tool_call` inlined in execute call, `result` kept as it's used in printf - acceptable for readability)
- ✅ **Brace placement**: Plan keeps brace style consistent (line breaks for namespaces/classes/methods, inline for control structures)
- ✅ **`this.` prefix**: Plan uses `this.` for all instance member access (manager, project_manager, data_dir, etc.)
- ✅ **GLib prefix & using statements**: Plan requires fully-qualified `GLib.*` (GLib.StringBuilder, GLib.stdin, GLib.FileUtils, GLib.Path, GLib.Environment, GLib.DateTime, GLib.IOError, GLib.Thread, GLib.Uuid, GLib.debug, etc.)
- ✅ **Property initialization**: Plan uses defaults (`get; set; default = null` for manager and project_manager properties)
- ✅ **Line length & breaking**: Plan breaks long lines appropriately (usage message, method calls with multiple arguments, string concatenation in error messages)
- ✅ **StringBuilder usage**: Plan does NOT use `GLib.StringBuilder` (queries are typically short, not hundreds of lines; uses `string.joinv()` for joining array of lines instead; all string operations use concatenation or `string.joinv()`)
- ✅ **ArrayList for strings**: Plan does NOT use `Gee.ArrayList<string>` or build arrays just to join them (uses plain string concatenation when building strings only to join; uses `string.joinv()` only with existing arrays via array slicing)

## Purpose

Create a new `ollmchat-cli` command-line tool (copied from `oc-test-cli`) to support testing agent tools directly. Add `--agent-tool {name}` and `--query {message}` options that create a fake "just ask" agent and execute the specified agent tool with the provided query. The original `oc-test-cli` remains unchanged.

## Requirements

1. **New Command-Line Options**:
   - `--agent-tool {name}`: Specifies the agent tool name to execute (optional)
   - `--query {message}`: Specifies the query/message to send (optional, if not provided, reads from stdin)
   - `--project {path}`: Specifies the project directory path (optional, but recommended for tools that need project context)
   - `--create-project`: Flag that allows creating the project if it doesn't exist (only used with --project)
   - If `--query` is not provided, the tool enters interactive mode and reads from stdin
   - If `--agent-tool` is provided, the query is sent to that agent tool
   - If `--agent-tool` is not provided, the query is sent to the standard "just ask" agent
   - `--create-project` can only be used with `--project`

2. **Query Input**:
   - **Command-line arguments**: If there are leftover arguments after option parsing, join them as the query (current behavior)
   - **Stdin input** (smart detection): If no leftover arguments:
     - Check if stdin has data available (non-blocking check)
     - If data available → read it immediately and execute (stdin mode, supports multi-line until EOF)
     - If stdin is empty → wait briefly, then prompt "Talk to me:" and enter interactive single-line mode (Enter executes)
   - This allows both `echo "query" | ollmchat-cli` (stdin mode) and `ollmchat-cli` (interactive mode) to work correctly

4. **Agent Tool Execution**:
   - Look up the agent tool by name from registered tools
   - **Requires ProjectManager**: Most agent tools need ProjectManager for tools like ReadFile, RunCommand, EditMode, CodebaseSearchTool
   - Validate that `--project` is provided when using `--agent-tool` (error or warning if missing)
   - Create a minimal "just ask" agent with session infrastructure
   - Execute the agent tool with the provided query
   - Display streaming output (if supported)
   - Display final result

6. **Tool Registration**:
   - Create a shared `Registry` class in `liboctools/Registry.vala` for tool registration
   - Registry has two entry points:
     - `init_config()`: Initializes tool config types with Config2 (Phase 1, no project_manager needed)
     - `fill_tools()`: Fills manager with tool instances (Phase 2, needs project_manager)
   - Both Window and ollmchat-cli can use the same Registry class
   - This avoids code duplication and ensures consistent tool registration

7. **ProjectManager Initialization**:
   - Create ProjectManager with database if `--project` is provided
   - For `--project` without `--create-project`: Load existing project from database (error if not found)
   - For `--project` with `--create-project`: Create new project if it doesn't exist, or use existing if it does
   - Activate the project so tools can access project context

## Current Code Analysis

### ollmchat-cli.vala Structure

**Location**: `examples/ollmchat-cli.vala`

**Current Flow**:
1. Parses command-line options (lines 32-41)
2. Loads config (lines 59-62)
3. Creates Client and Chat objects (lines 170-301)
4. Adds ReadFile tool to Chat (line 310)
5. Sends query directly to Chat (lines 316-317)
6. Displays response (lines 319-327)

**Key Components**:
- `OllmchatCliApp` class extends `Application` and implements `OLLMchat.ApplicationInterface`
- Uses `OLLMchat.Settings.Config2` for configuration
- Creates `OLLMchat.Client` and `OLLMchat.Call.Chat` objects
- Currently only supports direct LLM queries (no agent tool execution)

### What's Missing

1. **Manager Infrastructure**: 
   - No `OLLMchat.History.Manager` instance
   - No tool registration system
   - No agent tool scanning/registration

2. **Agent Infrastructure**:
   - No agent factory registration
   - No session creation for agents
   - No "just ask" agent setup

3. **Tool Execution Path**:
   - No tool lookup mechanism
   - No ToolCall creation
   - No tool.execute() call path

## Implementation Details

### Phase 1: Add Command-Line Options

**File**: `examples/ollmchat-cli.vala`

**Changes**:
1. Add static option variables:
   ```vala
   private static string? opt_agent_tool = null;
   private static string? opt_project = null;
   private static bool opt_create_project = false;
   ```

2. Add to `options` array:
   ```vala
   { "agent-tool", 0, 0, OptionArg.STRING, ref opt_agent_tool, "Agent tool name to execute (optional)", "NAME" },
   { "project", 'p', 0, OptionArg.STRING, ref opt_project, "Project directory path (REQUIRED with --agent-tool)", "PATH" },
   { "create-project", 0, 0, OptionArg.NONE, ref opt_create_project, "Allow creating project if it doesn't exist (use with --project)", null },
   ```

3. Update OptionContext summary (line 76):
   ```vala
   var opt_context = new OptionContext("OLLMchat Test CLI - Test LLM interactions and agent tools");
   ```

4. Reset new options in `command_line()` method (add to lines 66-73):
   ```vala
   opt_agent_tool = null;
   opt_project = null;
   opt_create_project = false;
   ```
   
5. Convert nullable string options to empty strings after option parsing (after line 87, before using them):
   ```vala
   // Convert nullable options to empty strings to avoid null checks
   opt_model = opt_model == null ? "" : opt_model;
   opt_agent_tool = opt_agent_tool == null ? "" : opt_agent_tool;
   opt_project = opt_project == null ? "" : opt_project;
   ```

4. Keep existing query processing logic (lines 98-107) - will be enhanced to also support stdin if no arguments

### Phase 1a: Update Query Input Handling

**File**: `examples/ollmchat-cli.vala`

**Changes**:
1. Update query processing to use leftover arguments OR stdin OR interactive mode:
   - Keep current behavior: join leftover arguments as query (lines 98-107)
   - If no leftover arguments, check stdin type:
     - If stdin is not a TTY (pipe/file) → read from stdin until EOF
     - If stdin is a TTY (interactive) → enter interactive mode (read line, Enter executes)
   
2. Add method to read query from stdin (data available, pipe/file):
   ```vala
   private string read_query_from_stdin() throws Error
   {
       // Read all lines from stdin (data is available)
       // Use plain string concatenation - building array just to join it is unnecessary
       string query = "";
       string? line;
       while ((line = GLib.stdin.read_line()) != null) {
           query += line + "\n";
       }
       
       query = query.strip();
       if (query == "") {
           throw new GLib.IOError.INVALID_ARGUMENT("No query provided");
       }
       
       return query;
   }
   ```
   
5. Add method for interactive mode (stdin empty, wait then prompt):
   ```vala
   private string read_query_interactive() throws Error
   {
       // Wait briefly (100ms) to see if data arrives (e.g., from pipe that hasn't started yet)
       GLib.usleep(100000); // 100ms wait (100000 microseconds)
       
       // Check if stdin has data available using GLib.IOChannel
       var stdin_channel = new GLib.IOChannel.unix_new(Posix.STDIN_FILENO);
       stdin_channel.set_flags(GLib.IOFlags.NONBLOCK);
       if ((stdin_channel.get_buffer_condition() & GLib.IOCondition.IN) != 0) {
           // Data arrived during wait - use stdin mode instead
           return this.read_query_from_stdin();
       }
       
       // Still no data - enter interactive mode
       stdout.printf("Talk to me:\n");
       stdout.flush();
       
       // Read one line (Enter triggers execution)
       string? line = GLib.stdin.read_line();
       if (line == null) {
           throw new GLib.IOError.INVALID_ARGUMENT("No query provided");
       }
       
       string query = line.strip();
       if (query == "") {
           throw new GLib.IOError.INVALID_ARGUMENT("No query provided");
       }
       
       return query;
   }
   ```

### Phase 2: Create Manager Infrastructure

**File**: `examples/ollmchat-cli.vala`

**Changes**:
1. Add Manager, ProjectManager, and Registry properties to `OllmchatCliApp`:
   ```vala
   private OLLMchat.History.Manager? manager { get; set; default = null; }
   private OLLMfiles.ProjectManager? project_manager { get; set; default = null; }
   private OLLMtools.Registry tools_registry { get; set; }
   ```

2. Create Manager instance and connect to signals:
   ```vala
   private async void setup_manager() throws Error
   {
       // Create Manager instance
       this.manager = new OLLMchat.History.Manager(this);
       
       // Connect to Manager signals for streaming output (works for both agent tool and standard agent modes)
       this.manager.stream_chunk.connect((new_text, is_thinking, response) => {
           if (!is_thinking) {  // Only output content, not thinking
               stdout.write(new_text.data);
               stdout.flush();
           }
       });
       
       // Connect to tool_message signal for tool status messages
       this.manager.tool_message.connect((message) => {
           stdout.printf("[Tool] %s\n", message.content);
           stdout.flush();
       });
       
       // Override model if --model option was provided (must be done before ensure_model_usage)
       // This ensures ensure_model_usage() verifies the command-line model, not the config model
       // Note: opt_model is converted to "" if null early in command_line() processing
       if (opt_model != "") {
           if (this.manager.default_model_usage != null) {
               this.manager.default_model_usage.model = opt_model;
           }
       }
       
       // Ensure model usage is valid
       // What it does:
       //   - Verifies that default_model_usage.model exists on the server connection
       //   - Calls verify_model() which checks if the model is available via API call
       // Error handling:
       //   - Throws GLib.IOError.FAILED if default_model_usage is null
       //   - Throws GLib.IOError.FAILED if model doesn't exist on the connection
       //   - Error message includes model name and connection URL for debugging
       yield this.manager.ensure_model_usage();
   }
   ```

3. Create ProjectManager if --project is provided:
   ```vala
   private async void setup_project_manager(string project_path, bool allow_create, SQ.Database db) throws Error
   {
       if (project_path == "") {
           return; // No project manager needed
       }
       
       // Verify project directory exists
       if (!GLib.FileUtils.test(project_path, GLib.FileTest.IS_DIR)) {
           throw new GLib.IOError.NOT_FOUND("Project directory does not exist: %s", project_path);
       }
       
       // Create ProjectManager
       this.project_manager = new OLLMfiles.ProjectManager(db);
       
       // Load existing projects from database
       yield this.project_manager.load_projects_from_db();
       
       // Get project from database (if it exists)
       var project = this.project_manager.projects.path_map.get(project_path);
       
       // Error: --create-project cannot be used with existing projects
       if (allow_create && project != null) {
           throw new GLib.IOError.EXISTS(
               "Project already exists: %s (id=%lld). " +
               "Cannot use --create-project with existing projects. " +
               "Remove --create-project flag to use the existing project.",
               project_path,
               project.id
           );
       }
       
       // Error: Project doesn't exist and --create-project not provided
       if (project == null && !allow_create) {
           throw new GLib.IOError.NOT_FOUND(
               "Project not found in database: %s\n" +
               "  Projects must be created using the main application or use --create-project flag",
               project_path
           );
       }
       
       // Create new project if it doesn't exist
       if (project == null) {
           project = new OLLMfiles.Folder(this.project_manager);
           project.path = project_path;
           project.is_project = true;
           project.display_name = GLib.Path.get_basename(project_path);
           
           // Save project to database
           project.saveToDB(db, null, false);
           this.project_manager.projects.append(project);
       }
       
       // Load existing project files from database first
       yield project.load_files_from_db();
       
       // Disable background recursion for CLI (faster, but may miss some files)
       OLLMfiles.Folder.background_recurse = false;
       
       // Scan directory and populate project files
       yield project.read_dir(new GLib.DateTime.now_local().to_unix(), true);
       
       // Activate the project so it becomes the active project
       yield this.project_manager.activate_project(project);
   }
   ```

**Dependencies**:
- Manager requires `OLLMchat.ApplicationInterface` (already implemented)
- Manager needs `app.data_dir` (already set in constructor, line 51-53)
- Manager needs `app.config` (already loaded, line 56)

### Phase 3: Create Tool Registry Class

**File**: `liboctools/Registry.vala` (NEW)

**Purpose**: Shared tool registration class used by both Window and ollmchat-cli to avoid code duplication

**Changes**:
1. Create new Registry class with two entry points:
   ```vala
   namespace OLLMtools
   {
       /**
        * Central registry for registering all tools.
        * 
        * Used by both Window and ollmchat-cli to ensure consistent tool registration.
        * Has two phases: config registration (Phase 1) and tool instance registration (Phase 2).
        */
       public class Registry : Object
       {
			/**
				* Phase 1: Initializes tool config types with Config2.
				* 
				* Must be called before loading config. Ensures all tool GTypes are registered,
				* then calls BaseTool.register_config() to discover and register config types.
				* Does not require project_manager.
				*/
			public void init_config()
			{
				// Ensure all tool GTypes are registered in GType system
				// GType registration is lazy, so we need to explicitly reference each type
				typeof(OLLMtools.ReadFile.Tool).ensure();
				typeof(OLLMtools.RunCommand.Tool).ensure();
				typeof(OLLMtools.WebFetch.Tool).ensure();
				typeof(OLLMtools.EditMode.Tool).ensure();
				typeof(OLLMvector.Tool.CodebaseSearchTool).ensure();
				typeof(OLLMtools.GoogleSearch.Tool).ensure();
				
				// Register all tool config types with Config2
				// This discovers all tools via GType registry and registers their config types
				OLLMchat.Tool.BaseTool.register_config();
				
				GLib.debug("Registry.init_config: Registered tool config types");
			}
			
			/**
				* Phase 2: Fills the manager with all tool instances.
				* 
				* Creates tool instances with project_manager and registers them.
				* Also registers wrapped tools and agent tools.
				* 
				* @param manager The history manager to register tools with
				* @param project_manager Optional project manager (null if not available)
				*/
			public void fill_tools(
				OLLMchat.History.Manager manager,
				OLLMfiles.ProjectManager? project_manager = null
			)
           {
               // Register standard tools with project_manager
               manager.register_tool(new OLLMtools.ReadFile.Tool(project_manager));
               manager.register_tool(new OLLMtools.RunCommand.Tool(project_manager));
               manager.register_tool(new OLLMtools.WebFetch.Tool(project_manager));
               manager.register_tool(new OLLMtools.EditMode.Tool(project_manager));
               manager.register_tool(new OLLMtools.GoogleSearch.Tool(project_manager));
               manager.register_tool(new OLLMvector.Tool.CodebaseSearchTool(project_manager));
               
               GLib.debug("Registry.fill_tools: Registered %d standard tools", 
                   manager.tools.size);
               
               // Register wrapped tools from .tool definition files
               var builder = new OLLMtools.ToolBuilder(manager.tools);
               builder.scan_and_build();
               
               GLib.debug("Registry.fill_tools: Registered wrapped tools (total tools: %d)", 
                   manager.tools.size);
               
               // Register agent tools from resources/agents/
               var parser = new OLLMtools.Child.Parser();
               parser.scan_and_register(manager, project_manager);
               
               GLib.debug("Registry.fill_tools: Registered agent tools (total tools: %d)", 
                   manager.tools.size);
           }
       }
   }
   ```

2. Add to `liboctools/meson.build`:
   ```meson
   'Registry.vala',
   ```
   (Add to `octools_src` array, e.g., after `'ToolBuilder.vala'`)

3. Add to `docs/meson.build` for valadoc:
   ```meson
   '../liboctools/Registry.vala',
   ```
   (Add to `valadoc_docs` input files list, e.g., after `'../liboctools/ToolBuilder.vala'`)

### Phase 3a: Use Registry for Config Initialization in ollmchat-cli

**File**: `examples/ollmchat-cli.vala`

**Changes**:
1. Call config initialization in constructor (before loading config):
   ```vala
   public OllmchatCliApp()
   {
       Object(
           application_id: "org.roojs.ollmchat-cli",
           flags: GLib.ApplicationFlags.HANDLES_COMMAND_LINE
       );
       
       // Set up data_dir
       this.data_dir = GLib.Path.build_filename(
           GLib.Environment.get_home_dir(), ".local", "share", "ollmchat"
       );
       
       // Phase 1: Initialize tool config types (before loading config)
       this.tools_registry = new OLLMtools.Registry();
       this.tools_registry.init_config();
       
       // Load config (no vector types needed for simple CLI)
       this.config = this.load_config();
   }
   ```

### Phase 3b: Use Registry for Tool Registration in ollmchat-cli

**File**: `examples/ollmchat-cli.vala`

**Changes**:
1. Inline tool registration in `run_agent_tool()` method (after setting up manager and project_manager):
   ```vala
   // Fill manager with tools (after project manager is set up)
   this.tools_registry.fill_tools(this.manager, this.project_manager);
   ```

**Note**: 
- **ProjectManager is REQUIRED for agent tools**: When using `--agent-tool`, `--project` must be provided because most tools that agent tools call require ProjectManager (ReadFile, RunCommand, EditMode, CodebaseSearchTool, etc.)
- For standard agent mode (without `--agent-tool`), `project_manager` can be `null` and tools will work in a limited mode (only tools like WebFetch/GoogleSearch that don't require project context will work)

### Phase 4: Use Manager's Just-Ask Agent

**File**: `examples/ollmchat-cli.vala`

**Changes**:
1. No separate method needed - use Manager's session directly:
   - Manager already registers "just-ask" agent in constructor (line 151-152)
   - Manager's session is already an EmptySession with just-ask agent
   - Just activate the session and use its agent

### Phase 5: Look Up and Execute Agent Tool

**File**: `examples/ollmchat-cli.vala`

**Changes**:
1. Add method to execute agent tool:
   ```vala
   private async void run_agent_tool(string tool_name, string query, string project_path, bool allow_create, ApplicationCommandLine command_line) throws Error
   {
       // Setup manager
       yield this.setup_manager();
       
       // Setup project manager if needed
       SQ.Database? project_db = null;
       if (project_path != "") {
           // Create database for ProjectManager
           var db_path = GLib.Path.build_filename(this.data_dir, "files.sqlite");
           project_db = new SQ.Database(db_path);
           yield this.setup_project_manager(project_path, allow_create, project_db);
       }
       
       // Fill manager with tools (after project manager is set up)
       this.tools_registry.fill_tools(this.manager, this.project_manager);
       
       // Verify tool exists
       if (!this.manager.tools.has_key(tool_name)) {
           throw new GLib.IOError.NOT_FOUND(
               "Agent tool '%s' not found. Available tools: %s", 
               tool_name,
               string.joinv(", ", this.manager.tools.keys.to_array())
           );
       }
       
       // Ensure Manager's session has just-ask agent activated
       // Manager already registers "just-ask" agent in constructor
       if (this.manager.session.agent_name != "just-ask") {
           this.manager.session.agent_name = "just-ask";
       }
       this.manager.session.activate(); // Creates agent handler if needed
       
       // Get agent from Manager's session
       // Agent's chat() already has all tools from Manager copied (done in Agent.Base constructor)
       // Factory.configure_tools() is called but JustAsk doesn't filter, so all tools are available
       var agent = this.manager.session.agent;
       
       // Manager signals are already connected in setup_manager()
       // No need to connect again here - Manager relays from active session automatically
       
       // Emulate calling the tool on the agent (same as if LLM requested it)
       stdout.printf("Executing agent tool: %s\n", tool_name);
       stdout.printf("Query: %s\n\n", query);
       stdout.printf("Response:\n");
       
       // Create ToolCall and execute via agent (emulates LLM tool call)
       var arguments = new Json.Object();
       arguments.set_string_member("query", query);
       var tool_call = new OLLMchat.Response.ToolCall() {
           id = "call_" + GLib.Uuid.string_random(),
           function = new OLLMchat.Response.CallFunction() {
               name = tool_name,
               arguments = arguments
           }
       };
       var tool_calls = new Gee.ArrayList<OLLMchat.Response.ToolCall>();
       tool_calls.add(tool_call);
       
       // Execute tool via agent (same flow as when LLM requests a tool)
       var tool_reply_messages = yield agent.execute_tools(tool_calls);
       
       // Get result from tool reply message
       string result = "";
       if (tool_reply_messages.size > 0) {
           result = tool_reply_messages.get(0).content;
       }
       
       stdout.printf("\n\n--- Complete Response ---\n");
       stdout.printf("Result: %s\n", result);
   }
   ```

### Phase 6: Update Command-Line Processing

**File**: `examples/ollmchat-cli.vala`

**Changes**:
1. Update query processing logic (lines 98-107) to use leftover arguments OR stdin OR interactive mode:
   ```vala
   // After option parsing (line 87)
   
   // Get query from leftover arguments (current behavior), stdin, or interactive mode
   string query = "";
   if (args.length > 1) {
       // Join all remaining arguments as the query (current behavior)
       // Use string.joinv() here because we already have an array (args) - no need to build another
       query = string.joinv(" ", args[1:args.length]);
   } else {
       // No leftover arguments: smart stdin detection (non-blocking check using GLib.IOChannel)
       var stdin_channel = new GLib.IOChannel.unix_new(Posix.STDIN_FILENO);
       stdin_channel.set_flags(GLib.IOFlags.NONBLOCK);
       if ((stdin_channel.get_buffer_condition() & GLib.IOCondition.IN) != 0) {
           // Stdin has data available (pipe/file) → read immediately and execute
           query = this.read_query_from_stdin();
       } else {
           // Stdin is empty → wait briefly (100ms), then prompt for interactive mode
           query = this.read_query_interactive();
       }
   }
   
   if (query == "") {
       command_line.printerr("Error: No query provided.\n");
       return 1;
   }
   
   // Validate --create-project is only used with --project
   if (opt_create_project && opt_project == "") {
       command_line.printerr("Error: --create-project can only be used with --project.\n");
       return 1;
   }
   
   // Validate --project is provided when using --agent-tool
   // Most agent tools require ProjectManager for tools like ReadFile, RunCommand, EditMode, CodebaseSearchTool
   bool use_agent_tool = (opt_agent_tool != "");
   if (use_agent_tool && opt_project == "") {
       command_line.printerr("Error: --project is required when using --agent-tool.\n");
       command_line.printerr("  Most agent tools require ProjectManager for file operations, codebase search, etc.\n");
       command_line.printerr("  Use --project=PATH or --project=PATH --create-project to specify a project.\n");
       return 1;
   }
   
   // Hold application and execute
   this.hold();
   if (use_agent_tool) {
       // Agent tool mode
       this.run_agent_tool.begin(opt_agent_tool, query, opt_project, opt_create_project, command_line, (obj, res) => {
           try {
               this.run_agent_tool.end(res);
           } catch (Error e) {
               command_line.printerr("Error: %s\n", e.message);
           } finally {
               this.release();
               this.quit();
           }
       });
   } else {
       // Standard agent mode (existing behavior)
       this.run_test.begin(query, command_line, (obj, res) => {
           try {
               this.run_test.end(res);
           } catch (Error e) {
               command_line.printerr("Error: %s\n", e.message);
           } finally {
               this.release();
               this.quit();
           }
       });
   }
   return 0;
   ```

2. Update OptionContext summary and usage message:
   
   a. Update OptionContext summary (line 76):
   ```vala
   var opt_context = new OptionContext("OLLMchat Test CLI - Test LLM interactions and agent tools");
   ```
   
   b. Update usage message to include new options (lines 126-143):
   ```vala
   var usage = @"Usage: $(args[0]) [OPTIONS] [QUERY]

Send a query to the LLM or execute an agent tool.

Options:
  -d, --debug          Enable debug output
  --url=URL           Ollama server URL (required if config not found)
  --api-key=KEY       API key (optional)
  -m, --model=MODEL    Model name (overrides config)
  --stats=FILE         Output statistics from last message to file
  --list-models        List available models and exit
  --ctx-num=NUM        Context window size in tokens (1K = 1024)
  --agent-tool=NAME    Agent tool name to execute (optional, if not provided uses standard agent)
  -p, --project=PATH   Project directory path (REQUIRED with --agent-tool, optional otherwise)
  --create-project     Allow creating project if it doesn't exist (use with --project)

Query Input:
  QUERY can be provided as leftover arguments, or:
  - If stdin has data (pipe/file): reads from stdin until EOF
  - If stdin is empty (interactive): prompts \"Talk to me:\" and reads one line

Examples:
  $(args[0]) \"What is the capital of France?\"
  $(args[0]) --model llama2 \"Write a hello world program\"
  $(args[0]) --agent-tool=codebase_search --project=/path/to/project \"Find all functions that use database\"
  $(args[0]) --agent-tool=read_file --project=/path/to/project --create-project
  echo \"query text\" | $(args[0]) --agent-tool=run_command --project=/path/to/project
";
   ```

### Phase 7: Handle Streaming Output

**File**: `examples/ollmchat-cli.vala`

**Considerations**:
- Both agent tool mode and standard agent mode should use Manager signals for output
- Manager relays signals from the active session (SessionBase → Manager → UI/CLI)
- Manager provides `stream_chunk` and `tool_message` signals
- Manager signals are connected once and work for all session activity

**Implementation**:
- Connect to `manager.stream_chunk` signal (filters out thinking content with `!is_thinking` check)
- Connect to `manager.tool_message` signal for tool status messages
- Manager automatically relays from the active session, so no need to connect to individual Chat objects
- Both agent tool execution and standard agent queries will stream through Manager signals

**Note**: Since Manager relays from the active session, we only need to connect to Manager signals once (e.g., in `setup_manager()` or constructor), and they will work for both paths.

### Phase 7.5: Update Window to Use Registry

**File**: `ollmapp/Window.vala` and `ollmapp/Application.vala`

**Changes**:
1. Update `Application.vala` constructor to use Registry for config initialization:
   ```vala
   // In Application constructor (around line 61-74)
   // Replace manual tool type registration with Registry.init_config()
   var tools_registry = new OLLMtools.Registry();
   tools_registry.init_config();
   
   // Load config after registrations
   this.config = this.load_config();
   ```

2. Update `Window.vala.register_tools()` to use Registry for tool registration:
   ```vala
   // In Window.register_tools() (around line 954-997)
   // Replace manual tool registration with Registry.fill_tools()
   var tools_registry = new OLLMtools.Registry();
   tools_registry.fill_tools(this.history_manager, this.project_manager);
   
   // CodebaseSearchTool initialization remains separate (async, requires config)
   // This is called after register_tools() completes
   ```

3. Remove the manual tool registration code:
   - Remove individual `register_tool()` calls for ReadFile, RunCommand, WebFetch, EditMode, GoogleSearch, CodebaseSearchTool
   - Remove ToolBuilder and Parser calls (Registry.fill_tools() handles these)
   - Keep the debug logging if desired

**Benefits**:
- Ensures Window and ollmchat-cli use identical tool registration logic
- Reduces code duplication
- Centralizes tool registration in one place
- Makes it easier to add new tools (only need to update Registry)

### Phase 8: Error Handling

**File**: `examples/ollmchat-cli.vala`

**Error Cases to Handle**:
1. **Missing --project with --agent-tool**: 
   - Validate that `--project` is provided when `--agent-tool` is used
   - Show clear error message explaining why ProjectManager is required
   - Suggest using `--create-project` if project doesn't exist

2. **Tool Not Found**: 
   - Check if tool exists in `manager.tools`
   - List available tools in error message

3. **Manager Setup Failure**:
   - Config not loaded
   - Model not found
   - Connection failed

4. **Session Creation Failure**:
   - Database errors
   - Agent factory not found

5. **Tool Execution Failure**:
   - Tool execution errors (caught by tool.execute())
   - Agent execution errors (from nested agent)
   - Errors from tools that require ProjectManager when it's not available

## Dependencies

### Required Classes
- `OLLMchat.History.Manager` - For tool registration and session management
- `OLLMchat.History.Session` - For agent session creation
- `OLLMchat.Agent.JustAskFactory` - For creating "just ask" agent
- `OLLMchat.Agent.JustAsk` - The "just ask" agent implementation
- `OLLMtools.Registry` - Shared tool registration class (NEW)
- `OLLMtools.Child.Parser` - For scanning and registering agent tools
- `OLLMchat.Response.ToolCall` - For creating tool call objects
- `OLLMchat.Response.CallFunction` - For creating function call objects

### Required Tools
- Standard tools: ReadFile, RunCommand, WebFetch, EditMode, GoogleSearch, CodebaseSearchTool
- Agent tools: Automatically registered from `resources/agents/` directory

## Testing

### Test Cases

**Quick Testing Mode** (using --query for one-line queries):

1. **Quick Testing with Standard Agent**:
   ```bash
   ollmchat-cli --query "What is the capital of France?"
   ```

2. **Quick Testing with Agent Tool** (requires --project):
   ```bash
   ollmchat-cli --agent-tool codebase-locator --query "Find files related to authentication" --project /path/to/project
   ```

3. **Quick Testing with Project**:
   ```bash
   ollmchat-cli --agent-tool codebase-locator --query "Find files related to authentication" --project /path/to/project
   ```

**Interactive Mode** (no --query, for experimenting with multi-line input):

4. **Interactive Mode with Standard Agent**:
   ```bash
   oc-test-cli
   # Prompts: "Talk to me:"
   # User enters multi-line input, terminated by EOF (Ctrl+D)
   ```

5. **Interactive Mode with Agent Tool**:
   ```bash
   oc-test-cli --agent-tool codebase-locator
   # Prompts: "Talk to me:"
   # User enters multi-line input, terminated by EOF (Ctrl+D)
   ```

6. **Interactive Mode with Project**:
   ```bash
   ollmchat-cli --agent-tool codebase-locator --project /path/to/project
   # Prompts: "Talk to me:"
   # User enters multi-line input
   ```

**Error Cases**:

7. **Missing --project with --agent-tool**:
   - Should error: "--project is required when using --agent-tool"
   - Should explain that most agent tools need ProjectManager

8. **List Available Tools** (if tool not found):
   - Should show error with list of available tools

9. **Empty Input in Interactive Mode**:
   - Should error if stdin is empty

4. **Streaming Output**:
   - Verify that streaming output appears in real-time
   - Verify final result is displayed

5. **Command-Line Arguments as Query**:
   - Test with leftover arguments (current behavior)
   - Test multi-word queries from arguments
   - Test with --agent-tool and arguments
   - Test without --agent-tool and arguments (standard agent)

6. **Stdin Input** (no arguments, stdin has data):
   - Test with pipe: `echo "query" | ollmchat-cli` (should detect data and read immediately)
   - Test with file: `ollmchat-cli < query.txt` (should detect data and read immediately)
   - Test multi-line input from stdin
   - Verify detection works correctly (non-blocking check)

7. **Interactive Mode** (no arguments, stdin is empty):
   - Test interactive mode (no leftover arguments, stdin empty)
   - Verify brief wait before prompting
   - Test one-liner input (Enter triggers execution)
   - Test empty input in interactive mode (should error)
   - Test interactive mode with --agent-tool
   - Test interactive mode without --agent-tool (standard agent)

7. **Error Handling**:
   - Test with non-existent tool name
   - Test with invalid query
   - Test with missing config
   - Test with non-existent project (--project should error without --create-project)
   - Test with --create-project without --project (should error)
   - Test with empty stdin input (should error)

## Implementation Order

1. ✅ **Phase 1**: Add command-line options (including --project and --create-project flag)
2. ✅ **Phase 1a**: Add interactive mode (smart stdin detection)
3. ✅ **Phase 2**: Create Manager infrastructure
4. ✅ **Phase 2a**: Create ProjectManager infrastructure (if --project provided)
5. ✅ **Phase 3**: Create shared Registry class in liboctools (with two entry points)
6. ✅ **Phase 3a**: Use Registry.init_config() in ollmchat-cli constructor
7. ✅ **Phase 3b**: Use Registry.fill_tools() in ollmchat-cli
8. ✅ **Phase 4**: Create fake "just ask" agent
9. ✅ **Phase 5**: Look up and execute agent tool
10. ✅ **Phase 6**: Update command-line processing (support both agent tool and standard agent modes)
11. ✅ **Phase 7**: Handle streaming output
12. ✅ **Phase 7.5**: Update Window to use Registry
13. ✅ **Phase 8**: Error handling

## Notes

### Manager Initialization
- Manager requires `OLLMchat.ApplicationInterface` (already implemented)
- Manager creates database in `app.data_dir/history/history.db`
- Manager needs valid `default_model_usage` from config

### Tool Registration
- Agent tools are registered via `Child.Parser.scan_and_register(manager, project_manager)`
- This scans `resources/agents/` directory and creates `Child.Tool` instances
- Each agent tool is registered with its `name` from frontmatter
- `project_manager` should be provided if `--project` is specified
- Tools work without `project_manager` but have limited functionality (no project context)

### Agent Session
- Session must be a real `Session` (not `EmptySession`) for agent execution
- Session activation creates the agent handler automatically
- Agent handler creates Chat object internally

### Tool Execution
- Tools are executed via `tool.execute(chat_call, tool_call)`
- The Chat object provides the agent context
- Tool execution is async and may stream output

### Streaming
- Agent tools create nested agent sessions
- Streaming comes from the nested agent's Chat object
- We connect to the outer agent's Chat, but streaming may come from nested Chat
- May need to investigate nested streaming support

## Future Enhancements

1. **Refactor Application to Use Registry for Config Initialization**:
   - Replace manual `typeof().ensure()` calls and `BaseTool.register_config()` with `new OLLMtools.Registry().init_config()`
   - This centralizes config initialization logic

2. **Refactor Window to Use Registry for Tool Registration**:
   - Update `Window.register_tools()` to use `new OLLMtools.Registry().fill_tools()`
   - This ensures both Window and ollmchat-cli use the same registration logic
   - Reduces code duplication and ensures consistency

2. **List Available Agent Tools**:
   - Add `--list-agent-tools` option to list all registered agent tools

4. **Tool Parameter Validation**:
   - Validate tool parameters before execution
   - Show tool description and parameters in help

5. **Verbose Mode**:
   - Add `--verbose` flag to show tool execution details
   - Show nested agent execution steps

6. **Output Format**:
   - Support JSON output format for programmatic use
   - Support markdown output format
