# Refactor Markdown Parser to State-Based Architecture

## Refactor status: **DONE** (mapping refactor only)

The mapping refactor is complete. MarkerMap, FormatMap, BlockMap, and ListMap are in place; Parser uses instance `formatmap` and `blockmap`; handler methods (`handle_line_break`, `handle_fence_result`, `handle_block_result`, `handle_format_result`) are extracted. Code is in a clean state. **No further refactor phases** (e.g. ParserBase, ParserFormatting, sub-parsers) are planned for now. Proceeding to table support (see 1.8-markdown-table-support.md).

## Overview

Explore refactoring the markdown parser to use separate parser classes for different parsing states, similar to the ParserTable approach. Each parser would handle a specific context (code blocks, literal mode, HTML, lists, formatting, etc.) and the main parser would delegate to the appropriate sub-parser based on current state.

## Proposed Architecture

### Parser Classes

1. **ParserStart** - Handles block-level parsing at line start (headings, horizontal rules, blockquotes, etc.)
2. **ParserCodeBlock** - Handles fenced code blocks (``` or ~~~)
3. **ParserLiteral** - Handles literal/inline code spans (`code`)
4. **ParserHtml** - Handles HTML tag parsing
5. **ParserList** - Handles list parsing (ordered, unordered, task lists, continuation)
6. **ParserFormatting** - Handles inline formatting (bold, italic, strikethrough, etc.)
7. **ParserTable** - Handles table parsing (from 1.8 plan)

### Design Decisions

#### 1. Initialization Strategy

**DECIDED: Option A - Initialize all parsers at start**
- All parsers created in main Parser constructor
- No allocation overhead during parsing
- Simple state management
- Fast switching between parsers
- Memory overhead acceptable (parsers are lightweight)

#### 2. Reset Strategy

**DECIDED: Option B - start() method**
- Consistent with current Parser API
- Clear intent
- Can be called multiple times safely
- Each parser implements: `public void start()`

#### 3. State Management

**DECIDED: Each parser maintains its own state**

**Main Parser State:**
- `current_block: FormatType` - Current block type (stored in main parser)
- `current_parser: ParserBase?` - Currently active sub-parser
- `at_line_start: bool` - At start of line (main parser tracks this)
- `last_line_block: FormatType` - Previous line's block type (main parser)

**Sub-Parser State:**
- Each sub-parser maintains its own internal state
- Sub-parsers have reference to main parser (passed in constructor)
- When sub-parser finishes, it tells main parser who's next
- Main parser updates `current_parser` based on sub-parser's return

**State Transitions:**
- Sub-parsers return control to parent when done
- Sub-parsers can delegate to other sub-parsers (e.g., ParserList -> ParserFormatting)
- Main parser tracks `current_block` (not sub-parsers)
- Nested states handled by sub-parser delegation (e.g., formatting inside list items)

#### 4. Parser Hierarchy

**DECIDED: Main parser does NOT extend ParserBase, sub-parsers DO**

```
Parser (main orchestrator - does NOT extend ParserBase)
  ├── Contains instances of:
  │   ├── ParserBase (abstract)
  │   │   ├── ParserTable extends ParserBase
  │   │   ├── ParserCodeBlock extends ParserBase
  │   │   ├── ParserLiteral extends ParserBase
  │   │   ├── ParserHtml extends ParserBase
  │   │   ├── ParserList extends ParserBase
  │   │   └── ParserFormatting extends ParserBase
  │   └── ParserStart (may or may not extend ParserBase - TBD)
```

#### 5. Marker maps (FormatMap, BlockMap, ListMap)

**DECIDED: Instance-based map classes with a common base; peek is a generic method of the base.**

- **Base class (e.g. `MarkerMap`)** – in its own file (e.g. `libocmarkdown/MarkerMap.vala`). Not fully static: holds an **instance** `Gee.HashMap<string, FormatType> map`. Constructor copies a static map into this instance (subclass passes static data or base accepts map to copy). **Generic `peek(chunk, chunk_pos, is_end_of_chunks, out matched_type, out byte_length)`** is an instance method on the base; it runs the same loop using `this.map`. All map types share this peek logic.
- **FormatMap** – extends MarkerMap. Static map + `static construct { setup(); }` for format (inline) markers. Constructor copies the static map into the instance `map`. Used for format detection.
- **BlockMap** – extends MarkerMap. Static map + setup for block markers (headings, HR, fenced code, blockquote, list prefixes, etc. – current `block_map`). Ctor copies static map to instance. Used by peekBlock.
- **ListMap** – extends MarkerMap. Static map + setup for list-only markers (CONTINUE_LIST, ORDERED_LIST, UNORDERED_LIST and their INVALID precursors). Ctor copies static map to instance. Used by peekListBlock.
- **Parser** has get/set properties and creates instances in constructor (or default property values):
  - **`formatmap`** – `FormatMap formatmap { get; set; }` default `= new FormatMap()`
  - **`blockmap`** – `BlockMap blockmap { get; set; }` default `= new BlockMap()`
  - **`listmap`** – `ListMap listmap { get; set; }` default `= new ListMap()`
- Call sites: **`this.formatmap.peek(...)`**, **`this.blockmap.peek(...)`**, **`this.listmap.peek(...)`**. No static peek; no peekMap taking a raw map – each map class has its own instance and base class provides `peek()`.

**Rationale:**
- Main Parser orchestrates and delegates
- Sub-parsers share common utilities via ParserBase
- Main Parser has direct access to renderer and main state
- Marker maps isolate lookup data and shared peek logic; instance-based so Parser can own and optionally replace maps (get/set)

## Analysis of Current Parser Flow

### Current add() Method Flow

1. Handle newlines (end blocks, reset state)
2. Check if in fenced code block → handle specially
3. Check if at line start → peekBlockHandler()
4. Handle escape sequences
5. Handle format sequences (peekFormat)
6. Handle HTML tags
7. Accumulate text

### Potential Parser Delegation Points

1. **At line start**: Delegate to ParserStart
   - Detects blocks (headings, HR, blockquotes, lists, tables)
   - Returns block type and bytes consumed

2. **In code block**: Delegate to ParserCodeBlock
   - Handles code content until closing fence
   - Returns bytes consumed

3. **In literal mode**: Delegate to ParserLiteral
   - Handles code span content until closing backtick
   - Returns bytes consumed

4. **HTML tag detected**: Delegate to ParserHtml
   - Parses HTML tag and attributes
   - Returns bytes consumed

5. **In list block**: Delegate to ParserList
   - Handles list items, continuation, nesting
   - Returns bytes consumed

6. **Formatting detected**: Delegate to ParserFormatting
   - Handles inline formatting (bold, italic, etc.)
   - Manages format stack
   - Returns bytes consumed

## Benefits of State-Based Architecture

1. **Separation of Concerns**: Each parser handles one responsibility
2. **Maintainability**: Easier to modify individual parser logic
3. **Testability**: Can test each parser independently
4. **Extensibility**: Easy to add new parser types (e.g., ParserTable)
5. **Code Organization**: Related logic grouped together

## Challenges

1. **State Coordination**: Multiple parsers need to coordinate state
2. **Performance**: Overhead of switching between parsers
3. **Complexity**: More classes to manage
4. **Shared State**: Some state needs to be shared (renderer, leftover_chunk)
5. **Error Handling**: Need consistent error handling across parsers

## Proposed Implementation Approach

### Phase 1: Extract MarkerMap base and FormatMap — **done**
- Create **MarkerMap** base class with instance `map` and generic **`peek()`** method. Create **FormatMap** extending it (static setup, ctor copies to instance). Parser gets **`formatmap`** property = new FormatMap(); call sites use **`this.formatmap.peek(...)`**. No peekFormat() wrapper. Parser continues to own peekMap, peekHTML, block_map.

**Concrete code for Phase 1:**

1. **New file `libocmarkdown/MarkerMap.vala`** – base class (not fully static):
   - **Instance:** `protected Gee.HashMap<string, FormatType> map` – populated by subclass ctor (copy from static or pass-in).
   - **Generic `peek(chunk, chunk_pos, is_end_of_chunks, out matched_type, out byte_length)`** – instance method; same loop as current peekMap (Parser lines 321–419) using `this.map`. Returns length (1–N), 0, or -1. Subclasses do not override peek; they just supply the map.
   - Constructor: subclasses call `base()` after copying their static map into a new HashMap assigned to `this.map` (or base accepts map to store). `FormatType` visible to MarkerMap (e.g. in Parser.vala or Types.vala).

2. **New file `libocmarkdown/FormatMap.vala`** – extends MarkerMap:
   - Static map + `static construct { setup_format(); }` (format_map content from Parser lines 102–143). Constructor creates/copies static map into instance and passes to base (or assigns to inherited `map`).
   - No extra methods; **`peek()`** is inherited from MarkerMap.

3. **Changes in `Parser.vala`:**
   - **Remove:** `private static Gee.HashMap<string, FormatType> format_map` and its setup (lines 94, 102–143). Parser keeps `block_map` and block_map setup.
   - **Add:** **`public FormatMap formatmap { get; set; }`** – in constructor set `formatmap = new FormatMap()` (or default property init).
   - **Remove `peekFormat()`** (lines 422–462). At the call site in `add()` (~line 907): call **`this.formatmap.peek(...)`** and apply in_literal filter inline.
   - **Keep:** `peekMap()`, `block_map`, `peekHTML()`, `in_literal`. No other Parser changes in Phase 1.

4. **Meson:** Add `MarkerMap.vala` and `FormatMap.vala` to **libocmarkdown/meson.build** (MarkerMap before FormatMap). Add same to **docs/meson.build** libocmarkdown sources list.

### Phase 2: Extract BlockMap and ListMap; Extract ParserBase — **DONE (mapping only); ParserBase deferred**
- Add **BlockMap** and **ListMap** (extend MarkerMap; static setup, ctor copies to instance). Parser gets **`blockmap`** and **`listmap`** properties; **peekBlock** uses **`this.blockmap.peek()`**, **peekListBlock** uses **`this.listmap.peek()`**. Remove `block_map` and **peekMap()** from Parser. ~~Create **ParserBase**~~ — **not done**; ParserBase extraction deferred. BlockMap/ListMap and Parser handler extraction (handle_line_break, handle_fence_result, handle_block_result, handle_format_result) are done.

**Concrete code for Phase 2:**

1. **New file `libocmarkdown/BlockMap.vala`** – extends MarkerMap:
   - Static map + `static construct { setup_block(); }` – current block_map content (Parser lines 145–251). Ctor copies static map to instance (e.g. pass to base or assign to `map`). Used by peekBlock.

2. **New file `libocmarkdown/ListMap.vala`** – extends MarkerMap:
   - Static map + setup for list-only markers: CONTINUE_LIST, ORDERED_LIST, UNORDERED_LIST and their INVALID precursors (subset of current block_map entries that peekListBlock cares about). Ctor copies to instance. Used by peekListBlock.

3. **Parser.vala** – add map properties and remove block_map / peekMap:
   - **Add:** **`public BlockMap blockmap { get; set; }`**, **`public ListMap listmap { get; set; }`** – in constructor `blockmap = new BlockMap()`, `listmap = new ListMap()`.
   - **Remove:** `private static Gee.HashMap<string, FormatType> block_map` and all block_map population in `setup_maps()`. **Remove `peekMap()`** (lines 321–419).
   - **peekBlock:** call **`this.blockmap.peek(...)`** instead of `this.peekMap(..., block_map)`; keep existing special handling for fenced code and CONTINUE_LIST (peekBlock still calls peekListBlock when CONTINUE_LIST; peekListBlock uses **`this.listmap.peek(...)`**).
   - **peekListBlock:** use **`this.listmap.peek(...)`** (or equivalent: iterate using listmap instead of block_map). Replace direct block_map.has_key/get with listmap.peek or listmap’s map if a getter is needed for the loop; if peekListBlock’s logic is a different loop, have ListMap expose peek() and use it where the list-only sequence is consumed.
   - **Keep:** peekBlock, peekListBlock, peekBlockHandler (they now use blockmap/listmap). Parser still has formatmap from Phase 1.

4. **New file `libocmarkdown/ParserBase.vala`** – abstract class with:
   - `protected RenderBase renderer` (constructor param)
   - `protected bool in_literal` (moved from Parser; used at call sites when calling formatmap.peek())
   - `protected int peekHTML(...)` – HTML tag start check (Parser lines 698–724)
   - Abstract: `add()`, `flush()`, `start()`
   - No peekMap – block/list use Parser’s blockmap/listmap; format uses formatmap.

5. **Code removed from `Parser.vala`:**
   - **Instance field:** `private bool in_literal = false` (line 283) – moves to ParserBase; assignments in Parser remain but operate on inherited field.
   - **Methods (delete from Parser):** `peekHTML()` (698–724). (peekMap removed above; peekFormat already removed in Phase 1.)
   - **Parser changes:** Declare `public class Parser : ParserBase`. Constructor calls `base(renderer)`. Parser keeps: peekBlock (uses blockmap.peek), peekListBlock (uses listmap.peek), peekBlockHandler, got_format, do_format, do_block, peekFencedEnd, add_html, main add() loop (formatmap.peek + in_literal; inherited peekHTML).

   **Note:** Parser extends ParserBase. Main parser “does NOT extend ParserBase” can be revisited in a later phase if desired.

6. **Meson:** Add `BlockMap.vala`, `ListMap.vala`, `ParserBase.vala` to **libocmarkdown/meson.build** (MarkerMap before FormatMap/BlockMap/ListMap; ParserBase before Parser). Add same to **docs/meson.build**.

### Phase 3: Extract ParserFormatting — **deferred**
- Extends ParserBase
- Takes main_parser reference in constructor
- Handles format stack and inline formatting
- Only activated when needed (not always active)
- Returns control to parent when done
- Test with existing parser

### Phase 4: Extract ParserCodeBlock — **deferred**
- Extends ParserBase
- Takes main_parser reference in constructor
- Already has distinct handling in current code
- Clear boundaries (fenced code blocks)
- Updates main_parser.current_block when finished
- Test with existing parser

### Phase 5: Extract ParserList — **deferred**
- Extends ParserBase
- Takes main_parser reference in constructor
- Complex logic (continuation, nesting)
- Delegates to ParserFormatting for item content
- Returns control to parent when done
- Test with existing parser

### Phase 6: Extract ParserHtml — **deferred**
- Extends ParserBase
- Takes main_parser reference in constructor
- Already has separate add_html() method
- Clear boundaries
- Returns control to parent when done
- Test with existing parser

### Phase 7: Extract ParserStart — **deferred**
- Block detection at line start
- May or may not extend ParserBase (TBD)
- Integrates with other parsers
- Delegates to appropriate parser based on block type
- Returns control to main parser
- Test with existing parser

### Phase 8: Extract ParserLiteral — **deferred**
- Extends ParserBase
- Takes main_parser reference in constructor
- Handles inline code spans
- Works with ParserFormatting
- Returns control to parent when done
- Test with existing parser

## Architecture Details

### Main Parser Structure

**Main Parser Properties:**
```vala
public class Parser {
    private RenderBase renderer;
    
    // Marker maps (get/set; default new instances in constructor)
    public FormatMap formatmap { get; set; }
    public BlockMap blockmap { get; set; }
    public ListMap listmap { get; set; }
    
    // All sub-parsers initialized in constructor
    private ParserStart parser_start;
    private ParserCodeBlock parser_code_block;
    private ParserLiteral parser_literal;
    private ParserHtml parser_html;
    private ParserList parser_list;
    private ParserFormatting parser_formatting;
    private ParserTable? parser_table; // From 1.8 plan
    
    // Main parser state
    private ParserBase? current_parser = null; // Currently active sub-parser
    private FormatType current_block = FormatType.NONE; // Block-level state
    private bool at_line_start = true;
    private FormatType last_line_block = FormatType.NONE;
    private string leftover_chunk = "";
}
```

### Sub-Parser Communication

**Sub-Parser Constructor:**
```vala
public ParserFormatting(Parser main_parser, RenderBase renderer)
{
    base(renderer);
    this.main_parser = main_parser;
}
```

**Sub-Parser Return Values:**
- `int` - Number of characters consumed
- `-1` - Need more data (save to leftover_chunk, return)
- `0` - Finished, return control to parent
- `>0` - Consumed N characters, continue with this parser

**Control Flow in Main Parser:**
```vala
public void add(string in_chunk, bool is_end_of_chunks = false)
{
    var chunk = this.leftover_chunk + in_chunk;
    this.leftover_chunk = "";
    var chunk_pos = 0;
    
    while (chunk_pos < chunk.length) {
        // If sub-parser is active, delegate to it
        if (this.current_parser != null) {
            var remaining = chunk.substring(chunk_pos);
            var result = this.current_parser.add(remaining, is_end_of_chunks);
            
            if (result == -1) {
                // Need more data
                this.leftover_chunk = remaining;
                return;
            }
            if (result == 0) {
                // Sub-parser finished, determine next parser
                this.current_parser = null;
                // Continue with main parsing logic
                continue;
            }
            // Sub-parser consumed characters
            chunk_pos += result;
            continue;
        }
        
        // Main parsing logic (determine which parser to activate)
        // ...
    }
}
```

### Parser Activation

**ParserFormatting:**
- Only active when expected (not always active)
- Activated by ParserStart after block detection
- Activated by ParserList for list item content
- Activated by other parsers when they need inline formatting

**Parser Flow Example:**
```
Main Parser.add()
  -> At line start: current_parser = parser_start
     -> ParserStart.add() detects list block
        -> Sets main_parser.current_block = FormatType.UNORDERED_LIST
        -> Returns 0 (finished)
     -> Main parser: current_parser = parser_list
     -> ParserList.start()
     -> ParserList.add() processes list item
        -> For item content: current_parser = parser_formatting
        -> ParserFormatting.start()
        -> ParserFormatting.add() processes inline formatting
           -> Returns 0 (finished)
        -> ParserList continues (current_parser = null, back to ParserList)
     -> ParserList returns 0 (finished)
     -> Main parser: current_parser = null, current_block = FormatType.NONE
```

**Key Points:**
- `current_block` is stored in main parser (not sub-parsers)
- Sub-parsers update `main_parser.current_block` when needed
- Sub-parsers set `main_parser.current_parser` to delegate to other parsers
- When sub-parser returns 0, main parser sets `current_parser = null`
- Main parser determines next parser based on state

### Nested States

**Handled by Sub-Parser Delegation:**
- ParserList delegates to ParserFormatting for item content
- ParserFormatting can delegate to ParserLiteral for code spans
- No explicit "nested state stack" - handled by call chain
- Main parser only tracks `current_block` (block-level state)

## Resolved Questions

1. ✅ **ParserFormatting activation**: Only active when expected (not always active)
2. ✅ **Nested states**: Handled by sub-parser delegation (ParserList -> ParserFormatting)
3. ✅ **Parser delegation**: Yes, parsers can delegate to other parsers
4. ⏳ **Error recovery**: To be determined during implementation
5. ⏳ **ParserText**: To be determined - may not be needed if ParserFormatting handles plain text

## Remaining Questions

1. Should ParserStart extend ParserBase or be a separate class?
2. How should error recovery work? (if ParserHtml fails, fall back to text?)
3. Should there be a ParserText for plain text accumulation, or does ParserFormatting handle it?
4. How should leftover_chunk be managed? (main parser or sub-parsers?)

## Next Steps (historical; refactor stopped after mapping phase)

1. ~~Review this architecture with team~~
2. ~~Decide on initialization and reset strategies~~
3. ~~Implement Phase 1 (MarkerMap, FormatMap) and Phase 2 mapping (BlockMap, ListMap)~~ — **done**
4. **Proceed to table support** (1.8-markdown-table-support.md); sub-parser extraction (Phases 3–8) deferred.
5. **Meson:** When adding new .vala files in libocmarkdown, update **libocmarkdown/meson.build** and **docs/meson.build** (libocmarkdown sources for valadoc) so the build and docs stay in sync.

