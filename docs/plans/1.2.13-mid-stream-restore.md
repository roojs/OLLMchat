# 1.2.13 - Mid-Stream Restore Visual Break

## Problem

When restoring a session that's still streaming (mid-block), there's a visual break:

1. `load_messages()` renders all messages including the last streaming message ("content-stream" or "think-stream")
2. When streaming resumes, new chunks start appending
3. This creates a visual gap/break in the output

## Solution

Move message restoration logic to the session layer. When a session is activated and it's still running, the session should restore messages via `restore_messages()` which emits them through the `message_created` signal. If the last message is a streaming message ("content-stream" or "think-stream"), trigger the streaming callback with that message's content by calling `handle_stream_chunk()`. This will set up `current_stream_message` and emit it to the UI immediately. When streaming resumes, the existing `handle_stream_chunk()` logic will naturally append new chunks to `current_stream_message`.

This approach:
- Keeps logic in the session layer where it belongs
- Works automatically for session switching (session restores its own messages when activated)
- UI just listens to signals (already does via `on_message_created`)
- Better separation of concerns
- Uses existing streaming infrastructure - no manual prepending needed

## Implementation

### File: `libollmchat/History/Session.vala`

**1. Add `restore_messages()` method** (after `activate()` method):

- Iterate through all messages except the last one (i < messages.size - 1) and emit them via `message_created` signal
- After the loop, check the last message:
  - If it's a stream message ("content-stream" or "think-stream") AND session is still running (`this.is_running == true`):
    - Determine `is_thinking` from message role ("think-stream" → true, "content-stream" → false)
    - Call `handle_stream_chunk(message.content, is_thinking, null)` to trigger streaming callback
    - This will set up `current_stream_message` and emit it to the UI via streaming infrastructure
  - Otherwise, emit it normally via `message_created` signal

**2. No changes needed to `handle_stream_chunk()` method**:

- The existing logic already handles `current_stream_message` correctly
- If `current_stream_message` exists and stream type matches, it appends to it (line 171)
- This naturally handles the restored message when streaming resumes

**4. Call `restore_messages()` from `activate()` method**:

- After activation completes, if session has messages, call `restore_messages()` to emit them to UI
- This ensures messages are restored when session becomes active

### File: `libollmchatgtk/ChatWidget.vala`

**1. Update `switch_to_session()` method** (line 190):

- Currently always sets `this.chat_input.set_streaming(false)` regardless of session state
- Should check if session is still running after switching: `if (this.manager.session.is_running) { this.chat_input.set_streaming(true); }`
- This ensures the send button changes to "Stop" button if the session is still streaming
- The button state should match the actual session streaming state

**2. Remove or simplify `load_messages()` method**:

- Since session now emits messages via `message_created` signal in `restore_messages()`, `load_messages()` may no longer be needed
- Or keep it as a fallback but session's `restore_messages()` should be the primary method
- **Note**: `clear_chat()` is already called in `switch_to_session()` (line 194) BEFORE `manager.switch_to_session()`, so the chat window is cleared before messages are restored

## Details

### Detecting Last Streaming Message

In `restore_messages()`, we need to:

1. Iterate through all messages except the last one (i < messages.size - 1) and emit them via `message_created` signal
2. After the loop, check the last message:
   - If session is still running (`this.is_running == true`) AND last message has role "content-stream" or "think-stream":
     - Determine `is_thinking` from message role ("think-stream" → true, "content-stream" → false)
     - Call `handle_stream_chunk(message.content, is_thinking, null)` to trigger streaming callback
     - This will set up `current_stream_message` and emit it to the UI via streaming infrastructure
   - Otherwise, emit the last message normally via `message_created` signal

### Using Existing Streaming Infrastructure

When we call `handle_stream_chunk()` with the restored message content:

- It will create or set `current_stream_message` with the existing content
- It will emit the message to the UI via the streaming infrastructure (`base.handle_stream_chunk()` → Manager → ChatWidget)
- When new chunks arrive from the actual stream, `handle_stream_chunk()` will see `current_stream_message` exists and append to it (line 171)
- This ensures seamless continuation - the restored content appears immediately, then new chunks append to it

### Session Activation Flow

When a session is activated:
1. `Session.activate()` is called (or `SessionBase.activate()`)
2. After activation completes, if session has messages, call `restore_messages()`
3. `restore_messages()` emits messages via `message_created` signal
4. ChatWidget's `on_message_created()` handler receives and renders them
5. If last message is a streaming message and session is running:
   - Call `handle_stream_chunk(message.content, is_thinking, null)` to trigger streaming callback
   - This sets up `current_stream_message` and emits it to the UI via streaming infrastructure
6. When streaming resumes, `handle_stream_chunk()` sees `current_stream_message` exists and appends new chunks to it naturally

### Flow from History Item Click to Message Restoration

When user clicks on a history item:

1. **HistoryBrowser.session_selected signal** is emitted (HistoryBrowser.vala line 108)
2. **ChatWidget.switch_to_session()** is called (ChatWidget.vala line 184):
   - Finalizes any active streaming (line 189)
   - Sets streaming state to false (line 190)
   - Locks input (line 191)
   - **Calls `clear_chat()`** (line 194) - **This clears the chat window** (`chat_view.clear()`)
   - Disables scrolling (line 198)
3. **Manager.switch_to_session()** is called (ChatWidget.vala line 203):
   - Deactivates current session (Manager.vala line 225)
   - Loads new session if needed (line 230) - for SessionPlaceholder, this loads JSON and creates Session
   - Activates new session (line 241) - calls `session.activate()`
   - Emits `session_activated` signal (line 244)
4. **Session.activate()** is called (SessionBase.vala line 266):
   - Sets `is_active = true` (line 271)
   - Clears unread count (line 272)
   - **Should call `restore_messages()` here** (to be added)
5. **Session.restore_messages()** (to be added):
   - Emits all messages except last via `message_created` signal
   - If last message is streaming and session is running, calls `handle_stream_chunk()` with existing content
6. **ChatWidget.load_messages()** is called (ChatWidget.vala line 213):
   - **This may no longer be needed** if `restore_messages()` handles everything via signals
   - Currently iterates through `session.messages` and renders them directly
   - With new approach, messages are already emitted via signals, so this may be redundant

**Key Points:**
- `clear_chat()` is called BEFORE session switching, so chat window is already cleared
- `activate()` is called during `manager.switch_to_session()`
- `restore_messages()` should be called from `activate()` or right after
- `load_messages()` may need to be removed or simplified since `restore_messages()` emits via signals

## Edge Cases

- If session stops running between restore and first chunk, `current_stream_message` should be cleared and the message should be emitted via `message_created` signal
- If no chunks arrive (session stops), `current_stream_message` should be cleared and the message should be emitted on finalization or when session stops
- Need to handle the case where `current_stream_message` exists but streaming never resumes (should emit it when session stops)
- When switching sessions, the old session's `current_stream_message` should be cleared (or emitted) on deactivation
- When a session is deactivated and then reactivated, `restore_messages()` should be called again
- Need to ensure `current_stream_message` is already in `messages` list (it should be, since it came from `messages`)

## Testing

- Restore a session that's mid-stream
- Verify no visual break appears
- Verify content flows seamlessly
- Verify finalization works correctly if streaming stops before chunks arrive

