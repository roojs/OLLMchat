# 1.3.5. Tools Page and Tool Configuration

## Overview

Implement the Tools tab in the Settings dialog for configuring tools, setting up models for tools, and managing tool-specific settings. This includes the ToolsPage UI component and tool configuration management.

## Status

⏳ **TODO** - Not yet implemented

## Related Plans

- **1.3** - Configuration Overview
- **1.3.1** - Configuration Classes
- **1.3.2** - Configuration Interface
- **1.6** - Tools Management

## Tools Tab

**Purpose**: Configure tools, set up models for tools, manage tool-specific settings.

**Components**:
- **Horizontal Box (Action Bar)**: Top horizontal container with search
  - **Adw.SearchBar**: Search bar for filtering tools
    - Filters tool list in real-time as user types
    - Searches by tool name and description
  - (No action buttons - tools are auto-discovered from registry)
- **Adw.PreferencesGroup**: Contains the tool list
  - Wraps `Adw.BoxedList` for consistent styling
- **Tool List**: Uses `Adw.BoxedList` to display all registered tools
  - Shows: tool name, enabled status, description
  - Each tool uses `Adw.ExpanderRow` to show/edit tool configurations
  - Each tool can have multiple configurations (e.g., `vector.embed`, `vector.analysis`)
- **Tool Configuration List**: When tool row is expanded
  - Lists all configurations for the tool (e.g., "Embedding Settings", "Analysis Settings")
  - Each config shows: config name, display name, enabled status
  - Actions: Edit config, Remove config, Add new config
- **Tool Configuration Panel**: Uses `Adw.ExpanderRow` - when a specific config is selected
  - Settings widgets are added as children to the `Adw.ExpanderRow` using `add_row()`
  - Config Name: Text entry (e.g., "embed", "analysis") - used as key suffix
  - Config Display Name: Text entry (e.g., "Embedding Settings", "Analysis Settings") - shown in UI
  - Enabled: Checkbox to enable/disable this specific configuration
  - Model Configuration: `ModelUsage` editor (connection, model, options)
    - Uses the same `ModelUsage` class as ocvector
    - Connection dropdown: References `Config2.connections`
    - Model dropdown: Models available from selected connection
    - Separator (visual divider)
    - Options fields listed directly: Temperature, Top P, Top K, Num Ctx, etc.
  - Tool-Specific Settings: Dynamic UI based on tool type
    - Uses tool registration system to discover configurable properties
    - Each tool can register its configuration schema via `register_type()` in Config2
    - Example: `vector.embed` might have `vector_db_path`, `index_settings`, etc.

**Data Sources**:
- Tool registry: `Client.tools` (Gee.HashMap<string, Tool>)
- Tool configurations: `Config2.external_configs` (via registered types)
  - Tools register their config type with Config2: `config2.register_type("vector", typeof(ToolConfig))`
  - Tool configs stored with composite keys: `external_configs["vector.embed"]` → ToolConfig object
  - Multiple configs per tool: `vector.embed`, `vector.analysis`, etc.

**Tool Registration Pattern**:
- Tools register their configuration class with Config2 using `register_type(tool_name, typeof(ToolConfig))`
- Tool configs stored in `Config2.external_configs` map with composite keys: `tool_name.config_name`
- Examples:
  - `vector.embed` → Embedding settings (for semantic search)
  - `vector.analysis` → Analysis settings (for semantic search)
  - `codebase_search.main` → Main codebase search configuration
- Tool config classes should implement `Json.Serializable`
- Tool config classes can contain `ModelUsage` for model configuration
- Each tool can have multiple configurations, each with its own key in the format `tool_name.config_name`

## Files to Create

**4. ToolsPage**
- **Location**: `ollmchat/Settings/ToolsPage.vala`
- **Status**: ⏳ **NOT YET IMPLEMENTED**
- **UI Framework**: Uses `Adw.PreferencesPage` with:
  - Horizontal box at top containing `Adw.SearchBar` (no action buttons - tools auto-discovered)
  - `Adw.PreferencesGroup` wrapping `Adw.BoxedList` for tool list
  - Tool rows use `Adw.ExpanderRow` for expandable configuration panels
  - Settings widgets added to `Adw.ExpanderRow` via `add_row()` method
  - See [Adw.ExpanderRow documentation](https://valadoc.org/libadwaita-1/Adw.ExpanderRow.html)
- **Purpose**: Tools tab content
- **Properties**:
  - `settings_dialog` (SettingsDialog) - Reference to parent SettingsDialog (which has the config object)
  - `selected_tool` (string?) - Currently selected tool name
  - `selected_config` (string?) - Currently selected config name (format: `tool_name.config_name`)
- **Methods**:
  - `get_tool_configs(string tool_name)` - Get all configurations for a tool (returns list of config keys)
  - `configure_tool(string tool_name, string? config_name)` - Configure tool settings (config_name null = add new)
  - `add_tool_config(string tool_name, string config_name, string display_name)` - Add new configuration for tool
  - `remove_tool_config(string tool_name, string config_name)` - Remove configuration for tool
  - `get_tool_config_ui(Tool tool, string config_name)` - Generate dynamic UI for tool-specific config
  - Note: Tools are auto-discovered from Client registry, no refresh needed

**5. ToolConfig (Base Tool Configuration Class)**
- **Location**: `libollmchat/Settings/ToolConfig.vala` (optional base class)
- **Purpose**: Base configuration class for tools (data class, not UI)
- **Properties**:
  - `enabled` (bool) - Whether tool is enabled
  - `model_usage` (Settings.ModelUsage?) - Model configuration for tool
- **Note**: Tools can extend this or create their own config classes, registering with Config2

## Implementation Considerations

### Tool Configuration Discovery
**Problem**: Tools need to register their configuration schema, but we need UI to discover what's configurable.

**Solution**:
- Tools register their configuration types with Config2 using `Config2.register_type(key, gtype)`
- Tool config classes must implement `Json.Serializable` for persistence
- ToolsPage queries Client or tool registry to discover available tools
- Tool-specific configs are stored in Config2.usage map with registered keys
- UI generation for tool configs is tool-specific (may need custom UI per tool)

### Tool Model Configuration vs. Global Model Options
**Problem**: Tools have their own model configuration (ModelUsage in Config2.usage), but models also have global options (Config2.model_options). Which takes precedence?

**Solution**:
- Tool model configuration (ModelUsage) is separate from global model options
- Tool configs (like ocvector) use ModelUsage in Config2.usage map for tool-specific operations (e.g., embeddings, analysis)
- Global model options (Config2.model_options) are per-model option overrides for chat operations
- Clear separation: tool configs in `usage` map, model options in `model_options` map
- When a tool needs model options, it uses its own ModelUsage.options, not Config2.model_options

## Integration Points

- **Config2**: All settings stored in Config2 (connections, model_options, external_configs)
  - Tool configs use composite keys: `tool_name.config_name` (e.g., `vector.embed`, `vector.analysis`)
- **Client**: Used for fetching models, testing connections
- **Tool Registry**: Access via `Client.tools` or global registry
- **ModelUsage**: Used for tool model configuration (each tool config can have its own ModelUsage)
- **Call.Options**: Used for model options and tool model options
- **Multiple Configs per Tool**: Tools can register multiple configurations, each with a unique `tool_name.config_name` key in `external_configs`

