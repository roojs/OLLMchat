# 1.23.12 Prompt Refinements from Design

**Note:** Some information in this plan is **out of date and has been superseded**. For current implementation and behaviour, see **1.23.14-DONE-outstanding**, **1.23.11-DONE-runner-implementation**, **1.23.14-DONE-existing-skill-code-updates**, and **1.23.18-tail-end-issues**. Use this plan for prompt-content and format proposals; treat Runner/parser/Details details here as historical unless confirmed in the DONE plans.

## Overview

- **Parent:** Sub-plan of 1.23.2 (go back and change prompts per modified design).
- **Scope:** All detailed prompt changes and related files in `resources/skill-prompts`.
- **Design changes to reflect:**
  - Multiple tools per skill
  - Refinement generates all tool calls
  - Executor receives output from multiple tool calls
  - Context restriction between stages
- **This plan covers:**
  - What to change in each prompt
  - How refinement output expresses tool calls (e.g. code blocks)
  - How context/relevance filtering appears in prompts or Runner instructions
- **Out of scope:** Runner behaviour (parsing, passing code blocks, invoking tools) — stays in 1.23.11.
- **In scope:** Prompt content and format so prompts align with design; format of tool call content (e.g. code blocks) is defined here and in refinement prompt (1.23.4).

## Status

- **PLAN** — Concrete proposed changes added below (parser contract, context format, How to run tools, full prompt files for task_refinement, task_execution; template optional sections per 1.23.17). Task list iteration is implemented: prompt **task_list_iteration.md**, Runner **run_task_list_iteration()**.

### Items to address (from 1.23.13 / 1.23.14)

- **Task list format (parser contract)**
  - ResultParser expects `##` sections: **Original prompt**, **Goals / summary**, **Tasks** (no separate "General information for all tasks" — put context in task References). Parser may need to make **general-information-for-all-tasks** optional if present.
  - Under `## Tasks`: level-3 headings `### Task section 1`, `### Task section 2`, …; each section = list; each list item = one task; nested list with **Name**, **What is needed**, **Skill**, **References**, **Expected output** (optional: **Requires user approval**).
  - References: `#project-description`, absolute file path, `/path/to/file#section-name`, URLs, task output `#task-name-results` (give each task a Name e.g. "Research 1").
  - Action: **task_list_iteration.md** (task list iteration prompt) must produce output parseable by `ResultParser.parse_task_list()`. (task_creation_initial.md updated.)

- **Refinement output format**
  - ResultParser.extract_refinement expects heading **task** (section "## Task"): list → to_key_map → task.update_props; fenced code blocks → task.code_blocks; heading **tool-calls** ("## Tool Calls"): fenced blocks → Tool.parse. Tool call JSON: **name** (required), **arguments** (optional object).
  - Action: **task_refinement.md** must instruct the LLM to produce ## Task and ## Tool Calls so parsing succeeds.

- **Context restriction format**
  - Define:
    - Where "no longer relevant" or phase/relevance is expressed (task list, plan sections, or dedicated field)
    - Exact format so that (a) prompts can produce/reference it and (b) Runner / Details (1.23.13, 1.23.14) can filter reference content when building task context.

- **How to run tools section**
  - Add **"How to run tools"** to relevant prompt(s) (e.g. task refinement, task execution, or shared block).
  - Content: how tools are run — tool name in fence info string, one fenced block per call, arguments as JSON in block body; every tool call must define a name.
  - So the LLM knows the format the Runner will parse and execute.

- **Template fill — optional sections ({tag/start}, {tag/end})**
  - See **1.23.17** for implementation.
  - Extend template fill to support **{tag/start}** and **{tag/end}** in addition to **{tag}**.
  - Region between start/end = "section" for that tag.
  - When **{tag}** = `""`: section content and start/end tags are cleared from filled output.
  - When **{tag}** non-empty: replace start/end and **{tag}** with value as usual.
  - Implement per 1.23.17; document for prompt authors.

## Dependencies

- 1.23.2 (Three Prompt Types and Orchestration)
- 1.23.3, 1.23.4, 1.23.5, 1.23.6 (prompt plans — we refine their content and prompt files)
- 1.23.11 (Runner): Runner passes code blocks; prompt format here must align with what Runner parses/passes
- 1.23.17 (template changes): template API, fill stores rendered, optional sections, header+body helper

## Scope

- **Consolidate design-driven prompt changes**
  - All detailed requirements for updating prompts (from modified design) live in this plan.
  - 1.23.11 = *how* Runner parses and passes; this plan = *what* prompts and prompt files say and produce.

- **Tool call content as code blocks**
  - Refinement output includes tool call(s) for the task.
  - Content expressed as code blocks (or other well-defined format) so Runner can extract and pass to tool execution.
  - This plan + refinement prompt (1.23.4) define format; 1.23.11 specifies Runner parses and passes those blocks.

- **Per-prompt refinements (expand below):**
  - **Task refinement (1.23.4 / task_refinement.md):** Refinement generates all tool calls (possibly multiple). Output must include tool call content in code blocks (or agreed format). Define exact format (e.g. one fenced block per call vs one block for all; syntax for tool name + params). Prompt must instruct refiner to output in that format.
  - **Task list iteration (1.23.5 / task_list_iteration.md):** Implemented. Prompt reviews outputs from all tasks and outputs the full task list again; Runner calls **run_task_list_iteration()** after each round.
  - **Task execution (1.23.6 / executor skills):** Executor receives output from multiple tool calls; prompt/examples must say so. Any change to result summary/details. List concrete edits.

- **Context restriction and relevance**
  - Design: restrict context between stages (e.g. after research done, don’t keep all references for refinement/post-completion).
  - When plan/task list builds context for a step, it should indicate **information no longer relevant** so it’s not included.
  - This plan must specify:
    - **Prompt-level:** Add instructions (e.g. creation, task list iteration) that "relevance" or "phase" can limit what’s included? Or purely Runner (Runner filters by metadata/phase)?
    - **Format for "no longer relevant":** If task list or other artifact carries this — where (task list structure, dedicated field, plan sections) and how Runner uses it. Detail here so 1.23.11 can implement filtering and prompts can be updated.

- **Work order:** After expanding this plan, implement prompt file changes (and plan doc updates in 1.23.3–1.23.6) so Runner (1.23.11) can rely on code blocks for tool call content and updated formats.

- **File content vs tools (main plan):**
  - **Links to files** are the best way to add file content to task context. Put file paths in **References** (markdown links with absolute path); the Runner resolves and injects full content at refinement/execution. Prefer this over calling ReadFile for whole files.
  - **ReadFile** tool: use only when you need a **specific part** of a file (e.g. a range of lines or a snippet), not for "add this file to context" — use a link in References instead.
  - **CodeSearch:** using **multiple queries** is highly recommended. You can issue several tool calls with different queries and study the combined results; this is more informative than a single call.

---

## 1. Task refinement — tool call format and code blocks (to expand)

- **## Tool Calls (refinement format):**
  - Section heading: **## Tool Calls**
  - One fenced code block per tool call
  - Block body = single JSON: **uid**, **name**, **arguments** (e.g. `{ "uid": "call_1", "name": "toolname", "arguments": {"key": "value"} }`)
  - Document in **task_refinement.md**; parsed by ResultParser (1.23.15)

- **How to use a tool (for prompts):**
  - Tell LLM: output only **name**, **description**, **parameters** (type, required, properties) — not full Ollama wrapper

- **Tool call content as code blocks:**
  - Refinement output must express tool call(s) in a form Runner can parse and pass.
  - Use code blocks (fenced). Define:
    - One block per tool call vs one block with multiple calls (syntax TBD per skill)
    - How Runner extracts blocks and passes to tool execution (1.23.11)

- **task_refinement.md** and plan 1.23.4: instruct refiner to output **all** tool calls in the code-block format. Skill input requirements define syntax inside block(s).
- List any other refinement prompt changes (e.g. multiple tool calls, examples with multiple blocks).

## 2. Task list iteration

- **Implemented.** Prompt file **task_list_iteration.md**; Runner **run_task_list_iteration()** loads it, fills current task list + precursor with completed outputs, sends to LLM, parses response with `parse_task_list()`, replaces `this.task_list` on success. Optional future refinements: align output format with parser (e.g. Name, link types) per § Task list format above.

## 3. Context restriction and relevance (to expand)

- **Goal:** Restrict data passed between stages. After completed tasks (e.g. research), don’t keep all references in context for refinement/task-list-iteration. When building context, indicate **no longer relevant** so Runner excludes it.
- **Where expressed:** Task list? Plan sections? Dedicated "relevance" or "phase" marker? Specify so (a) prompts can produce/reference it and (b) 1.23.11 can implement filtering.
- **Prompt changes:** If any prompt must output or reference "relevance" or "phase" for Runner to filter context, specify exact wording and format here.

## 4. How to run tools section

- Add **"How to run tools"** to relevant prompt(s) (e.g. task refinement, task execution, or shared block).
- Content:
  - Tool name in fence info string
  - One fenced block per call
  - Arguments as JSON in block body
  - Every tool call must define a name
- Purpose: LLM knows exact format Runner will parse and execute (align with 1.23.15).
- List which prompt files get this section and exact wording (to expand).

## 5. Template fill — optional sections ({tag/start}, {tag/end})

- **Implementation:** See **1.23.17** (PromptTemplate; optional sections in fill).
- **Update task_refinement.md:** When optional sections exist (1.23.17), wrap "Your previous output" in **{previous_output/start}** … **{previous_output/end}** so that section is omitted when `previous_output` is empty (first attempt); only retries show header and previous output.

---

## Proposed changes (concrete)

Verify parser/runner behaviour against current code (ResultParser, Tool, Details) and 1.23.14-DONE-outstanding; some details below may be superseded.

### Parser contract (ResultParser)

- `parse_task_list()`: headings **original-prompt**, **goals-summary**, **tasks** (and optionally **general-information-for-all-tasks** if present; prompt omits it — put context in task References instead; parser may need to make this heading optional). Under **tasks**: **task-section-1**, **task-section-2**, …; each section = list; each list item = one task; nested list keys **Name**, **What is needed**, **Skill**, **References**, **Expected output**, optional **Requires user approval**.
- `extract_refinement()`: heading **task** (section title "## Task"); list → to_key_map → task.update_props; fenced code blocks → task.code_blocks; heading **tool-calls** (section title "## Tool Calls") → fenced code blocks → Tool.parse(block).
- Tool call JSON (Tool.parse): `{ "name": "<tool_name>", "arguments": { "<key>": "<value>" } }`. **name** required; **arguments** optional object. Runner assigns id (toolname_1, toolname_2, …).

### Context restriction format

- (Deferred: no **Relevance** field in task list in current prompts; context is via task References only.)

### How to run tools (exact block for refinement and execution prompts)

~~~~
## How to run tools

**Prefer multiple tool calls** — output as many fenced blocks as needed; the Runner runs them and passes all results to the skill. Generating multiple tool calls is more efficient than one.

- **File content:** The best way to add file content is **References** (markdown links with absolute path); the Runner injects content. Use the **ReadFile** tool only when you need a **specific part** of a file (e.g. a line range), not for whole-file context.
- **CodeSearch:** Use **multiple queries** when researching; issue several tool calls and study the combined results — more informative than a single call.

The Runner executes one tool call per fenced code block. Each block must contain a single JSON object with:
- **name** (required): the tool name, exactly as registered.
- **arguments** (optional): object of parameter names and values.

Example (one block per call): a fenced code block with body: { "name": "ReadFile", "arguments": { "path": "/abs/path/to/file" } }

Output one fenced code block per tool call (add as many as needed). The Runner assigns an id to each call and passes results to the skill.
~~~~

### Template optional sections (1.23.17)

- Prompt files keep placeholders **{previous_output_issues}** and **{previous_output}**.
- When fill value for **previous_output** is empty: template engine (1.23.17) clears the region between **{previous_output/start}** and **{previous_output/end}** from filled output.
- When non-empty: replace region with header + value. No change to prompt file text for task_refinement.md beyond the full content above (placeholders remain as-is).

---

## Deliverable

- **Updated prompt files** in `resources/skill-prompts` (and executor skill bodies as needed):
  - Multiple tools per skill
  - Refinement outputs all tool calls in code blocks
  - Executor receives multiple tool outputs
  - Context/relevance handling when specified
- **Updated plan docs** 1.23.3–1.23.6 for any lasting scope or output-format changes.
- **Single source of detail** for "what to change in the prompts" so 1.23.11 stays focused on Runner behaviour (including passing code blocks as tool call content).

## References

- 1.23.2 (orchestration, design)
- 1.23.3, 1.23.4, 1.23.5, 1.23.6 (prompt plans — we refine their content)
- 1.23.11 (Runner): parses refinement output, extracts code blocks (tool call content), passes to tool execution; context filtering when specified here
- 1.23.17 (template changes): template API, fill stores rendered, optional sections, header+body helper
