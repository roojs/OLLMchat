# 1.23.12 Prompt Refinements from Design

## Overview

Sub-plan of 1.23.2: **go back and make changes to our prompts** (and related prompt files in `resources/skill-prompts`) based on the **modified design** we have been developing. The design has evolved (e.g. multiple tools per skill, refinement generates all tool calls, executor receives output from multiple tool calls, context restriction between stages). This plan is the place for **all detailed information about those prompt changes**: what to change in each prompt, how the refinement output format should express tool calls (e.g. as code blocks), and how context/relevance filtering should be reflected in prompts or in instructions to the Runner. Implementation of **Runner behaviour** (parsing, passing code blocks, invoking tools) stays in 1.23.11; this plan focuses on **prompt content and format** so that the prompts align with the design. The Runner implementation (1.23.11) must still be able to **pass code blocks** — the tool call content from refinement — to the tool execution step; the **format** of that tool call content (e.g. code blocks in refinement output) is defined here and in the refinement prompt (1.23.4).

## Status

**PLAN** — Not started. Expand this document with concrete changes per prompt (1.23.3–1.23.6) and per prompt file.

**Items to address (from 1.23.13 / 1.23.14):**
- **Task list format (parser contract):** ResultParser (1.23.13) expects: ## sections **Original prompt**, **Goals / summary**, **General information for all tasks**, **Tasks**. Under ## Tasks, level-3 headings **### Task section 1**, **### Task section 2**, …; each such section contains **one list** where each list item is one task (break between items); within each list item, **nested list** with **What is needed**, **Skill**, **References**, **Expected output** (and optionally **Requires user approval**). Task creation (initial) and post-completion prompts must require this exact structure — update **task_creation_initial.md** and **task_post_completion.md** so the LLM output is parseable by ResultParser.parse_task_list().
- **Refinement output format:** ResultParser.extract_refinement (1.23.13) expects a **"Refined task"** section containing a list (first list item → to_key_map → task.update_props) and fenced code blocks appended to the task (code_blocks). Optionally a **"Skill call"** section with fenced code. **task_refinement.md** must instruct the LLM to produce this structure so parsing succeeds.
- **Context restriction format:** Define where "no longer relevant" or phase/relevance is expressed (task list, plan sections, or dedicated field) and the exact format so that (a) prompts can be updated to produce or reference it and (b) Runner / Details (1.23.13, 1.23.14) can filter reference content when building task context.
- **How to run tools section:** Add a **"How to run tools"** section to the relevant prompt(s) (e.g. task refinement, task execution, or a shared block). Content: instructions for how tools are run (e.g. tool name in fence info string, one fenced block per call, arguments as JSON in block body; every tool call must define a name). Use this section so the LLM knows the exact format the Runner will parse and execute.
- **Template fill — optional sections ({tag/start}, {tag/end}):** Extend the template fill implementation to support **{tag/start}** and **{tag/end}** in addition to simple **{tag}** placeholders. The region between **{tag/start}** and **{tag/end}** is the "section" for that tag. When **{tag}** is set to **""** (empty string), that section’s content and the start/end tags are **cleared** (removed) from the filled output. When **{tag}** is non-empty, replace **{tag/start}** and **{tag/end}** with the same markers (or nothing) and **{tag}** with the value as usual, so the section contains the filled value. Implement in the code that performs template fill (e.g. PromptTemplate or equivalent); document the behaviour in this plan so prompt authors can use optional sections.

## Dependencies

- Plan 1.23.2 (Three Prompt Types and Orchestration).
- Plans 1.23.3, 1.23.4, 1.23.5, 1.23.6 (prompt plans — we are refining their content and the content of the prompt files).
- Plan 1.23.11 (Runner implementation): Runner passes code blocks (tool call content); prompt format changes here must align with what the Runner parses and passes).

## Scope

- **Consolidate design-driven prompt changes:** All detailed requirements for updating prompts based on the modified design belong in this plan. The Runner plan (1.23.11) describes *how* the Runner parses and passes data; this plan describes *what* the prompts and prompt files should say and produce.
- **Tool call content as code blocks:** Refinement output includes **tool call(s)** for the task. That content is expressed as **code blocks** (or another well-defined format) so the Runner can extract and pass it to tool execution. This plan and the refinement prompt (1.23.4) must define that format; 1.23.11 specifies that the Runner parses and **passes those code blocks** (tool call content) to the tool execution step.
- **Per-prompt refinements (to expand below):**
  - **Task creation (initial) (1.23.3 / `task_creation_initial.md`):** Any wording or output-format updates needed for the evolved design (e.g. skills may use multiple tools; no need to spell out “one tool” in the prompt). List concrete edits or additions.
  - **Task refinement (1.23.4 / `task_refinement.md`):** Refinement generates **all** tool calls for the task (possibly multiple). Output must include **tool call content in code blocks** (or agreed format) so the Runner can pass it. Define the exact format (e.g. one fenced code block per tool call, or one block containing all calls; syntax for tool name + parameters). Skill input requirements may define per-skill syntax; the prompt must instruct the refiner to output tool call(s) in that format (code blocks).
  - **Post completion (1.23.5 / `task_post_completion.md`):** Any updates for design alignment (e.g. references to multiple task outputs, or to “refinement” adding tasks). List concrete edits.
  - **Task execution (1.23.6 / executor skills):** Executor receives **output from multiple tool calls**; prompt text and examples must say so. Any change to how result summary or details are expressed. List concrete edits.
- **Context restriction and relevance:** The design calls for **restricting context** between stages: once we have completed tasks (e.g. research done), we do not need to keep including all references in context for refinement or post-completion. When the plan / task list management builds context for a step, it should be able to indicate that **certain information is no longer relevant** so it is not included. This plan must specify:
  - **Prompt-level changes:** Do we add instructions in any prompt (e.g. creation, post-completion) that “relevance” or “phase” can be used to limit what is included? Or is this purely Runner behaviour (Runner filters precursor based on metadata or task phase)?
  - **Format for “no longer relevant”:** If the task list or some other artifact is to carry “this reference is no longer relevant for later steps”, where is that expressed (e.g. in task list structure, in a dedicated field, in plan sections) and how does the Runner use it? Put the detailed specification here so 1.23.11 can implement the filtering and prompts can be updated if they need to produce or reference that information.
- **Work order:** After this plan is expanded, implement prompt file changes (and any plan doc updates in 1.23.3–1.23.6) so that the Runner (1.23.11) can rely on code blocks for tool call content and on the updated formats.

## 1. Task creation (initial) — refinements (to expand)

- List concrete changes to the task creation (initial) prompt text and to `resources/skill-prompts/task_creation_initial.md`. Examples: remove or soften “one tool” if still present; clarify that a skill may involve multiple steps/tools; any wording that supports context relevance (if we express it in the task list).

## 2. Task refinement — tool call format and code blocks (to expand)

- **Tool call content as code blocks:** The refinement output must express **tool call(s)** in a form the Runner can parse and pass to tool execution. We use **code blocks** (fenced blocks) for this tool call content. Define:
  - One code block per tool call, or one block containing multiple calls (syntax TBD per skill).
  - How the Runner extracts these code blocks and passes them to the tool execution layer (1.23.11).
- Refinement prompt (`task_refinement.md`) and plan 1.23.4: instruct the refiner to output **all** tool calls for the task (possibly multiple) in the specified code-block format. Skill input requirements (from the skill file) define the syntax inside the block(s); the prompt says to use code blocks for the tool call content.
- List any other refinement prompt changes (e.g. multiple tool calls, examples showing multiple blocks).

## 3. Post completion — refinements (to expand)

- List concrete changes to the post-completion prompt text and to `resources/skill-prompts/task_post_completion.md` for design alignment (e.g. multiple outputs, adding tasks that use refinement again).

## 4. Task execution — refinements (to expand)

- List concrete changes to the task execution prompt/skill content (1.23.6 and executor skills in `resources/skills`): executor receives **output from multiple tool calls**; update role, input description, and examples to say so. Result summary and optional details format unchanged unless needed.

## 5. Context restriction and relevance (to expand)

- **Goal:** Restrict the amount of data passed between stages. Once we have completed tasks (e.g. research done), references from those tasks do not all need to be kept in context for refinement or post-completion. When building context for a step, indicate **information that is no longer relevant** so the Runner does not include it.
- **Where it is expressed:** Task list? Plan sections? A dedicated “relevance” or “phase” marker? Specify here so that (a) prompts can be updated to produce or reference it if needed, and (b) 1.23.11 can implement filtering.
- **Prompt changes:** If any prompt (e.g. task creation, post-completion) must output or reference “relevance” or “phase” so the Runner can filter context, specify the exact wording and format here.

## 6. How to run tools section

- Add a **"How to run tools"** section to the relevant prompt(s) (e.g. task refinement, task execution, or a shared block).
- Content: instructions for how tools are run — tool name in fence info string, one fenced block per call, arguments as JSON in block body; every tool call must define a name.
- Purpose: LLM knows the exact format the Runner will parse and execute (align with 1.23.15 Tool / refinement format).
- List which prompt files get this section and the exact wording (to expand).

## 7. Template fill — optional sections ({tag/start}, {tag/end})

- Extend template fill code to support **{tag/start}** and **{tag/end}** in addition to **{tag}**.
- Region between **{tag/start}** and **{tag/end}** = optional section for that tag.
- **When {tag} is "" (empty):** Clear that section: remove the section content and both tags from the filled output.
- **When {tag} is non-empty:** Fill **{tag}** with the value; leave or replace start/end markers as needed so the section contains the value.
- Implement in template fill code (e.g. PromptTemplate); document so prompt authors can use optional sections.

## Deliverable

- **Updated prompt files** in `resources/skill-prompts` (and executor skill bodies as needed) that match the design: multiple tools per skill, refinement outputs all tool calls in code blocks, executor receives multiple tool outputs, and (when specified) context/relevance handling.
- **Updated plan docs** 1.23.3–1.23.6 with any lasting changes to scope or output format that belong in those plans.
- **Single source of detail** for “what to change in the prompts” so 1.23.11 remains focused on Runner behaviour (including passing code blocks as tool call content).

## References

- Plan 1.23.2 (orchestration, design).
- Plans 1.23.3, 1.23.4, 1.23.5, 1.23.6 (prompt plans — we refine their content).
- Plan 1.23.11 (Runner implementation): Runner parses refinement output, extracts **code blocks** (tool call content), and passes them to tool execution; context filtering behaviour when specified in this plan).
