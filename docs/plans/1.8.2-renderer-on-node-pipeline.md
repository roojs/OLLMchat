# 1.8.2 Renderer pipeline — narrow to `on_node(FormatType, bool, string, string, string)`

- **Goal:** Narrow the renderer pipeline **only for the string-based callbacks** — those that fit (FormatType, is_start, 0–3 strings). Those get a single public entry point `on_node(...)` and become protected; all other callbacks stay as they are for the time being.
- **Status:** implemented.
- **Parent:** 1.8 (markdown outstanding issues); refines 1.8.1 (document renderer) and RenderBase.
- **Coding standards:** All new/modified Vala code must follow `.cursor/rules/CODING_STANDARDS.md`: `this.` prefix, brace style (line breaks for namespace/class/method, inline for control structures), no nullable strings (use empty string), no `@"..."` except multi-line help/docs, no trivial temporaries, fully-qualified `GLib.*` where needed, property defaults.

---

## Scope

1. **Narrow only callbacks that already have (is_start, 0–3 strings):** We replace **only** existing methods whose signature is already exactly `(bool is_start)` or `(bool is_start, string)` or `(bool is_start, string, string)` or `(bool is_start, string, string, string)` — or, for leaf content, `(string)` or `(string, string)` with no is_start (e.g. on_text, on_img). Callbacks whose only extra parameter can be derived from the type (e.g. heading level 1–6 from HEADING_1..HEADING_6) are still relayed with **zero strings**. Any callback that has uint/int/bool/char that we do not derive from the type, or has no parameters, remains public and is called directly by the parser.
2. **Dispatch:** Default implementation in RenderBase performs a switch on `type` and calls the corresponding protected method. No encoding of numbers or booleans as strings — only methods that already take strings are in the switch.
3. **Protected methods:** Only the callbacks that already have (is_start, 0–3 strings) become **protected virtual** and are called from the default `on_node` implementation (or overridden by subclasses).
4. **on_text:** Handled by `on_node` with `type == FormatType.TEXT`: `is_start` is ignored; only the first string is used (the text content).
5. **Other methods remain as-is:** All callbacks that do **not** have the (is_start, 0–3 strings) signature stay **public**, keep their current signatures, and are **not** changed. The parser continues to call them directly. This includes: on_ul/on_ol (uint indentation), on_quote (uint level), on_table_hcell/on_table_cell (int align), on_a (bool is_reference), on_task_list, on_code, on_code_text, on_hr. Exceptions: on_h relayed with zero strings (level from type); on_br, on_hr relayed and ignore all arguments; on_code_text relayed, is_start ignored, s1 = text.
6. **Strings:** Never use null for string parameters; use empty string `""` only.

---

## Signature and semantics

- **Public method (RenderBase):**
  - `public virtual void on_node(FormatType type, bool is_start, string s1 = "", string s2 = "", string s3 = "")`
  - Callers may omit trailing string arguments; they default to empty string, so there is no need to pass `"", "", ""` explicitly.
  - For **TEXT:** `is_start` is ignored; only `s1` is the text to add. No push/pop.
  - For all other types in the switch, semantics match the current protected method (e.g. is_start = true → open, false → close; s1/s2/s3 carry string form of extra args).

- **No non-string args:** We do **not** encode uint/int/bool as strings. Only methods whose existing parameters are (is_start, 0–3 strings) or (string[, string]) are routed through `on_node`.

- **FormatType:** Uses the existing **FormatType** enum in `Parser.vala`. Plan 1.8.1 adds `TABLE_ROW`, `TABLE_HCELL`, `TABLE_CELL`, `LIST_ITEM`, `TEXT`, `IMAGE`, `BR`, `U`, `OTHER`; `HORIZONTAL_RULE` already exists. Add `CODE_TEXT` for on_code_text if not present. Every dispatched callback has a distinct type in the switch.

---

## Concrete code proposal

### 1. RenderBase.vala — public `on_node` and protected callbacks

- Replace the current set of public abstract/virtual callbacks that fit (type, is_start, 0–3 strings) with:
  - **One public method:** `on_node(FormatType type, bool is_start, string s1 = "", string s2 = "", string s3 = "")` with a default implementation that switches on `type` and calls the protected methods below.
  - **Protected virtual methods** (default empty `{}`), called only from the switch — **only** those whose existing signature is (is_start [, string [, string [, string]]]) or (string [, string]):
    - `protected virtual void on_p(bool is_start) {}`
    - `protected virtual void on_h(bool is_start, uint level) {}` (level from type HEADING_1..6; zero strings)
    - `protected virtual void on_li(bool is_start) {}`
    - `protected virtual void on_em(bool is_start) {}`
    - `protected virtual void on_strong(bool is_start) {}`
    - `protected virtual void on_code_span(bool is_start) {}`
    - `protected virtual void on_del(bool is_start) {}`
    - `protected virtual void on_u(bool is_start) {}`
    - `protected virtual void on_text(string text) {}`
    - `protected virtual void on_html(bool is_start, string tag, string attributes) {}`
    - `protected virtual void on_other(bool is_start, string tag_name) {}`
    - `protected virtual void on_code_block(bool is_start, string lang) {}`
    - `protected virtual void on_table(bool is_start) {}`
    - `protected virtual void on_table_row(bool is_start) {}`
    - `protected virtual void on_img(string src, string title) {}` (use empty string when no title; no nullable).
    - `protected virtual void on_br() {}` (no args; relayed via on_node, all arguments ignored).
    - `protected virtual void on_code_text(string text) {}` (relayed via on_node; is_start ignored, s1 = text).
    - `protected virtual void on_hr() {}` (no args; relayed via on_node, all arguments ignored).
  - **Not in switch (remain public):** on_ul(uint), on_ol(uint), on_quote(uint), on_table_hcell(int), on_table_cell(int), on_a(bool is_reference), plus on_task_list, on_code.

- **Subclasses are not required to implement any of these.** In Vala, `virtual` with a default body `{}` means the method is optional: if a subclass does not override it, the base’s empty implementation runs (no-op). So extended classes can (1) override **on_node** only and do everything in one switch — the protected methods are never called and need not be implemented — or (2) override only the protected methods they care about; the rest get the base’s no-op. The base handles all of them by default.

- **TEXT:** In the switch, when `type == FormatType.TEXT`, call `on_text(s1)` and return (ignore `is_start`).
- **IMAGE:** Treated as a leaf: when `type == FormatType.IMAGE`, call `on_img(s1, s2)` (ignore `is_start`).

Default implementation of `on_node` (pseudocode; actual Vala in next subsection). Only types whose existing callback has (is_start [, string...]) or (string [, string]):

```
switch (type) {
  case TEXT:       on_text(s1); return;
  case IMAGE:      on_img(s1, s2); return;
  case PARAGRAPH:  on_p(is_start); return;
  case HEADING_1:  on_h(is_start, 1); return;
  case HEADING_2:  on_h(is_start, 2); return;
  case HEADING_3:  on_h(is_start, 3); return;
  case HEADING_4:  on_h(is_start, 4); return;
  case HEADING_5:  on_h(is_start, 5); return;
  case HEADING_6:  on_h(is_start, 6); return;
  case LIST_ITEM:  on_li(is_start); return;
  case ITALIC:     on_em(is_start); return;
  case BOLD:       on_strong(is_start); return;
  case CODE:       on_code_span(is_start); return;
  case STRIKETHROUGH: on_del(is_start); return;
  case U:          on_u(is_start); return;
  case HTML:       on_html(is_start, s1, s2); return;
  case OTHER:      on_other(is_start, s1); return;
  case FENCED_CODE_QUOTE:
  case FENCED_CODE_TILD: on_code_block(is_start, s1); return;
  case TABLE:      on_table(is_start); return;
  case TABLE_ROW:  on_table_row(is_start); return;
  case BR:         on_br(); return;   // no args; is_start and s1/s2/s3 ignored
  case CODE_TEXT:  on_code_text(s1); return;   // is_start ignored, s1 = text
  case HORIZONTAL_RULE: on_hr(); return;   // no args; all ignored
  default:         break;
}
```

**Not in switch:** on_ul, on_ol, on_quote, on_table_hcell, on_table_cell, on_a, on_task_list, on_code — parser keeps calling them directly with their existing signatures.

---

### 2. RenderBase.vala — full default `on_node` (Vala)

```vala
public virtual void on_node(FormatType type, bool is_start, string s1 = "", string s2 = "", string s3 = "")
{
	switch (type) {
		case FormatType.TEXT:
			this.on_text(s1);
			return;
		case FormatType.IMAGE:
			this.on_img(s1, s2);
			return;
		case FormatType.PARAGRAPH:
			this.on_p(is_start);
			return;
		case FormatType.HEADING_1:
			this.on_h(is_start, 1);
			return;
		case FormatType.HEADING_2:
			this.on_h(is_start, 2);
			return;
		case FormatType.HEADING_3:
			this.on_h(is_start, 3);
			return;
		case FormatType.HEADING_4:
			this.on_h(is_start, 4);
			return;
		case FormatType.HEADING_5:
			this.on_h(is_start, 5);
			return;
		case FormatType.HEADING_6:
			this.on_h(is_start, 6);
			return;
		case FormatType.LIST_ITEM:
			this.on_li(is_start);
			return;
		case FormatType.ITALIC:
			this.on_em(is_start);
			return;
		case FormatType.BOLD:
			this.on_strong(is_start);
			return;
		case FormatType.CODE:
			this.on_code_span(is_start);
			return;
		case FormatType.STRIKETHROUGH:
			this.on_del(is_start);
			return;
		case FormatType.U:
			this.on_u(is_start);
			return;
		case FormatType.HTML:
			this.on_html(is_start, s1, s2);
			return;
		case FormatType.OTHER:
			this.on_other(is_start, s1);
			return;
		case FormatType.FENCED_CODE_QUOTE:
		case FormatType.FENCED_CODE_TILD:
			this.on_code_block(is_start, s1);
			return;
		case FormatType.TABLE:
			this.on_table(is_start);
			return;
		case FormatType.TABLE_ROW:
			this.on_table_row(is_start);
			return;
		case FormatType.BR:
			this.on_br();
			return;
		case FormatType.CODE_TEXT:
			this.on_code_text(s1);
			return;
		case FormatType.HORIZONTAL_RULE:
			this.on_hr();
			return;
		default:
			break;
	}
}
```

- **Optional:** Add a `FormatType` for entity-decoded text if we want to fold `on_entity(string)` into `on_node` as well (e.g. same as TEXT); then the parser would call `on_node(FormatType.TEXT, false, decoded_entity)` for entities and no separate `on_entity` would be needed in the “remaining” list for the pipeline.

---

### 3. Parser and other call sites — call `on_node` instead of old callbacks

- **Parser.vala:** Replace every call that matches the (type, is_start, 0–3 strings) pattern with `this.renderer.on_node(...)`. Omit trailing string arguments (they default to empty string). Examples:
  - `this.renderer.on_p(is_start)` → `this.renderer.on_node(FormatType.PARAGRAPH, is_start)`
  - `this.renderer.on_h(is_start, level)` → `this.renderer.on_node(FormatType.HEADING_1 + (level - 1), is_start)` (zero strings; level from type)
  - `this.renderer.on_text(str)` → `this.renderer.on_node(FormatType.TEXT, false, str)`
  - `this.renderer.on_em(is_start)` → `this.renderer.on_node(FormatType.ITALIC, is_start)`
  - `this.renderer.on_html(is_start, tag, attributes)` → `this.renderer.on_node(FormatType.HTML, is_start, tag, attributes)`
- For **on_br**, parser calls `this.renderer.on_node(FormatType.BR, false)` (all arguments ignored by base; calls protected `on_br()`).
- Do **not** change calls to on_ul, on_ol, on_quote, on_table_hcell, on_table_cell, on_a, on_task_list, on_code, on_code_text, on_hr — parser keeps calling them directly.
- **BlockMap.vala, FormatMap.vala, LeftMap.vala, RightMap.vala, TableState.vala:** Similarly replace direct `renderer.on_*` calls with `renderer.on_node(...)` using the appropriate FormatType and string arguments.

- Headings use zero strings: parser calls `on_h(is_start, level)` as `on_node(FormatType.HEADING_1 + (level - 1), is_start)`.

---

### 4. Subclasses — do not modify existing renderers; DocumentRender uses on_node

- **Existing renderers (PangoRender, HtmlRender, DummyRenderer, libocmarkdowngtk Render):** Do **not** modify them. They continue to override the protected methods (e.g. `on_p`, `on_h`, `on_text`, …) as they do today. The base `on_node` will call those overrides; no need to change their logic or to override `on_node`. They do not benefit from rewriting to use the new pipeline.
- **Document renderer (DocumentRender, from plan 1.8.1):** Will **override on_node only** and implement a single switch that builds the document tree. It benefits heavily from this: one entry point, one switch on type, no need to implement the many protected methods. The base’s protected methods are never used for DocumentRender.

---

## Other methods (remain as-is — two of them)

These **two** callbacks do **not** fit the pattern and **remain unchanged**: same public API, parser keeps calling them directly.

| Method | Reason not in `on_node` |
|--------|--------------------------|
| `on_task_list(bool is_start, bool is_checked)` | Two booleans; no string args. |
| `on_code(bool is_start, string? lang, char fence_char)` | Includes `char` (fence_char); not expressible as 1–3 strings. |

**Note:** `on_br()`, `on_hr()` are routed through `on_node` (all arguments ignored). `on_code_text(string)` is routed through `on_node(FormatType.CODE_TEXT, false, text)` (is_start ignored). Any other callbacks (e.g. `on_softbr`, `on_entity`) also remain as-is unless we later fold them into the string pipeline.

---

## Implementation checklist

- [x] **Coding standards:** Follow `.cursor/rules/CODING_STANDARDS.md`: `this.` prefix, brace style (line breaks for class/method, inline for switch/if), no nullable strings (empty string only), no `@"..."` except multi-line docs, no trivial temporaries, `GLib.` prefix where needed.
- [x] **Parser.vala:** Ensure FormatType has all values needed for the switch (see 1.8.1; add CODE_TEXT for on_code_text if not present; HORIZONTAL_RULE already exists).
- [x] **RenderBase.vala:** Add public `on_node(FormatType, bool, string, string, string)` with default implementation (switch); convert current public callbacks that fit the pattern to protected virtual; keep default empty implementations for those protected methods.
- [x] **RenderBase.vala:** Add safe parsing for numeric s1/s2/s3 where used (e.g. level, indentation, align) so empty or invalid strings do not crash.
- [x] **Parser.vala, BlockMap.vala, FormatMap.vala, LeftMap.vala, RightMap.vala, TableState.vala:** Replace every `renderer.on_*(...)` that is covered by `on_node` with `renderer.on_node(type, is_start, s1, s2, s3)`.
- [x] **Subclasses:** Either override `on_node` only (Option A) or keep overriding the protected `on_p`, `on_h`, etc. (Option B); ensure no code still calls the old public callback names from outside the base.
- [x] **Tests:** Update any tests that assert on or mock the old public callback list; ensure document renderer and other renderers still behave correctly after the pipeline change.

---

## Summary

| Item | Description |
|------|-------------|
| **Public API** | Single entry: `on_node(FormatType type, bool is_start, string s1 = "", string s2 = "", string s3 = "")`. Callers omit trailing string args (default to empty). TEXT: is_start ignored, s1 = text. Never use null for strings. |
| **Dispatch** | Default implementation in RenderBase switches on `type` and calls protected `on_p`, `on_h`, `on_text`, … |
| **Protected** | Callbacks in the switch become protected virtual: on_p, on_h (level from type), on_li, on_em, on_strong, on_code_span, on_del, on_u, on_text, on_html, on_other, on_code_block, on_table, on_table_row, on_img, on_br, on_code_text (is_start ignored), on_hr (all args ignored). |
| **Other (unchanged)** | Two methods remain public and unchanged: on_task_list, on_code. Parser keeps calling them directly. |
| **Callers** | Parser and maps call `on_node(...)` only for string-based callbacks; call the four other methods as today. |
