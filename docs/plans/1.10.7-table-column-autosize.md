# Table support Phase 7: Table column auto-size (1.10.7)

- Part of the phased implementation for markdown table support.
- See **1.8.2-table-support-current-design.md** for the overall design and phase order.
- Depends on **1.10.4-DONE-table-handling.md**, **1.10.5-DONE-calling-code-types.md** (table rendering in GTK).

**Status: open.**

- **Coding standards:** Verify this plan against **.cursor/rules/CODING_STANDARDS.md** (nullable types, null checks, string interpolation, temporaries, brace placement, `this.` prefix, GLib prefix, property init, line length, Gee.HashMap `.set()`/`.get()`, etc.) before implementing.

- **This plan:** Content-based column width sizing:
  - **this.cells** = HashMap&lt;row, HashMap&lt;col, ScrolledWindow&gt;&gt; — used for resizing (all cell widgets).
  - **this.cellwidths** = HashMap&lt;col, width&gt; — max natural width per column (accumulated).
  - **End of each cell:** Add cell to this.cells outside idle; Idle.add → update cellwidths to max of existing or current cell’s measured width.
  - **End of row:** Idle.add → **this.build_widths_and_resize()** (no args), which builds widths and calls **this.resize(widths)** to set every cell’s width_request.

---

## Goal

- After rendering a table in **libocmarkdowngtk/Table.vala**, resize column widths from cell content.
- Use W3C-style automatic table layout (per-column min/natural, then choose width in min/max bounds).
- **End of each cell:** Add ScrolledWindow to **this.cells** via **this.cells.get(row).set(col, sw)** outside idle; Idle.add measures cell and updates **cellwidths** via **cellwidths.set(col, max(…, nat_w))** (use `.set()`/`.get()`).
- **End of row:** Idle.add calls **this.build_widths_and_resize()** (no args), which builds widths from this.cellwidths and calls **this.resize(widths)** to update all cell widths.
- **No** resize at table end in Render.

---

## Data structures

- **this.cells:** `Gee.HashMap<int, Gee.HashMap<int, Gtk.ScrolledWindow>>`
  - row → (col → ScrolledWindow).
  - Used by **resize(widths)** to set width_request on every cell.
- **this.cellwidths:** `Gee.HashMap<int, int>`
  - col → max natural width seen so far (raw max, no min/max rules until row end).

**When on_table starts:** Render creates a **new Table()** per table (Render.on_table(true) → `this.current_table = new Table(this)`). Each Table has its own **this.cells** and **this.cellwidths**. Idles are scheduled from that Table's methods, so when they run **this** is still that table — **no need to capture local_table / local_cells / local_cellwidths**; use **this.cellwidths**, **this.cells**, **this.build_widths_and_resize()** with no arguments. Each Table instance gets its own fresh hashmaps so idles for table A never touch table B’s data.

---

## Min / max column width rules

- **Min:** 10% of container width if num_cols &lt; 5, else 50 px.
- **Max:** 60% of container width when num_cols ≤ 5, else 400 px per column.
- **Container width:** grid allocation or passed-in; fallback 50 px / 400 px when unknown.

---

## Flow

### Start of row (on_row(true))

- Set **this.cells** row: **this.cells.set(current_row, new Gee.HashMap<int, Gtk.ScrolledWindow>())** so the row exists before any cell is added.
- **Why only on start:** We create the row map once when the row begins; then each cell close does **this.cells.get(current_row).set(current_cell, sw)** without a has_key check (use `.set()`/`.get()` per CODING_STANDARDS). We don’t set it at row end — the next row’s map is created on the next on_row(true).

### End of each cell (on_hcell(false) / on_cell(false))

- **Before** `set_renderer_to_fake()`:
  - **Add cell to this.cells outside the idle:** `sw = this.renderer.current_textview.get_parent() as Gtk.ScrolledWindow`; **this.cells.get(current_row).set(current_cell, sw)** (row already set on on_row(true)).
  - **Capture only local_tv and local_col** for the idle (which cell we're measuring — renderer will have moved on). Use **this.cellwidths** in the callback (same table).
- **Idle.add** callback: measure local_tv (HORIZONTAL, -1) → nat_w; **this.cellwidths.set(local_col, max(this.cellwidths.get(local_col) or 0, nat_w))**; return false.
- Then call `set_renderer_to_fake()` and `current_cell++` as now.

### End of row (on_row(false))

- After adding the separator, **before** `current_row++`: **Idle.add** with no capture — callback calls **this.build_widths_and_resize()** (no args); return false.
- Then `current_row++` as now. (**build_widths_and_resize()** uses **this.cellwidths** and **this.cells**, builds widths map, calls **this.resize(widths)**.)

### resize(widths)

- **No cells argument** — use **this.cells**. For each row in this.cells, for each col: set **this.cells.get(row).get(col).width_request = widths.has_key(col) ? widths.get(col) : 100**.

---

## Implementation plan

### 1. Add num_cols, cells, cellwidths in Table (new maps when table starts)

- **num_cols:** set when first row ends (`on_row(false)`, `current_row == 0` → `num_cols = current_cell` before `current_row++`).
- **this.cells** and **this.cellwidths:** Use property default (`get; set; default = new ...`) so each Table gets its own hashmaps; do **not** set in constructor or reuse shared maps (CODING_STANDARDS: property initialization).

**Concrete code (Table.vala):**

```vala
// At top of class with other fields
private int num_cols = 0;
private Gee.HashMap<int, Gee.HashMap<int, Gtk.ScrolledWindow>> cells;
private Gee.HashMap<int, int> cellwidths;

// In constructor, after this.grid = new Gtk.Grid()... :
this.cells = new Gee.HashMap<int, Gee.HashMap<int, Gtk.ScrolledWindow>>();
this.cellwidths = new Gee.HashMap<int, int>();

// In on_row(bool is_start):
// When is_start == true (row start): create row map once so we can add cells at each cell close without has_key
if (is_start) {
	this.current_cell = 0;
	this.cells[this.current_row] = new Gee.HashMap<int, Gtk.ScrolledWindow>();
	return;
}
// When is_start == false (row end): set num_cols on first row, attach separator, then Idle.add (this.build_widths_and_resize()), then current_row++
if (this.current_row == 0) {
	this.num_cols = this.current_cell;
}
```

### 2. End of each cell: add cell to cells outside idle; Idle.add only updates cellwidths

- In `on_hcell(false)` and `on_cell(false)`, **before** `set_renderer_to_fake()`:
  - **Add cell to this.cells outside the idle:** `sw = this.renderer.current_textview.get_parent() as Gtk.ScrolledWindow`; **this.cells.get(current_row).set(current_cell, sw)** (row already set on on_row(true)).
  - **Capture only local_tv and local_col** (which cell we're measuring — renderer moves on). Idle callback uses **this.cellwidths** (same table).
  - Idle.add: measure local_tv → nat_w; **this.cellwidths.set(local_col, max(this.cellwidths.get(local_col) or 0, nat_w))**; return false.
- Then `set_renderer_to_fake(); current_cell++;`

**Concrete code (Table.vala) — in on_hcell / on_cell when is_start == false, before set_renderer_to_fake():**

```vala
// Add cell to this.cells outside idle (row already set in on_row(true))
var sw = this.renderer.current_textview.get_parent() as Gtk.ScrolledWindow;
this.cells.get(this.current_row).set(this.current_cell, sw);

// Idle: only capture which cell we're measuring (local_tv, local_col); use this.cellwidths (same table)
var local_tv = this.renderer.current_textview;
var local_col = this.current_cell;
GLib.Idle.add(() => {
	int min_w, nat_w;
	local_tv.measure(Gtk.Orientation.HORIZONTAL, -1, out min_w, out nat_w, null, null);
	int cur = this.cellwidths.has_key(local_col) ? this.cellwidths.get(local_col) : 0;
	this.cellwidths.set(local_col, int.max(cur, nat_w));
	return false; // one-shot
});
this.set_renderer_to_fake();
this.current_cell++;
```

### 3. resize(widths) — set width_request on all cells

- **Signature:** `private void resize(Gee.HashMap<int, int> widths)`. Uses **this.cells** (no cells argument).
- For each row in this.cells, for each col: `this.cells.get(row).get(col).width_request = widths.has_key(col) ? widths.get(col) : 100;`

**Concrete code (Table.vala):**

```vala
private void resize(Gee.HashMap<int, int> widths)
{
	foreach (var row_entry in this.cells.entries) {
		var row_cells = row_entry.value;
		foreach (var col_entry in row_cells.entries) {
			int c = col_entry.key;
			var sw = col_entry.value;
			int w = widths.has_key(c) ? widths.get(c) : 100;
			sw.width_request = w;
		}
	}
}
```

### 4. build_widths_and_resize() — method (no args)

- **Signature:** `private void build_widths_and_resize()`. Uses **this.cellwidths** and **this.cells** (no arguments).
- Get container (this.grid width or 400); ncols = this.num_cols &gt; 0 ? this.num_cols : this.current_cell; min_col/max_col from rules; build HashMap&lt;col, width&gt; from **this.cellwidths** (clamp each to min_col..max_col); call **this.resize(widths)**.

**Concrete code (Table.vala):**

```vala
private void build_widths_and_resize()
{
	int ncols = this.num_cols > 0 ? this.num_cols : this.current_cell;
	int container = 400;
	if (this.grid.get_width() > 0) {
		container = this.grid.get_width();
	}
	int min_col = (ncols < 5) ? (int)(0.10 * container) : 50;
	int max_col = (ncols <= 5) ? (int)(0.60 * container) : 400;

	var widths = new Gee.HashMap<int, int>();
	foreach (var e in this.cellwidths.entries) {
		int c = e.key;
		int w = e.value.clamp(min_col, max_col);
		widths.set(c, w);
	}
	this.resize(widths);
}
```

### 5. End of row: Idle.add — call build_widths_and_resize()

- In **on_row(bool is_start)**, when `is_start == false`: after attaching separator, **before** `current_row++`, **GLib.Idle.add** with no capture — callback calls **this.build_widths_and_resize()** (no args); return false.
- Then `current_row++`.

**Concrete code (Table.vala) — in on_row(false), after attaching separator, before current_row++:**

```vala
GLib.Idle.add(() => {
	this.build_widths_and_resize();
	return false; // one-shot
});
this.current_row++;
```

### 6. Optional: respect container width for distribution

- If total chosen width exceeds container, scale or cap column widths; min/max rules already tie to container when available.

---

## Data flow (high level)

```mermaid
sequenceDiagram
  participant Parser
  participant Render
  participant Table
  participant Grid

  Parser->>Render: on_table(true)
  Render->>Table: new Table()
  Parser->>Render: on_table_row/hcell/cell (all rows)
  Render->>Table: on_row, on_hcell, on_cell
  Table->>Grid: attach cells (width_request=100)
  Note over Table: end of each cell: add to cells outside idle; Idle.add(measure, cellwidths[col]=max)
  Note over Table: end of each row: Idle.add → this.build_widths_and_resize() (no args)
  Parser->>Render: on_table(false)
  Render->>Render: clear(); current_table = null
  Table->>Table: this.resize(widths) sets width_request on every ScrolledWindow
```

---

## Files to change

| File | Change |
|------|--------|
| **libocmarkdowngtk/Table.vala** | **When on_table starts:** Use property default for **this.cells** and **this.cellwidths** (get; set; default = new ...) so each Table gets its own; do not set in constructor. **on_row(true):** **this.cells.set(current_row, new HashMap<...>())** so row exists before cells are added. Add **num_cols**; set in `on_row(false)` when `current_row == 0`. **End of each cell:** Add cell to **this.cells** outside idle (**this.cells.get(current_row).set(current_cell, sw)**). Capture only **local_tv, local_col**; Idle callback uses **this.cellwidths.set(local_col, max(…, nat_w))**. **End of row:** Idle.add calls **this.build_widths_and_resize()** (no args; no capture). Add **build_widths_and_resize()** (no args; uses this.cellwidths, this.cells; build widths, call this.resize(widths)). Add **resize(widths)** (uses this.cells) to set width_request on every cell. |
| **libocmarkdowngtk/Render.vala** | In `on_table(false)`, keep `this.clear(); this.current_table = null` and `create_textview()` — no resize at table end. |

---

## Constants / formulas

- **Min column width:** 10% of container if num_cols &lt; 5, else 50 px.
- **Max column width:** 60% of container if num_cols ≤ 5, else 400 px.
- **When container width unknown:** fallback min = 50 px, max = 400 px.
