# 1.2. Refactor Client and Chat Relationship

## Overview

Refactor the Client and Chat relationship to make Chat Options a real object rather than a realized one, and ensure that creating new chats copies options from the Client. Use Client values as defaults when creating Chat.

## Status

✅ **DONE** - All refactoring complete. All subplans (1.2.1 through 1.2.13) have been completed.

## ⚠️ CRITICAL: Incremental Implementation Required

**IMPORTANT**: All 1.2.* plans have been restructured to follow an incremental approach. Each step must be implemented incrementally to keep the code usable after each step.

**See**: [1.2 Incremental Refactor Strategy](./1.2-incremental-refactor-strategy.md) for the overall approach.

**Key Principle**: Add new code paths first, migrate call sites incrementally, remove old code paths last.

**Note**: All subplans (1.2.1 through 1.2.6) have been updated to follow this incremental approach with clear phases and testing checkpoints.

## Ideal Interface Design

### Architecture Overview

The ideal architecture separates concerns into three main layers:

1. **Connection** - Stores server connection configuration
2. **Client** - Thin HTTP communication layer with signals
3. **Chat** - Request-specific configuration and execution

### Object Responsibilities

#### Connection (`Settings.Connection`)
**Purpose**: Stores connection configuration and can create clients.

**Responsibilities**:
- Store connection details (URL, API key, name, is_default)
- Create HTTP messages with proper headers (`soup_message()`)
- Manage HTTP soup (Soup.Session) - shared across all Clients using this Connection
- Manage HTTP timeout (non-serialized runtime property)
- Manage `available_models` cache (populated when models are fetched via Client)
- Connection is immutable configuration - shared across clients (except non-serialized runtime properties)

**Properties**:
- `name` (string) - Connection alias
- `url` (string) - Server URL
- `api_key` (string) - API key for authentication
- `is_default` (bool) - Whether this is the default connection
- `hidden_models` (ArrayList<string>) - Models to hide from UI
- `timeout` (uint) - HTTP request timeout in seconds (default: 300)
  - **Note**: Non-serialized property (runtime state, not saved to config)
  - **Note**: Used by Call.Base to set `soup.timeout` when making requests
- `soup` (Soup.Session) - HTTP session (initialized when Connection is created or when added to base)
  - **Note**: Shared across all Clients using this Connection (connection pooling)
  - **Note**: Non-serialized property (runtime state, not saved to config)
  - **Note**: Soup should be initialized whenever it's added to base, so it's never null and should never be tested for null
- `available_models` (HashMap<string, Response.Model>) - Cached model info for this connection
  - **Note**: Connection-specific (models available on that server)
  - **Note**: Non-serialized property (runtime cache, not saved to config)
  - **Note**: Connection manages its own cache - Client updates it when fetching models

**Methods**:
- `clone()` - Create a copy
- `soup_message(method, url, body?)` - Create HTTP message with auth headers
- `create_client()` - Factory method to create a Client instance (optional convenience)
- `fetch_all_model_details()` - Fetch all model details and populate `available_models` cache
  - **Note**: Creates temporary Client internally to make HTTP requests
  - Populates Connection's own `available_models` cache

#### Client (`OLLMchat.Client`)
**Purpose**: Thin wrapper around Connection for HTTP communication. Should NOT hold options or settings that are not directly related to connecting to the server.

**Responsibilities** (What Client DOES):
- Convenience wrapper providing simple API methods (ps, models, version, show_model, chat, embed, generate)
- Creates Call objects and delegates HTTP execution to Call.Base
- **Note**: Call.Base takes Connection directly (not Client) - Client is just a convenience wrapper

**Properties** (What Client KEEPS):
- `connection` (Settings.Connection) - Connection configuration
  - **Used by Client**: Passed to Call constructors (Call.Base takes Connection directly)

**Properties** (What Client REMOVES - where they go):
- ❌ `model` → **Moves to Chat/Embed/Generate** (request-specific)
- ❌ `stream` → **Moves to Chat** (request-specific)
- ❌ `format` → **Moves to Chat** (request-specific)
- ❌ `think` → **Moves to Chat** (request-specific)
- ❌ `keep_alive` → **Moves to Chat** (request-specific)
- ❌ `options` (Call.Options) → **Moves to Chat/Embed/Generate** (request-specific)
- ❌ `tools` (HashMap<string, Tool.BaseTool>) → **Moves to Chat** (conversation-specific, caller manages)
- ❌ `permission_provider` (ChatPermission.Provider) → **Moves to Session** (UI/session-specific)
- ❌ `config` (Settings.Config2?) → **Remove** (caller manages options, not Client/Chat)
- ❌ `streaming_response` (Response.Chat?) → **Moves to Chat** (session-specific state)
- ❌ `session` (Soup.Session?) → **Moves to Connection as `soup`** (connection-specific, shared across Clients)
- ❌ `timeout` (uint) → **Moves to Connection** (connection-specific, non-serialized)
- ❌ `available_models` (HashMap<string, Response.Model>) → **Moves to Connection** (connection-specific, non-serialized)
- ❌ `fetch_all_model_details()` → **Moves to Connection** (Connection manages its own cache)

**Signals** (What Client REMOVES):
- ❌ `chat_send(Call.Chat)` → **Remove** - caller knows when they call `send()`
- ❌ `message_created(Message, ChatContentInterface?)` → **Remove** - caller creates messages, they know when
- ❌ `stream_content(string, Response.Chat)` → **Remove** - redundant, use `stream_chunk` with `is_thinking` check

**Signals** (What Client KEEPS temporarily, moves to Chat in final tidy-up):
- ⏸️ `stream_chunk(string, bool, Response.Chat)` → **Moves to Chat** (in 1.2.7) - Chat orchestrates conversation, emits signals
- ⏸️ `stream_start()` → **Moves to Chat** (in 1.2.7) - Chat emits when streaming starts
- ⏸️ `tool_message(Message)` → **Moves to Chat** (in 1.2.7) - Chat emits tool status messages

**Methods** (What Client KEEPS):
- `ps()` - List running models
- `models()` - List available models
- `version()` - Get server version
- `show_model(string)` - Get model details

**Methods** (Simple convenience methods - create Call objects internally):
- `chat(string, Cancellable?)` - Simple chat (creates `Call.Chat` internally with defaults)
- `embed(string model, string input, ...)` - Simple embeddings (creates `Call.Embed` internally)
  - **Note**: Currently exists, needs update to take `model` parameter (currently uses `this.model`)
- `embed_array(string model, ArrayList<string> input_array, ...)` - Simple embeddings for array (creates `Call.Embed` internally)
  - **Note**: Currently exists, needs update to take `model` parameter (currently uses `this.model`)
- `generate(string model, string prompt, string system = "", ...)` - Simple generation (creates `Call.Generate` internally)
  - **Note**: Currently exists, needs update to take `model` parameter (currently uses `this.model`)

**Methods** (What Client REMOVES):
- ❌ `add_tool(Tool.BaseTool)` → **Remove** - tools managed by caller on Chat

**What Client Should NOT Have**:
- ❌ `model` - Request-specific, belongs in Chat/Embed/Generate
- ❌ `stream` - Request-specific, belongs in Chat
- ❌ `format` - Request-specific, belongs in Chat
- ❌ `think` - Request-specific, belongs in Chat
- ❌ `keep_alive` - Request-specific, belongs in Chat
- ❌ `options` (Call.Options) - Request-specific, belongs in Chat/Embed/Generate
- ❌ `tools` (HashMap<string, Tool.BaseTool>) - Conversation-specific, belongs in Chat/Session
- ❌ `permission_provider` (ChatPermission.Provider) - Session/UI-specific, belongs in Session

#### Chat (`OLLMchat.Call.Chat`)
**Purpose**: Request-specific configuration and execution. Holds all settings for a specific chat request.

**Responsibilities**:
- Store request configuration (model, options, stream, format, think, keep_alive)
- Send chat requests (uses pre-prepared messages array from agent)
- Manage conversation history (messages array)
- Handle tool execution and recursion
- Call agent methods directly during execution (if agent reference is set)
- Emit signals for loosely coupled components (UI/Manager)

**Properties** (Request configuration):
- `model` (string) - Model name (required)
- `options` (Call.Options) - Runtime options (temperature, top_p, etc.)
- `stream` (bool) - Whether to stream responses
- `format` (string?) - Response format
- `format_obj` (Json.Object?) - JSON schema for structured output
- `think` (bool) - Whether to return thinking output
- `keep_alive` (string?) - Model keep-alive duration

**Properties** (Conversation):
- `messages` (ArrayList<Message>) - Conversation history
  - **Note**: Agent/handler prepares messages array directly - no need for intermediate `system_content` or `chat_content` properties

**Properties** (References):
- `connection` (Settings.Connection) - Connection for HTTP communication
  - **Note**: Call.Base takes Connection directly (not Client) - Client is just a convenience wrapper
- `agent` (BaseAgent?) - Optional reference to agent for direct method calls
  - **Note**: Chat calls agent methods directly (not via signals) - signals are for UI/Manager/loosely coupled components

**Properties** (Conversation-specific):
- `tools` (HashMap<string, Tool.BaseTool>) - Registered tools for this chat/conversation
  - **Note**: Tools are conversation-specific, not connection-specific
  - **Caller manages tools**: The caller (AgentHandler, Session, etc.) adds tools to Chat directly
  - Tools are NOT on Client - Client is just for HTTP communication
  - Each Chat can have different tools

**Properties** (State):
- `fid` (string) - Session ID
- `streaming_response` (Response.Chat?) - Current streaming state
- `cancellable` (Cancellable?) - Cancellation token

**Signals** (Asynchronous events - Chat does NOT emit signals):
- **Note**: Chat calls handler/agent methods directly (not signals)
- **Note**: For agent usage, Manager emits signals (UI connects to manager)
- **Note**: For non-agent usage, Client emits signals (UI connects to client)

**Methods**:
- `add_tool(Tool.BaseTool)` - Add a tool to this chat (caller manages tools)
- `send()` - Send chat request (uses client for HTTP, emits signals)
- `reply(string, Response.Chat)` - Continue conversation
- `tool_reply(Response.Chat)` - Execute tools and continue (uses `this.tools`, not `client.tools`)

### Usage Patterns

#### Pattern 1: Simple Operations (Trivial)
For simple operations that don't need per-request configuration:

```vala
var connection = new Settings.Connection() {
    url = "http://127.0.0.1:11434/api",
    timeout = 300  // Optional: set timeout (non-serialized, runtime property)
};

var client = new Client(connection);

// Simple operations - no Chat needed
var models = yield client.models();
var version = yield client.version();
var running = yield client.ps();

// Simple convenience methods (create Call objects internally)
var response = yield client.chat("Hello!");
var embeddings = yield client.embed("llama3.2", "text to embed");
var generated = yield client.generate("llama3.2", "prompt text");
```

#### Pattern 2: Main Usage (Chat with Configuration)
For chat requests with specific configuration:

```vala
var connection = new Settings.Connection() {
    url = "http://127.0.0.1:11434/api",
    timeout = 300  // Non-serialized, can be set at runtime
};

// Create Chat with request-specific configuration
// Note: Call.Chat takes Connection directly (not Client)
var options = new Call.Options() {
    temperature = 0.7,
    top_p = 0.9
};

var chat = new Call.Chat(connection, "llama3.2") {
    options = options,
    stream = true,
    think = false,
    keep_alive = "5m"
};

// Caller adds tools to Chat (not Client)
chat.add_tool(new Tools.ReadFile());
chat.add_tool(new Tools.RunCommand());

// Prepare messages (agent/handler does this)
chat.messages.add(new Message(chat, "user", "Hello!"));

// Send
var response = yield chat.send();
```

#### Pattern 3: With Connection Factory
Connection could provide a factory method:

```vala
var connection = new Settings.Connection() {
    url = "http://127.0.0.1:11434/api"
};

// Connection creates client (for convenience methods)
var client = connection.create_client();

// Or use Connection directly with Call
var chat = new Call.Chat(connection) {
    model = "llama3.2",
    stream = true
};
```

### Signal Flow

#### Design Principle: Signals Only for Asynchronous Events

Signals should only be used for truly asynchronous events that the caller cannot know about synchronously. The caller is responsible for updating state directly.

**What Gets Signals** (Asynchronous only):
- Streaming chunks arriving from HTTP (can't know synchronously)
- Tool status messages from background operations

**What Does NOT Get Signals** (Caller handles directly):
- Request sent - Caller knows when they call `send()`
- Message created - Caller creates messages, they know when
- Request started - Caller knows when they call the method

#### How Signals Connect

1. **Chat emits signals for asynchronous events**:
   - `stream_start()` - When streaming begins (first chunk received)
   - `stream_chunk(string, bool, Response.Chat)` - For each chunk received (content or thinking)
     - Tools can filter by checking the `bool is_thinking` parameter
   - `tool_message(Message)` - Tool status notifications
   - **Note**: Chat uses Connection (via Call.Base) for HTTP, but emits signals itself during execution

2. **Chat uses Connection for HTTP execution**:
   - Chat calls Call.Base methods which use Connection's soup and URL
   - Chat does NOT connect to any signals (it emits them)
   - Chat orchestrates the conversation and emits signals as events occur
   - **Caller handles state updates**: When caller calls `chat.send()`, they can update UI/state directly

3. **Chat calls Agent/Handler methods directly** (no signals for agents):
   ```vala
   // Agent creates Handler (parent-child relationship)
   // Agent is persistent, Handler is ephemeral (created per request)
   public AgentHandler(BaseAgent agent, ChatRequest request, Session session) {
       this.agent = agent;  // Handler has reference to parent agent
       this.request = request;
       this.session = session;  // Handler has reference to parent session for callbacks
   }
   
   public async Response.Chat send(ChatRequest request) {
       // Handler creates Chat with agent reference
       var connection = get_connection_from_request(request);
       var chat = new Call.Chat(connection, request.model) {
           options = options,
           agent = this.agent  // Chat has reference to agent
       };
       
       // Chat calls agent/handler methods directly during execution
       // Example: chat.on_chunk(chunk) calls handler.on_chunk(chunk)
       // Example: chat.on_stream_start() calls handler.on_stream_start()
       // Handler then calls session.on_chunk(chunk) → session calls manager.on_chunk(chunk)
       // NO signals - direct method calls through parent chain
       
       // Send
       return yield chat.send();
   }
   ```

4. **UI connects to Manager signals** (Manager relays from agent infrastructure):
   ```vala
   // UI connects to Manager signals (Manager does NOT have reference to UI)
   // Manager relays from Handler → Session → Manager → UI
   // Handler calls session methods directly, session calls manager, manager emits signal
   
   manager.stream_chunk.connect((text, is_thinking, response) => {
       if (is_thinking) {
           // Handle thinking content separately if needed
       } else {
           // Update UI with regular content
       }
   });
   
   // Tools can filter for content-only:
   manager.stream_chunk.connect((text, is_thinking, response) => {
       if (!is_thinking) {
           // Process content chunks only
       }
   });
   
   // State updates handled directly by caller
   var response = yield handler.send(user_input);
   // Caller knows request was sent, can update UI directly
   ui.show_waiting_indicator();
   ```

5. **Caller handles state updates directly**:
   ```vala
   // UI should block send button before send() is called
   ui.disable_send_button();
   
   // Caller creates messages and knows when
   var user_msg = new Message(chat, "user", text);
   session.save_message(user_msg); // Direct call, no signal
   
   // Caller knows when request is sent
   // Note: send() begins execution after message is sent and returns after sending,
   // not waiting for response. Response comes via signals/callbacks.
   yield chat.send();
   // send() has returned - request has been sent, but response may still be streaming
   ui.show_waiting_indicator(); // Direct call, no signal
   ```

**Signal Chain** (Asynchronous events only):
```
For Agent usage (direct method calls):
HTTP Streaming Response 
  → Chat (calls handler methods directly)
    → Handler (calls session methods directly)
      → Session (calls manager methods directly)
        → Manager (emits signals for UI)
          → UI (connected to manager signals)

For non-agent usage (loosely coupled):
HTTP Streaming Response 
  → Client (emits signals for loosely coupled components)
    → UI (connected to client signals directly)
```

**Key Points**:
- **Chat calls handler/agent methods directly** - Agent infrastructure uses direct method calls (not signals)
- **Manager emits signals for UI** - Manager does NOT have reference to UI, UI connects to manager signals
- **Client emits signals for non-agent usage** - For loosely coupled components (direct client usage without agents)
- **Connection is passive** - Just configuration, no signals, used by Call.Base for HTTP
- **Client is just a convenience wrapper** - Can emit signals for non-agent usage, but agent infrastructure uses direct calls
- **Signals only for loosely coupled components** - Manager (for UI) and Client (for non-agent usage) use signals
- **Agent infrastructure uses direct method calls** - Handler → Session → Manager (no signals in this chain)
- Signals only for asynchronous events (streaming, tool notifications)
- Caller handles state updates directly (no signals for "I did X")

### Message Flow Architecture

The message flow follows a clear path from UI through Manager, Session, Agent, to Chat:

#### Flow Overview

```
UI → Manager.send(fid, message)
  → Session.send(message)
    → Session adds Message to session history and emits message_added signal
    → If message.role == "user": Session delegates to AgentHandler
      → AgentHandler.send_async(message)
        → AgentHandler builds full message history from this.session.messages
        → AgentHandler creates Chat and calls chat.send(messages, cancellable)
          → Chat.send() executes request and streams response
            → AgentHandler processes response and creates assistant messages
              → AgentHandler calls session.send(assistant_message) → Manager.message_added signal → UI
```

#### Manager.send() - Entry Point

**Purpose**: Central entry point for UI to send messages. Routes messages to the correct session.

**Signature**:
```vala
// Manager.vala
public async void send(string fid, Message message, GLib.Cancellable? cancellable = null) throws Error
```

**Responsibilities**:
- Find session by `fid` (using `sessions_by_fid` HashMap for O(1) lookup)
- Delegate to `session.send(message, cancellable)`
- Handle errors if session not found

**Usage**:
```vala
// UI creates Message object and calls Manager
var message = new Message(null, "user", "Hello!");
yield manager.send(session.fid, message);
```

#### Session.send() - Message History Management

**Purpose**: Adds Message to session history, emits signal, and delegates to AgentHandler if needed.

**Signature**:
```vala
// SessionBase.vala
public abstract async void send(Message message, GLib.Cancellable? cancellable = null) throws Error;

// Session.vala
public async void send(Message message, GLib.Cancellable? cancellable = null) throws Error
```

**Responsibilities**:
- Add message to `session.messages` array (session history)
- Emit `manager.message_added(message, this)` signal to notify UI
- If `message.role == "user"`, delegate to AgentHandler: `yield this.agent.send_async(message, cancellable)`

**Implementation**:
```vala
public async void send(Message message, GLib.Cancellable? cancellable = null) throws Error
{
    // Add to session history
    this.messages.add(message);
    
    // Emit signal to notify UI
    this.manager.message_added(message, this);
    
    // If not user message, we're done
    if (message.role != "user") {
        return;
    }
    
    // User message - delegate to AgentHandler
    if (this.agent == null) {
        throw new OllamaError.INVALID_ARGUMENT("No agent available for session");
    }
    
    yield this.agent.send_async(message, cancellable);
}
```

**Key Points**:
- Session manages message history (`session.messages`)
- Session adds messages immediately to history and emits signal
- Session delegates to AgentHandler for user messages
- Session does NOT create Chat objects - that's AgentHandler's responsibility
- Session has `agent` property (AgentHandler) set when session is created or agent is changed

#### AgentHandler.send_async() - History Building and Chat Execution

**Purpose**: Builds full message history from session data and sends to Chat.

**Signature**:
```vala
// AgentHandler.vala
public async void send_async(Message message, GLib.Cancellable? cancellable = null) throws Error
```

**Responsibilities**:
- Read full message history from `this.session.messages` (AgentHandler has session reference from constructor)
- Prepare complete message array including:
  - System messages (if needed - CodeAssistant builds complex system prompt, BasicAgent does nothing)
  - Filtered messages from `this.session.messages` (API-compatible roles: system, user, assistant, tool)
  - Exclude non-API message types (user-sent, ui, etc.)
- Create `Call.Chat` object for this request
- Call `chat.send(messages, cancellable)` with full message array
- Process streaming response
- Create assistant messages and add to session via `session.send(assistant_message)`

**Implementation**:
```vala
public async void send_async(Message message, GLib.Cancellable? cancellable = null) throws Error
{
    // Build full message history from this.session
    var messages = new Gee.ArrayList<Message>();
    
    // Build system prompt at this point in time
    // CodeAssistant does this, BasicAgent does nothing
    string system_content = this.agent.generate_system_prompt();
    if (system_content != "") {
        messages.add(new Message(null, "system", system_content));
    }
    
    // Filter and add messages from this.session.messages (full conversation history)
    // Filter to get API-compatible messages (system, user, assistant, tool)
    // Exclude non-API message types (user-sent, ui, etc.)
    foreach (var msg in this.session.messages) {
        if (msg.role == "system" || msg.role == "user" || msg.role == "assistant" || msg.role == "tool") {
            messages.add(msg);
        }
    }
    
    // Create Chat for this request
    var chat = new Call.Chat(this.session.client.connection, this.session.model) {
        cancellable = cancellable,
        stream = true,
        think = true,
        options = this.get_options_for_model(this.session.model)
    };
    
    // Set agent reference on Chat (for tool execution callbacks)
    chat.agent = this;
    
    // Send full message array
    var response = yield chat.send(messages, cancellable);
    
    // Process response and add assistant messages to session via session.send()
    // (handled via streaming callbacks or response processing)
}
```

**Key Points**:
- AgentHandler builds complete message history from `this.session.messages`
- AgentHandler filters messages to get API-compatible roles only
- AgentHandler creates Chat per request (Chat is not stored on Session)
- AgentHandler sends full message array to Chat
- AgentHandler processes response and updates session via `session.send(assistant_message)`
- AgentHandler uses `this.session` (set in constructor) instead of taking session as parameter

#### Chat.send() - Request Execution

**Purpose**: Executes the chat request with the provided message array.

**Signature**:
```vala
// Call.Chat.vala
public async Response.Chat send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null) throws Error
```

**Responsibilities**:
- Reset internal state (streaming_response, etc.)
- Use provided messages array (not `this.messages`)
- Execute HTTP request via Call.Base
- Stream response back to AgentHandler (via direct method calls) or emit signals (for non-agent usage)
- Return Response.Chat

**Key Points**:
- Chat is stateless and reusable
- Each call is independent
- Messages are passed explicitly, not stored on Chat
- Chat does NOT manage conversation history - that's Session's job
- Chat calls AgentHandler methods directly during streaming (if agent is set)
- Chat emits signals for non-agent usage (loosely coupled components)

#### Benefits of This Flow

1. **Clear Separation of Concerns**:
   - Manager: Routing and session lookup
   - Session: Message history management
   - Agent: Message preparation and Chat creation
   - Chat: Request execution

2. **Single Entry Point**: UI always calls `manager.send(fid, type, message)`

3. **History Management**: Session owns and manages message history

4. **Stateless Chat**: Chat is created per request, no persistent state

5. **Flexible Agents**: Different agents can build history differently (system prompts, etc.)

6. **Testability**: Each layer can be tested independently

#### Migration from Current Flow

**Current Flow** (Legacy):
- UI calls `session.send_message(text, cancellable)` directly (or similar methods)
- Session uses `this.chat` (persistent Chat object)
- Session manages Chat lifecycle

**New Flow** (Target):
- UI creates Message object and calls `manager.send(fid, message)`
- Manager routes to `session.send(message)` (using `sessions_by_fid` HashMap for lookup)
- Session adds Message to history, emits `message_added` signal, delegates to AgentHandler if user message
- AgentHandler creates Chat per request, filters messages from session, sends full history

**See**: [1.2.6.2. Update Session to Use Agent Instead of Direct Chat Access](./1.2.6.2-update-session-chat.md) for detailed migration steps.

### Migration Path

The migration is broken down into detailed subplans:

- **[1.2.1. Remove Configuration from Client](./1.2.1-remove-config-from-client.md)** - Remove request-specific and conversation-specific properties from Client
- **[1.2.2. Remove Signals from Client](./1.2.2-remove-signals-from-client.md)** - Remove synchronous state update signals
- **[1.2.3. Update Call.Base to Take Connection](./1.2.3-update-call-base-connection.md)** - Make Call objects take Connection directly
- **[1.2.4. Update All Chat Creation](./1.2.4-update-all-chat-creation.md)** - Update all Chat creation points
- **[1.2.5. Update Callers to Handle State Directly](./1.2.5-update-callers-state.md)** - Remove signal dependencies for state updates
- **[1.2.6. Update Legacy Methods](./1.2.6-DONE-update-legacy-methods.md)** - Update Client convenience methods
  - **[1.2.6.1. Update Client Method Signatures](./1.2.6.1-DONE-update-client-method-signatures.md)** - Make model parameter required, options optional
  - **[1.2.6.2. Update Session to Use Agent Instead of Direct Chat Access](./1.2.6.2-update-session-chat.md)** - Implement new message flow: Manager.send() → Session.send() → Agent → Chat.send()

Each subplan contains detailed implementation steps, files to modify, and testing checklists.

**See**: [Message Flow Architecture](#message-flow-architecture) section above for the complete flow design.

### Benefits of This Design

1. **Clear Separation**: Client = HTTP, Chat = Request config
2. **No Confusion**: Client doesn't hold request-specific settings
3. **Flexibility**: Each Chat can have different settings
4. **Simplicity**: Client is thin and focused
5. **Explicitness**: Chat creation requires explicit configuration
6. **Cleaner Signals**: Signals only for asynchronous events, caller handles state directly
7. **Less Coupling**: No signals for "I did X" - caller knows when they do things

## Client Overview

### Current Client Responsibilities

The `Client` class (`libollmchat/Client.vala`) is the main interface for interacting with Ollama API and OpenAI-compatible REST interfaces. It currently handles:

#### Configuration Properties
- **Connection Management**: `connection` (Settings.Connection), `config` (Settings.Config2)
- **Model Selection**: `model` (string) - model name to use for requests
- **Streaming Configuration**: 
  - `stream` (bool) - whether to stream responses
  - `format` (string?) - response format ("json" or JSON schema)
  - `think` (bool) - whether to return thinking output separately
  - `keep_alive` (string?) - model keep-alive duration
- **Runtime Options**: `options` (Call.Options) - runtime parameters (temperature, top_p, etc.)
- **Timeout**: `timeout` (uint) - HTTP request timeout in seconds

#### Tool Management
- **Tools HashMap**: `tools` (Gee.HashMap<string, Tool.BaseTool>) - available tools indexed by name
- **Tool Registration**: `add_tool(Tool.BaseTool)` - adds tool to the map and sets tool.client

#### Permission System
- **Permission Provider**: `permission_provider` (ChatPermission.Provider) - handles permission requests for tool execution

#### State Management
- **Streaming Response**: `streaming_response` (Response.Chat?) - current streaming state
- **Available Models**: `available_models` (Gee.HashMap<string, Response.Model>) - cached model information
- **HTTP Session**: `session` (Soup.Session?) - HTTP session for requests (will be renamed to `soup` and moved to Connection)

#### Signal Emission
The Client emits several signals for event handling:
- `stream_chunk(string, bool, Response.Chat)` - streaming chunk received
- `stream_content(string, Response.Chat)` - streaming content (not thinking) received
- `tool_message(Message)` - tool status message
- `chat_send(Call.Chat)` - chat request sent
- `stream_start()` - streaming started
- `message_created(Message, ChatContentInterface?)` - message created in conversation

#### API Methods
- `chat(string, Cancellable?)` - Legacy chat method (backward compatibility)
- `chat_execute(Call.Chat)` - Legacy method (replaced by `chat.send()`, may be removed)
- `models()` - Gets list of available models
- `ps()` - Gets list of running models
- `version(Cancellable?)` - Gets Ollama server version
- `show_model(string)` - Gets detailed model information
- `fetch_all_model_details()` - Fetches details for all models
- `embed(string, ...)` - Generates embeddings
- `embed_array(ArrayList<string>, ...)` - Generates embeddings for array
- `generate(string, string, Cancellable?)` - Generates response without conversation history

### Current Chat Creation Issues

#### Problem 1: "Realized" Properties
Chat currently has several properties that are "realized" (read-only getters that delegate to `client`):
```vala
public bool stream { 
    get { return this.client.stream; }
    set { } // Fake setter for serialization
}
```
**Current realized properties** (in `libollmchat/Call/Chat.vala`):
- `stream` (line 46-49) - reads from `this.client.stream`
- `format` (line 51-54) - reads from `this.client.format`
- `think` (line 65-68) - reads from `this.client.think`
- `keep_alive` (line 70-73) - reads from `this.client.keep_alive`
- `tools` (line 75-78) - reads from `this.client.tools`

**Real properties** (not realized):
- `model` (line 44) - real property, set via constructor
- `options` (line 63) - real property, set via constructor or loaded from config
- `format_obj` (line 61) - real property for JSON schema
- `system_content` (line 79) - real property
- `messages` (line 81) - real property

**Problem**: Chat cannot have different values than Client for `stream`, `format`, `think`, `keep_alive`, and `tools`, making it impossible to have per-chat configuration. Tools should be on Chat, not Client, and the caller should add tools directly to Chat.

#### Problem 2: Options Loading Logic
Chat constructor (`libollmchat/Call/Chat.vala:87-110`) currently:
```vala
public Chat(Client client, string model, Call.Options? options = null)
{
    // ...
    // Load model options from config if options not provided
    if (options != null) {
        this.options = options;
    } else {
        if (this.client.config.model_options.has_key(model)) {
            this.options = this.client.config.model_options.get(model);
        } else {
            this.options = new Call.Options();
        }
    }
}
```

**Problems**: 
- Options are NOT copied from `client.options` (Client's default options are ignored)
- Falls back to `client.config.model_options[model]`, which may not match Client's current runtime options
- Creates empty `Call.Options()` if neither provided nor in config
- Requires `client.config` to be non-null (will fail if null)

#### Problem 3: Inconsistent Chat Creation
Chat instances are created in 8 different places with inconsistent patterns:

1. **AgentHandler** (`libollmchat/Prompt/AgentHandler.vala:131`):
   ```vala
   var call = new OLLMchat.Call.Chat(this.client, this.client.model);
   ```
   - No options provided - relies on constructor fallback to `client.config.model_options`

2. **CodeAssistantHandler** (`liboccoder/Prompt/CodeAssistantHandler.vala:55`):
   ```vala
   var call = new OLLMchat.Call.Chat(this.client, this.client.model);
   ```
   - No options provided - relies on constructor fallback

3. **Client.chat()** (`libollmchat/Client.vala:320`):
   ```vala
   var call = new Call.Chat(this, this.model) {
       cancellable = cancellable
   };
   ```
   - No options provided - relies on constructor fallback
   - Uses `this.model` (Client property that will be removed)

4. **Manager.new_client()** usage (`libollmchat/History/Manager.vala:271`):
   ```vala
   var session = new Session(this, new Call.Chat(client, client.model));
   ```
   - No options provided - relies on constructor fallback
   - Uses `client.model` (Client property that will be removed)

5. **EmptySession.send_message()** (`libollmchat/History/EmptySession.vala:73`):
   ```vala
   var chat = new Call.Chat(new_client, new_client.model);
   ```
   - No options provided - relies on constructor fallback
   - Uses `new_client.model` (Client property that will be removed)

6. **SessionPlaceholder** (`libollmchat/History/SessionPlaceholder.vala:88`):
   ```vala
   var real_session = new Session(this.manager, new Call.Chat(client, this.model));
   ```
   - No options provided - relies on constructor fallback

7. **Config2.create_chat()** (`libollmchat/Settings/Config2.vala:559`):
   ```vala
   return new OLLMchat.Call.Chat(client, model_usage_obj.model, model_usage_obj.options);
   ```
   - ✅ Explicitly provides options from ModelUsage (good pattern)

8. **Analysis** (`libocvector/Indexing/Analysis.vala:322`):
   ```vala
   var chat = new OLLMchat.Call.Chat(analysis_client, analysis_usage.model, analysis_usage.options);
   ```
   - ✅ Explicitly provides options from usage (good pattern)

**Problem**: 6 out of 8 creation points don't provide options, relying on inconsistent fallback logic. Only Config2 and Analysis explicitly provide options. All creation points use `Client` (which will change to `Connection`).

### What Should Be Removed from Client

Based on the ideal interface design (see [Object Responsibilities](#object-responsibilities) above), the following should be removed from Client:

**Request-Specific Properties** (move to Chat/Embed/Generate):
- `model` (string) - Request-specific, belongs in Chat/Embed/Generate
- `stream` (bool) - Request-specific, belongs in Chat
- `format` (string?) - Request-specific, belongs in Chat
- `think` (bool) - Request-specific, belongs in Chat
- `keep_alive` (string?) - Request-specific, belongs in Chat/Embed/Generate
- `options` (Call.Options) - Request-specific, belongs in Chat/Embed/Generate

**Conversation-Specific Properties** (move to Chat/Session):
- `tools` (HashMap<string, Tool.BaseTool>) - Conversation-specific, belongs in Chat (caller manages tools on Chat)
- `permission_provider` (ChatPermission.Provider) - Session/UI-specific, belongs in Session

**State Properties** (move to Chat):
- `streaming_response` (Response.Chat?) - Session-specific state, belongs in Chat

**Connection-Specific Properties** (move to Connection):
- `soup` (Soup.Session) - Connection-specific, shared across Clients using same Connection
  - **Note**: Soup should be initialized whenever it's added to base, so it's never null and should never be tested for null
- `timeout` (uint) - Connection-specific, non-serialized runtime property
- `available_models` (HashMap<string, Response.Model>) - Connection-specific cache, non-serialized

**Configuration Properties** (remove):
- `config` (Settings.Config2?) - Remove from Client (caller manages options, not Client/Chat)

**Methods to Remove**:
- `add_tool(Tool.BaseTool)` - Tools managed by caller on Chat, not Client

**Signals to Remove** (see [1.2.2](./1.2.2-remove-signals-from-client.md)):
- `chat_send(Call.Chat)` - Caller knows when they call `send()`
- `message_created(Message, ChatContentInterface?)` - Caller creates messages, they know when
- `stream_content(string, Response.Chat)` - Redundant, use `stream_chunk` with `is_thinking` check

**Signals to Keep Temporarily** (for non-agent usage only, moved to Chat in 1.2.7):
- `stream_chunk(string, bool, Response.Chat)` - Asynchronous event for loosely coupled components (moved to Chat in final tidy-up)
- `stream_start()` - Asynchronous event for loosely coupled components (moved to Chat in final tidy-up)
- `tool_message(Message)` - Asynchronous event for loosely coupled components (moved to Chat in final tidy-up)

**Note**: For agent usage, Chat calls handler methods directly (no signals). Signals are only for loosely coupled components (non-agent usage). These signals are kept on Client during refactoring for backward compatibility, but will be moved to Chat in [1.2.7. Move Signals to Chat](./1.2.7-DONE-move-signals-to-chat.md).

### What Client Should Keep

Client should remain a thin HTTP communication layer with:
- `connection` (Settings.Connection) - Connection configuration (passed to Call constructors)
- Convenience API methods (`ps()`, `models()`, `version()`, `show_model()`, `chat()`, `embed()`, `generate()`) - Simple wrapper methods that create Call objects internally
- Signals for non-agent usage (loosely coupled components) - `stream_chunk`, `stream_start`, `tool_message`

**Client is just a convenience wrapper** - Call objects take Connection directly, Client methods are optional convenience methods for simple operations.

## Implementation Details

### Overview

This refactoring is broken down into detailed subplans that should be implemented in order:

1. **[1.2.1. Remove Configuration from Client](./1.2.1-remove-config-from-client.md)** - Remove request-specific and conversation-specific properties from Client
2. **[1.2.2. Remove Signals from Client](./1.2.2-remove-signals-from-client.md)** - Remove synchronous state update signals
3. **[1.2.3. Update Call.Base to Take Connection](./1.2.3-update-call-base-connection.md)** - Make Call objects take Connection directly instead of Client
4. **[1.2.4. Update All Chat Creation](./1.2.4-update-all-chat-creation.md)** - Update all Chat creation points to use Connection and explicit properties
5. **[1.2.5. Update Callers to Handle State Directly](./1.2.5-update-callers-state.md)** - Remove signal dependencies for state updates
6. **[1.2.6. Update Legacy Methods](./1.2.6-update-legacy-methods.md)** - Update Client convenience methods
7. **[1.2.7. Move Signals to Chat](./1.2.7-DONE-move-signals-to-chat.md)** - Final tidy-up: Move remaining asynchronous signals from Client to Chat

### Key Changes Summary

1. **Chat takes Connection directly** (not Client)
   - Chat constructor changes from `Chat(Client client, ...)` to `Chat(Connection connection, ...)`
   - Call.Base takes Connection directly - Client is just a convenience wrapper
   - Connection manages HTTP soup (Soup.Session), timeout, and available_models cache
   - **Soup initialization**: Soup should be initialized whenever it's added to base, so it's never null and should never be tested for null

2. **Chat properties become real (not "realized")**
   - Convert `stream`, `format`, `think`, `keep_alive`, `tools` from getters to real properties
   - All properties must be set explicitly when creating Chat (no longer read from Client)
   - Chat can have different values per instance

3. **Options handling**
   - `options` is a property on Chat (not a constructor parameter)
   - Can be set using Vala constructor-style property setting: `new Chat(...) { options = ... }`
   - Defaults to `new Call.Options()` if not set
   - Caller is responsible for providing options if needed (Chat/Client do not access Config2)
   - Chat no longer depends on `client.config` or `client.options` (both removed from Client)

4. **Tools management**
   - Tools are NOT on Client - caller adds tools directly to Chat via `chat.add_tool()`
   - Each Chat can have different tools (conversation-specific)
   - Tools are managed by the caller (AgentHandler, Session, etc.)

5. **Permission provider**
   - Moves from Client to Session (UI/session-specific, not connection-specific)
   - Tools access via `chat_call.session.permission_provider`

6. **Signals**
   - Remove synchronous signals: `chat_send`, `message_created`, `stream_content`
   - Keep asynchronous signals temporarily: `stream_chunk`, `stream_start`, `tool_message` (for non-agent usage, moved to Chat in 1.2.7)
   - For agent usage, Chat calls handler methods directly (no signals)

### Benefits

- **Clear separation**: Client = HTTP convenience wrapper, Chat = Request config, Connection = Server config
- **No confusion**: Client doesn't hold request-specific settings
- **Flexibility**: Each Chat can have different settings and tools
- **Simplicity**: Client is thin and focused on HTTP communication
- **Explicitness**: Chat creation requires explicit configuration
- **Cleaner signals**: Signals only for asynchronous events, caller handles state directly
- **Less coupling**: No signals for "I did X" - caller knows when they do things

### Current State vs. Target State

**Current State** (see [Current Chat Creation Issues](#current-chat-creation-issues)):
- Chat takes `Client` and reads properties from `client.*`
- Chat has "realized" properties that delegate to Client
- Chat depends on `client.config.model_options` for options fallback
- Client holds request-specific properties (`model`, `stream`, `format`, `think`, `keep_alive`, `options`)
- Client holds conversation-specific properties (`tools`, `permission_provider`)
- Client holds connection-specific properties (`session`, `timeout`, `available_models`)

**Target State** (see [Ideal Interface Design](#ideal-interface-design)):
- Chat takes `Connection` directly
- Chat has real properties set explicitly by caller
- Chat `options` defaults to `new Call.Options()` if not set (caller provides options if needed)
- Client is thin wrapper with only `connection` property
- Chat holds all request-specific properties
- Session holds conversation-specific properties (`permission_provider`)
- Connection holds connection-specific properties (`soup`, `timeout`, `available_models`)

### Implementation Approach

Each subplan contains:
- Detailed implementation steps
- Files to modify
- Code examples showing current vs. target state
- Testing checklists
- Dependencies on other subplans

Refer to the individual subplans for detailed implementation guidance. The subplans should be implemented in order to minimize breaking changes and ensure each step builds on the previous one.
