# 1.3.5. Tools Page and Management

## Overview

Implement the Tools tab in the Settings dialog and the underlying tool management system for configuring tools, setting up models for tools, managing tool-specific settings, enabling/disabling tools, and managing tool permissions. This includes the ToolsPage UI component, tool registry system, and tool configuration management.

## Status

✅ **COMPLETE** - All phases implemented and complete

## Implementation Phases

This plan is divided into two phases:
1. **Phase 1: Storage Implementation** - Data structures, configuration classes, and Config2 integration
2. **Phase 2: UI Implementation** - ToolsPage UI component and user interface

## Related Plans

- **1.3** - Configuration Overview
- **1.3.1** - Configuration Classes
- **1.3.2** - Configuration Interface
- **1.4** - Client Configuration Setup (uses client connections for tool setup)

---

# Phase 1: Storage Implementation

## Overview

Implement the data structures, configuration classes, and storage system for tool configurations. This phase focuses on the backend storage and data model, without any UI components.

## Status

✅ **COMPLETE** - All storage implementation tasks completed

## Goals

- ✅ Create configuration classes for tools (BaseToolConfig, CodebaseSearchToolConfig, GoogleSearchToolConfig)
- ✅ Add `tools` map to Config2 for storing tool configurations
- ✅ Implement auto-population: Auto-fill tool configs from `usage` map if they don't exist in `tools` map
- ✅ Ensure all configuration classes implement Json.Serializable for persistence
- ✅ Update tool system files to use new configuration structure with unified tool registration

## Configuration Classes

**Important**: All configuration classes must use GObject properties (not plain fields) with proper source attributes for property metadata. This is required for Phase 2 UI generation via property introspection.

**Property Metadata Requirements**:
- Properties must be GObject properties with `get` and `set` accessors
- Properties should use `[Description(nick = "...", blurb = "...")]` source attributes
- `nick` provides short label text for UI
- `blurb` provides description/tooltip text for UI
- Property types determine widget types in Phase 2

### BaseToolConfig (Base Tool Configuration Class)
- **Location**: `libollmchat/Settings/BaseToolConfig.vala`
- **Purpose**: Base configuration class for simple tools that only need enabled/disabled
- **Properties**:
  - `enabled` (bool) - Whether tool is enabled (default: true)
    - Must be GObject property with `[Description(nick = "enabled", blurb = "Whether the tool is enabled")]`
- **Usage**: For simple tools like ReadFile, EditFile, WebFetch that don't need complex configuration
- **Note**: Implements Json.Serializable for persistence
- **Note**: All properties must be GObject properties with proper metadata for Phase 2 UI generation

### GoogleSearchToolConfig (Tool-Specific Configuration Class)
- **Location**: `libollmchat/Settings/GoogleSearchToolConfig.vala` (or in tool-specific location)
- **Purpose**: Tool-specific configuration for Google search tool
- **Extends**: BaseToolConfig
- **Properties**:
  - `enabled` (bool) - Inherited from BaseToolConfig
  - `api_key` (string) - Google Custom Search API key
    - Must be GObject property with proper metadata
  - `engine_id` (string) - Google Custom Search Engine ID (CSID)
    - Must be GObject property with proper metadata
- **Usage**: For Google search tool configuration (tool name: `google_search`)
- **Migration**: Currently uses `GoogleSearchConfig` loaded from `~/.config/ollmchat/google.json`, needs moving to `Config2.tools["google_search"]` with GoogleSearchToolConfig
- **Note**: All properties must be GObject properties with proper metadata for Phase 2 UI generation

### CodebaseSearchToolConfig (Tool-Specific Configuration Class)
- **Location**: `libocvector/Tool/CodebaseSearchToolConfig.vala` (or in libollmchat/Settings/)
- **Purpose**: Tool-specific configuration for codebase search with multiple model usages
- **Extends**: BaseToolConfig
- **Properties**:
  - `enabled` (bool) - Inherited from BaseToolConfig
  - `embed` (ModelUsage) - Embedding model configuration (connection, model, options)
    - Must be GObject property with proper metadata
    - Nested ModelUsage properties will be introspected recursively in Phase 2
  - `analysis` (ModelUsage) - Analysis model configuration (connection, model, options)
    - Must be GObject property with proper metadata
    - Nested ModelUsage properties will be introspected recursively in Phase 2
- **Usage**: For codebase search tool which needs two model configurations (embed and analysis)
- **Auto-Population**: If `Config2.tools["codebase_search"]` doesn't exist, auto-populate from `Config2.usage["ocvector.embed"]` and `Config2.usage["ocvector.analysis"]`
- **Tool Registration**: Will use unified single tool registration instead of split embed/analysis registration
- **Note**: All properties must be GObject properties with proper metadata for Phase 2 UI generation

## Config2 Storage Structure

### New `tools` Map in Config2
- Add `tools` map to Config2: `Gee.Map<string, BaseToolConfig>`
- Follows same pattern as `model_options` map
- Tool configs stored with tool name as key: `tools["codebase_search"]` → CodebaseSearchToolConfig, `tools["read_file"]` → BaseToolConfig
- Each tool has one configuration entry (not multiple configs per tool)
- Simple tools use BaseToolConfig (just enabled), complex tools use tool-specific configs that extend BaseToolConfig (e.g., CodebaseSearchToolConfig)
- **Tool Object Registration**: Tool objects (`Tool.Interface`) are registered in `Client.tools` (Gee.HashMap<string, Tool.Interface>), also keyed by tool name
  - ToolsPage uses `Client.tools` to get tool objects for displaying tool names, descriptions, and other metadata
  - Tool configs in `Config2.tools` are matched to tool objects in `Client.tools` by tool name (same key)
  - This allows ToolsPage to display tool information (name, description) alongside configuration settings

### Tool Configuration Structure
- New `tools` map in Config2 (similar to `model_options`)
- Tool-specific configs extend BaseToolConfig and add their own properties:
  - Simple tools: Just extend BaseToolConfig (e.g., ReadFile, EditFile, WebFetch)
  - Complex tools: Extend BaseToolConfig and add ModelUsage or other properties (e.g., CodebaseSearchToolConfig)
- Tools that require config:
  - `codebase_search` - Currently in `usage` map, needs moving to `tools` map with CodebaseSearchToolConfig
  - `google_search` - Needs GoogleSearchToolConfig with api_key and engine_id (CSID)
  - Other tools can add tool-specific config classes as needed

### Auto-Population from ModelUsage
- Existing ModelUsage entries in `Config2.usage` map remain (not removed - pointless to remove them):
  - `usage["ocvector.embed"]` → ModelUsage (embedding model)
  - `usage["ocvector.analysis"]` → ModelUsage (analysis model)
- When loading tool configurations, if tool config doesn't exist in `Config2.tools`, auto-populate from `Config2.usage`:
  - For `codebase_search`: If `tools["codebase_search"]` doesn't exist, create CodebaseSearchToolConfig and populate:
    - `embed` property from `usage["ocvector.embed"]` if it exists
    - `analysis` property from `usage["ocvector.analysis"]` if it exists
  - Similar auto-population can be done for other tools that have ModelUsage entries in usage map
- **Tool Registration**: Codebase search tool registration will be unified:
  - Currently: Split registration for embed and analysis separately
  - New: Single tool registration (`codebase_search`) that sets up both embed and analysis model+options from CodebaseSearchToolConfig
  - The unified registration reads from `tools["codebase_search"]` (or auto-populates from usage map if not present)

### Tool Model Configuration vs. Global Model Options
- Tool model configuration (e.g., ModelUsage properties in CodebaseSearchToolConfig) is separate from global model options
- Tool configs use their own model/options for tool-specific operations (e.g., embeddings, analysis)
- Global model options (Config2.model_options) are per-model option overrides for chat operations
- Clear separation: tool configs in `tools` map, model options in `model_options` map
- When a tool needs model options, it uses its own ModelUsage properties (e.g., embed/analysis in CodebaseSearchToolConfig), not Config2.model_options

## Tool-Specific Configurations

### Codebase Search Tool (Multiple Model Usages)
- **Current State**: Uses two separate ModelUsage entries in `Config2.usage` map:
  - `usage["ocvector.embed"]` → ModelUsage (embedding model)
  - `usage["ocvector.analysis"]` → ModelUsage (analysis model)
  - These entries remain in the usage map (not removed - pointless to remove them)
- **New State**: Single CodebaseSearchToolConfig in `Config2.tools["codebase_search"]` with sub-settings:
  - `embed` (ModelUsage) - Embedding model configuration
  - `analysis` (ModelUsage) - Analysis model configuration
- **Auto-Population**: If `Config2.tools["codebase_search"]` doesn't exist, auto-populate from existing usage map entries:
  - Create CodebaseSearchToolConfig
  - Populate `embed` from `usage["ocvector.embed"]` if it exists
  - Populate `analysis` from `usage["ocvector.analysis"]` if it exists
- **Configuration Properties**:
  - `enabled` (bool) - Whether tool is enabled
  - `embed` (ModelUsage) - Embedding model config (connection, model, options)
    - Connection for embedding model
    - Model name (e.g., "bge-m3:latest")
    - Options (temperature: 0.0, num_ctx: 2048, etc.)
  - `analysis` (ModelUsage) - Analysis model config (connection, model, options)
    - Connection for analysis model
    - Model name (e.g., "qwen3-coder:30b")
    - Options (temperature: 0.0, etc.)
- **Tool Registration**: Unified single tool registration
  - Currently: Split registration for embed and analysis separately
  - New: Single `codebase_search` tool registration that sets up both embed and analysis model+options from CodebaseSearchToolConfig
  - The unified registration reads from `tools["codebase_search"]` (or uses auto-populated version)

### File Tools (Simple Config - BaseToolConfig)
- **Read File**: 
  - Uses `BaseToolConfig` (just enabled/disabled)
  - Simple tool, no complex configuration needed
- **Edit File**: 
  - Uses `BaseToolConfig` (just enabled/disabled)
  - Simple tool, no complex configuration needed
- **Note**: Future enhancements could add properties like max_file_size, allowed_extensions, backup_settings, but for now just enabled/disabled

### Terminal Command Tool
- **Working Directory**: Default directory
- **Allowed Commands**: Whitelist/blacklist
- **Timeout Settings**: Command execution timeout

### Google Search Tool
- **Configuration Properties**:
  - `enabled` (bool) - Whether tool is enabled (inherited from BaseToolConfig)
  - `api_key` (string) - Google Custom Search API key
  - `engine_id` (string) - Google Custom Search Engine ID (CSID)
- **Storage**: Stored in `Config2.tools["google_search"]` with GoogleSearchToolConfig
- **Migration**: Currently uses `GoogleSearchConfig` loaded from `~/.config/ollmchat/google.json`, needs moving to unified settings system

### Web Fetch Tool (Simple Config - BaseToolConfig)
- **Configuration Properties**:
  - `enabled` (bool) - Whether tool is enabled
- **Storage**: Stored in `Config2.tools["web_fetch"]` with BaseToolConfig
- **Note**: Simple tool, just needs enabled/disabled. Future enhancements could add timeout, max_response_size, but for now just enabled/disabled

## Files to Create (Phase 1)

### Configuration Classes
- `libollmchat/Settings/BaseToolConfig.vala` - Base tool configuration class for simple tools
  - Just has `enabled` property
  - For tools like ReadFile, EditFile, WebFetch
  - Implements Json.Serializable
  - All properties must be GObject properties with proper metadata
- `libocvector/Tool/CodebaseSearchToolConfig.vala` - Tool-specific configuration for codebase search
  - Extends BaseToolConfig
  - Has `embed` (ModelUsage) and `analysis` (ModelUsage) as sub-settings
  - For codebase search tool which needs two model configurations
  - Implements Json.Serializable
  - All properties must be GObject properties with proper metadata
- `libollmchat/Settings/GoogleSearchToolConfig.vala` - Tool-specific configuration for Google search
  - Extends BaseToolConfig
  - Has api_key and engine_id properties
  - For Google search tool configuration (tool name: `google_search`)
  - Implements Json.Serializable
  - All properties must be GObject properties with proper metadata
  - Migration: Replaces current `GoogleSearchConfig` loaded from `~/.config/ollmchat/google.json`

## Files to Modify (Phase 1)

### Config2
- `libollmchat/Settings/Config2.vala` - Add `tools` map
  - Add `public Gee.Map<string, BaseToolConfig> tools { get; set; }`
  - Similar to `model_options` map structure
  - Can store BaseToolConfig or tool-specific configs that extend BaseToolConfig (like CodebaseSearchToolConfig)
  - Support type registration for `tools` map (similar to `usage` map)
    - Tools register their config types using `Config2.register_type(tool_name, typeof(ToolConfig))`
    - For example: `Config2.register_type("codebase_search", typeof(CodebaseSearchToolConfig))`
    - This allows Config2 to deserialize tool configs from JSON using the registered types

### Tool System Files
- `libollmchat/Client.vala` - Tool registration and management
- `libollmchat/Call/Chat.vala` - Tool configuration per chat
- `libollmchat/Tool/Interface.vala` - Add configuration interface for tools
  - Add configuration validation methods
- `ollmchat/Window.vala` - Add tools to Client
  - Window is responsible for adding tools to Client via `client.addTool(Tool.Interface)`
  - Tools are added based on settings and availability
  - Window calls tool's `register_config()` method before loading config to ensure config types are registered

### Tool Registration and Auto-Population Files
- `libocvector/Database.vala` - Update codebase search tool registration
  - Implement auto-population: If `Config2.tools["codebase_search"]` doesn't exist, create CodebaseSearchToolConfig and populate from `Config2.usage["ocvector.embed"]` and `Config2.usage["ocvector.analysis"]`
  - Update to use CodebaseSearchToolConfig from `Config2.tools["codebase_search"]` (or auto-populated version)
  - Update `setup_embed_usage()` and related methods to read from CodebaseSearchToolConfig
  - **Unified Tool Registration**: Combine split embed/analysis registration into single `codebase_search` tool registration
    - Single registration reads both embed and analysis from CodebaseSearchToolConfig
    - Sets up both model+options from the unified config
- `libocvector/Indexing/Analysis.vala` - Update analysis config usage
  - Update `setup_analysis_usage()` to work with CodebaseSearchToolConfig from `Config2.tools["codebase_search"]`
  - Remove separate registration of "ocvector.analysis" (now part of unified codebase_search registration)
- `libocvector/Tool/CodebaseSearchTool.vala` - Add unified config registration method
  - Add `register_config()` static method that registers tool config type with Config2
  - Registers `CodebaseSearchToolConfig` type for `tools["codebase_search"]` key using `Config2.register_type("codebase_search", typeof(CodebaseSearchToolConfig))`
  - This is the tool's responsibility - tools register their own config options
  - This replaces the need to call `Database.register_config()` and `Analysis.register_config()` separately
  - The unified method registers config for the tool (CodebaseSearchToolConfig) and any dependencies
- `examples/oc-vector-index.vala` - Update to use unified tool config registration
  - Replace calls to `OLLMvector.Database.register_config()` and `OLLMvector.Indexing.Analysis.register_config()`
  - Call `OLLMvector.Tool.CodebaseSearchTool.register_config()` instead
- `examples/oc-vector-search.vala` - Update to use unified tool config registration
  - Replace calls to `OLLMvector.Database.register_config()` and `OLLMvector.Indexing.Analysis.register_config()`
  - Call `OLLMvector.Tool.CodebaseSearchTool.register_config()` instead
- `ollmchat/Application.vala` - Update to use unified tool config registration
  - Replace calls to `OLLMvector.Database.register_config()` and `OLLMvector.Indexing.Analysis.register_config()`
  - Call `OLLMvector.Tool.CodebaseSearchTool.register_config()` instead
- `liboctools/GoogleSearchRequest.vala` - Migrate Google search config
  - Move from `GoogleSearchConfig.load()` (from `~/.config/ollmchat/google.json`) to `Config2.tools["google_search"]`
  - Update to use GoogleSearchToolConfig from Config2 instead of loading from file
  - Remove dependency on standalone `google.json` config file

## Config2 Structure (Phase 1)

**New `tools` Map in Config2**:
```json
{
  "tools": {
    "read_file": {
      "enabled": true
    },
    "edit_file": {
      "enabled": true
    },
    "codebase_search": {
      "enabled": true,
      "embed": {
        "connection": "http://127.0.0.1:11434/api",
        "model": "bge-m3:latest",
        "options": {
          "temperature": 0.0,
          "num_ctx": 2048
        }
      },
      "analysis": {
        "connection": "http://127.0.0.1:11434/api",
        "model": "qwen3-coder:30b",
        "options": {
          "temperature": 0.0
        }
      }
    },
    "google_search": {
      "enabled": true,
      "api_key": "",
      "engine_id": ""
    },
    "web_fetch": {
      "enabled": true
    }
  }
}
```

**Tool Config Types**:
- **Simple Tools** (BaseToolConfig): `read_file`, `edit_file`, `web_fetch` - Just enabled/disabled
- **Complex Tools** (Tool-Specific Config): `codebase_search` (CodebaseSearchToolConfig) - Needs multiple model configurations (embed + analysis)

---

# Phase 2: UI Implementation

## Overview

Implement the ToolsPage UI component for the Settings dialog. This phase focuses on the user interface for viewing and editing tool configurations, building on the storage system implemented in Phase 1.

## Status

✅ **COMPLETE** - All UI implementation tasks completed

## Goals

- ✅ Create ToolsPage UI component
- ✅ Implement tool list display
- ✅ Implement tool configuration panels using Adw.ExpanderRow
- ✅ Create reusable ModelUsage editor component
- ✅ Generate dynamic UI for tool-specific settings via property introspection
- ✅ Integrate with Config2.tools map for persistence

## Tools Tab UI

**Purpose**: Configure tools, set up models for tools, manage tool-specific settings.

**Components**:
- **Adw.PreferencesGroup**: Contains the tool list
  - Wraps tool list for consistent styling (same pattern as ConnectionsPage and ModelsPage)
  - Uses `Gtk.Box` (not `Adw.BoxedList`) for the tool list container
- **Tool List**: Uses `Gtk.Box` to display all registered tools
  - Shows: tool name, enabled status, description
  - Each tool uses `Adw.ExpanderRow` to show/edit tool configuration
  - Each tool has one configuration entry (not multiple configs per tool)
- **Tool Configuration Panel**: Uses `Adw.ExpanderRow` - when a tool row is expanded
  - **All tool panels are generated by introspecting the config object**
  - Settings widgets are added as children to the `Adw.ExpanderRow` using `add_row()`
  - Property introspection automatically discovers all configurable properties
  - No distinction between "simple" and "complex" tools - all handled the same way
  - For example, CodebaseSearchToolConfig will show:
    - Enabled: Checkbox (from BaseToolConfig.enabled)
    - Embed: ModelUsage editor (from CodebaseSearchToolConfig.embed property)
    - Analysis: ModelUsage editor (from CodebaseSearchToolConfig.analysis property)
  - For BaseToolConfig, only the `enabled` property will be shown
  - UI is generated automatically based on property types and metadata

**Data Sources**:
- Tool registry: `Client.tools` (Gee.HashMap<string, Tool.Interface>)
  - Contains tool objects with name, description, and other metadata
  - ToolsPage uses this to display tool names and descriptions in the UI
  - Tool objects are registered via `Client.addTool()` method
- Tool configurations: `Config2.tools` (Gee.Map<string, BaseToolConfig>)
  - Tool configs stored with tool name as key: `tools["codebase_search"]` → CodebaseSearchToolConfig, `tools["read_file"]` → BaseToolConfig
  - Each tool has one configuration entry (not multiple configs per tool)
  - Simple tools use BaseToolConfig, complex tools use tool-specific configs extending BaseToolConfig
  - Tool configs are matched to tool objects by tool name (same key in both maps)

## Property Introspection-Based UI Generation

**Approach**: Use GObject property introspection (pspec, blurb, nick) from source attributes to automatically generate UI.

**Key Principles**:
- Configuration classes must use GObject properties with proper source attributes
- Properties should have `nick` (short name), `blurb` (description), and appropriate `pspec` metadata
- ToolsPage introspects configuration objects to discover all properties
- UI widgets are generated automatically based on property types and metadata
- All configuration is rendered on load
- Tools are automatically added to UI if they're not already present

**Property Metadata Requirements**:
- All configuration properties must be GObject properties (not plain fields)
- Properties should use source attributes for metadata:
  ```vala
  [Description(nick = "enabled", blurb = "Whether the tool is enabled")]
  public bool enabled { get; set; }
  ```
- Property types determine widget types:
  - `bool` → `Adw.SwitchRow` or checkbox
  - `string` → `Adw.EntryRow` or text entry
    - **Special case**: If property name is `"connection"`, show dropdown/list of connections from `Config2.connections`
    - **Special case**: If property name is `"model"`, show dropdown/list of models from the selected connection
  - `ModelUsage` → Reusable ModelUsage editor component
  - `Call.Options` → Reuse existing options widget (already built for model options)
    - Contains int properties: `seed`, `top_k`, `num_predict`, `num_ctx`
    - Contains double properties: `temperature`, `top_p`, `min_p`
    - Contains string properties: `stop`
    - All handled by the existing options widget - no need to handle int/double types directly
  - Complex objects → Recursive introspection

**UI Generation Process**:
1. On load, ToolsPage queries `Client.tools` registry to discover all available tools (Tool.Interface objects)
2. For each tool in `Client.tools`:
   - Get tool object to access name, description, and other metadata for display
   - Get configuration from `Config2.tools` map using tool name as key
   - Tool configs should already exist (created by tool registration code, which handles auto-population from usage map if needed)
   - If config doesn't exist, skip that tool or show a message (configs are created by tool registration, not UI)
3. For each tool, create `Adw.ExpanderRow` with:
   - Tool name from `Tool.Interface.name` property
   - Tool description from `Tool.Interface.description` property
4. Introspect the configuration object's GObject class to get all properties
5. For each property in the config:
   - Get property spec (pspec) to determine type
   - Get property name to check for special cases
   - Get `nick` for label text
   - Get `blurb` for description/tooltip
   - Switch case on property type and name to instantiate appropriate config widget class:
     - `bool` → `new ConfigBool(pspec, config)` - creates switch/checkbox widget
     - `string` with name `"connection"` → `new ConfigConnection(pspec, config)` - creates connection dropdown
     - `string` with name `"model"` → `new ConfigModel(pspec, config)` - creates model dropdown
     - `string` (other) → `new ConfigString(pspec, config)` - creates text entry
     - `ModelUsage` → `new ConfigModelUsage(pspec, config)` - creates ModelUsage editor
     - `Call.Options` → `new ConfigOptions(pspec, config)` - reuses existing options widget
   - Each config widget class handles widget creation and property binding internally
6. Add generated widgets to `Adw.ExpanderRow` using `add_row()`
7. If a tool is registered in `Client.tools` but not in UI, automatically add it

**Special Handling** (implemented by config widget classes):
- **Property Name "connection"**: `ConfigConnection` class handles connection dropdown
  - Gets available connections from `Config2.connections` map
  - Populates dropdown with connection URLs (keys from connections map)
  - Display format can show connection name if available (e.g., "name (url)" or just "url")
  - Used in ModelUsage properties (e.g., ModelUsage.connection)
- **Property Name "model"**: `ConfigModel` class handles model dropdown
  - Gets available models from the connection selected in the parent context (e.g., from ModelUsage.connection)
  - Populates dropdown with models available from that connection
  - If property is within a ModelUsage, uses the connection from that ModelUsage
- **Property Type Call.Options**: `ConfigOptions` class reuses existing options widget
  - The options widget is already built for model options (used in ModelsPage)
  - Reuses the same widget component for options properties within tool configs
  - This handles options within ModelUsage properties (e.g., ModelUsage.options)
- **Property Type ModelUsage**: `ConfigModelUsage` class uses reusable ModelUsage editor component (same as used in ModelsPage)
  - This handles nested ModelUsage properties like `embed` and `analysis` in CodebaseSearchToolConfig
  - ModelUsage editor includes connection dropdown, model dropdown, and options widget
- **Complex Nested Objects**: Config widget classes handle recursive introspection (e.g., `Call.Options` within ModelUsage)
- **Property Visibility**: Can use property flags or metadata to hide certain properties from UI if needed

**Benefits**:
- No manual UI code needed for each tool configuration
- Automatic UI generation based on property definitions
- Consistent UI across all tools
- Easy to add new tool properties - just add property with metadata
- Type-safe property binding using GObject property system

## Files to Create (Phase 2)

### Config Widget Classes
- `ollmchat/Settings/ConfigWidget/ConfigItemWidget.vala` - Base class for all config widget classes
  - Abstract base class that all config widget classes extend
  - Contains generic functionality:
    - Property binding to config object
    - Getting `nick` and `blurb` from pspec for labels/descriptions
    - Common widget setup and initialization
    - Abstract method for creating the specific widget type
- `ollmchat/Settings/ConfigWidget/ConfigBool.vala` - Widget class for bool properties
  - Extends `ConfigItemWidget`
  - Creates `Adw.SwitchRow` or checkbox widget
- `ollmchat/Settings/ConfigWidget/ConfigString.vala` - Widget class for string properties
  - Extends `ConfigItemWidget`
  - Creates `Adw.EntryRow` or text entry widget
- `ollmchat/Settings/ConfigWidget/ConfigConnection.vala` - Widget class for connection properties
  - Extends `ConfigItemWidget`
  - Creates connection dropdown widget
  - Populates dropdown from `Config2.connections` map
- `ollmchat/Settings/ConfigWidget/ConfigModel.vala` - Widget class for model properties
  - Extends `ConfigItemWidget`
  - Creates model dropdown widget
  - Gets available models from the selected connection
- `ollmchat/Settings/ConfigWidget/ConfigModelUsage.vala` - Widget class for ModelUsage properties
  - Extends `ConfigItemWidget`
  - Creates ModelUsage editor widget (reusable component)
  - Handles nested properties (connection, model, options)
- `ollmchat/Settings/ConfigWidget/ConfigOptions.vala` - Widget class for Call.Options properties
  - Extends `ConfigItemWidget`
  - Reuses existing options widget (from ModelsPage)

### UI Components
- `ollmchat/Settings/ToolsPage.vala` - Tools tab content
  - **UI Framework**: Uses `SettingsPage` base class (same pattern as ConnectionsPage and ModelsPage):
    - `Adw.PreferencesGroup` wrapping tool list (same pattern as other pages)
    - Uses `Gtk.Box` (not `Adw.BoxedList`) for tool list container
    - Tool rows use `Adw.ExpanderRow` for expandable configuration panels
    - Settings widgets added to `Adw.ExpanderRow` via `add_row()` method
    - All tool configuration panels are generated by introspecting the config object
    - See [Adw.ExpanderRow documentation](https://valadoc.org/libadwaita-1/Adw.ExpanderRow.html)
  - **Properties**:
    - `settings_dialog` (SettingsDialog) - Reference to parent SettingsDialog (which has the config object)
    - `client` (Client) - Reference to Client instance to access `Client.tools` registry for tool objects
    - `selected_tool` (string?) - Currently selected tool name
  - **Methods**:
    - `load_tools()` - Load all tools from `Client.tools` registry and render their configurations
      - Iterates through `Client.tools` to get Tool.Interface objects
      - For each tool, gets config from `Config2.tools` using tool name as key
      - Creates UI rows with tool name/description from Tool.Interface and config from Config2.tools
    - `get_tool_config(string tool_name)` - Get configuration for a tool from `Config2.tools`
      - Returns the config if it exists, or null if not found
      - Tool configs should be created by tool registration code, not by UI code
    - `create_tool_row(Tool.Interface tool, BaseToolConfig config)` - Create Adw.ExpanderRow for a tool with all its configuration widgets
      - Uses `tool.name` and `tool.description` from Tool.Interface for display
      - Uses `config` for property introspection and UI generation
    - `introspect_config_properties(BaseToolConfig config)` - Introspect GObject properties of config object
    - `create_property_widget(ParamSpec pspec, BaseToolConfig config)` - Generate UI widget for a property based on its pspec
      - Switch case on property type and name to instantiate appropriate config widget class (all extend `ConfigItemWidget`):
        - `bool` → `new ConfigBool(pspec, config)`
        - `string` with name `"connection"` → `new ConfigConnection(pspec, config)`
        - `string` with name `"model"` → `new ConfigModel(pspec, config)`
        - `string` (other) → `new ConfigString(pspec, config)`
        - `ModelUsage` → `new ConfigModelUsage(pspec, config)`
        - `Call.Options` → `new ConfigOptions(pspec, config)`
      - Each config widget class extends `ConfigItemWidget` and handles creating the appropriate UI widget
      - `ConfigItemWidget` base class handles property binding, getting nick/blurb from pspec, and other generic functionality
    - `add_tool_if_missing(Tool tool)` - Add tool to UI if it's not already present
    - Note: Tools are auto-discovered from Client registry on load
    - Note: All configuration is rendered on load
    - Note: Tools are automatically added to UI if they're registered but not present

## Files to Modify (Phase 2)

### Configuration Classes (Phase 1 - Ensure Property Metadata)
- `libollmchat/Settings/BaseToolConfig.vala` - Ensure all properties have proper GObject property metadata
  - Properties must use source attributes: `[Description(nick = "...", blurb = "...")]`
  - Properties must be GObject properties (not plain fields)
- `libocvector/Tool/CodebaseSearchToolConfig.vala` - Ensure all properties have proper GObject property metadata
  - Properties must use source attributes with nick and blurb
  - Nested ModelUsage properties (`embed`, `analysis`) should also have proper metadata
- `libollmchat/Settings/GoogleSearchToolConfig.vala` - Ensure all properties have proper GObject property metadata
  - Properties must use source attributes with nick and blurb

### Settings Dialog
- `ollmchat/Settings/SettingsDialog.vala` - Add ToolsPage to settings dialog
  - Add ToolsPage as a new tab/page in the settings dialog
  - Connect ToolsPage to Config2 instance
  - Ensure ToolsPage has access to Client instance for tool registry

## Integration Points (Phase 2)

- **Config2**: All settings stored in Config2 (connections, model_options, tools)
  - Tool configs stored in `tools` map with tool name as key: `tools["codebase_search"]` → CodebaseSearchToolConfig, `tools["read_file"]` → BaseToolConfig
  - Each tool has one configuration entry (not multiple configs per tool)
  - Simple tools use BaseToolConfig (just enabled)
  - Complex tools use tool-specific configs extending BaseToolConfig (e.g., CodebaseSearchToolConfig with embed and analysis sub-settings)
- **Client**: Used for fetching models, testing connections, tool registry
  - `Client.tools` (Gee.HashMap<string, Tool.Interface>) provides tool registry for discovering available tools
  - Tool objects contain name, description, and other metadata
  - Tools are registered via `Client.addTool(Tool.Interface)` method
- **Tool Registry**: Access via `Client.tools` (Gee.HashMap<string, Tool.Interface>)
  - ToolsPage queries `Client.tools` on load to discover all tools and get tool objects
  - Tool objects are matched to configs in `Config2.tools` by tool name (same key)
  - ToolsPage uses tool objects for display (name, description) and configs for settings
  - Automatically adds tools to UI if they're registered in `Client.tools` but not present
- **GObject Property Introspection**: Core mechanism for UI generation
  - ToolsPage uses `ObjectClass.list_properties()` to discover all properties
  - Property metadata (nick, blurb, pspec) drives UI generation
  - Property types determine widget types automatically
- **BaseToolConfig**: Base class for simple tools (just enabled/disabled) - created in Phase 1
  - Must have GObject properties with proper metadata
- **CodebaseSearchToolConfig**: Tool-specific class for codebase search (has embed and analysis ModelUsage sub-settings) - created in Phase 1
  - Must have GObject properties with proper metadata
  - Nested ModelUsage properties are handled recursively
- **ModelUsage**: Used as sub-settings within tool configs (e.g., embed and analysis in CodebaseSearchToolConfig)
  - Reusable ModelUsage editor component handles nested ModelUsage properties
- **Call.Options**: Used for model options in ModelUsage sub-settings
  - Handled recursively through property introspection

## Completion Summary

✅ **All phases complete** - The Tools Page and Management system has been fully implemented:
- Phase 1: All storage implementation tasks completed (BaseToolConfig, CodebaseSearchToolConfig, GoogleSearchToolConfig, Config2.tools map, auto-population)
- Phase 2: All UI implementation tasks completed (ToolsPage component, property introspection-based UI generation, tool configuration panels)

## Future Considerations

- **Tool Plugin System**: Support for loading external tools
- **Tool Marketplace**: Repository of community tools
- **Tool Development**: API for creating custom tools

