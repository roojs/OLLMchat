# Vector Storage Architecture: What Goes Where

## Overview

The vector indexing system uses **two separate storage systems** with distinct purposes:

1. **FAISS** - Stores only vector embeddings (arrays of floats)
2. **SQL Database** - Stores metadata mapping vector IDs to code locations

## Storage Breakdown

### FAISS Vector Index (`libocvector/Index.vala`)

**What it stores:**
- **ONLY** vector embeddings (arrays of floats, typically 768 dimensions)
- Vector IDs (sequential integers: 0, 1, 2, 3, ...)

**What it does:**
- Fast similarity search (finds nearest vectors to a query vector)
- Returns: `(vector_id, similarity_score, rank)`

**What it CANNOT do:**
- ❌ Cannot tell you what code a vector represents
- ❌ Cannot tell you file path, line numbers, or element info
- ❌ Cannot store text, metadata, or any structured data

**Example FAISS search result:**
```vala
SearchResult {
    document_id = 42,           // Just a number - meaningless without metadata
    similarity_score = 0.87,
    rank = 1
}
```

### SQL Database (`libocsqlite`)

**What it stores:**
- **Metadata mapping** from vector_id → code location
- **Required fields:**
  - `vector_id` - Links to FAISS vector ID
  - `file_id` - Foreign key to OLLMfiles.File.id
  - `start_line`, `end_line` - Line range to read code snippet
  - `element_type`, `element_name` - For display/filtering

**What it does:**
- **Core function**: Fast lookup for LLM tool search results:
  ```sql
  SELECT vm.vector_id, vm.file_id, vm.start_line, vm.end_line,
         vm.element_type, vm.element_name, f.path
  FROM vector_metadata vm
  JOIN files f ON vm.file_id = f.id
  WHERE vm.vector_id = 42
  ```
- Enables result display: "This vector represents `DatabaseManager.execute_query()` at lines 85-105 in `/path/to/database.vala`"

## Why This Architecture?

### The Problem FAISS Solves
FAISS is **extremely fast** at finding similar vectors. It uses optimized algorithms (GPU support, approximate nearest neighbor) that would be impossible to replicate in SQL.

### The Problem SQL Solves
After FAISS finds similar vectors, you get back:
```
vector_id = 42, similarity = 0.87
```

But you need to show the user:
```
Found: DatabaseManager.execute_query() 
File: /home/user/project/src/database.vala
Lines: 85-105
```

**SQL provides the lookup** from vector_id → human-readable code location.

## Data Flow

### Indexing Flow:
```
1. Code Element (CodeElement object)
   ↓
2. Format as text document (VectorBuilder)
   ↓
3. Generate embedding via Ollama API → float[768]
   ↓
4. Store vector in FAISS → gets vector_id (e.g., 42)
   ↓
5. Store metadata in SQL:
   INSERT INTO vector_metadata (vector_id, file_id, start_line, end_line, element_type, element_name)
   VALUES (42, 123, 85, 105, 'method', 'execute_query');
   -- vector_id=42, file_id=123 (from OLLMfiles.File.id), start_line=85, end_line=105, element_type='method', element_name='execute_query'
```

### Search Flow:
```
1. User query: "database connection"
   ↓
2. Generate query embedding → float[768]
   ↓
3. FAISS search → returns [(vector_id=42, score=0.87), (vector_id=15, score=0.82), ...]
   ↓
4. SQL lookup for each vector_id (minimal query):
   SELECT vm.vector_id, vm.file_id, vm.start_line, vm.end_line,
          vm.element_type, vm.element_name, f.path
   FROM vector_metadata vm
   JOIN files f ON vm.file_id = f.id
   WHERE vm.vector_id IN (42, 15, ...)
   ↓
5. Read code snippets from filesystem using f.path + start_line/end_line
   ↓
6. Return formatted results to user
```

## What is NOT Stored

### ❌ NOT in FAISS:
- File paths
- Line numbers
- Element names
- Code snippets
- Any text or metadata

### ❌ NOT in SQL:
- Vector embeddings (too large, not queryable)
- Full code snippets (read from filesystem when needed)
- Original document text (read from filesystem when needed)

### ✅ Stored in Filesystem:
- Original source code files (always current)
- Code snippets read on-demand for result display

## Value of SQL Metadata Storage

### 1. **Result Display**
Without SQL metadata, search results would be useless:
```
❌ Without SQL: "Found vector 42 with similarity 0.87"
✅ With SQL: "Found DatabaseManager.execute_query() at database.vala:85-105"
```

### 2. **Incremental Updates**
SQL enables efficient updates:
```sql
-- Find all vectors for a file that needs re-indexing (by file_id)
SELECT vector_id FROM vector_metadata WHERE file_id = 123;

-- Or by path using join
SELECT vm.vector_id FROM vector_metadata vm
JOIN files f ON vm.file_id = f.id
WHERE f.path = '/path/to/file.vala';

-- Delete old vectors from FAISS
-- Re-index file
-- Insert new vectors with new IDs
```

### 3. **Query Capabilities**
SQL enables rich queries:
```sql
-- Core query: Lookup metadata for search results (what LLM tool needs)
SELECT vm.vector_id, vm.file_id, vm.start_line, vm.end_line, 
       vm.element_type, vm.element_name, f.path
FROM vector_metadata vm
JOIN files f ON vm.file_id = f.id
WHERE vm.vector_id IN (42, 15, 8);

-- Find all classes indexed (for filtering)
SELECT * FROM vector_metadata WHERE element_type = 'class';

-- Find vectors for files matching a path pattern
SELECT vm.*, f.path, f.mtime FROM vector_metadata vm
JOIN files f ON vm.file_id = f.id
WHERE f.path LIKE '%database%';
```

### 4. **Change Detection**
Link with `OLLMfiles.File.mtime`:
```sql
-- Find vectors that need re-indexing (file changed)
-- Note: Would need timestamp field for this, add later if incremental updates needed
SELECT vm.vector_id FROM vector_metadata vm
JOIN files f ON vm.file_id = f.id
WHERE f.mtime > ?;  -- Compare against last indexing time (stored elsewhere or passed as parameter)
```

## Current Implementation Status

### ✅ Implemented:
- FAISS vector storage (`libocvector/Index.vala`)
- Ollama embeddings API integration
- Basic vector search

### ❌ Missing:
- SQL database schema for metadata
- SQL insert/select methods in `Database.vala`
- Metadata lookup after search
- Integration with `libocsqlite`

## Proposed SQL Schema

For the LLM tool use case, the required fields are:

```sql
CREATE TABLE vector_metadata (
    vector_id INTEGER PRIMARY KEY,       -- Links to FAISS vector ID
    file_id INTEGER NOT NULL,            -- Foreign key to OLLMfiles.File.id
    start_line INTEGER NOT NULL,          -- Starting line number (1-indexed)
    end_line INTEGER NOT NULL,           -- Ending line number (1-indexed)
    element_type TEXT NOT NULL,          -- "class", "method", "function", etc. (for filtering/display)
    element_name TEXT NOT NULL,          -- Name of element (for display)
    FOREIGN KEY (file_id) REFERENCES files(id)
);

CREATE INDEX idx_vector_metadata_file_id ON vector_metadata(file_id);
CREATE INDEX idx_vector_metadata_vector_id ON vector_metadata(vector_id);
```

**Why this schema:**
- `vector_id` → links to FAISS result
- `file_id` → join to `files` table to get `path` (for reading code snippet)
- `start_line`, `end_line` → read code snippet from file
- `element_type`, `element_name` → display in results

**What we don't store (and why):**
- ❌ `file_path` - Can get via join to `files` table
- ❌ `signature` - Already in code snippet (read from file)
- ❌ `description` - Already in vectorized text, code snippet shows what it does
- ❌ `timestamp` - Only needed for incremental updates (add later if needed)

**Core query for LLM tool:**
```sql
SELECT vm.vector_id, vm.file_id, vm.start_line, vm.end_line,
       vm.element_type, vm.element_name, f.path
FROM vector_metadata vm
JOIN files f ON vm.file_id = f.id
WHERE vm.vector_id IN (?, ?, ?);  -- vector_ids from FAISS search
```

## Summary

| Storage | What It Stores | Purpose | Query Type |
|---------|----------------|----------|------------|
| **FAISS** | Vector embeddings (float arrays) | Fast similarity search | "Find vectors similar to query" |
| **SQL** | Metadata (file_id, lines, element info) | Map vector_id → code location | "What code does vector_id 42 represent?" |
| **Filesystem** | Source code files | Read code snippets on-demand | "Read lines 85-105 from file.vala" |

**The SQL database is essential** because FAISS only returns vector IDs, and you need metadata to make those IDs meaningful to users.

## Schema Summary

**6 fields (all required):**
- `vector_id` (PRIMARY KEY)
- `file_id` (FOREIGN KEY)
- `start_line`, `end_line`
- `element_type`, `element_name`

**Why this is sufficient:**
1. FAISS search returns `vector_id`
2. SQL lookup returns `file_id` + line range + element info
3. Join to `files` table to get `path`
4. Read code snippet from filesystem using `path` + line range
5. Return formatted result to LLM

**Fields we don't need:**
- `file_path` - Get via join
- `signature` - In code snippet
- `description` - In code snippet/vectorized text
- `timestamp` - Add later if incremental updates needed

### What the LLM Tool Returns

The LLM tool returns a **string** that the LLM can use to cite code. Based on the citation format requirements (`startLine:endLine:filepath`), the LLM needs:

**Absolutely Required:**
- **File path** - for citation `filepath`
- **Start line, end line** - for citation `startLine:endLine`
- **Code snippet** - the actual code content (read from filesystem)

**Not Required (but helpful):**
- Element name/type - helps LLM understand context, but not needed for citation
- Description - nice to have, but code snippet is what matters
- Signature - can be extracted from code snippet

**Example LLM tool return format:**
```
Found 3 results for "database connection":

1. DatabaseManager.execute_query (method) - /path/to/database.vala:85-105
```85:105:/path/to/database.vala
public async string? execute_query(string sql, GLib.Cancellable? cancellable = null) throws GLib.Error {
  var conn = yield this.acquire_connection(cancellable);
  return yield conn.execute(sql);
}
```

2. Connection.acquire (method) - /path/to/connection.vala:42-58
```42:58:/path/to/connection.vala
public async Connection? acquire(GLib.Cancellable? cancellable = null) throws GLib.Error {
  // ... connection logic ...
}
```
```

**Key Insight:** The LLM primarily needs the **code snippet with file location**. Element name/type are helpful context but not required. The database only needs to store enough to:
1. Look up the file path (via `file_id` join)
2. Know which lines to read (`start_line`, `end_line`)
3. Optionally provide context (`element_name`, `element_type`)

**So the minimum database schema is correct** - we just need file_id, line range, and element info. The code snippet is read from the filesystem when needed.

### Can the LLM Use the Code with Just the Snippet?

**For functions/methods: YES** - The code snippet with signature is sufficient:
```vala
public async string? execute_query(string sql, GLib.Cancellable? cancellable = null) throws GLib.Error {
  var conn = yield this.acquire_connection(cancellable);
  return yield conn.execute(sql);
}
```

From this snippet, the LLM can extract:
- ✅ Function name: `execute_query`
- ✅ Parameters: `string sql`, `GLib.Cancellable? cancellable = null`
- ✅ Return type: `string?`
- ✅ Access modifier: `public`
- ✅ Async: `async`
- ✅ Exceptions: `throws GLib.Error`

**This is enough to write code that calls it:**
```vala
var result = yield db.execute_query("SELECT * FROM users", null);
```

**For classes: MAYBE** - Depends on what's in the snippet:
- If snippet shows class declaration + all public methods → sufficient
- If snippet only shows class declaration → LLM might need to search for individual methods
- **Solution**: We index each method separately, so LLM can find individual methods

**What's NOT needed from database:**
- ❌ Description - Code snippet usually shows what it does
- ❌ Signature separately - Already in code snippet
- ❌ Parameters list separately - Already in code snippet signature
- ❌ Return type separately - Already in code snippet signature

**Conclusion:** The code snippet with signature is **sufficient** for the LLM to write code that uses the found function/method. Element name/type help with context but aren't strictly required for usage.

### Extended Schema (Optional)
Add these only if you need:
- `file_path` - Path-based queries without joins (rare)
- `signature` - Display signatures without reading file
- `description` - Quick preview without reading file  
- `timestamp` - Incremental updates/change detection

**Recommendation:** Start with minimum schema, add optional fields only when needed.
