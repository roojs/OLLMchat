# 1.3.5.1. Tool Registration and Title Management

## Overview

Improve tool registration system and fix title handling. Currently, tools are registered manually in `Window.vala`, and titles are extracted by splitting tool names or descriptions, which is unreliable. This plan addresses both issues by implementing automatic tool discovery via GType registry and proper title management in tool classes.

## Status

⏳ **TODO** - Not yet implemented

## Implementation Phases

### Phase 1: Constructor Standardization ✅
- ✅ Standardize all tool constructors to: `(Client client, ProjectManager project_manager)`
- ✅ Hardcode `base_directory` in `RunCommand` constructor (home dir)
- ✅ Hardcode `Database` location in `CodebaseSearchTool` constructor
- ✅ Extract `embedding_client` from `client.config` in `CodebaseSearchTool` (remove from constructor)
- ✅ **Make constructors nullable**: 
  - ✅ Base constructor: `protected BaseTool(Client? client = null)` - allows `Object.new(typeof(Class))` to work
    - **Note**: `Tool.BaseTool` is an abstract class (renamed from `Tool.Interface` to avoid confusion with interface concept and `base()` keyword)
    - Constructor is needed for: creating `Function` instance and parsing `parameter_description` (abstract property)
    - Must handle null `client` gracefully (for Phase 1 dummy instances)
  - ✅ Tool constructors: `ReadFile(Client? client = null, ProjectManager? project_manager = null)` - all parameters nullable with defaults
  - ✅ Use `Object.new(typeof(ReadFile))` for Phase 1 (config registration) - no parameters needed, just call `config_class()`
  - ✅ Use `Object.new(typeof(ReadFile), "client", client, "project_manager", project_manager)` for Phase 2 - properties set after construction
  - ✅ Constructors must handle null values gracefully (for Phase 1 dummy instances)

### Phase 2: Add Tool Properties and Methods
- Add `title` abstract property to `Tool.BaseTool` abstract class
- Add `config_class()` abstract method to `Tool.BaseTool` abstract class
- Implement `title` property in all tool classes
- Implement `config_class()` method in all tool classes (returns `typeof(ConfigClass)`)
- Remove static `register_config()` methods from all tool classes

### Phase 3: Implement Tool Discovery
- Add static `discover_classes()` method to `Tool.BaseTool` (GType registry discovery)
- Add static `register_config()` method to `Tool.BaseTool` (Phase 1 registration)
- Add static `register_all_tools()` method to `Tool.BaseTool` (Phase 2 registration)

### Phase 4: Update Application Startup
- Update `Application.vala` to use `Tool.BaseTool.register_config()` before loading config
- Remove individual `register_config()` method calls
- Update `Window.vala` to use `Tool.BaseTool.register_all_tools()` after dependencies ready

### Phase 5: Update UI and Config
- Update `ToolsPage` and `ToolRow` to use `tool.title` from tool registry
- Remove `title` field from `BaseToolConfig`
- Remove title extraction from `setup_tool_config()` methods

### Phase 6: BackgroundScan Integration
- Update `BackgroundScan` constructor to accept `CodebaseSearchTool` instance
- Update `Window.vala` to create `BackgroundScan` using tool instance from registry

## Related Plans

- **1.3.5** - Tools Page and Management
- **2.0** - Tool Infrastructure

---

## Current State

### Tool Registration

Tools are currently registered manually in `Window.vala`:

```vala
this.history_manager.base_client.addTool(
    new OLLMtools.ReadFile(this.history_manager.base_client, this.project_manager));
this.history_manager.base_client.addTool(
    new OLLMtools.EditMode(this.history_manager.base_client, this.project_manager));
// ... more tools ...
```

Each tool class has a static `register_config()` method that registers the tool config type with Config2:

```vala
OLLMvector.Tool.CodebaseSearchTool.register_config();
OLLMtools.GoogleSearchTool.register_config();
```

These are called in `Application.vala` before loading config.

### Title Handling

Currently, titles are set in `setup_tool_config()` methods by creating a dummy tool instance and extracting the first line of the description:

```vala
var dummy_tool = Object.new(typeof(GoogleSearchTool)) as GoogleSearchTool;
tool_config.title = dummy_tool.description.strip().split("\n")[0];
```

This approach has several problems:
- It's a kludge - titles are stored in config but should come from the tool class
- Splitting on newlines is unreliable (what if description doesn't have newlines?)
- Titles are duplicated in config instead of being a property of the tool class
- The UI has to read titles from config instead of from the tool registry

### Static Constructors Limitation

**Important Note**: Static constructors in Vala don't work as expected - they don't call until the class is used somewhere. This means we can't rely on static constructors for automatic tool registration.

However, we could use the GType registry to discover all classes that extend `Tool.BaseTool` (the abstract base class) and instantiate them to trigger registration. This would allow automatic tool discovery without manual registration.

---

## Goals

1. **Automatic Tool Discovery**: Use GType registry to find all classes extending `Tool.BaseTool` (abstract base class) and register them automatically
2. **Proper Title Management**: Add `title` property to `Tool.BaseTool` abstract class and get titles from tool registry instead of config
3. **Unified Tool Registry**: Move tool registry code to base class or static method for consistency
4. **Remove Title Kludge**: Remove title extraction from `setup_tool_config()` methods and get titles from tool classes directly

---

## Implementation

### Two-Phase Registration Process

**Critical Requirement**: Tool registration must happen in two separate phases:

1. **Phase 1: Config Type Registration** (in `Application.vala`, before loading config)
   - Discover tool classes via GType registry
   - Create tool instances using `Object.new()` (may need minimal constructor params)
   - Call `config_class()` method on each tool instance to get config GType
   - Register the config type with Config2
   - Must happen before `config.load_config()` is called

2. **Phase 2: Tool Instance Creation** (in `Window.vala`, after dependencies are ready)
   - Discover tool classes via GType registry (same discovery as Phase 1)
   - Use `Object.new()` to create tool instances with constructor parameters
   - Register tool instances via `Client.addTool()`
   - Requires dependencies: client, project_manager, etc.
   - Happens after all dependencies are created and available

**Why Two Phases?**
- Config types must be registered before JSON deserialization can work
- Tool instances need dependencies that aren't available at application startup
- `Object.new()` can be used for real instantiation once constructors are standardized

### 1. Tool Registration System

#### Summary of Current Registration

Currently, tool registration happens in two places:

1. **Config Type Registration** (in `Application.vala`):
   - Each tool class has a `config_class()` method that returns the GType of its config class
   - Create tool instance, call `config_class()` to get config type, register with Config2
   - Example: `var tool = Object.new(typeof(CodebaseSearchTool)); var config_type = tool.config_class(); Config2.register_tool_type("codebase_search", config_type);`

2. **Tool Instance Registration** (in `Window.vala`):
   - Tools are manually instantiated and added to `Client.tools` via `client.addTool()`
   - Each tool requires specific constructor parameters (client, project_manager, etc.)
   - Example: `client.addTool(new OLLMtools.ReadFile(client, project_manager))`

**Why Static Constructors Don't Work**: Static constructors in Vala are only called when the class is first used (e.g., when creating an instance or accessing a static member). They don't run automatically at program startup, so we can't rely on them for automatic registration.

#### Alternative: GType Registry Discovery

We can use the GType registry to discover all classes that extend `Tool.BaseTool` (abstract base class):

1. **Query GType Registry**: Loop through all registered GTypes and find classes that extend `Tool.BaseTool`
2. **Instantiate Tools**: Use `Object.new()` to create instances, which triggers constructors
3. **Register Tools**: Add discovered tools to `Client.tools` registry

**Two-Phase Registration Approach**:

We need two separate steps because:
1. **Config registration must happen before loading config** (in `Application.vala`)
2. **Tool object creation needs dependencies** (client, project_manager, etc.) which are only available later (in `Window.vala`)

**Phase 1: Config Type Registration** (before loading config):
- Discover tool classes via GType registry
- Create tool instances using `Object.new()` (may need minimal constructor params)
- Call `config_class()` method on each tool instance to get the config GType
- Register the config type with Config2 using `Config2.register_tool_type(tool_name, config_type)`
- Happens in `Application.vala` before `load_config()`
- Note: `config_class()` is a trivial method that just returns `typeof(ConfigClass)` - no static method needed

**Phase 2: Tool Instance Creation** (after dependencies are ready):
- Discover tool classes via GType registry (same as Phase 1)
- Use `Object.new()` to create tool instances with required constructor parameters
- Register tool instances via `Client.addTool()`
- Happens in `Window.vala` after all dependencies (client, project_manager, etc.) are available

**Constructor Standardization**:

Current tool constructor signatures:

1. **ReadFile**: `ReadFile(Client? client = null, ProjectManager? project_manager = null)`
2. **EditMode**: `EditMode(Client? client = null, ProjectManager? project_manager = null)`
3. **WebFetchTool**: `WebFetchTool(Client? client = null, ProjectManager? project_manager = null)`
4. **GoogleSearchTool**: `GoogleSearchTool(Client? client = null, ProjectManager? project_manager = null)`
5. **RunCommand**: `RunCommand(Client? client = null, ProjectManager? project_manager = null)` - `base_directory` hardcoded to `GLib.Environment.get_home_dir()`
6. **CodebaseSearchTool**: `CodebaseSearchTool(Client? client = null, ProjectManager? project_manager = null)` - `Database` location hardcoded in constructor, `embedding_client` extracted from `client.config` internally (if client not null)

**Standard Constructor Pattern**:
- **All parameters nullable with defaults**: `Client? client = null`, `ProjectManager? project_manager = null`
- Base constructor: `protected Interface(Client? client = null)` - allows `Object.new(typeof(Class))` to work
- All tool constructors: `(Client? client = null, ProjectManager? project_manager = null)`
- Constructors must handle null values gracefully (for Phase 1 dummy instances that only need `config_class()`)
- **Special Cases**:
  - `RunCommand`: `base_directory` hardcoded to `GLib.Environment.get_home_dir()` in constructor
  - `CodebaseSearchTool`: 
    - `Database` location hardcoded in constructor (vector database path)
    - `embedding_client` extracted from `client.config` internally (if client not null, otherwise null)

**For Phase 1 (Config Registration)**:
- Use `Object.new(typeof(Class))` without parameters - works because constructors are now nullable
- No dummy instances needed - constructors handle null values
- Call `config_class()` on the instance (doesn't need real dependencies)
- For `RunCommand`: `base_directory` is hardcoded in constructor (works even with null client/project_manager)
- For `CodebaseSearchTool`: `Database` location hardcoded, `embedding_client` will be null (but `config_class()` doesn't need it)

**For Phase 2 (Tool Instance Creation)**:
- Use `Object.new(typeof(Class), "client", client, "project_manager", project_manager)` - properties set after construction
- Pass real `Client` and `ProjectManager` instances
- `RunCommand`: Uses hardcoded home dir (no parameter needed)
- `CodebaseSearchTool`: 
  - Uses hardcoded Database location (no parameter needed)
  - `embedding_client` extracted from `client.config` internally (client is not null, so this works)

**Standardization Requirements**:
- Make all constructor parameters nullable with defaults: `(Client? client = null, ProjectManager? project_manager = null)`
- Base constructor: `protected Interface(Client? client = null)` - allows `Object.new(typeof(Class))` to work
- Constructors must handle null values gracefully (for Phase 1 dummy instances)
- Example Phase 1: `Object.new(typeof(ReadFile))` - no parameters needed
- Example Phase 2: `Object.new(typeof(ReadFile), "client", client, "project_manager", project_manager)` - properties set after construction
- Base class `Tool.BaseTool` constructor: `protected BaseTool(Client? client = null)` - nullable to allow `Object.new(typeof(Class))` to work

#### Tool Registry Code Location

**Recommended**: Add methods to `Tool.BaseTool` abstract class:

1. **Static `discover_classes()`** - Discovers all tool classes via GType registry
   - Queries GType registry for all types
   - Filters to find classes that extend `Tool.BaseTool` (abstract base class)
   - Returns list of tool class types

2. **Static `register_config()`** - Registers all tool config types (Phase 1)
   - Calls `discover_classes()` to get all tool types
   - For each tool type:
     - Creates tool instance using `Object.new()` (may need minimal constructor params)
     - Calls `config_class()` on the instance to get config GType
     - Gets tool name from instance
     - Registers config type with Config2: `Config2.register_tool_type(tool_name, config_type)`

3. **Instance `config_class()`** - Abstract method that returns the GType of the tool's config class
   - Each tool implements this trivial method: `return typeof(ConfigClass);`
   - Example: `return typeof(CodebaseSearchToolConfig);` or `return typeof(BaseToolConfig);`

**Process**:
- Phase 1 (before config load): Call `Tool.BaseTool.register_config()` in `Application.vala`
- Phase 2 (after dependencies ready): Create tool instances and register them in `Window.vala`

### 2. Title Management

#### Current Problem

Titles are currently:
- Extracted from tool descriptions by splitting on newlines
- Stored in `BaseToolConfig.title` field
- Read from config in UI instead of from tool registry

This is unreliable because:
- Description format may not have newlines
- Titles are duplicated in config
- UI should get titles from tool objects, not config

#### Solution: Add Title Property to Tool.BaseTool

Add `title` property to `Tool.BaseTool` abstract class:

```vala
public abstract class BaseTool : Object, Json.Serializable
{
    // Existing properties
    public abstract string name { get; }
    public abstract string description { get; }
    
    // New property
    public abstract string title { get; }
    
    // ... rest of class
}
```

Each tool class implements `title` property:

```vala
public override string title { get { return "Google Search"; } }
```

#### UI Changes

Update `ToolsPage` and `ToolRow` to get titles from tool registry:

- `ToolsPage.load_tools()`: Get tool object from `Client.tools` and use `tool.title` instead of `config.title`
- `ToolRow`: Use `tool.title` from tool object

#### Remove Title from Config

- Remove `title` field from `BaseToolConfig`
- Remove title extraction from `setup_tool_config()` methods
- Titles come from tool classes, not config

---

## Files to Modify

### Tool Base Class
- `libollmchat/Tool/Tool.vala` (rename `Tool.Interface` to `Tool.BaseTool`)
  - Rename class from `Interface` to `BaseTool` to avoid confusion with interface concept and `base()` keyword
  - Add `title` abstract property
  - Add `config_class()` abstract method that returns the GType of the tool's config class
  - Add static `discover_classes()` method to find all classes extending Tool.BaseTool (abstract base class) via GType registry
  - Add static `register_config()` method that creates tool instances, calls `config_class()`, and registers config types (Phase 1)
  - Add static `register_all_tools()` method that creates tool instances using `Object.new()` and registers them (Phase 2)

### Tool Implementations
- `liboctools/ReadFile.vala` - Add `title` property implementation, add `config_class()` method returning `typeof(BaseToolConfig)`, standardize constructor for `Object.new()`, remove static `register_config()` method
- `liboctools/EditMode.vala` - Add `title` property implementation, add `config_class()` method returning `typeof(BaseToolConfig)`, standardize constructor for `Object.new()`, remove static `register_config()` method
- `liboctools/RunCommand.vala` - Add `title` property implementation, add `config_class()` method returning `typeof(BaseToolConfig)`, **change constructor to hardcode `base_directory` to `GLib.Environment.get_home_dir()`** (remove `base_directory` parameter), standardize constructor for `Object.new()`, remove static `register_config()` method
- `liboctools/WebFetchTool.vala` - Add `title` property implementation, add `config_class()` method returning `typeof(BaseToolConfig)`, standardize constructor for `Object.new()`, remove static `register_config()` method
- `liboctools/GoogleSearchTool.vala` - Add `title` property implementation, add `config_class()` method returning `typeof(GoogleSearchToolConfig)`, remove title extraction from `setup_tool_config()`, remove static `register_config()` method, standardize constructor for `Object.new()`
- `libocvector/Tool/CodebaseSearchTool.vala` - Add `title` property implementation, add `config_class()` method returning `typeof(CodebaseSearchToolConfig)`, remove title extraction from `setup_tool_config()`, remove static `register_config()` method, **change constructor**: `ProjectManager` is non-nullable (required), **hardcode `Database` location** in constructor, **extract `embedding_client` from `client.config` internally** (remove from constructor parameters), standardize constructor for `Object.new()`

### Configuration Classes
- `libollmchat/Settings/BaseToolConfig.vala` - Remove `title` field (titles come from tool classes)

### UI Components
- `ollmchat/SettingsDialog/ToolsPage.vala` - Update to use `tool.title` from tool registry instead of `config.title`
- `ollmchat/SettingsDialog/Rows/ToolRow.vala` - Update to use `tool.title` from tool object instead of `config.title`

### Application Startup
- `ollmchat/Application.vala` - Use `Tool.BaseTool.register_config()` instead of calling individual tool registration methods (Phase 1: before loading config)
- `ollmchat/Window.vala` - Use `Tool.BaseTool.register_all_tools()` to create and register tool instances after dependencies are ready (Phase 2: after client and project_manager are created)
- Remove all static `register_config()` method calls from `Application.vala`

### BackgroundScan Integration
- `libocvector/BackgroundScan.vala` - Update constructor to accept `CodebaseSearchTool` instance
  - Change constructor from: `BackgroundScan(Client embedding_client, Database vector_db, SQ.Database sql_db, GitProviderBase git_provider)`
  - To: `BackgroundScan(CodebaseSearchTool tool, GitProviderBase git_provider)`
  - Extract `embedding_client` from `tool.embedding_client`
  - Extract `vector_db` from `tool.vector_db`
  - Extract `sql_db` from `tool.project_manager.db`
  - Still requires `git_provider` parameter (new instance for thread safety)
- `ollmchat/Window.vala` - After tool registration, create `BackgroundScan` by passing the tool instance
  - Get tool from `client.tools["codebase_search"]` after registration
  - Create `BackgroundScan` with tool instance and new `GitProvider()`
  - This simplifies dependency management - BackgroundScan gets everything it needs from the tool

---

## GType Registry Discovery Implementation

### Finding Tool Classes

Use GType registry to find all classes extending `Tool.BaseTool`:

```vala
public static Gee.ArrayList<Type> discover_classes()
{
    var tool_types = new Gee.ArrayList<Type>();
    var tool_base_type = typeof(Tool.BaseTool);
    
    // Get all registered types
    uint n_types;
    Type[] types = Type.list_types(null);
    
    foreach (var type in types) {
        // Check if type extends Tool.BaseTool (abstract base class)
        if (type.is_a(tool_base_type) && type.is_classed() && !type.is_abstract()) {
            tool_types.add(type);
        }
    }
    
    return tool_types;
}
```

### Registering Config Types (Phase 1)

Create tool instances and call `config_class()` to get config types:

```vala
public static void register_config()
{
    var tool_classes = discover_classes();
    
    foreach (var tool_type in tool_classes) {
        // Create tool instance without parameters - works because constructors are nullable
        // Constructors handle null values gracefully (for Phase 1, we only need config_class())
        var tool = Object.new(tool_type) as Tool.BaseTool;
        
        // Get config class type from tool instance
        var config_type = tool.config_class();
        var tool_name = tool.name;
        
        // Register config type with Config2
        Config2.register_tool_type(tool_name, config_type);
    }
}
```

**Note**: Each tool class implements `config_class()` which is a trivial method that just returns `typeof(ConfigClass)`. This replaces the need for static `register_config()` methods. Called in `Application.vala` before loading config.

### Creating Tool Instances (Phase 2)

After dependencies are available, create tool instances using `Object.new()`:

```vala
public static void register_all_tools(Client client, ProjectManager project_manager, Config2? config = null)
{
    var tool_classes = discover_classes();
    
    foreach (var tool_type in tool_classes) {
        // Use Object.new() to create tool instance with constructor parameters
        // Standard signature: (Client client, ProjectManager project_manager)
        // Special cases handled in constructors:
        // - RunCommand: base_directory hardcoded to home dir
        // - CodebaseSearchTool: Database location hardcoded, embedding_client extracted from client.config internally
        var tool = Object.new(tool_type, 
            "client", client,
            "project_manager", project_manager
        ) as Tool.BaseTool;
        
        client.addTool(tool);
    }
}
```

**Note**: With standardized constructors:
- All tools use: `(Client? client = null, ProjectManager? project_manager = null)` - both nullable with defaults
- Base constructor: `protected Interface(Client? client = null)` - allows `Object.new(typeof(Class))` to work
- Constructors must handle null values gracefully (for Phase 1 dummy instances)
- `RunCommand` hardcodes `base_directory` to `GLib.Environment.get_home_dir()` internally
- `CodebaseSearchTool` hardcodes `Database` location and extracts `embedding_client` from `client.config` internally (if client not null)

**Constructor Standardization**: All tool classes must follow a consistent constructor pattern so `Object.new()` can be used. This may require refactoring existing tool constructors to use GObject property construction.

---

## Config Class Method Implementation

### Base Class

Add abstract `config_class()` method to `Tool.BaseTool`:

```vala
public abstract class BaseTool : Object, Json.Serializable
{
    public abstract string name { get; }
    public abstract string description { get; }
    public abstract Type config_class();  // Returns GType of config class
    // ... rest
}
```

### Tool Implementations

Each tool implements `config_class()` to return its config type:

```vala
public class GoogleSearchTool : Tool.BaseTool
{
    public override Type config_class() { return typeof(GoogleSearchToolConfig); }
    // ... rest
}

public class ReadFile : Tool.BaseTool
{
    public override Type config_class() { return typeof(BaseToolConfig); }
    // ... rest
}
```

**Note**: This is a trivial method that just returns `typeof(ConfigClass)`. It replaces the need for static `register_config()` methods.

## Title Property Implementation

### Base Class

Add abstract `title` property to `Tool.BaseTool`:

```vala
public abstract class BaseTool : Object, Json.Serializable
{
    public abstract string name { get; }
    public abstract string description { get; }
    public abstract string title { get; }  // New property
    public abstract Type config_class();  // Returns GType of config class
    // ... rest
}
```

### Tool Implementations

Each tool implements `title`:

```vala
public class GoogleSearchTool : Tool.BaseTool
{
    public override string name { get { return "google_search"; } }
    public override string description { get { return "Perform web searches..."; } }
    public override string title { get { return "Google Search"; } }  // New implementation
    // ... rest
}
```

### UI Usage

Get title from tool object:

```vala
// In ToolsPage.load_tools()
var tool = this.client.tools.get(tool_name);
if (tool != null) {
    var title = tool.title;  // Get from tool, not config
    // Use title for UI
}
```

---

## Migration Path

1. **Rename Tool.Interface to Tool.BaseTool**: Rename class to avoid confusion with interface concept and `base()` keyword
2. **Add config_class() Method**: Add abstract `config_class()` method to `Tool.BaseTool` and implement in all tools (replaces static `register_config()` methods)
3. **Standardize Constructors**: Rationalize tool constructors to use consistent pattern for `Object.new()` instantiation
4. **Add Title Property**: Add `title` to `Tool.BaseTool` and implement in all tools
5. **Implement Discovery**: Add GType registry discovery methods to `Tool.BaseTool`
6. **Phase 1 Registration**: Update `Application.vala` to use `Tool.BaseTool.register_config()` before loading config
7. **Phase 2 Registration**: Update `Window.vala` to use `Tool.BaseTool.register_all_tools()` after dependencies are ready
7. **Remove Static Methods**: Remove static `register_config()` methods from all tool classes
8. **Update UI**: Change UI to read titles from tool registry instead of config
9. **Remove Title from Config**: Remove `title` field from `BaseToolConfig` and extraction from `setup_tool_config()`

---

## Benefits

1. **Automatic Discovery**: Tools are discovered automatically via GType registry
2. **Proper Titles**: Titles are properties of tool classes, not extracted from descriptions
3. **Single Source of Truth**: Tool metadata (name, title, description) comes from tool classes
4. **Less Manual Work**: No need to manually register each tool in multiple places
5. **Better Maintainability**: Adding a new tool only requires implementing the class, not updating registration code

---

## Future Considerations

- **Tool Plugins**: External tools loaded at runtime (would need different discovery mechanism)
- **Tool Metadata**: Additional metadata properties (icon, category, version, etc.)
- **Tool Dependencies**: Tools that depend on other tools or services
- **Tool Validation**: Validate tool implementations at discovery time

