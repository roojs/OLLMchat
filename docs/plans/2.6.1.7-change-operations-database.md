# 2.6.1.7. File History Database Table

## Overview

Create a new database table to track **file change history** - what happened to each file during command execution **and edit file actions**. This is organized around **files** (what users understand), not operations (implementation details). Each entry represents a change event in a file's history.

**Key Purpose**: This table is primarily for **user review, approval, and restoration** of changes - not just tracking what happened during command execution or edit file actions. It enables:
- **User thinks in terms of files**: "What happened to file X?" rather than "What operations occurred?"
- Listing file changes for user review before applying them
- Backing up files so they can be compared (diff)
- Approving/rejecting file changes with ability to restore if rejected
- Restoring files if changes are rejected
- Reviewing what changed and when for each file

## ⚠️ Important Note: Ignored Files

**This plan does NOT deal with `is_ignored` files.**

Files with `is_ignored = true` are **filtered out** and **not tracked** in the file_history table. Only non-ignored files are recorded in the history for user review and approval.

## Status

⏳ **PLANNING** - Design phase. Details to be worked out.

## Prerequisites

- **Note**: This plan supersedes Phase 6 (2.6.1.6) - it replaces the previous approach
- See main plan: `2.6.1-code-exec-improvements.md` for context

## Goals

1. Create new `file_history` database table to track what happened to each file
2. Separate active filesystem view (current `filebase` table) from change history
3. **File-centric design**: Users see "file X was deleted", "file Y was modified", not "operation 1, operation 2"
4. Better handle file/folder deletions and recreations
5. Better handle type mismatches (file→folder, folder→file)
6. Improve change tracking and audit trail
7. **Enable user review and approval workflow** - changes are tracked but not immediately applied
8. **Enable restoration** - if user rejects a change, restore from backup

## Implementation Details

### Database Schema

**New table: `file_history`**

**File-Centric Design**: Each row represents "what happened to a file at a point in time"

**Core Fields (File Identity):**
- `id` INTEGER PRIMARY KEY
- `path` TEXT NOT NULL - **The file path** (primary identifier - what user cares about)
- `filebase_id` INT64 - Reference to filebase record (0 for new files or deleted files - deleted files are removed from filebase)
- `timestamp` INT64 - **When the change occurred** (when file was removed or changed)
  - **Note**: For overlay/command execution updates, all timestamps for the same command/run/edit should be the same (based on when the command/run/edit started, NOT when the record was created)
- `agent_id` TEXT - **Agent identifier** (empty string "" for now, may be used later to track which agent/tool made the change)

**Change Type:**
- `change_type` TEXT - "added", "modified", "deleted"
  - User-friendly: "file X was deleted", "file Y was modified", "file Z was added"
  - **Note**: Type changes (file→folder, folder→file) are just delete + add, not a separate action
  - **Note**: Renames use `change_type="deleted"` with `moved_to` filled in (file was deleted from original path, moved to new path)
  - **Note**: Renames also use `change_type="added"` with `moved_from` filled in (file was added at new path, moved from old path)

**File Type:**
- `base_type` TEXT - **The file type before it was changed** (matches filebase `base_type` standard)
  - Type identifiers: "f" = File, "d" = Folder/Directory, "fa" = FileAlias (alias/symlink, can point to file or folder)
  - **Note**: FileAlias always uses "fa" regardless of whether it points to a file or folder (no "da" distinction)
  - For history purposes - represents what the file was before the change
  - For "added": represents the type of the new file
  - For "deleted": represents what type it was before deletion
  - For "modified": represents the file type (usually "f")

**Backup/Restoration:**
- `backup_path` TEXT - **Path where the old version will be saved** (empty string "" for new files)
  - This is the path where FileHistory class will save the backup of the original file
  - Used for restoration if change is rejected
  - For new files: `backup_path` = "" (empty string, no backup needed)
  - For modified/deleted files: `backup_path` = path where backup file will be created
  - **Note**: `backup_path` will be removed from `filebase` table - this is the only place to store it
  - **Note**: **FileHistory class is responsible for creating backups** (this responsibility used to be in ProjectManager or elsewhere)
  - **Note**: The filebase contains the 'new file' info and the real file has the contents - so `backup_path` will be empty "" for new files

**Status:**
- `status` INTEGER - User approval state (0 = pending, 1 = approved, -1 = rejected)
  - 0 = pending (not yet reviewed)
  - 1 = approved (user approved the change)
  - -1 = rejected (user rejected the change)
  - **Note**: Don't track "applied" or "restored" - status is just approval state

**Alias Support:**
- `alias_target` TEXT - **Target path if file was previously an alias** (symlink target)
  - Empty string "" if file was not an alias
  - Stored for restoration purposes

**Rename/Move Fields:**
- `moved_to` TEXT - Destination path (for rename operations when file was deleted - file was moved to here)
  - For renames: `change_type="deleted"`, `path` = original path, `moved_to` = destination path
  - Empty string "" for non-rename operations (regular delete, add, modify)
- `moved_from` TEXT - Source path (for rename operations when file was added - file was moved from here)
  - For renames: `change_type="added"`, `path` = new path, `moved_from` = original path
  - Empty string "" for non-rename operations (regular add, delete, modify)

**Design Notes:**
- **Primary organization**: By `path` - query "SELECT * FROM file_history WHERE path = ?" to see history of a file
- **⚠️ Ignored files**: Do not track `is_ignored` items - they are filtered out (see Important Note above)
- **No NULL values**: Use empty strings "" or 0 instead of NULL
- For **new files**: `filebase_id` = 0, `backup_path` = "" (empty string, no backup needed), `change_type="added"`, `base_type` = type of new file ("f", "d", "fa")
- For **deleted files**: `filebase_id` = 0 (deleted files removed from filebase), `backup_path` = backup location, `change_type="deleted"`, `base_type` = type before deletion ("f", "d", "fa")
- For **updated files**: `filebase_id` = file record ID, `backup_path` = backup location, `change_type="modified"`, `base_type` = "f" (typically)
- For **renames**: 
  - Delete entry: `change_type="deleted"`, `path` = original path, `moved_to` = destination path
  - Add entry: `change_type="added"`, `path` = new path, `moved_from` = original path
- **Multiple entries per file**: If same file is modified multiple times, each gets a row (full history)
- **User view**: User will see a list of unique files with changes (normally pending, `status = 0`) so they can review the diff

### Benefits

- **File-centric design**: Users think in terms of files, not operations
  - "What happened to file X?" → Query by `path`
  - "Show me all changed files" → Query all unique `path` values
- Active filesystem view (`filebase` table) remains clean - only current state
  - **Deleted files are removed from filebase** - history is only place to track them
  - **`backup_path` removed from filebase** - only stored in history table
- File change history tracked separately with full timeline
- **User can review changes before applying them**
- **User can approve/reject individual file changes**
- **User can restore files if changes are rejected** (using backup_path)
- Files stored in edited folder (same system as edit file tool) - replaces overlay_path
- Can handle complex scenarios:
  - File deleted then recreated as folder (two entries: deleted, then added - no special "type_change" action)
  - Folder deleted then recreated as file (two entries: deleted, then added - no special "type_change" action)
  - Multiple changes to same path (multiple rows for same `path`, ordered by `timestamp`)
  - Renames (two entries: delete with `moved_to`, add with `moved_from`)
  - Aliases (symlinks) - `alias_target` stored for restoration
- Better audit trail: "What happened to this file?" is a simple query
- Can replay/undo file changes if needed

### Design Questions

**New Files:**
- Currently new files are "touched" but this is pretty pointless
- Should store: `path`, `change_type="added"`, `filebase_id=0`, `backup_path=""`, `base_type` = type of new file ("f", "d", "fa")
- User can review and approve to actually create the file in the real filesystem
- **User sees**: "File /path/to/newfile.txt was added"

**Renames:**
- **Implementation**: Two entries for a rename:
  - Delete entry: `change_type="deleted"`, `path` = original path, `moved_to` = destination path
  - Add entry: `change_type="added"`, `path` = new path, `moved_from` = original path
- **User sees**: "File /old/path.txt was deleted" (with `moved_to` indicating it was renamed to /new/path.txt)
- The file was deleted from the original location - `moved_to` indicates where it moved to
- The file was added at the new location - `moved_from` indicates where it came from

**Type Changes:**
- **Not a separate action**: If a file is deleted and a folder is created at the same path (or vice versa), that's just two separate actions:
  - First entry: `change_type="deleted"`, `base_type` = "f" (or "d")
  - Second entry: `change_type="added"`, `base_type` = "d" (or "f")
- **User sees**: "File /path was deleted" then "Folder /path was added"
- The file was deleted - period. Then a new item (of different type) was added.

**Multiple Changes to Same File:**
- If file is modified multiple times during command execution, each gets a row
- **User sees**: Timeline of changes to that file
- Query: `SELECT * FROM file_history WHERE path = ? ORDER BY timestamp`

**User Interaction (File-Centric):**
- User will see a list of unique files with changes (normally pending, `status = 0`) so they can review the diff
- **List all changed files** (group by `path`, show latest `change_type`, filter by `status = 0` for pending)
  - Query: `SELECT DISTINCT path FROM file_history WHERE status = 0`
- **Show file history** (all entries for a specific `path`)
  - Query: `SELECT * FROM file_history WHERE path = ? ORDER BY timestamp`
- **Show diff** for each file change (compare backup_path with current file, or show new file content)
- **Approve/reject individual file changes** (set `status = 1` for approved, `status = -1` for rejected)
- **Bulk approve/reject** by file
- **Restore rejected file changes** from backup (using `backup_path`)

### FileHistory Class Design

**Location**: `libocfiles/FileHistory.vala`

**Purpose**: Handle file change history tracking and backup creation. This class is responsible for:
- Creating backups of files before they are modified/deleted
- Storing change history in the database
- Filtering out ignored files

**Workflow**:
1. Create FileHistory object with change information in constructor
2. Call `commit()` method to:
   - Check if file is ignored (skip if so)
   - Create backup file if needed (for modified/deleted files)
   - Insert change record into database

**Class Mockup**:

```vala
namespace OLLMfiles
{
    /**
     * Represents a file change history entry.
     * Handles backup creation and database storage for file changes.
     */
    public class FileHistory : Object
    {
        // Database fields (properties)
        public int64 id { get; set; default = 0; }
        public string path { get; set; default = ""; }
        public int64 filebase_id { get; set; default = 0; }
        public int64 timestamp { get; set; default = 0; }
        public string change_type { get; set; default = ""; } // "added", "modified", "deleted"
        public string base_type { get; set; default = ""; } // "f", "d", "fa"
        public string backup_path { get; set; default = ""; }
        public int status { get; set; default = 0; } // 0 = pending, 1 = approved, -1 = rejected
        public string alias_target { get; set; default = ""; }
        public string moved_to { get; set; default = ""; }
        public string moved_from { get; set; default = ""; }
        public string agent_id { get; set; default = ""; }
        
        // Internal fields
        private SQ.Database db;
        private FileBase? filebase_object;
        
        /**
         * Constructor - creates a FileHistory object for a change.
         * 
         * @param db Database instance
         * @param filebase_object FileBase object (File or Folder) - can be null for new files
         * @param change_type "added", "modified", or "deleted"
         * @param timestamp Timestamp when change occurred (same for all changes in same command/run/edit)
         * @param moved_to Destination path for renames (empty string "" if not a rename)
         * @param moved_from Source path for renames (empty string "" if not a rename)
         */
        public FileHistory(
            SQ.Database db,
            FileBase? filebase_object,
            string change_type,
            int64 timestamp,
            string moved_to = "",
            string moved_from = "")
        {
            this.db = db;
            this.filebase_object = filebase_object;
            this.change_type = change_type;
            this.timestamp = timestamp;
            this.moved_to = moved_to;
            this.moved_from = moved_from;
            
            // Set path and filebase_id from filebase_object if provided
            if (filebase_object != null) {
                this.path = filebase_object.path;
                this.filebase_id = filebase_object.id;
                this.base_type = filebase_object.base_type;
                // Store alias target if it's an alias
                if (filebase_object.is_alias && filebase_object.target_path != "") {
                    this.alias_target = filebase_object.target_path;
                }
            }
        }
        
        /**
         * Commit the change to database.
         * 
         * This method:
         * 1. Checks if file is ignored (skips if so)
         * 2. Creates backup file if needed (for modified/deleted files)
         * 3. Inserts change record into database
         * 
         * @throws Error if backup creation or database insert fails
         */
        public async void commit() throws Error
        {
            // Check if file is ignored - skip if so
            if (this.filebase_object != null && this.filebase_object.is_ignored) {
                return; // Do nothing for ignored files
            }
            
            // Create backup if needed (for modified/deleted files)
            if (this.change_type == "modified" || this.change_type == "deleted") {
                if (this.filebase_object == null || this.filebase_object.path == "") {
                    throw new GLib.IOError.FAILED("Cannot create backup: filebase_object or path is missing");
                }
                this.backup_path = yield this.create_backup();
            } else {
                // For "added" files, backup_path remains empty string ""
                this.backup_path = "";
            }
            
            // Insert into database
            yield this.save_to_db();
        }
        
        /**
         * Create backup file for modified/deleted files.
         * 
         * @return Path to backup file
         * @throws Error if backup creation fails
         */
        private async string create_backup() throws Error
        {
            // Implementation: Create backup using same system as edit file tool
            // Returns path to backup file
            // TODO: Implement backup creation logic
            return "";
        }
        
        /**
         * Save FileHistory record to database.
         * 
         * @throws Error if database insert fails
         */
        private async void save_to_db() throws Error
        {
            // Implementation: Insert into file_history table
            // TODO: Implement database insert logic
        }
        
        /**
         * Initialize file_history table in database.
         * 
         * @param db Database instance
         */
        public static void init_db(SQ.Database db)
        {
            // Implementation: Create file_history table if it doesn't exist
            // TODO: Implement table creation
        }
        
        /**
         * Query file history records.
         * 
         * @param db Database instance
         * @param path Optional path to filter by
         * @param status Optional status to filter by (0 = pending, 1 = approved, -1 = rejected)
         * @return List of FileHistory objects
         */
        public static Gee.List<FileHistory> query(
            SQ.Database db,
            string path = "",
            int? status = null)
        {
            // Implementation: Query file_history table
            // TODO: Implement query logic
            return new Gee.ArrayList<FileHistory>();
        }
    }
}
```

**Constructor Parameters**:
- `db` (SQ.Database) - Database instance (required)
- `filebase_object` (FileBase?) - FileBase object (File or Folder) - can be null for new files
- `change_type` (string) - "added", "modified", or "deleted" (required)
- `timestamp` (int64) - Timestamp when change occurred (required, same for all changes in same command/run/edit)
- `moved_to` (string) - Destination path for renames, empty string "" if not a rename (optional, default "")
- `moved_from` (string) - Source path for renames, empty string "" if not a rename (optional, default "")

**Methods**:
- `commit()` - Main method: checks ignored, creates backup if needed, inserts into database
- `create_backup()` (private) - Creates backup file for modified/deleted files
- `save_to_db()` (private) - Inserts record into database
- `init_db()` (static) - Initializes file_history table
- `query()` (static) - Queries file_history table

### Implementation Phases

**Phase 1: FileHistory Class + Database (Current Phase)**
- Create `libocfiles/FileHistory.vala` - FileHistory class with database operations
  - All FileHistory code should be in this class (not scattered across other files)
  - Follow same patterns as FileBase for database operations
  - Implement constructor, commit(), create_backup(), save_to_db(), init_db(), query()
- Add `file_history` table initialization (call FileHistory.init_db() from FileBase.initDB())
- Implement basic CRUD operations for FileHistory
- **Do NOT modify** filebase, runcommand, or editmode yet

**Phase 2: Integration (Future)**
- Integrate FileHistory with `liboctools/RunCommand/Monitor.vala` - Record file changes in history table
- Integrate FileHistory with `liboctools/RunCommand/Overlay.vala` - Process file changes from history table
- Remove `backup_path` from filebase table
- Update editmode to use FileHistory
- Additional files TBD

## Notes

- Details to be worked out during implementation
- This is a significant architectural change
- May require migration of existing change tracking logic
- **Key insight**: This is less about storing actions relating to the runcommand, and more about giving the user ability to restore, check, and approve changes
- **Workflow change**: Instead of immediately applying changes after command execution, file changes are stored in this table for user review
- **Design philosophy**: **File-centric, not operation-centric**
  - Users understand files: "What happened to file X?"
  - Operations are implementation details: "delete operation, add operation"
  - Table organized by `path` - natural query pattern
- **Storage**: Only `backup_path` is stored - no `edited_path` field needed
- **⚠️ Ignored files**: Not tracked in history table - filtered out completely (see Important Note above)
- **Deleted files**: Removed from filebase table, only exist in history table
- **Backup path**: Removed from filebase table, only stored in history table
- The exact workflow depends on how the user will interact with the changes (UI design needed)
