# 1.23.1 Skill Runner in occoder

## Coding standards (this document)

All code in this plan must follow `.cursor/rules/CODING_STANDARDS.md`. Reminder bullets:

- **Nullable types:** Avoid nullable types; use default objects/flags where possible.
- **Null checks:** Forbidden unless design explicitly requires null (e.g. external API); redesign instead of adding null checks.
- **String interpolation:** No `@"..."` except for multi-line usage/help or documentation; use concatenation or `.printf()`.
- **Temporary variables:** No one-use temporaries; no trivial aliases (except long chains 4+ steps).
- **Brace placement:** Line break for namespace/class/method braces; inline for control structures (`if (x) {`). Never one-line if/else with body — opening brace and body on separate lines.
- **`this.` prefix:** Use `this.` for instance members.
- **GLib prefix:** Use fully-qualified `GLib.*`; avoid `using` imports.
- **Property initialization:** Use `get; set; default =` or field defaults; do not set defaults in constructors.
- **Line length:** Break long lines (e.g. on `(`, on `+`, one argument per line).
- **StringBuilder:** Never use `GLib.StringBuilder` here; use `+` or `string.joinv()` or (for Skill) document mutation.
- **String building in loops:** Never build strings in a loop with `+=`; use `string.joinv(sep, array)` or `string.nfill()`/`replace()`.
- **ArrayList for strings:** When building strings to join, use `string[]` and `string.joinv()`, not `Gee.ArrayList<string>`.
- **Character looping:** Avoid; prefer string methods and `GLib.Regex`.
- **Gee.HashMap / Gee.ArrayList:** Use `.set()`/`.get()` and `.add()`/`.get()`, not `[]` accessors.
- **Reducing nesting:** Prefer early returns, avoid else when possible.
- **Switch vs if/else if:** Use `switch/case` for long chains.
- **Debug statements:** Do not prefix with class/function names; debug output already includes location.
- **SQL (if any):** No table aliases; full table names (see user rules for joinAdd exception).

## Overview

Subplan of 1.23: implement the **SkillRunner** agent and **SkillRunnerFactory** in liboccoder, plus a **Skill** class (one skill file: YAML header + markdown body), a **SkillManager** (holds an array of skills directories and lists available skills by scanning them), and **templates** in the skills folder. Skills directories are an **array** (initially one). Which skills the current skill *can use* is declared **in the skill document** in a section (e.g. “## Available skills”); we use the **markdown parser** (libocmarkdown) to extract that section, then **cross-reference** with the skills actually present (from SkillManager scanning the directories). The system message is built from: (1) `system.template.md`, (2) the cross-referenced available-skills list, (3) the current skill’s full content. The **SkillRunner** builds both messages; **SkillRunnerFactory** is lightweight (creates SkillManager and runners only). First supported skill: Conductor (`conductor.md`).

## Status

**PLAN** – Implementation not started.

## Dependencies

- Plan 1.23 (Skills Agent & Conductor).
- Existing: `OLLMchat.Agent.Factory`, `OLLMchat.Agent.Base`, `OLLMcoder.Agent` / `OLLMcoder.AgentFactory` (reference only; no code reuse).
- libocmarkdown: used to parse the current skill’s markdown body via `Markdown.Document.Render.parse(body)` and extract the “Available skills” section (by heading) for cross-reference with SkillManager.

## Files to add or modify

**liboccoder/Skill/** uses namespace **OLLMcoder.Skill**. Classes: **PromptTemplate** (Skill/PromptTemplate.vala), **Definition** (skill file: YAML + markdown body; Skill/Definition.vala), **Manager** (scans dirs; Skill/Manager.vala), **Factory** (creates runners; Skill/Factory.vala), **Runner** (builds messages; Skill/Runner.vala).

| Action | File |
|--------|------|
| Add | `liboccoder/Skill/` folder — namespace **OLLMcoder.Skill**. |
| Add | `liboccoder/Skill/PromptTemplate.vala` (OLLMcoder.Skill.PromptTemplate) |
| Add | `liboccoder/Skill/Definition.vala` (skill file: YAML + markdown body; was Skill.vala) |
| Add | `liboccoder/Skill/Manager.vala` (scans directories; was SkillManager.vala) |
| Add | `liboccoder/Skill/Factory.vala` (creates runners; was SkillRunnerFactory.vala) |
| Add | `liboccoder/Skill/Runner.vala` (builds messages; was SkillRunner.vala) |
| Add | `resources/skills/system.template.md` |
| Add | `resources/skills/user.template.md` |
| Edit | `libollmchat/Prompt/Template.vala` (add base class; see §3 Prompt template) |
| Edit | `libocvector/Indexing/PromptTemplate.vala` (extend OLLMchat.Prompt.Template) |
| Edit | `liboccoder/meson.build` (add Skill/PromptTemplate, Skill/Definition, Skill/Manager, Skill/Factory, Skill/Runner) |
| Edit | `docs/meson.build` (add `Prompt/Template.vala`, `Skill/PromptTemplate.vala` to valadoc input list so build succeeds) |
| Edit | `ollmapp/Window.vala` (register SkillRunner factory) |
| Edit | `libocmarkdown/document/Document.vala` (heading cache) |
| Edit | `libocmarkdown/document/Node.vala` (next() method) |

---

## 0. libocmarkdown Document and Node (for “Available skills” lookup)

- **RenderBase (RenderBase.vala):** **`parse(string text)`** — parses a full document in one call (equivalent to `start()`, `add(text, true)`, `flush()`). Use via a document renderer: `var doc_render = new Markdown.Document.Render(); doc_render.parse(body); document = doc_render.document;` (e.g. in Skill.load() and Skill.apply_skills()).
- **Document (document/Document.vala):** Add a cache **heading name → Block**: e.g. `Gee.HashMap<string, Block> headings_by_name`. Key is the heading text (e.g. `"Available skills"`); value is the Block node for that heading (kind HEADING_1..6). Populate the cache when the document is built (e.g. in the document render path when a heading is adopted) or lazily on first access by walking top-level children and adding any block whose kind is HEADING_* with key = that block’s text content (flattened from its Format children). Normalization of the key (e.g. strip) is up to the implementation; lookup will use the same normalization. Add **`Node create(FormatType type, string text = "")`** — returns a new node (Block for block kinds e.g. PARAGRAPH, Format for inline kinds) with uid assigned from this.uid_count and uid_count incremented; when type is TEXT or when text is non-empty for a format that carries text, set the node’s text. Returns a node that the caller can adopt.
- **Node (document/Node.vala):** Add **`Node? next()`** — returns the next sibling in the parent’s `children` list, or `null` if this node is last or has no parent. Add **`string text_content()`** — returns the flattened text of this node (e.g. for a ListItem: walk children, take first Block with kind PARAGRAPH or Format subtree, concatenate TEXT and other inline content into a single line string). Add **`ListItem append_li()`** — on a node that can contain a nested list (e.g. ListItem): if the last child is a List, use it; otherwise create a List and adopt it. Create a new ListItem, adopt it into that List, return the ListItem (uids from document). Add **`void append_raw(string raw)`** — appends a child node representing the raw markdown string (e.g. parse as inline / one paragraph and adopt as child; implementation builds the Block/Format tree for the string). So original list "- research" "- plan" becomes "- research" with nested "- ***When to use*** … description …", "- plan" with same.
- **Skill plan usage:** `skills_list()` uses the document’s heading cache and `next()`. Skill names are collected inline from that list by calling `item.text_content()` on each ListItem.

---

## 1. Skill.Definition (Skill/Definition.vala)

- **Namespace:** `OLLMcoder.Skill`
- **Role:** Represents a single skill file: path, YAML header, markdown body, and a **parsed markdown document** (from libocmarkdown). Can validate referenced skills against an array of available skills and render the skill content with a skills list (descriptions) appended. No listing logic; that lives in SkillManager.
- **Constructor:** `Skill(string path)` — caller builds the path and passes it; Skill only stores this `path`. Does **not** read the file. Initializes empty `header`, `body`, `full_content`, and `document`.
- **load() throws GLib.Error:** Reads the file, validates format (must start with `---` and have a closing `---`), splits into header and body, parses key-value lines into `header`, sets `body` and `full_content`. **Creates the markdown document** by calling `Markdown.Document.Render.parse(this.body)` and storing `doc_render.document` so we can later extract sections (e.g. “Available skills”) and validate. Validates that `header` contains non-empty `"name"` and non-empty `"description"` (skills are not valid without a description). Throws on any failure.
- **Properties:** `string path`, `string body`, `string full_content`, `Gee.HashMap<string, string> header`, **`int64 mtime`** (file modification time, set in load()), and **`Markdown.Document.Document document`** — the parsed body as a document.
- **validate_skills(Gee.HashMap<string, Skill> available):** Takes a map of skill name → Skill (e.g. SkillManager.by_name after scan()). Validates that any skills this document references (e.g. in its “Available skills” section) are in that map. Returns a list of **missing** skill names. If the list is non-empty, that is an **error condition** — the caller must **not run** the skill; validate_skills is the gate that prevents running when required skills are not listed/available.
- **apply_skills(Gee.HashMap<string, Skill> available):** **First re-parses the document** via `doc_render.parse(this.body)`; then finds the list under the “Available skills” heading and **append** a nested list item with "***When to use*** " + that skill's description for each list item. Original item label unchanged. Uses append_li() then append_raw().
- **content_with_applied_skills():** Returns the document (after apply_skills has been called) rendered to a markdown string, for use in the system message. Implementation: document → markdown (e.g. Document or libocmarkdown provides a to_markdown / serialize path).
- **No** static `list_available` — listing is done by **SkillManager**.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMcoder
{
	/**
	 * One skill file: YAML header (key-value map) and markdown body.
	 * Constructor only stores path; call load() to read and parse.
	 * Header is stored in a hash map; "name" etc. are read from the map after load.
	 */
	public class Skill : Object
	{
		public string path { get; private set; default = ""; }
		public string body { get; private set; default = ""; }
		public string full_content { get; private set; default = ""; }
		public Gee.HashMap<string, string> header { get; private set; default = new Gee.HashMap<string, string>(); }
		/** File modification time; set in load(). */
		public int64 mtime { get; private set; default = 0; }
		/** Parsed body as a markdown document (libocmarkdown). */
		public Markdown.Document.Document document { get; private set; }

		public Skill(string path)
		{
			this.path = path;
		}

		/**
		 * Load and parse the skill file. Validates content; throws on read or validation failure.
		 */
		public void load() throws GLib.Error
		{
			string contents = "";
			if (!GLib.FileUtils.get_contents(this.path, out contents)) {
				throw new GLib.FileError.FAILED("Skill: could not read %s".printf(this.path));
			}

			this.full_content = contents;

			// Require valid header: file must start with --- and have a closing ---
			if (!contents.has_prefix("---")) {
				throw new GLib.FileError.INVAL("Skill: %s does not start with YAML header (---)".printf(this.path));
			}
			var parts = contents.split("\n---", 2);
			if (parts.length < 2) {
				throw new GLib.FileError.INVAL("Skill: %s has no closing header delimiter (---)".printf(this.path));
			}
			string header_text = parts[0].substring(3).strip();
			this.body = parts[1].strip();

			this.header.clear();
			foreach (var line in header_text.split("\n")) {
				var stripped = line.strip();
				var colon = stripped.index_of(":");
				if (colon > 0) {
					var key = stripped.substring(0, colon).strip();
					var value = stripped.substring(colon + 1).strip();
					this.header.set(key, value);
				}
			}

			// Validate: require non-empty "name" so the skill can be listed and identified
			if (!this.header.has_key("name") || this.header.get("name") == "") {
				throw new GLib.FileError.INVAL("Skill: %s has no valid 'name' in header".printf(this.path));
			}
			// Validate: require non-empty "description" — skills are not valid without a description
			if (!this.header.has_key("description") || this.header.get("description") == "") {
				throw new GLib.FileError.INVAL("Skill: %s has no valid 'description' in header".printf(this.path));
			}

			// Store file mtime for cache invalidation (file exists — we just read it)
			var file = GLib.File.new_for_path(this.path);
			var info = file.query_info(GLib.FileAttribute.TIME_MODIFIED, GLib.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
			this.mtime = info.get_modification_time().to_unix();

			// Create markdown document from body (libocmarkdown Document.Render)
			var doc_render = new Markdown.Document.Render();
			doc_render.parse(this.body);
			this.document = doc_render.document;
		}

		/**
		 * Validates that skills referenced in this document are in the available map (key = skill name).
		 * Returns list of skill names that are referenced but not in available.
		 * If the list is non-empty, caller must not run the skill (error condition).
		 */
		public Gee.ArrayList<string> validate_skills(Gee.HashMap<string, Skill> available)
		{
			var list = this.skills_list();
			if (list == null) {
				return new Gee.ArrayList<string>();
			}
			var missing = new Gee.ArrayList<string>();
			foreach (var child in list.children) {
				if (!(child is Markdown.Document.ListItem)) {
					continue;
				}
				var name = ((Markdown.Document.ListItem) child).text_content();
				if (!available.has_key(name)) {
					missing.add(name);
				}
			}
			return missing;
		}

		/**
		 * First re-parses the document from this.body (refresh from memory); then finds the list
		 * under "Available skills" and appends a nested list item with "***When to use*** " + description
		 * for each list item. Original item label unchanged.
		 */
		public void apply_skills(Gee.HashMap<string, Skill> available)
		{
			var doc_render = new Markdown.Document.Render();
			doc_render.parse(this.body);
			this.document = doc_render.document;
			var target_list = this.skills_list();
			if (target_list == null) {
				return;
			}
			foreach (var child in target_list.children) {
				if (!(child is Markdown.Document.ListItem)) {
					continue;
				}
				var item = (Markdown.Document.ListItem) child;
				item.append_li().append_raw(
					"***When to use*** "
					+ available.get(item.text_content()).header.get("description"));
			}
		}

		/** List block under "Available skills" heading in this.document (heading cache + next()). */
		private Markdown.Document.List? skills_list()
		{
			var heading = this.document.headings_by_name.get("Available skills");
			if (heading == null) {
				return null;
			}
			var next_block = heading.next();
			return next_block is Markdown.Document.List ? (Markdown.Document.List) next_block : null;
		}

	}
}
```

---

## 2. SkillManager (SkillManager.vala)

- **Namespace:** `OLLMcoder`
- **Role:** Keeps an eye on all skills: holds an **array of directories** (skills base paths) and can list the skills actually present by scanning those directories. Initially we use one directory; the type is an array so we can add more later.
- **Constructor:** `SkillManager(Gee.ArrayList<string> skills_directories)` — takes the list of base paths (e.g. one element: `{HOME}/gitlive/OLLMchat/resources/skills`). Caller builds the array.
- **Properties:** `by_path` and `by_name` — public maps **path → Skill** and **name → Skill**, updated in place by `scan()`. Call `scan()` then read the properties.
- **Method:** `void scan() throws GLib.Error` — updates by_path/by_name in place. Enumerate with `standard::name,standard::type,time::modified`; for each `.md` file (exclude templates), get mtime from enumerator’s FileInfo; if already in `this.by_path` and mtime matches cached skill, skip; else load and set. No separate file stat; no purge.
- **Removed:** get_system_inputs_max_mtime and get_file_mtime (not needed).

- **Templates location:** The first directory in the array (`skills_directories.get(0)` when size > 0) is used for `system.template.md` and `user.template.md`.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 * (Same license as Skill.vala)
 */

namespace OLLMcoder
{
	/**
	 * Holds an array of skills directories and two maps: path → Skill and name → Skill.
	 * One scan populates both; each Skill stores its own mtime.
	 */
	public class SkillManager : Object
	{
		public Gee.ArrayList<string> skills_directories { get; private set; default = new Gee.ArrayList<string>(); }
		public Gee.HashMap<string, Skill> by_path { get; set; default = new Gee.HashMap<string, Skill>(); }
		public Gee.HashMap<string, Skill> by_name { get; set; default = new Gee.HashMap<string, Skill>(); }

		public SkillManager(Gee.ArrayList<string> skills_directories)
		{
			this.skills_directories = skills_directories;
		}

		public void scan() throws GLib.Error
		{
			var keys_before = new Gee.ArrayList<string>();
			keys_before.add_all(this.by_path.keys);
			foreach (var skills_base_path in this.skills_directories) {
				var dir = GLib.File.new_for_path(skills_base_path);
				if (!dir.query_exists()) {
					continue;
				}
				var enumerator = dir.enumerate_children(
					"standard::name,standard::type,time::modified",
					GLib.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
				GLib.FileInfo? info;
				while ((info = enumerator.next_file(null)) != null) {
					var name = info.get_name();
					if (!name.has_suffix(".md")) {
						continue;
					}
					// TODO: temporary until we work out how to handle templates (exclude from skills list)
					if (name == "system.template.md" || name == "user.template.md") {
						continue;
					}
					var skill_path = GLib.Path.build_filename(skills_base_path, name);
					int64 file_mtime = (int64) info.get_modification_time().tv_sec;
					if (this.by_path.has_key(skill_path)
						&& file_mtime == this.by_path.get(skill_path).mtime) {
						keys_before.remove(skill_path);
						continue;
					}
					var skill = new Skill(skill_path);
					try {
						skill.load();
						this.by_path.set(skill_path, skill);
						this.by_name.set(skill.header.get("name"), skill);
						keys_before.remove(skill_path);
					} catch (GLib.Error e) {
						GLib.warning("SkillManager: skip %s: %s", name, e.message);
					}
				}
			}
			foreach (var path in keys_before) {
				var skill = this.by_path.get(path);
				this.by_path.unset(path);
				this.by_name.unset(skill.header.get("name"));
			}
		}
	}
}
```

---

## 3. Templates in skills folder

- **Location:** `resources/skills/` (same as plan 1.23; path for dev: `{HOME}/gitlive/OLLMchat/resources/skills`). May be moved later.
- **system.template.md** — Included at the top of the system message. Content: summary of how to deal with skills (picking by description, task manager Input/Output format, skill output = document + short summary). Placeholder content below; refine when implementing.
- **user.template.md** — Used to build the user message for the time being (e.g. wrap the raw query in a template). Placeholder below.

- **Prompt template (base in libollmchat):** **`OLLMchat.Prompt.Template`** (`libollmchat/Prompt/Template.vala`) — base class with **`source`** (default `"resource://"`), **`base_dir`**, **`filename`** (renamed from resource_path). **`exists() throws GLib.Error`**: if `source == "resource://"` returns `true`; otherwise checks filesystem and returns whether the file exists. **`load()`** calls `exists()` first and throws if not found; then loads from resource URI or path and splits on `---` into `system_message` and `user_template`. **`fill(...)`** replaces `{key}` placeholders from varargs key-value pairs. **OLLMvector.Indexing.PromptTemplate** (libocvector) extends it and sets `source = "resource://"`, `base_dir = "/ocvector"`; constructor takes `filename` only (e.g. `"analysis-prompt.txt"`). **`OLLMcoder.Skill.PromptTemplate`** (liboccoder `Skill/PromptTemplate.vala`) extends it and sets `source = "file://"`, `base_dir` from constructor; constructor is `PromptTemplate(string base_dir, string filename)`. Use for system and user templates: `var tpl = new SkillPromptTemplate(primary, "system.template.md"); tpl.load();` then `tpl.system_message`, and for user `tpl.fill("query", user_query)` (use `{query}` in the template to match).

**system.template.md (placeholder):**

```markdown
## How to use skills

- Pick a skill from the **descriptions** listed below (name and description from each skill's YAML header).
- Available skills are listed next. After that, a **Tasks** section is injected (see below). Then the current skill's full instructions follow.

### Tasks

List each task with:

- **Skill** — name of the skill you want to run.
- **Query** — what to ask or pass in. Add bullet points with any information that this skill might find useful.
- **Output** — what you expect (e.g. a document; the skill will add a short summary at the end).

You can add a task to **ask the user to review** (e.g. **Skill** Conductor or a review skill, **Query** “Please review the following before we proceed”, **Output** user confirmation). This is normally **essential prior to making any changes** to content that is not a plan or Research.

To run skills **concurrently**, list multiple skills in one task. To run **sequentially**, use a heading for each step (e.g. **Task 1**, **Task 2**).
```

**Injection order in system message:** (1) the above “How to use skills” block from `system.template.md`, (2) **## Available skills** (factory-built list with name + description), (3) **Tasks** content (injected after the skills section; source TBD — e.g. from user message or skill document), (4) **## Current skill** (current skill body).

**user.template.md (placeholder):**

```markdown
<user_query>
{{query}}
</user_query>
```

(At runtime replace `{{query}}` with the actual user message content.)

---

## 4. SkillRunnerFactory.vala

- **Namespace:** `OLLMcoder`
- **Extends:** `OLLMchat.Agent.Factory`
- **Role:** **Lightweight** — only creates SkillRunner instances. The factory **creates** the SkillManager (from the given skills directories) and holds `skill_filename`; it does **not** build messages or cache. Making the factory heavy was concluded to be a bad idea; the **SkillRunner** is responsible for building the system and user messages.
- **Constructor:** `SkillRunnerFactory(Gee.ArrayList<string> skills_directories, string skill_filename = "")` — creates `SkillManager(skills_directories)` and stores it; sets `skill_filename` (default `"conductor.md"`). Sets `name = "skill-runner"`, `title = "Conductor"`.
- **Override:** `create_agent(SessionBase session)` — return `new SkillRunner(this, session)`.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMcoder
{
	/**
	 * Lightweight factory: creates SkillManager and SkillRunner only. Message building lives in SkillRunner.
	 */
	public class SkillRunnerFactory : OLLMchat.Agent.Factory
	{
		public SkillManager skill_manager { get; private set; }
		public string skill_filename { get; private set; }

		public SkillRunnerFactory(Gee.ArrayList<string> skills_directories, string skill_filename = "")
		{
			this.name = "skill-runner";
			this.title = "Skills Agent";
			this.skill_manager = new SkillManager(skills_directories);
			this.skill_filename = skill_filename != "" ? skill_filename : "conductor.md";
		}

		public override OLLMchat.Agent.Base create_agent(OLLMchat.History.SessionBase session)
		{
			return new SkillRunner(this, session);
		}
	}
}
```

---

## 5. SkillRunner.vala

- **Namespace:** `OLLMcoder`
- **Extends:** `OLLMchat.Agent.Base`
- **Role:** **Responsible for building the system and user messages.** Override `send_async` to: (1) build system message (template + available skills list + current skill content), building the system message each time (no cache); (2) build user message from user template or pass-through; (3) add system and user to session/messages, filter for API roles, set is_running, customize model, yield chat_call.send. Validation gate: when building system message, call `current.validate_skills(scanned)` and throw if any missing — skill does not run.
- **Constructor:** `SkillRunner(SkillRunnerFactory factory, SessionBase session)` — call `base(factory, session)`. Runner gets `skill_manager` and `skill_filename` from the factory.
- **Override:** `send_async` — call internal `get_system_message()` and `get_user_prompt(message.content)` (runner-owned), then proceed as above. If `get_system_message()` throws (e.g. validate_skills found missing skills), the skill does not run and the error is propagated.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMcoder
{
	/**
	 * Agent that runs a single skill. Builds system message (template + available skills + current skill)
	 * and user message (template or pass-through); injects them and sends.
	 */
	public class SkillRunner : OLLMchat.Agent.Base
	{
		private string cached_user_tpl = "";
		private int64 cached_user_tpl_mtime = 0;

		public SkillRunner(SkillRunnerFactory factory, OLLMchat.History.SessionBase session)
		{
			base(factory, session);
		}

		private SkillRunnerFactory sr_factory()
		{
			return (SkillRunnerFactory) this.factory;
		}

		private string load_template(string filename)
		{
			var primary = this.sr_factory().skill_manager.skills_directories.size > 0 ? this.sr_factory().skill_manager.skills_directories.get(0) : "";
			if (primary == "") {
				return "";
			}
			var path = GLib.Path.build_filename(primary, filename);
			try {
				string contents;
				if (GLib.FileUtils.get_contents(path, out contents)) {
					return contents;
				}
			} catch (GLib.FileError e) {
				GLib.warning("SkillRunner: failed to load %s: %s", path, e.message);
			}
			return "";
		}

		private Gee.ArrayList<string> extract_available_skills_section(string body)
		{
			var names = new Gee.ArrayList<string>();
			// TODO: var doc_render = new Markdown.Document.Render(); doc_render.parse(body); use doc_render.document and skills_list() to collect list item text as names
			return names;
		}

		private string get_system_message() throws GLib.Error
		{
			var sm = this.sr_factory().skill_manager;
			string skill_filename = this.sr_factory().skill_filename;
			string result = "";
			string system_tpl = this.load_template("system.template.md");
			if (system_tpl != "") {
				result = result + system_tpl + "\n\n";
			}

			var primary = sm.skills_directories.size > 0 ? sm.skills_directories.get(0) : "";
			var current_path = primary != "" ? GLib.Path.build_filename(primary, skill_filename) : "";
			Skill current;
			try {
				current = new Skill(current_path);
				current.load();
			} catch (GLib.Error e) {
				result = result + "(Current skill file could not be loaded: " + e.message + ")";
				return result;
			}

			sm.scan();
			var missing = current.validate_skills(sm.by_name);
			if (missing.size > 0) {
				throw new GLib.FileError.INVAL("Skill references missing or unavailable skills: " + string.joinv(", ", missing.to_array()));
			}

			current.apply_skills(sm.by_name);
			result = result + "## Current skill\n\n" + current.content_with_applied_skills();
			return result;
		}

		private string get_user_prompt(string user_query)
		{
			var primary = this.sr_factory().skill_manager.skills_directories.size > 0 ? this.sr_factory().skill_manager.skills_directories.get(0) : "";
			var tpl_path = primary != "" ? GLib.Path.build_filename(primary, "user.template.md") : "";
			// Empty directories are bailed on earlier; when we reach here with tpl_path != "" we have a primary dir.
			int64 now = 0;
			if (tpl_path != "") {
				var file = GLib.File.new_for_path(tpl_path);
				if (file.query_exists()) {
					var info = file.query_info(GLib.FileAttribute.TIME_MODIFIED, GLib.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
					now = info.get_modification_time().to_unix();
				}
			}
			if (now == this.cached_user_tpl_mtime && this.cached_user_tpl != "") {
				return this.cached_user_tpl.replace("{{query}}", user_query);
			}
			string user_tpl = this.load_template("user.template.md");
			this.cached_user_tpl_mtime = now;
			this.cached_user_tpl = user_tpl;
			if (user_tpl == "") {
				return user_query;
			}
			return user_tpl.replace("{{query}}", user_query);
		}

		public override async void send_async(OLLMchat.Message message, GLib.Cancellable? cancellable = null) throws GLib.Error
		{
			var messages = new Gee.ArrayList<OLLMchat.Message>();

			string system_content = this.get_system_message();
			if (system_content != "") {
				var system_msg = new OLLMchat.Message("system", system_content);
				this.session.messages.add(system_msg);
				messages.add(system_msg);
			}

			string user_content = this.get_user_prompt(message.content);
			this.session.messages.add(new OLLMchat.Message("user", user_content));

			foreach (var msg in this.session.messages) {
				if (msg.role == "user" || msg.role == "assistant" || msg.role == "tool") {
					messages.add(msg);
				}
			}

			this.session.is_running = true;
			GLib.debug("is_running=true session %s", this.session.fid);

			if (this.session.model_usage.model_obj != null) {
				try {
					var customized_model_name = yield this.session.model_usage.model_obj.customize(
						this.connection,
						this.chat_call.options
					);
					this.chat_call.model = customized_model_name;
				} catch (GLib.Error e) {
					GLib.warning("SkillRunner.send_async: Failed to customize model '%s': %s. Using base model.",
						this.session.model_usage.model_obj.name, e.message);
				}
			} else {
				this.chat_call.model = this.session.model_usage.model;
			}

			this.chat_call.cancellable = cancellable;
			var response = yield this.chat_call.send(messages, cancellable);
		}
	}
}
```

---

## 5. meson.build (liboccoder)

Add the new sources after `Agent.vala`. Order: `Skill/PromptTemplate.vala`, then `Skill/Definition.vala` (no deps), `Skill/Manager.vala`, `Skill/Factory.vala` (uses Skill.Definition), `Skill/Runner.vala` (uses Skill.Factory). All under namespace **OLLMcoder.Skill**.

```meson
occoder_src = files([
  'BufferProvider.vala',
  # ...
  'SourceView.vala',
  'AgentFactory.vala',
  'Agent.vala',
  'Skill/PromptTemplate.vala',
  'Skill/Definition.vala',
  'Skill/Manager.vala',
  'Skill/Factory.vala',
  'Skill/Runner.vala',
  'List/SortedList.vala',
  # ...
])
```

---

## 7. Window.vala (ollmapp)

Register the SkillRunner factory in the same block where Code Assistant is registered (e.g. after `fill_tools` / before `setup_agent_dropdown`). Use default constructor so skills path is `{HOME}/gitlive/OLLMchat/resources/skills` and skill file is `conductor.md`.

```vala
			// Register CodeAssistant agent
			var code_assistant = new OLLMcoder.AgentFactory(this.project_manager);
			this.history_manager.agent_factories.set(code_assistant.name, code_assistant);

			// Register SkillRunner (Conductor) agent: factory creates SkillManager from directories
			var skills_dirs = new Gee.ArrayList<string>();
			skills_dirs.add(GLib.Path.build_filename(GLib.Environment.get_home_dir(), "gitlive", "OLLMchat", "resources", "skills"));
			var skill_runner = new OLLMcoder.SkillRunnerFactory(skills_dirs, "");
			this.history_manager.agent_factories.set(skill_runner.name, skill_runner);

			// Set up agent dropdown now that agents are registered
			this.setup_agent_dropdown();
```

---

## 7. VAPI / custom_target (occoder)

If the project uses a hand-maintained `occoder.vapi` or `custom_target` that lists sources, add the `Skill/*.vala` files in the same order as in `occoder_src`.

---

## 9. Verification

- Build: `meson compile -C build` (or equivalent) succeeds.
- Run app, open agent dropdown: entries include "Just Ask", "Coding Assistant", "Conductor".
- Select Conductor, send a message: system prompt includes (1) content of `system.template.md`, (2) a list of available skills (from the current skill document’s “Available skills” section, cross-referenced with SkillManager’s scanned list; name + description from each skill’s header), (3) the full content of the current skill. User message from `user.template.md` if present, else raw query. No crash if templates or skill file are missing (fallbacks used).
- **Validation gate:** If the current skill document references skills that are not in `skill_manager.by_name` after `scan()` (e.g. not listed or not loadable), the runner’s system-message build throws and the skill does not run; the error is surfaced to the user (e.g. “Skill references missing or unavailable skills: …”).
- Cache: after a first call to `get_system_message()` or `get_user_prompt()`, a second call without any file change returns the cached value; after touching (e.g. saving) a skill file or template, the next call rebuilds and updates the cache.

---

## References

- Plan 1.23 (Skills Agent & Conductor; “How to utilize skills”, task manager format, skill output = document + summary).
- `libollmchat/Agent/JustAsk.vala`, `JustAskFactory.vala` (minimal agent/factory).
- `liboccoder/Agent.vala`, `AgentFactory.vala` (send_async with system + user message pattern).
- `libollmchat/Agent/Base.vala` (`send_async` default, no system message).
- Skill: one class per skill file (YAML header + markdown body); no listing. SkillManager: array of skills directories, public by_path/by_name updated by scan(), scan() and by_path/by_name. SkillRunnerFactory: lightweight, creates SkillManager and SkillRunner only. SkillRunner: builds messages and caches. Available skills listed in the skill document (section “Available skills”); extracted via libocmarkdown and cross-referenced with SkillManager. Templates in primary directory (system.template.md, user.template.md).
