# 1.23.1 Skill Runner in occoder

## Coding standards (this document)

All code in this plan must follow `.cursor/rules/CODING_STANDARDS.md`. Reminder bullets:

- **Nullable types:** Avoid nullable types; use default objects/flags where possible.
- **Null checks:** Forbidden unless design explicitly requires null (e.g. external API); redesign instead of adding null checks.
- **String interpolation:** No `@"..."` except for multi-line usage/help or documentation; use concatenation or `.printf()`.
- **Temporary variables:** No one-use temporaries; no trivial aliases (except long chains 4+ steps).
- **Brace placement:** Line break for namespace/class/method braces; inline for control structures (`if (x) {`). Never one-line if/else with body — opening brace and body on separate lines.
- **`this.` prefix:** Use `this.` for instance members.
- **GLib prefix:** Use fully-qualified `GLib.*`; avoid `using` imports.
- **Property initialization:** Use `get; set; default =` or field defaults; do not set defaults in constructors.
- **Line length:** Break long lines (e.g. on `(`, on `+`, one argument per line).
- **StringBuilder:** Never use `GLib.StringBuilder` here; use `+` or `string.joinv()` or (for Skill) document mutation.
- **String building in loops:** Never build strings in a loop with `+=`; use `string.joinv(sep, array)` or `string.nfill()`/`replace()`.
- **ArrayList for strings:** When building strings to join, use `string[]` and `string.joinv()`, not `Gee.ArrayList<string>`.
- **Character looping:** Avoid; prefer string methods and `GLib.Regex`.
- **Gee.HashMap / Gee.ArrayList:** Use `.set()`/`.get()` and `.add()`/`.get()`, not `[]` accessors.
- **Reducing nesting:** Prefer early returns, avoid else when possible.
- **Switch vs if/else if:** Use `switch/case` for long chains.
- **Debug / warning statements:** Do not include class or method names in `GLib.debug()` or `GLib.warning()` messages; file and line are logged automatically. Use user-friendly text for UI/warnings (e.g. "ui-warning" message role).
- **SQL (if any):** No table aliases; full table names (see user rules for joinAdd exception).

## Overview

Subplan of 1.23: implement the **SkillRunner** agent and **SkillRunnerFactory** in liboccoder, plus a **Skill** class (one skill file: YAML header + markdown body), a **SkillManager** (holds an array of skills directories and lists available skills by scanning them), and **templates** in the skills folder. Skills directories are an **array** (initially one). Which skills the current skill *can use* is declared **in the skill document** in a section (e.g. “## Available skills”); we use the **markdown parser** (libocmarkdown) to extract that section, then **cross-reference** with the skills actually present (from SkillManager scanning the directories). The system message is built from: (1) `system.template.md`, (2) the cross-referenced available-skills list, (3) the current skill’s full content. The **SkillRunner** builds both messages; **SkillRunnerFactory** is lightweight (creates SkillManager and runners only). First supported skill: Conductor (`conductor.md`).

## Status

**PLAN** – Implementation not started.

## Dependencies

- Plan 1.23 (Skills Agent & Conductor).
- Existing: `OLLMchat.Agent.Factory`, `OLLMchat.Agent.Base`, `OLLMcoder.Agent` / `OLLMcoder.AgentFactory` (reference only; no code reuse).
- libocmarkdown: used to parse the current skill’s markdown body via `Markdown.Document.Render.parse(body)` and extract the “Available skills” section (by heading) for cross-reference with SkillManager.

## Files to add or modify

**liboccoder/Skill/** uses namespace **OLLMcoder.Skill**. Classes: **PromptTemplate** (Skill/PromptTemplate.vala), **Definition** (skill file: YAML + markdown body; Skill/Definition.vala), **Manager** (scans dirs; Skill/Manager.vala), **Factory** (creates runners; Skill/Factory.vala), **Runner** (builds messages; Skill/Runner.vala).

| Action | File |
|--------|------|
| Add | `liboccoder/Skill/` folder — namespace **OLLMcoder.Skill**. |
| Add | `liboccoder/Skill/PromptTemplate.vala` (OLLMcoder.Skill.PromptTemplate) |
| Add | `liboccoder/Skill/Definition.vala` (skill file: YAML + markdown body; was Skill.vala) |
| Add | `liboccoder/Skill/Manager.vala` (scans directories; was SkillManager.vala) |
| Add | `liboccoder/Skill/Factory.vala` (creates runners; was SkillRunnerFactory.vala) |
| Add | `liboccoder/Skill/Runner.vala` (builds messages; was SkillRunner.vala) |
| Add | `resources/skills/skill.template.md` (single template: system part above `---`, user part below) |
| Edit | `libollmchat/Prompt/Template.vala` (add base class; see §3 Prompt template) |
| Edit | `libollmchat/Agent/Base.vala` (add **protected virtual async void fill_model()** — session model logic; on customize failure send **Message("ui-warning", user-friendly text)** and set model; send_async calls **yield this.fill_model()**) |
| Edit | `libollmchat/Message.vala` (add role **"ui-warning"**; is_ui_visible) |
| Edit | `libollmchatgtk/ChatWidget.vala` (handle **ui-warning** in on_message_created like **ui**) |
| Edit | `libocvector/Indexing/PromptTemplate.vala` (extend OLLMchat.Prompt.Template) |
| Edit | `liboccoder/meson.build` (add Skill/PromptTemplate, Skill/Definition, Skill/Manager, Skill/Factory, Skill/Runner) |
| Edit | `docs/meson.build` — when adding new library sources, **valadoc input list must be updated** or the docs build fails. Add all new `.vala` files in dependency order. For this plan: add `Skill/PromptTemplate.vala`, `Skill/Definition.vala`, `Skill/Manager.vala`, `Skill/Factory.vala`, `Skill/Runner.vala` to the liboccoder section (after `Agent.vala`, in that order). |
| Edit | `ollmapp/Window.vala` (register SkillRunner factory) |
| Edit | `libocmarkdown/document/Document.vala` (heading cache) |
| Edit | `libocmarkdown/document/Node.vala` (next() method) |

---

## 0. libocmarkdown Document and Node (for “Available skills” lookup)

- **RenderBase (RenderBase.vala):** **`parse(string text)`** — parses a full document in one call (equivalent to `start()`, `add(text, true)`, `flush()`). Use via a document renderer: `var doc_render = new Markdown.Document.Render(); doc_render.parse(body); document = doc_render.document;` (e.g. in Skill.load() and Skill.apply_skills()).
- **Document (document/Document.vala):** Add a cache **heading name → Block**: e.g. `Gee.HashMap<string, Block> headings`. Key is the heading text (e.g. `"Available skills"`); value is the Block node for that heading (kind HEADING_1..6). Populate the cache when the document is built (e.g. in the document render path when a heading is adopted) or lazily on first access by walking top-level children and adding any block whose kind is HEADING_* with key = that block’s text content (flattened from its Format children). Normalization of the key (e.g. strip) is up to the implementation; lookup will use the same normalization. Add **`Node create(FormatType type, string text = "")`** — returns a new node (Block for block kinds e.g. PARAGRAPH, Format for inline kinds) with uid assigned from this.uid_count and uid_count incremented; when type is TEXT or when text is non-empty for a format that carries text, set the node’s text. Returns a node that the caller can adopt.
- **Node (document/Node.vala):** Add **`Node? next()`** — returns the next sibling in the parent’s `children` list, or `null` if this node is last or has no parent. Add **`string text_content()`** — returns the flattened text of this node (e.g. for a ListItem: walk children, take first Block with kind PARAGRAPH or Format subtree, concatenate TEXT and other inline content into a single line string). Add **`ListItem append_li()`** — on a node that can contain a nested list (e.g. ListItem): if the last child is a List, use it; otherwise create a List and adopt it. Create a new ListItem, adopt it into that List, return the ListItem (uids from document). Add **`void append_raw(string raw)`** — appends a child node representing the raw markdown string (e.g. parse as inline / one paragraph and adopt as child; implementation builds the Block/Format tree for the string). So original list "- research" "- plan" becomes "- research" with nested "- ***When to use*** … description …", "- plan" with same.
- **Skill plan usage:** `skills_list()` uses the document’s heading cache and `next()`. Skill names are collected inline from that list by calling `item.text_content()` on each ListItem.

---

## 1. Skill.Definition (Skill/Definition.vala)

- **Namespace:** `OLLMcoder.Skill`
- **Role:** Represents a single skill file: path, YAML header, markdown body, and a **parsed markdown document** (from libocmarkdown). Can validate referenced skills against an array of available skills and render the skill content with a skills list (descriptions) appended. No listing logic; that lives in Manager.
- **Constructor:** `Definition(string path)` — caller builds the path and passes it; Definition only stores this `path`. Does **not** read the file. Initializes empty `header`, `body`, `full_content`, and `document`.
- **load() throws GLib.Error:** Reads the file, validates format (must start with `---` and have a closing `---`), splits into header and body, parses key-value lines into `header` (skips lines where the value is empty or whitespace-only), sets `body` and `full_content`. **Creates the markdown document** by calling `Markdown.Document.Render.parse(this.body)` and storing `doc_render.document` so we can later extract sections (e.g. “Available skills”) and validate. Validates that `header` contains non-empty `"name"` and non-empty `"description"` (skills are not valid without a description). Throws on any failure. Header may also contain **`tools`** (space-separated list of tool names) and **`model`** (model name).
- **Properties:** `string path`, `string body`, `string full_content`, `Gee.HashMap<string, string> header`, **`int64 mtime`** (file modification time, set in load()), and **`Markdown.Document.Document document`** — the parsed body as a document.
- **validate_skills(Gee.HashMap<string, Definition> available):** Takes a map of skill name → Definition (e.g. Manager.by_name after scan()). Validates that any skills this document references (e.g. in its “Available skills” section) are in that map. Returns a list of **missing** skill names. If the list is non-empty, that is an **error condition** — the caller must **not run** the skill; validate_skills is the gate that prevents running when required skills are not listed/available.
- **apply_skills(Gee.HashMap<string, Definition> available):** **First re-parses the document** via `doc_render.parse(this.body)`; then finds the list under the “Available skills” heading and **append** a nested list item with "***When to use*** " + that skill's description for each list item. Original item label unchanged. Uses append_li() then append_raw().
- **to_markdown():** Returns the skill content for the system message: **this.document** rendered to markdown. Call after **apply_skills()** so the document includes the appended “When to use” descriptions. Implementation: `return this.document.to_markdown();` Document (libocmarkdown) must provide **to_markdown()**.
- **No** static `list_available` — listing is done by **SkillManager**.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMcoder.Skill
{
	/**
	 * One skill file: YAML header (key-value map) and markdown body.
	 * Constructor only stores path; call load() to read and parse.
	 * Header is stored in a hash map; "name" etc. are read from the map after load.
	 */
	public class Definition : Object
	{
		public string path { get; private set; default = ""; }
		public string body { get; private set; default = ""; }
		public string full_content { get; private set; default = ""; }
		public Gee.HashMap<string, string> header { get; private set; default = new Gee.HashMap<string, string>(); }
		/** File modification time; set in load(). */
		public int64 mtime { get; private set; default = 0; }
		/** Parsed body as a markdown document (libocmarkdown). */
		public Markdown.Document.Document document { get; private set; }

		public Definition(string path)
		{
			this.path = path;
		}

		/**
		 * Load and parse the skill file. Validates content; throws on read or validation failure.
		 */
		public void load() throws GLib.Error
		{
			string contents = "";
			if (!GLib.FileUtils.get_contents(this.path, out contents)) {
				throw new GLib.FileError.FAILED("Skill: could not read %s".printf(this.path));
			}

			this.full_content = contents;

			// Require valid header: file must start with --- and have a closing ---
			if (!contents.has_prefix("---")) {
				throw new GLib.FileError.INVAL("Skill: %s does not start with YAML header (---)".printf(this.path));
			}
			var parts = contents.split("\n---", 2);
			if (parts.length < 2) {
				throw new GLib.FileError.INVAL("Skill: %s has no closing header delimiter (---)".printf(this.path));
			}
			string header_text = parts[0].substring(3).strip();
			this.body = parts[1].strip();

			this.header.clear();
			foreach (var line in header_text.split("\n")) {
				var stripped = line.strip();
				var colon = stripped.index_of(":");
				if (colon > 0) {
					var key = stripped.substring(0, colon).strip();
					var value = stripped.substring(colon + 1).strip();
					if (value != "") {
						this.header.set(key, value);
					}
				}
			}

			// Validate: require non-empty "name" so the skill can be listed and identified
			if (!this.header.has_key("name") || this.header.get("name") == "") {
				throw new GLib.FileError.INVAL("Skill: %s has no valid 'name' in header".printf(this.path));
			}
			// Validate: require non-empty "description" — skills are not valid without a description
			if (!this.header.has_key("description") || this.header.get("description") == "") {
				throw new GLib.FileError.INVAL("Skill: %s has no valid 'description' in header".printf(this.path));
			}

			// Store file mtime for cache invalidation (file exists — we just read it)
			var file = GLib.File.new_for_path(this.path);
			var info = file.query_info(GLib.FileAttribute.TIME_MODIFIED, GLib.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
			this.mtime = info.get_modification_time().to_unix();

			// Create markdown document from body (libocmarkdown Document.Render)
			var doc_render = new Markdown.Document.Render();
			doc_render.parse(this.body);
			this.document = doc_render.document;
		}

		/**
		 * Validates that skills referenced in this document are in the available map (key = skill name).
		 * Returns list of skill names that are referenced but not in available.
		 * If the list is non-empty, caller must not run the skill (error condition).
		 */
		public Gee.ArrayList<string> validate_skills(Gee.HashMap<string, Skill> available)
		{
			var list = this.skills_list();
			if (list == null) {
				return new Gee.ArrayList<string>();
			}
			var missing = new Gee.ArrayList<string>();
			foreach (var child in list.children) {
				if (!(child is Markdown.Document.ListItem)) {
					continue;
				}
				var name = ((Markdown.Document.ListItem) child).text_content();
				if (!available.has_key(name)) {
					missing.add(name);
				}
			}
			return missing;
		}

		/**
		 * First re-parses the document from this.body (refresh from memory); then finds the list
		 * under "Available skills" and appends a nested list item with "***When to use*** " + description
		 * for each list item. Original item label unchanged.
		 */
		public void apply_skills(Gee.HashMap<string, Definition> available)
		{
			var doc_render = new Markdown.Document.Render();
			doc_render.parse(this.body);
			this.document = doc_render.document;
			var target_list = this.skills_list();
			if (target_list == null) {
				return;
			}
			foreach (var child in target_list.children) {
				if (!(child is Markdown.Document.ListItem)) {
					continue;
				}
				var item = (Markdown.Document.ListItem) child;
				item.append_li().append_raw(
					"***When to use*** "
					+ available.get(item.text_content()).header.get("description"));
			}
		}

		/** List block under "Available skills" heading in this.document (heading cache + next()). */
		private Markdown.Document.List? skills_list()
		{
			var heading = this.document.headings.get("Available skills");
			if (heading == null) {
				return null;
			}
			var next_block = heading.next();
			return next_block is Markdown.Document.List ? (Markdown.Document.List) next_block : null;
		}

		/**
		 * Returns this.document rendered to markdown.
		 * Call after apply_skills() so the document includes appended descriptions.
		 */
		public string to_markdown()
		{
			return this.document.to_markdown();
		}
	}
}
```

---

## 2. Manager (Skill/Manager.vala)

- **Namespace:** `OLLMcoder.Skill`
- **Role:** Keeps an eye on all skills: holds an **array of directories** (skills base paths) and can list the skills actually present by scanning those directories. Initially we use one directory; the type is an array so we can add more later.
- **Constructor:** `Manager(Gee.ArrayList<string> skills_directories)` — takes the list of base paths (e.g. one element: `{HOME}/gitlive/OLLMchat/resources/skills`). Caller builds the array.
- **Properties:** `by_path` and `by_name` — public maps **path → Definition** and **name → Definition**, updated in place by `scan()`. Call `scan()` then read the properties.
- **Method:** `void scan() throws GLib.Error` — updates by_path/by_name in place. Enumerate with `standard::name,standard::type,time::modified`; for each `.md` file (exclude templates), get mtime from enumerator’s FileInfo; if already in `this.by_path` and mtime matches cached skill, skip; else load and set. No separate file stat; no purge.
- **Removed:** get_system_inputs_max_mtime and get_file_mtime (not needed).

- **Templates location:** The first directory in the array (`skills_directories.get(0)` when size > 0) is used for the single template file `skill.template.md`.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 * (Same license as Skill.vala)
 */

namespace OLLMcoder.Skill
{
	/**
	 * Holds an array of skills directories and two maps: path → Definition and name → Definition.
	 * One scan populates both; each Definition stores its own mtime.
	 */
	public class Manager : Object
	{
		public Gee.ArrayList<string> skills_directories { get; private set; default = new Gee.ArrayList<string>(); }
		public Gee.HashMap<string, Definition> by_path { get; set; default = new Gee.HashMap<string, Definition>(); }
		public Gee.HashMap<string, Definition> by_name { get; set; default = new Gee.HashMap<string, Definition>(); }

		public Manager(Gee.ArrayList<string> skills_directories)
		{
			this.skills_directories = skills_directories;
		}

		public void scan() throws GLib.Error
		{
			var keys_before = new Gee.ArrayList<string>();
			keys_before.add_all(this.by_path.keys);
			foreach (var skills_base_path in this.skills_directories) {
				var dir = GLib.File.new_for_path(skills_base_path);
				if (!dir.query_exists()) {
					continue;
				}
				var enumerator = dir.enumerate_children(
					"standard::name,standard::type,time::modified",
					GLib.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
				GLib.FileInfo? info;
				while ((info = enumerator.next_file(null)) != null) {
					var name = info.get_name();
					if (!name.has_suffix(".md")) {
						continue;
					}
					// TODO: temporary until we work out how to handle templates (exclude from skills list)
					if (name == "skill.template.md") {
						continue;
					}
					var skill_path = GLib.Path.build_filename(skills_base_path, name);
					int64 file_mtime = (int64) info.get_modification_time().tv_sec;
					if (this.by_path.has_key(skill_path)
						&& file_mtime == this.by_path.get(skill_path).mtime) {
						keys_before.remove(skill_path);
						continue;
					}
					var skill = new Definition(skill_path);
					try {
						skill.load();
						this.by_path.set(skill_path, skill);
						this.by_name.set(skill.header.get("name"), skill);
						keys_before.remove(skill_path);
					} catch (GLib.Error e) {
						GLib.warning("Skill.Manager: skip %s: %s", name, e.message);
					}
				}
			}
			foreach (var path in keys_before) {
				var skill = this.by_path.get(path);
				this.by_path.unset(path);
				this.by_name.unset(skill.header.get("name"));
			}
		}
	}
}
```

---

## 3. Templates in skills folder

- **Location:** `resources/skills/` (same as plan 1.23; path for dev: `{HOME}/gitlive/OLLMchat/resources/skills`). May be moved later.
- **skill.template.md** — Single template file. Content above `---` is the system message (summary of how to deal with skills, etc.); content below `---` is the user message template (e.g. wrap the query). Load once; use **system_fill()** for system and **fill()** for user.

- **Prompt template (base in libollmchat):** **`OLLMchat.Prompt.Template`** (`libollmchat/Prompt/Template.vala`) — base class with **`source`** (default `"resource://"`), **`base_dir`**, **`filename`** (renamed from resource_path). **`exists() throws GLib.Error`**: if `source == "resource://"` returns `true`; otherwise checks filesystem and returns whether the file exists. **`load()`** calls `exists()` first and throws if not found; then loads from resource URI or path and splits on `---` into `system_message` and `user_template`. **`fill(...)`** replaces `{key}` placeholders in **user_template** from varargs key-value pairs. **`system_fill(...)`** does the same for **system_message** (same signature and behaviour). **OLLMvector.Indexing.PromptTemplate** (libocvector) extends it and sets `source = "resource://"`, `base_dir = "/ocvector"`; constructor takes `filename` only (e.g. `"analysis-prompt.txt"`). **`OLLMcoder.Skill.PromptTemplate`** (liboccoder `Skill/PromptTemplate.vala`) extends it and sets `source = "file://"`, `base_dir` to a hard-coded path (e.g. `{HOME}/gitlive/OLLMchat/resources/skills` for now); constructor is **`PromptTemplate(string filename)`** only (e.g. `"skill.template.md"`). One template: `var tpl = new SkillPromptTemplate(primary, "skill.template.md"); tpl.load();` then **tpl.system_fill("current_skill", ...)** for system and **tpl.fill("query", user_query)** for user.

**skill.template.md (placeholder):** Single file. System part (above `---`) contains **`{current_skill}`** only. User part (below `---`) contains **`{query}`**. Runner loads one template and calls **tpl.system_fill("current_skill", this.skill.to_markdown(), null)** for system and **tpl.fill("query", user_query)** for user. (Available skills are in the skill document after apply_skills; no separate placeholder.)

```markdown
## How to use skills

- Pick a skill from the **descriptions** listed below (name and description from each skill's YAML header).
- Available skills are listed in the current skill document. After that, a **Tasks** section is injected (see below). Then the current skill's full instructions follow.

### Tasks

List each task with:

- **Skill** — name of the skill you want to run.
- **Query** — what to ask or pass in. Add bullet points with any information that this skill might find useful.
- **Output** — what you expect (e.g. a document; the skill will add a short summary at the end).

You can add a task to **ask the user to review** (e.g. **Skill** Conductor or a review skill, **Query** “Please review the following before we proceed”, **Output** user confirmation). This is normally **essential prior to making any changes** to content that is not a plan or Research.

To run skills **concurrently**, list multiple skills in one task. To run **sequentially**, use a heading for each step (e.g. **Task 1**, **Task 2**).

## Current skill

{current_skill}
```

**Injection order in system message:** Filled by template via **system_fill**: (1) the above “How to use skills” block, (2) **## Current skill** via `{current_skill}`. Tasks content source TBD (e.g. from user message or skill document).

**User part (below `---` in same file):**

```markdown
<user_query>
{query}
</user_query>
```

---

## 4. Factory (Skill/Factory.vala)

- **Namespace:** `OLLMcoder.Skill`
- **Extends:** `OLLMchat.Agent.Factory`
- **Role:** **Lightweight** — only creates Runner instances. The factory **creates** the Manager (from the given skills directories) and holds **`skill_name`** (which skill to run, by name); it does **not** build messages or cache. Making the factory heavy was concluded to be a bad idea; the **Runner** is responsible for building the system and user messages.
- **Constructor:** `Factory(Gee.ArrayList<string> skills_directories, string skill_name = "")` — creates `Manager(skills_directories)` and stores it; sets **`skill_name`** (default `"task_creator"`, i.e. the skill formerly called conductor). Sets `name = "skill-runner"`, `title = "Skills Agent"`.
- **Override:** `create_agent(SessionBase session)` — return `new Runner(this, session)`.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMcoder.Skill
{
	/**
	 * Lightweight factory: creates Manager and Runner only. Message building lives in Runner.
	 */
	public class Factory : OLLMchat.Agent.Factory
	{
		public Manager skill_manager { get; private set; }
		public string skill_name { get; private set; }

		public Factory(Gee.ArrayList<string> skills_directories, string skill_name = "")
		{
			this.name = "skill-runner";
			this.title = "Skills Agent";
			this.skill_manager = new Manager(skills_directories);
			this.skill_name = skill_name != "" ? skill_name : "task_creator";
		}

		public override OLLMchat.Agent.Base create_agent(OLLMchat.History.SessionBase session)
		{
			return new Runner(this, session);
		}
	}
}
```

---

## 5. Runner (Skill/Runner.vala)

- **Namespace:** `OLLMcoder.Skill`
- **Extends:** `OLLMchat.Agent.Base`
- **Role:** **Responsible for building the system and user messages.** Override `send_async` to: (1) resolve and set **`this.skill`** from the manager (scan, then by_name.get(skill_name)); (2) build system message using **this.skill** (system_message); (3) build user message from user template or pass-through; (4) call **fill_model()** to set chat_call.model; (5) add system and user to session/messages, filter for API roles, set is_running, yield chat_call.send. Validation gate: system_message() calls skill.validate_skills; if any missing, error is sent as UI message.
- **Property:** **`skill`** — `public Definition skill { get; private set; }` (set at start of send_async from manager; used by system_message() and fill_model).
- **fill_model() (override):** **OLLMchat.Agent.Base** (libollmchat) gets **protected virtual async void fill_model()** as the default: sets **this.chat_call.model** from session (model_obj == null → model_usage.model and return; else try model_obj.customize(), on failure send **session.add_message(new Message("ui-warning", user_friendly_text))** and set chat_call.model = model_usage.model). User-friendly text e.g. **"You selected this model, however we were unable to use it. Using the default model instead."** — no technical "failed to load". Do **not** use GLib.warning with class/method (see coding standards: file/line are logged). **Message** supports role **"ui-warning"** (is_ui_visible; displayed like "ui"). Base.send_async calls **yield this.fill_model()**. **Runner** overrides: if skill header has **"model"** and it is available (connection.models), set model and add_message **"skill using XXX model."** and return; **if skill requested a model but it was not available**, send **session.add_message(Message("ui-warning", "The skill requested the model \"…\", but it was not available. Using your selected model instead."))** then **yield base.fill_model()**; else **yield base.fill_model()**.
- **Constructor:** `Runner(Factory factory, SessionBase session)` — call `base(factory, session)`. Runner gets `skill_manager` and **`skill_name`** from the factory (which skill to run; assume it is present in the manager after scan).
- **fill_tools():** Skill header may contain **tools:** with a **space-separated list** of tool names (header parser skips empty values, so if "tools" is present it is non-empty). If **no "tools" key**, **this.chat_call.tools.clear()** (do not add tools). Otherwise parse the value (e.g. .strip().split(" ")), for each name: if **this.session.manager.tools.has_key(name)** add that tool to **this.chat_call.tools**; else **this.session.add_message(new Message("ui-warning", "The skill requested the tool \"…\", but it was not available."))**. Call **fill_tools()** in send_async after this.skill is set (e.g. after fill_model).
- **Override:** `send_async` — set this.skill, then system_message(), user_prompt(), fill_model(), **fill_tools()**, then send. Catch errors from system_message() and chat_call.send; send as UI message via **this.session.add_message(new Message("ui", e.message))** and set is_running = false.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMcoder.Skill
{
	/**
	 * Agent that runs a single skill. Builds system message (template + available skills + current skill)
	 * and user message (template or pass-through); injects them and sends.
	 */
	public class Runner : OLLMchat.Agent.Base
	{
		public Definition skill { get; private set; }
		private Factory sr_factory {
			get { return (Factory) this.factory; }
		}
		private static PromptTemplate? tpl = null;

		static construct
		{
			tpl = new PromptTemplate("skill.template.md");
			tpl.load();
		}

		public Runner(Factory factory, OLLMchat.History.SessionBase session)
		{
			base(factory, session);
		}

		

		private Gee.ArrayList<string> extract_available_skills_section(string body)
		{
			var names = new Gee.ArrayList<string>();
			// TODO: var doc_render = new Markdown.Document.Render(); doc_render.parse(body); use doc_render.document and skills_list() to collect list item text as names
			return names;
		}

		private string system_message() throws GLib.Error
		{
			var sm = this.sr_factory.skill_manager;
			var missing = this.skill.validate_skills(sm.by_name);
			if (missing.size > 0) {
				throw new GLib.FileError.INVAL("Skill references missing or unavailable skills: " + string.joinv(", ", missing.to_array()));
			}

			this.skill.apply_skills(sm.by_name);
			return tpl.system_fill("current_skill", this.skill.to_markdown(), null);
		}

		public override async void fill_model()
		{
			if (this.skill.header.has_key("model")) {
				var skill_model = this.skill.header.get("model").strip();
				if (skill_model != "" && this.connection.models.has_key(skill_model)) {
					this.chat_call.model = skill_model;
					this.session.add_message(new OLLMchat.Message("ui", "skill using " + skill_model + " model."));
					return;
				}
				if (skill_model != "") {
					this.session.add_message(new OLLMchat.Message("ui-warning",
						"The skill requested the model \"" + skill_model + "\", but it was not available. Using your selected model instead."));
				}
			}
			yield base.fill_model();
		}

		private string user_prompt(string user_query)
		{
			return tpl.fill("query", user_query);
		}

		private void fill_tools()
		{
			this.chat_call.tools.clear();
			if (!this.skill.header.has_key("tools")) {
				return;
			}
			foreach (var name in this.skill.header.get("tools").split(" ")) {
				var tool_name = name.strip();
				if (tool_name == "") {
					continue;
				}
				if (!this.session.manager.tools.has_key(tool_name)) {
					this.session.add_message(new OLLMchat.Message("ui-warning",
						"The skill requested the tool \"" + tool_name + "\", but it was not available."));
					continue;
				}
				this.chat_call.tools.set(tool_name, this.session.manager.tools.get(tool_name));
			}
		}

		public override async void send_async(OLLMchat.Message message, GLib.Cancellable? cancellable = null)
		{
			this.sr_factory.skill_manager.scan();
			this.skill = this.sr_factory.skill_manager.by_name.get(
				this.sr_factory.skill_name);

			var messages = new Gee.ArrayList<OLLMchat.Message>();

			string system_content;
			try {
				system_content = this.system_message();
			} catch (GLib.Error e) {
				this.session.add_message(new OLLMchat.Message("ui", e.message));
				this.session.is_running = false;
				return;
			}

			if (system_content != "") {
				var system_msg = new OLLMchat.Message("system", system_content);
				this.session.messages.add(system_msg);
				messages.add(system_msg);
			}

			string user_content = this.user_prompt(message.content);
			this.session.messages.add(new OLLMchat.Message("user", user_content));

			foreach (var msg in this.session.messages) {
				if (msg.role == "user" || msg.role == "assistant" || msg.role == "tool") {
					messages.add(msg);
				}
			}

			this.session.is_running = true;
			GLib.debug("is_running=true session %s", this.session.fid);

			yield this.fill_model();
			this.fill_tools();

			this.chat_call.cancellable = cancellable;
			try {
				var response = yield this.chat_call.send(messages, cancellable);
			} catch (GLib.Error e) {
				this.session.add_message(new OLLMchat.Message("ui", e.message));
				this.session.is_running = false;
			}
		}
	}
}
```

---

## 5. meson.build (liboccoder)

Add the new sources after `Agent.vala`. Order: `Skill/PromptTemplate.vala`, then `Skill/Definition.vala` (no deps), `Skill/Manager.vala`, `Skill/Factory.vala` (uses Skill.Definition), `Skill/Runner.vala` (uses Skill.Factory). All under namespace **OLLMcoder.Skill**.

**Valadoc (docs/meson.build):** When adding new library sources, the valadoc custom target in `docs/meson.build` must be updated or the docs build fails. Add each new source file to the `input: files(...)` list in the same dependency order as in the library’s meson.build (for this plan: add the five `Skill/*.vala` files to the liboccoder section, after `Agent.vala`).

```meson
occoder_src = files([
  'BufferProvider.vala',
  # ...
  'SourceView.vala',
  'AgentFactory.vala',
  'Agent.vala',
  'Skill/PromptTemplate.vala',
  'Skill/Definition.vala',
  'Skill/Manager.vala',
  'Skill/Factory.vala',
  'Skill/Runner.vala',
  'List/SortedList.vala',
  # ...
])
```

---

## 7. Window.vala (ollmapp)

Register the SkillRunner factory in the same block where Code Assistant is registered (e.g. after `fill_tools` / before `setup_agent_dropdown`). Use default constructor so skills path is `{HOME}/gitlive/OLLMchat/resources/skills` and skill_name defaults to `"task_creator"` (the conductor/task-creation skill).

```vala
			// Register CodeAssistant agent
			var code_assistant = new OLLMcoder.AgentFactory(this.project_manager);
			this.history_manager.agent_factories.set(code_assistant.name, code_assistant);

			// Register SkillRunner (Conductor) agent: factory creates SkillManager from directories
			var skills_dirs = new Gee.ArrayList<string>();
			skills_dirs.add(GLib.Path.build_filename(GLib.Environment.get_home_dir(), "gitlive", "OLLMchat", "resources", "skills"));
			var skill_runner = new OLLMcoder.SkillRunnerFactory(skills_dirs, "");
			this.history_manager.agent_factories.set(skill_runner.name, skill_runner);

			// Set up agent dropdown now that agents are registered
			this.setup_agent_dropdown();
```

---

## 7. VAPI / custom_target (occoder)

If the project uses a hand-maintained `occoder.vapi` or `custom_target` that lists sources, add the `Skill/*.vala` files in the same order as in `occoder_src`.

---

## 9. Verification

- Build: `meson compile -C build` (or equivalent) succeeds.
- Run app, open agent dropdown: entries include "Just Ask", "Coding Assistant", "Conductor".
- Select Conductor (task_creator), send a message: system prompt includes (1) content of `skill.template.md` (system part) (from the current skill document’s “Available skills” section, cross-referenced with SkillManager’s scanned list; name + description from each skill’s header), (3) the current skill content via **skill.to_markdown()** (document rendered to markdown). User message from `user.template.md` if present, else raw query. Skill is looked up by **skill_name** from the factory (assume present after scan).
- **Validation gate:** If the current skill document references skills that are not in `skill_manager.by_name` after `scan()` (e.g. not listed or not loadable), the runner’s system-message build throws and the skill does not run; the error is surfaced to the user (e.g. “Skill references missing or unavailable skills: …”).
- Cache: after a first call to `system_message()` or `user_prompt()`, a second call without any file change returns the cached value; after touching (e.g. saving) a skill file or template, the next call rebuilds and updates the cache.

---

## References

- Plan 1.23 (Skills Agent & Conductor; “How to utilize skills”, task manager format, skill output = document + summary).
- `libollmchat/Agent/JustAsk.vala`, `JustAskFactory.vala` (minimal agent/factory).
- `liboccoder/Agent.vala`, `AgentFactory.vala` (send_async with system + user message pattern).
- `libollmchat/Agent/Base.vala` (`send_async` default, no system message).
- Skill: one class per skill file (YAML header + markdown body); **to_markdown()** returns document.to_markdown(). SkillManager: by_path/by_name updated by scan(). SkillRunnerFactory: holds **skill_name** (default "task_creator"), creates SkillManager and SkillRunner. SkillRunner: gets skill from manager by skill_name (assume present), apply_skills(), then **tpl.system_fill("current_skill", skill.to_markdown(), null)**. Single template in primary directory (skill.template.md); system_fill for system, fill for user.
