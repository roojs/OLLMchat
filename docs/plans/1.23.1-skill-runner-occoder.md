# 1.23.1 Skill Runner in occoder

## Coding standards (this document)

All code in this plan must follow `.cursor/rules/CODING_STANDARDS.md`. Reminder bullets:

- **Nullable types:** Avoid nullable types; use default objects/flags where possible.
- **Null checks:** Forbidden unless design explicitly requires null (e.g. external API); redesign instead of adding null checks.
- **String interpolation:** No `@"..."` except for multi-line usage/help or documentation; use concatenation or `.printf()`.
- **Temporary variables:** No one-use temporaries; no trivial aliases (except long chains 4+ steps).
- **Brace placement:** Line break for namespace/class/method braces; inline for control structures (`if (x) {`). Never one-line if/else with body — opening brace and body on separate lines.
- **`this.` prefix:** Use `this.` for instance members.
- **GLib prefix:** Use fully-qualified `GLib.*`; avoid `using` imports.
- **Property initialization:** Use `get; set; default =` or field defaults; do not set defaults in constructors.
- **Line length:** Break long lines (e.g. on `(`, on `+`, one argument per line).
- **StringBuilder:** Never use `GLib.StringBuilder` here; use `+` or `string.joinv()` or (for Skill) document mutation.
- **String building in loops:** Never build strings in a loop with `+=`; use `string.joinv(sep, array)` or `string.nfill()`/`replace()`.
- **ArrayList for strings:** When building strings to join, use `string[]` and `string.joinv()`, not `Gee.ArrayList<string>`.
- **Character looping:** Avoid; prefer string methods and `GLib.Regex`.
- **Gee.HashMap / Gee.ArrayList:** Use `.set()`/`.get()` and `.add()`/`.get()`, not `[]` accessors.
- **Reducing nesting:** Prefer early returns, avoid else when possible.
- **Switch vs if/else if:** Use `switch/case` for long chains.
- **Debug statements:** Do not prefix with class/function names; debug output already includes location.
- **SQL (if any):** No table aliases; full table names (see user rules for joinAdd exception).

## Overview

Subplan of 1.23: implement the **SkillRunner** agent and **SkillRunnerFactory** in liboccoder, plus a **Skill** class (one skill file: YAML header + markdown body), a **SkillManager** (holds an array of skills directories and lists available skills by scanning them), and **templates** in the skills folder. Skills directories are an **array** (initially one). Which skills the current skill *can use* is declared **in the skill document** in a section (e.g. “## Available skills”); we use the **markdown parser** (libocmarkdown) to extract that section, then **cross-reference** with the skills actually present (from SkillManager scanning the directories). The system message is built from: (1) `system.template.md`, (2) the cross-referenced available-skills list, (3) the current skill’s full content. The **SkillRunner** builds both messages; **SkillRunnerFactory** is lightweight (creates SkillManager and runners only). First supported skill: Conductor (`conductor.md`).

## Status

**PLAN** – Implementation not started.

## Dependencies

- Plan 1.23 (Skills Agent & Conductor).
- Existing: `OLLMchat.Agent.Factory`, `OLLMchat.Agent.Base`, `OLLMcoder.Agent` / `OLLMcoder.AgentFactory` (reference only; no code reuse).
- libocmarkdown: used to parse the current skill’s markdown body and extract the “Available skills” section (by heading) for cross-reference with SkillManager.

## Files to add or modify

| Action | File |
|--------|------|
| Add | `liboccoder/Skill.vala` |
| Add | `liboccoder/SkillManager.vala` |
| Add | `liboccoder/SkillRunnerFactory.vala` |
| Add | `liboccoder/SkillRunner.vala` |
| Add | `resources/skills/system.template.md` |
| Add | `resources/skills/user.template.md` |
| Edit | `liboccoder/meson.build` (add Skill, SkillRunnerFactory, SkillRunner) |
| Edit | `ollmapp/Window.vala` (register SkillRunner factory) |

---

## 1. Skill class (Skill.vala)

- **Namespace:** `OLLMcoder`
- **Role:** Represents a single skill file: path, YAML header, markdown body, and a **parsed markdown document** (from libocmarkdown). Can validate referenced skills against an array of available skills and render the skill content with a skills list (descriptions) appended. No listing logic; that lives in SkillManager.
- **Constructor:** `Skill(string path)` — caller builds the path and passes it; Skill only stores this `path`. Does **not** read the file. Initializes empty `header`, `body`, `full_content`, and `document`.
- **load() throws GLib.Error:** Reads the file, validates format (must start with `---` and have a closing `---`), splits into header and body, parses key-value lines into `header`, sets `body` and `full_content`. **Creates the markdown document** by parsing the body with the markdown parser and document renderer (libocmarkdown: Parser + Markdown.Document.Render); store the resulting document so we can later extract sections (e.g. “Available skills”) and validate. Validates that `header` contains non-empty `"name"` and non-empty `"description"` (skills are not valid without a description). Throws on any failure.
- **Properties:** `string path`, `string body`, `string full_content`, `Gee.HashMap<string, string> header`, **`int64 mtime`** (file modification time, set in load()), and **`Markdown.Document.Document document`** — the parsed body as a document.
- **validate_skills(Gee.HashMap<string, Skill> available):** Takes a map of skill name → Skill (e.g. from SkillManager.map_available()). Validates that any skills this document references (e.g. in its “Available skills” section) are in that map. Returns a list of **missing** skill names. If the list is non-empty, that is an **error condition** — the caller must **not run** the skill; validate_skills is the gate that prevents running when required skills are not listed/available.
- **apply_skills(Gee.HashMap<string, Skill> available):** **Modifies the markdown document** in place: find the list under the “Available skills” heading (or the relevant list in the document) and **add list items** — one per skill in `available` (optionally filtered by declared names) — each list item containing the skill name and description. Does not build a string; mutates `this.document` so the list items with descriptions are added at the top of that list (or as specified). Caller can then serialize the document to string if needed.
- **No** static `list_available` — listing is done by **SkillManager**.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMcoder
{
	/**
	 * One skill file: YAML header (key-value map) and markdown body.
	 * Constructor only stores path; call load() to read and parse.
	 * Header is stored in a hash map; "name" etc. are read from the map after load.
	 */
	public class Skill : Object
	{
		public string path { get; private set; default = ""; }
		public string body { get; private set; default = ""; }
		public string full_content { get; private set; default = ""; }
		public Gee.HashMap<string, string> header { get; private set; default = new Gee.HashMap<string, string>(); }
		/** File modification time; set in load(). */
		public int64 mtime { get; private set; default = 0; }
		/** Parsed body as a markdown document (libocmarkdown). */
		public Markdown.Document.Document document { get; private set; }

		public Skill(string path)
		{
			this.path = path;
		}

		/**
		 * Load and parse the skill file. Validates content; throws on read or validation failure.
		 */
		public void load() throws GLib.Error
		{
			string contents = "";
			if (!GLib.FileUtils.get_contents(this.path, out contents)) {
				throw new GLib.FileError.FAILED("Skill: could not read %s".printf(this.path));
			}

			this.full_content = contents;

			// Require valid header: file must start with --- and have a closing ---
			if (!contents.has_prefix("---")) {
				throw new GLib.FileError.INVAL("Skill: %s does not start with YAML header (---)".printf(this.path));
			}
			var parts = contents.split("\n---", 2);
			if (parts.length < 2) {
				throw new GLib.FileError.INVAL("Skill: %s has no closing header delimiter (---)".printf(this.path));
			}
			string header_text = parts[0].substring(3).strip();
			this.body = parts[1].strip();

			this.header.clear();
			foreach (var line in header_text.split("\n")) {
				var stripped = line.strip();
				var colon = stripped.index_of(":");
				if (colon > 0) {
					var key = stripped.substring(0, colon).strip();
					var value = stripped.substring(colon + 1).strip();
					this.header.set(key, value);
				}
			}

			// Validate: require non-empty "name" so the skill can be listed and identified
			if (!this.header.has_key("name") || this.header.get("name").strip() == "") {
				throw new GLib.FileError.INVAL("Skill: %s has no valid 'name' in header".printf(this.path));
			}
			// Validate: require non-empty "description" — skills are not valid without a description
			if (!this.header.has_key("description") || this.header.get("description").strip() == "") {
				throw new GLib.FileError.INVAL("Skill: %s has no valid 'description' in header".printf(this.path));
			}

			// Store file mtime for cache invalidation
			var file = GLib.File.new_for_path(this.path);
			if (file.query_exists()) {
				try {
					var info = file.query_info(GLib.FileAttribute.TIME_MODIFIED, GLib.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
					this.mtime = info.get_modification_time().to_unix();
				} catch (GLib.Error e) {
					this.mtime = 0;
				}
			}

			// Create markdown document from body (libocmarkdown Parser + Document.Render)
			var doc_render = new Markdown.Document.Render();
			var parser = new Markdown.Parser(doc_render);
			parser.start();
			parser.add(this.body, false);
			parser.flush();
			this.document = doc_render.document;
		}

		/**
		 * Validates that skills referenced in this document are in the available map (key = skill name).
		 * Returns list of skill names that are referenced but not in available.
		 * If the list is non-empty, caller must not run the skill (error condition).
		 */
		public Gee.ArrayList<string> validate_skills(Gee.HashMap<string, Skill> available)
		{
			var declared = this.get_declared_skill_names();  // from document "Available skills" section
			var missing = new Gee.ArrayList<string>();
			foreach (var name in declared) {
				if (!available.has_key(name)) {
					missing.add(name);
				}
			}
			return missing;
		}

		/**
		 * Modifies the markdown document: find the list (e.g. under "Available skills" heading)
		 * and add list items at the top — one per skill in available (filtered by declared if section exists) —
		 * each list item containing the skill name and description.
		 */
		public void apply_skills(Gee.HashMap<string, Skill> available)
		{
			var declared = this.get_declared_skill_names();
			Markdown.Document.List? target_list = this.find_available_skills_list();  // walk document for heading then list
			if (target_list == null) {
				return;
			}
			// Names to add: declared order if section exists, else all keys (e.g. sorted for stable order)
			Gee.Collection<string> names_to_add = declared.size > 0 ? declared : this.sorted_available_names(available);
			// Prepend list items (so they appear at top of list): create ListItem per skill, insert at start
			foreach (var name in names_to_add) {
				if (!available.has_key(name)) {
					continue;
				}
				var skill = available.get(name);
				string desc = skill.header.get("description");  // required at load(), so always set
				string item_text = "**" + name + "**: " + desc;
				var item = new Markdown.Document.ListItem();
				// Add block with the item text (paragraph or inline content) as child of item
				// TODO: build Block/Format tree for item_text and adopt into item, then target_list.children.insert(0, item)
			}
		}

		/** Ordered list of keys from available (e.g. sorted) when no declared section. */
		private Gee.ArrayList<string> sorted_available_names(Gee.HashMap<string, Skill> available)
		{
			var names = new Gee.ArrayList<string>();
			names.add_all(available.keys);
			names.sort(Gee.Functions.get_compare_func_for(typeof(string)));
			return names;
		}

		/** Find the list block under "Available skills" heading in this.document. */
		private Markdown.Document.List? find_available_skills_list()
		{
			// TODO: walk this.document children for HEADING_2 "Available skills", then next sibling or child list
			return null;
		}

		/** Extract skill names from document "Available skills" section (walk document by heading). */
		private Gee.ArrayList<string> get_declared_skill_names()
		{
			var names = new Gee.ArrayList<string>();
			// TODO: walk this.document, find heading "Available skills", collect list item text as names
			return names;
		}
	}
}
```

---

## 2. SkillManager (SkillManager.vala)

- **Namespace:** `OLLMcoder`
- **Role:** Keeps an eye on all skills: holds an **array of directories** (skills base paths) and can list the skills actually present by scanning those directories. Initially we use one directory; the type is an array so we can add more later.
- **Constructor:** `SkillManager(Gee.ArrayList<string> skills_directories)` — takes the list of base paths (e.g. one element: `{HOME}/gitlive/OLLMchat/resources/skills`). Caller builds the array.
- **Maps:** SkillManager maintains two maps populated by a single scan: **path → Skill** (`map_by_path()`) and **name → Skill** (`map_available()`). Each Skill stores its own `mtime` (set in `Skill.load()`).
- **Method:** `Gee.HashMap<string, Skill> map_available()` — (re)scans directories, fills both maps, returns the **name → Skill** map. Scan: enumerate `.md` files, exclude templates, create `Skill(path)`, `skill.load()`; on success set `by_path.set(path, skill)` and `by_name.set(skill_name, skill)` (skip if name empty).
- **Method:** `Gee.HashMap<string, Skill> map_by_path()` — returns the **path → Skill** map; same scan as above (so call after or with `map_available()` so both maps are populated).
- **Method:** `int64 get_system_inputs_max_mtime(string skill_filename)` — returns the max of: `system.template.md` mtime (via get_file_mtime), current skill file mtime (from `map_by_path().get(path)` if present else get_file_mtime), and each skill’s `skill.mtime` from the path map. Uses the individual skill mtimes; no per-skill file stat. Returns 0 if primary is empty.
- **Templates location:** The first directory in the array is used as the place to find `system.template.md` and `user.template.md` (runner uses `get_primary_directory()`).

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 * (Same license as Skill.vala)
 */

namespace OLLMcoder
{
	/**
	 * Holds an array of skills directories and two maps: path → Skill and name → Skill.
	 * One scan populates both; each Skill stores its own mtime.
	 */
	public class SkillManager : Object
	{
		public Gee.ArrayList<string> skills_directories { get; private set; default = new Gee.ArrayList<string>(); }

		private Gee.HashMap<string, Skill> _by_path = new Gee.HashMap<string, Skill>();
		private Gee.HashMap<string, Skill> _by_name = new Gee.HashMap<string, Skill>();

		public SkillManager(Gee.ArrayList<string> skills_directories)
		{
			this.skills_directories = skills_directories;
		}

		private void scan()
		{
			this._by_path.clear();
			this._by_name.clear();
			foreach (var skills_base_path in this.skills_directories) {
				var dir = GLib.File.new_for_path(skills_base_path);
				if (!dir.query_exists()) {
					continue;
				}
				try {
					var enumerator = dir.enumerate_children("standard::name,standard::type", GLib.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
					GLib.FileInfo? info;
					while ((info = enumerator.next_file(null)) != null) {
						var name = info.get_name();
						if (!name.has_suffix(".md")) {
							continue;
						}
						if (name == "system.template.md" || name == "user.template.md") {
							continue;
						}
						var skill_path = GLib.Path.build_filename(skills_base_path, name);
						var skill = new Skill(skill_path);
						try {
							skill.load();
							string skill_name = skill.header.has_key("name") ? skill.header.get("name").strip() : "";
							if (skill_name != "") {
								this._by_path.set(skill_path, skill);
								this._by_name.set(skill_name, skill);
							}
						} catch (GLib.Error e) {
							GLib.warning("SkillManager: skip %s: %s", name, e.message);
						}
					}
				} catch (GLib.Error e) {
					GLib.warning("SkillManager: %s: %s", skills_base_path, e.message);
				}
			}
		}

		/** Scan and return name → Skill map. */
		public Gee.HashMap<string, Skill> map_available()
		{
			this.scan();
			return this._by_name;
		}

		/** Scan and return path → Skill map. */
		public Gee.HashMap<string, Skill> map_by_path()
		{
			this.scan();
			return this._by_path;
		}

		/** First directory in the array; used for templates (system.template.md, user.template.md). */
		public string get_primary_directory()
		{
			return this.skills_directories.size > 0 ? this.skills_directories.get(0) : "";
		}

		/** Max mtime of system.template, current skill file, and all skills (uses skill.mtime). */
		public int64 get_system_inputs_max_mtime(string skill_filename)
		{
			int64 max = 0;
			var primary = this.get_primary_directory();
			if (primary == "") {
				return 0;
			}
			int64 m = this.get_file_mtime(GLib.Path.build_filename(primary, "system.template.md"));
			if (m > max) {
				max = m;
			}
			var by_path = this.map_by_path();
			var current_path = GLib.Path.build_filename(primary, skill_filename);
			if (by_path.has_key(current_path)) {
				m = by_path.get(current_path).mtime;
			} else {
				m = this.get_file_mtime(current_path);
			}
			if (m > max) {
				max = m;
			}
			foreach (var skill in by_path.values) {
				if (skill.mtime > max) {
					max = skill.mtime;
				}
			}
			return max;
		}

		private int64 get_file_mtime(string path)
		{
			var file = GLib.File.new_for_path(path);
			if (!file.query_exists()) {
				return 0;
			}
			try {
				var info = file.query_info(GLib.FileAttribute.TIME_MODIFIED, GLib.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
				return info.get_modification_time().to_unix();
			} catch (GLib.Error e) {
				return 0;
			}
		}
	}
}
```

---

## 3. Templates in skills folder

- **Location:** `resources/skills/` (same as plan 1.23; path for dev: `{HOME}/gitlive/OLLMchat/resources/skills`). May be moved later.
- **system.template.md** — Included at the top of the system message. Content: summary of how to deal with skills (picking by description, task manager Input/Output format, skill output = document + short summary). Placeholder content below; refine when implementing.
- **user.template.md** — Used to build the user message for the time being (e.g. wrap the raw query in a template). Placeholder below.

**system.template.md (placeholder):**

```markdown
## How to use skills

- Pick a skill from the **descriptions** listed below (name and description from each skill's YAML header).
- Available skills are listed next. After that, a **Tasks** section is injected (see below). Then the current skill's full instructions follow.

### Tasks

List each task with:

- **Skill** — name of the skill you want to run.
- **Query** — what to ask or pass in. Add bullet points with any information that this skill might find useful.
- **Output** — what you expect (e.g. a document; the skill will add a short summary at the end).

You can add a task to **ask the user to review** (e.g. **Skill** Conductor or a review skill, **Query** “Please review the following before we proceed”, **Output** user confirmation). This is normally **essential prior to making any changes** to content that is not a plan or Research.

To run skills **concurrently**, list multiple skills in one task. To run **sequentially**, use a heading for each step (e.g. **Task 1**, **Task 2**).
```

**Injection order in system message:** (1) the above “How to use skills” block from `system.template.md`, (2) **## Available skills** (factory-built list with name + description), (3) **Tasks** content (injected after the skills section; source TBD — e.g. from user message or skill document), (4) **## Current skill** (current skill body).

**user.template.md (placeholder):**

```markdown
<user_query>
{{query}}
</user_query>
```

(At runtime replace `{{query}}` with the actual user message content.)

---

## 4. SkillRunnerFactory.vala

- **Namespace:** `OLLMcoder`
- **Extends:** `OLLMchat.Agent.Factory`
- **Role:** **Lightweight** — only creates SkillRunner instances. The factory **creates** the SkillManager (from the given skills directories) and holds `skill_filename`; it does **not** build messages or cache. Making the factory heavy was concluded to be a bad idea; the **SkillRunner** is responsible for building the system and user messages.
- **Constructor:** `SkillRunnerFactory(Gee.ArrayList<string> skills_directories, string skill_filename = "")` — creates `SkillManager(skills_directories)` and stores it; sets `skill_filename` (default `"conductor.md"`). Sets `name = "skill-runner"`, `title = "Conductor"`.
- **Override:** `create_agent(SessionBase session)` — return `new SkillRunner(this, session)`.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMcoder
{
	/**
	 * Lightweight factory: creates SkillManager and SkillRunner only. Message building lives in SkillRunner.
	 */
	public class SkillRunnerFactory : OLLMchat.Agent.Factory
	{
		public SkillManager skill_manager { get; private set; }
		public string skill_filename { get; private set; }

		public SkillRunnerFactory(Gee.ArrayList<string> skills_directories, string skill_filename = "")
		{
			this.name = "skill-runner";
			this.title = "Conductor";
			this.skill_manager = new SkillManager(skills_directories);
			this.skill_filename = skill_filename != "" ? skill_filename : "conductor.md";
		}

		public override OLLMchat.Agent.Base create_agent(OLLMchat.History.SessionBase session)
		{
			return new SkillRunner(this, session);
		}
	}
}
```

---

## 5. SkillRunner.vala

- **Namespace:** `OLLMcoder`
- **Extends:** `OLLMchat.Agent.Base`
- **Role:** **Responsible for building the system and user messages.** Override `send_async` to: (1) build system message (template + available skills list + current skill content), using cache invalidated by `skill_manager.get_system_inputs_max_mtime(skill_filename)`; (2) build user message from user template or pass-through; (3) add system and user to session/messages, filter for API roles, set is_running, customize model, yield chat_call.send. Validation gate: when building system message, call `current.validate_skills(scanned)` and throw if any missing — skill does not run.
- **Constructor:** `SkillRunner(SkillRunnerFactory factory, SessionBase session)` — call `base(factory, session)`. Runner gets `skill_manager` and `skill_filename` from the factory.
- **Override:** `send_async` — call internal `get_system_message()` and `get_user_prompt(message.content)` (runner-owned), then proceed as above. If `get_system_message()` throws (e.g. validate_skills found missing skills), the skill does not run and the error is propagated.

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMcoder
{
	/**
	 * Agent that runs a single skill. Builds system message (template + available skills + current skill)
	 * and user message (template or pass-through); injects them and sends.
	 */
	public class SkillRunner : OLLMchat.Agent.Base
	{
		private string _cached_system_message = "";
		private int64 _cached_system_mtime = 0;
		private string _cached_user_tpl = "";
		private int64 _cached_user_tpl_mtime = 0;

		public SkillRunner(SkillRunnerFactory factory, OLLMchat.History.SessionBase session)
		{
			base(factory, session);
		}

		private SkillRunnerFactory sr_factory()
		{
			return (SkillRunnerFactory) this.factory;
		}

		private int64 get_file_mtime(string path)
		{
			var file = GLib.File.new_for_path(path);
			if (!file.query_exists()) {
				return 0;
			}
			try {
				var info = file.query_info(GLib.FileAttribute.TIME_MODIFIED, GLib.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
				return info.get_modification_time().to_unix();
			} catch (GLib.Error e) {
				return 0;
			}
		}

		private string load_template(string filename)
		{
			var primary = this.sr_factory().skill_manager.get_primary_directory();
			if (primary == "") {
				return "";
			}
			var path = GLib.Path.build_filename(primary, filename);
			try {
				string contents;
				if (GLib.FileUtils.get_contents(path, out contents)) {
					return contents;
				}
			} catch (GLib.FileError e) {
				GLib.warning("SkillRunner: failed to load %s: %s", path, e.message);
			}
			return "";
		}

		private Gee.ArrayList<string> extract_available_skills_section(string body)
		{
			var names = new Gee.ArrayList<string>();
			// TODO: parse body with Markdown.Parser / document model, find heading "Available skills", collect list item text as names
			return names;
		}

		private Gee.ArrayList<string> sorted_map_keys(Gee.HashMap<string, Skill> map)
		{
			var keys = new Gee.ArrayList<string>();
			keys.add_all(map.keys);
			keys.sort(Gee.Functions.get_compare_func_for(typeof(string)));
			return keys;
		}

		private string get_system_message() throws GLib.Error
		{
			var sm = this.sr_factory().skill_manager;
			string skill_filename = this.sr_factory().skill_filename;
			int64 now = sm.get_system_inputs_max_mtime(skill_filename);
			if (now == this._cached_system_mtime && this._cached_system_message != "") {
				return this._cached_system_message;
			}

			string result = "";
			string system_tpl = this.load_template("system.template.md");
			if (system_tpl != "") {
				result = result + system_tpl + "\n\n";
			}

			var primary = sm.get_primary_directory();
			var current_path = primary != "" ? GLib.Path.build_filename(primary, skill_filename) : "";
			Skill current;
			try {
				current = new Skill(current_path);
				current.load();
			} catch (GLib.Error e) {
				result = result + "(Current skill file could not be loaded: " + e.message + ")";
				this._cached_system_mtime = now;
				this._cached_system_message = result;
				return this._cached_system_message;
			}

			var scanned = sm.map_available();
			var missing = current.validate_skills(scanned);
			if (missing.size > 0) {
				throw new GLib.FileError.INVAL("Skill references missing or unavailable skills: " + string.joinv(", ", missing.to_array()));
			}

			var declared_names = this.extract_available_skills_section(current.body);
			if (scanned.size > 0) {
				string[] lines = {};
				Gee.Collection<string> names_to_show = declared_names.size > 0 ? declared_names : this.sorted_map_keys(scanned);
				foreach (var name in names_to_show) {
					if (!scanned.has_key(name)) {
						continue;
					}
					var skill = scanned.get(name);
					string desc = skill.header.get("description");
					lines += "- **" + name + "**: " + desc;
				}
				result = result + "## Available skills\n\n" + string.joinv("\n", lines) + "\n\n";
			}

			result = result + "## Current skill\n\n";
			result = result + current.full_content;

			this._cached_system_mtime = now;
			this._cached_system_message = result;
			return this._cached_system_message;
		}

		private string get_user_prompt(string user_query)
		{
			var primary = this.sr_factory().skill_manager.get_primary_directory();
			var tpl_path = primary != "" ? GLib.Path.build_filename(primary, "user.template.md") : "";
			int64 now = this.get_file_mtime(tpl_path);
			if (now == this._cached_user_tpl_mtime && this._cached_user_tpl != "") {
				return this._cached_user_tpl.replace("{{query}}", user_query);
			}
			string user_tpl = this.load_template("user.template.md");
			this._cached_user_tpl_mtime = now;
			this._cached_user_tpl = user_tpl;
			if (user_tpl == "") {
				return user_query;
			}
			return user_tpl.replace("{{query}}", user_query);
		}

		public override async void send_async(OLLMchat.Message message, GLib.Cancellable? cancellable = null) throws GLib.Error
		{
			var messages = new Gee.ArrayList<OLLMchat.Message>();

			string system_content = this.get_system_message();
			if (system_content != "") {
				var system_msg = new OLLMchat.Message("system", system_content);
				this.session.messages.add(system_msg);
				messages.add(system_msg);
			}

			string user_content = this.get_user_prompt(message.content);
			this.session.messages.add(new OLLMchat.Message("user", user_content));

			foreach (var msg in this.session.messages) {
				if (msg.role == "user" || msg.role == "assistant" || msg.role == "tool") {
					messages.add(msg);
				}
			}

			this.session.is_running = true;
			GLib.debug("is_running=true session %s", this.session.fid);

			if (this.session.model_usage.model_obj != null) {
				try {
					var customized_model_name = yield this.session.model_usage.model_obj.customize(
						this.connection,
						this.chat_call.options
					);
					this.chat_call.model = customized_model_name;
				} catch (GLib.Error e) {
					GLib.warning("SkillRunner.send_async: Failed to customize model '%s': %s. Using base model.",
						this.session.model_usage.model_obj.name, e.message);
				}
			} else {
				this.chat_call.model = this.session.model_usage.model;
			}

			this.chat_call.cancellable = cancellable;
			var response = yield this.chat_call.send(messages, cancellable);
		}
	}
}
```

---

## 5. meson.build (liboccoder)

Add the new sources after `Agent.vala`. Order: `Skill` (no deps), then `SkillRunnerFactory` (uses Skill), then `SkillRunner` (uses SkillRunnerFactory).

```meson
occoder_src = files([
  'BufferProvider.vala',
  # ...
  'SourceView.vala',
  'AgentFactory.vala',
  'Agent.vala',
  'Skill.vala',
  'SkillManager.vala',
  'SkillRunnerFactory.vala',
  'SkillRunner.vala',
  'List/SortedList.vala',
  # ...
])
```

---

## 7. Window.vala (ollmapp)

Register the SkillRunner factory in the same block where Code Assistant is registered (e.g. after `fill_tools` / before `setup_agent_dropdown`). Use default constructor so skills path is `{HOME}/gitlive/OLLMchat/resources/skills` and skill file is `conductor.md`.

```vala
			// Register CodeAssistant agent
			var code_assistant = new OLLMcoder.AgentFactory(this.project_manager);
			this.history_manager.agent_factories.set(code_assistant.name, code_assistant);

			// Register SkillRunner (Conductor) agent: factory creates SkillManager from directories
			var skills_dirs = new Gee.ArrayList<string>();
			skills_dirs.add(GLib.Path.build_filename(GLib.Environment.get_home_dir(), "gitlive", "OLLMchat", "resources", "skills"));
			var skill_runner = new OLLMcoder.SkillRunnerFactory(skills_dirs, "");
			this.history_manager.agent_factories.set(skill_runner.name, skill_runner);

			// Set up agent dropdown now that agents are registered
			this.setup_agent_dropdown();
```

---

## 7. VAPI / custom_target (occoder)

If the project uses a hand-maintained `occoder.vapi` or `custom_target` that lists sources, add `Skill.vala`, `SkillManager.vala`, `SkillRunnerFactory.vala`, and `SkillRunner.vala` in the same order as in `occoder_src`.

---

## 9. Verification

- Build: `meson compile -C build` (or equivalent) succeeds.
- Run app, open agent dropdown: entries include "Just Ask", "Coding Assistant", "Conductor".
- Select Conductor, send a message: system prompt includes (1) content of `system.template.md`, (2) a list of available skills (from the current skill document’s “Available skills” section, cross-referenced with SkillManager’s scanned list; name + description from each skill’s header), (3) the full content of the current skill. User message from `user.template.md` if present, else raw query. No crash if templates or skill file are missing (fallbacks used).
- **Validation gate:** If the current skill document references skills that are not in `map_available()` (e.g. not listed or not loadable), the runner’s system-message build throws and the skill does not run; the error is surfaced to the user (e.g. “Skill references missing or unavailable skills: …”).
- Cache: after a first call to `get_system_message()` or `get_user_prompt()`, a second call without any file change returns the cached value; after touching (e.g. saving) a skill file or template, the next call rebuilds and updates the cache.

---

## References

- Plan 1.23 (Skills Agent & Conductor; “How to utilize skills”, task manager format, skill output = document + summary).
- `libollmchat/Agent/JustAsk.vala`, `JustAskFactory.vala` (minimal agent/factory).
- `liboccoder/Agent.vala`, `AgentFactory.vala` (send_async with system + user message pattern).
- `libollmchat/Agent/Base.vala` (`send_async` default, no system message).
- Skill: one class per skill file (YAML header + markdown body); no listing. SkillManager: array of skills directories, map_available() and get_system_inputs_max_mtime(skill_filename). SkillRunnerFactory: lightweight, creates SkillManager and SkillRunner only. SkillRunner: builds messages and caches. Available skills listed in the skill document (section “Available skills”); extracted via libocmarkdown and cross-referenced with SkillManager. Templates in primary directory (system.template.md, user.template.md).
