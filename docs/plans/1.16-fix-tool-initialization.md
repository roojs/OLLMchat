# 1.16. Fix Tool Initialization

## Overview

The current "blind registry" approach to tool discovery and initialization doesn't work well. Tools are discovered via GType registry and created without dependencies, then dependencies must be set later via workarounds like `init_dependencies()`. This is fragile and error-prone.

## Status

‚è≥ **TODO** - Proper tool registration system needed.

## Problem

### Current Approach (Blind Registry)

1. **Discovery**: Tools are discovered via GType registry (`typeof(Tool.BaseTool).children()`)
2. **Creation**: Tools are created via `Object.new(tool_type)` without constructor parameters
3. **Dependencies**: Tools that need dependencies (like `CodebaseSearchTool` needing `ProjectManager`) are created with `null` dependencies
4. **Workaround**: Dependencies must be set later via `init_dependencies()` or similar methods
5. **Issues**:
   - Tools can be used before dependencies are set (crashes)
   - No clear initialization order
   - Dependencies are set in multiple places (fragile)
   - Hard to track which tools need which dependencies

### Example Problem

`CodebaseSearchTool` needs `ProjectManager` but:
- Created without it during `register_all_tools()`
- `ProjectManager` is created later in `initialize_client()`
- Must call `init_dependencies()` before using the tool
- `BackgroundScan` constructor checks for null and crashes if not set

## Goal

Implement proper tool registration that:
1. **Explicit Registration**: Tools register themselves explicitly, not via blind discovery
2. **Dependency Injection**: Dependencies are provided at registration time
3. **Initialization Order**: Clear order of operations (dependencies created before tools)
4. **Type Safety**: Compile-time checking of tool dependencies
5. **No Workarounds**: No need for `init_dependencies()` or similar methods

## Proposed Solution

### Option 1: Explicit Registration with Factory Functions

```vala
// In Application.vala or Window.vala
public static void register_all_tools(Manager manager, ProjectManager? project_manager)
{
    // Explicit registration - no blind discovery
    manager.tools.set("read_file", new OLLMtools.ReadFile(project_manager));
    manager.tools.set("run_command", new OLLMtools.RunCommand(project_manager));
    manager.tools.set("web_fetch", new OLLMtools.WebFetchTool(project_manager));
    manager.tools.set("edit_mode", new OLLMtools.EditMode(project_manager));
    
    // CodebaseSearchTool needs ProjectManager
    if (project_manager != null) {
        manager.tools.set("codebase_search", new OLLMvector.Tool.CodebaseSearchTool(project_manager));
    }
    
    manager.tools.set("google_search", new OLLMtools.GoogleSearchTool(project_manager));
}
```

**Pros**:
- Explicit and clear
- Dependencies provided at creation time
- No workarounds needed
- Easy to see which tools need which dependencies

**Cons**:
- Manual registration (but that's actually good - explicit is better)
- Need to update registration when adding new tools

### Option 2: Registration Interface with Dependency Injection

```vala
// Tool registration interface
public interface ToolRegistrar {
    public abstract void register_tools(Manager manager, ToolDependencies deps);
}

// Tool dependencies container
public class ToolDependencies {
    public ProjectManager? project_manager { get; set; }
    public Config2? config { get; set; }
    // ... other dependencies
}

// Each tool library provides registration
public class OLLMtoolsRegistrar : ToolRegistrar {
    public void register_tools(Manager manager, ToolDependencies deps) {
        manager.tools.set("read_file", new OLLMtools.ReadFile(deps.project_manager));
        manager.tools.set("run_command", new OLLMtools.RunCommand(deps.project_manager));
        // ...
    }
}

// In Window.vala
var deps = new ToolDependencies() {
    project_manager = this.project_manager,
    config = this.config
};

var registrar = new OLLMtoolsRegistrar();
registrar.register_tools(this.history_manager, deps);
```

**Pros**:
- Organized by library/namespace
- Dependency injection pattern
- Can have multiple registrars

**Cons**:
- More complex
- Still need to call registrars explicitly

### Option 3: Keep Discovery but Fix Initialization

Keep the current discovery approach but:
1. Create tools with dependencies when they're available
2. Store tool factories instead of tool instances
3. Create tool instances when needed with proper dependencies

```vala
// Store factories, not instances
public Gee.HashMap<string, ToolFactory> tool_factories { get; private set; }

// Factory interface
public interface ToolFactory {
    public abstract BaseTool create(ProjectManager? project_manager);
}

// Register factories (not instances)
tool_factories.set("codebase_search", new CodebaseSearchToolFactory());

// Create instances when dependencies are available
var tool = tool_factories.get("codebase_search").create(project_manager);
```

**Pros**:
- Still uses discovery
- Dependencies provided at creation time

**Cons**:
- More complex (factories)
- Still relies on blind discovery

## Recommendation

**Option 1 (Explicit Registration)** is recommended because:
- Simple and clear
- No magic/discovery
- Dependencies are explicit
- Easy to understand and maintain
- Matches the pattern we should have used from the start

## Implementation Steps

1. **Remove blind discovery**: Remove or deprecate `BaseTool.register_all_tools()` and `discover_classes()`
2. **Create explicit registration function**: `register_all_tools(Manager manager, ProjectManager? project_manager)`
3. **Update registration call**: Call explicit registration in `Window.initialize_client()` after `ProjectManager` is created
4. **Remove workarounds**: Remove `init_dependencies()` and similar methods
5. **Update tool constructors**: Ensure all tools can be created with dependencies in constructor
6. **Test**: Verify all tools work correctly with explicit registration

## Related Plans

- [1.3.5.1. Tool Registration and Titles](./1.3.5.1-DONE-tool-registration-and-titles.md) - Original tool registration plan
- [2.10. Codebase Search Tool](./2.10-codebase-search-tool.md) - CodebaseSearchTool implementation

## Notes

- The current workaround (`init_dependencies()`) should be removed once proper registration is implemented
- Tools that don't need dependencies (like `GoogleSearchTool`) can still be created without them
- Consider making `ProjectManager` a required parameter for tools that need it (compile-time safety)

