# 2.6.1.2. File Monitor Support

## Overview

Implement filesystem monitoring using inotify to track file changes during command execution. This phase creates the monitoring infrastructure that will be used by overlay and backup systems in later phases.

## Status

⏳ **PLANNING** - Design phase.

## Prerequisites

- Phase 1 (2.6.1.1) must be completed
- See main plan: `2.6.1-code-exec-improvements.md` for general architecture

## Goals

1. Create `Monitor` class for inotify-based filesystem monitoring
2. Implement dynamic recursive directory monitoring
3. Track files/folders that were written/added during execution
4. Provide simple lists of changes (not detailed event logs)

## Implementation Details

### Files to Create

- `liboctools/RunCommand/Monitor.vala` - inotify-based filesystem change detection

### Monitor Class Design

The `Monitor` class provides filesystem change detection using GLib's FileMonitor API (which uses inotify on Linux). It tracks file and directory changes during command execution and maintains simple lists of changes.

#### Class Structure

```vala
namespace OLLMtools.RunCommand
{
    public class Monitor : Object
    {
        // Properties (read-only after stop())
        public Gee.ArrayList<OLLMfiles.FileBase> added { get; private set; }
        public Gee.ArrayList<OLLMfiles.FileBase> removed { get; private set; }
        public Gee.ArrayList<OLLMfiles.FileBase> updated { get; private set; }
        
        // Private fields
        private string path;
        private GLib.FileMonitor? monitor;
        private Gee.HashMap<string, Monitor> monitors;
        private Gee.HashSet<string> known_paths;
        private OLLMfiles.ProjectManager project_manager;
        private bool is_monitoring;
        
        // Constructor
        public Monitor(string path, OLLMfiles.ProjectManager project_manager) throws Error;
        
        // Public methods
        public void start() throws Error;
        public void stop();
        
        // Private methods
        private void on_file_changed(GLib.File file, GLib.File? other_file, GLib.FileMonitorEvent event);
        private void handle_directory_created(string dir_path);
        private void handle_file_created(string file_path);
        private void handle_file_modified(string file_path);
        private void handle_file_deleted(string file_path);
        private OLLMfiles.FileBase? create_filebase_from_path(string file_path);
    }
}
```

#### Constructor: `Monitor(string path, OLLMfiles.ProjectManager project_manager)`

**Purpose**: Initialize a Monitor instance for a specific directory.

**Parameters**:
- `path` (string): Absolute path to the directory to monitor
- `project_manager` (OLLMfiles.ProjectManager): ProjectManager instance for creating FileBase objects and looking up existing files

**Implementation**:
1. Validate that `path` exists and is a directory using `GLib.FileUtils.test(path, GLib.FileTest.IS_DIR)`
2. Store normalized absolute path in `path`
3. Store `project_manager` reference
4. Initialize empty lists for `added`, `removed`, `updated` (all `Gee.ArrayList<OLLMfiles.FileBase>`)
5. Initialize empty `Gee.HashMap<string, Monitor>` for `monitors` (tracks all active monitors including root)
6. Initialize empty `Gee.HashSet<string>` for `known_paths` (tracks paths we've seen)
7. Set `is_monitoring = false`
8. Set `monitor = null`

**Throws**: `GLib.IOError` if directory doesn't exist or isn't a directory

**Example**:
```vala
var monitor = new Monitor("/path/to/monitor", project_manager);
```

#### Method: `start()`

**Purpose**: Begin monitoring the directory for filesystem changes.

**Implementation**:
1. Check if already monitoring (`is_monitoring`), return early if true
2. Get `GLib.File` object for `path`
3. Create `GLib.FileMonitor` using `file.monitor_directory()` with flags:
   - `GLib.FileMonitorFlags.WATCH_MOVES` (optional, for future use)
4. Connect to `changed` signal: `monitor.changed.connect(on_file_changed)`
5. Store monitor in `monitor` field
6. Add this monitor to `monitors` HashMap: `monitors.set(path, this)`
7. Set `is_monitoring = true`
8. Initialize `known_paths` with any existing files in the directory (optional baseline)

**Throws**: `GLib.IOError` if monitoring cannot be started

**Usage**:
```vala
monitor.start();
// ... execute command ...
monitor.stop();
```

#### Method: `stop()`

**Purpose**: Stop all monitoring and finalize change lists.

**Implementation**:
1. If not monitoring (`!is_monitoring`), return early
2. Set `is_monitoring = false`
3. Cancel `monitor` if it exists: `monitor.cancel()`
4. Recursively stop all subdirectory monitors:
   - Iterate over `monitors.values`
   - Skip this monitor (don't stop ourselves recursively)
   - Call `stop()` on each subdirectory monitor
5. Clear `monitors` HashMap (except this monitor entry)
6. Set `monitor = null`
7. Process any pending events (events may arrive after cancellation)
8. Finalize change lists (deduplicate FileBase objects by path)

**Note**: After `stop()` is called, the properties (`added`, `removed`, `updated`) contain the final change lists and are read-only.

**Usage**:
```vala
monitor.stop();
var added_files = monitor.added; // Now available
```

#### Private Method: `on_file_changed(GLib.File file, GLib.File? other_file, GLib.FileMonitorEvent event)`

**Purpose**: Event handler for filesystem change events from GLib.FileMonitor.

**Parameters**:
- `file` (GLib.File): The file or directory that changed
- `other_file` (GLib.File?): For move/rename events, the destination file
- `event` (GLib.FileMonitorEvent): The type of event that occurred

**Implementation**:
1. Get absolute path from `file.get_path()` (or `file.get_uri()` if path is null)
2. Switch on `event` type:
   - `G_FILE_MONITOR_EVENT_CREATED`:
     - Check if path is a directory using `GLib.FileUtils.test(path, GLib.FileTest.IS_DIR)`
     - If directory: call `handle_directory_created(path)`
     - If file: call `handle_file_created(path)`
   - `G_FILE_MONITOR_EVENT_CHANGED`:
     - Check if path is a file (not directory) using `GLib.FileUtils.test(path, GLib.FileTest.IS_REGULAR)`
     - If file: call `handle_file_modified(path)`
   - `G_FILE_MONITOR_EVENT_DELETED`:
     - Call `handle_file_deleted(path)`
   - `G_FILE_MONITOR_EVENT_MOVED` (optional, for future use):
     - Handle as deletion of source and creation of destination
3. Ignore other event types (attributes changed, etc.)

**Note**: This method is called asynchronously by GLib's event loop when inotify events occur.

#### Private Method: `handle_directory_created(string dir_path)`

**Purpose**: Handle creation of a new directory by creating a recursive monitor for it and adding Folder to `added` list.

**Parameters**:
- `dir_path` (string): Absolute path to the newly created directory

**Implementation**:
1. Normalize path (resolve any symlinks, ensure absolute)
2. Check if we're already monitoring this directory (check `monitors`)
3. If not already monitoring:
   - Create new `Monitor` instance for `dir_path` with same `project_manager`
   - Call `start()` on the new monitor
   - Add to `monitors` HashMap: `monitors.set(dir_path, new_monitor)`
4. Create Folder object using `create_filebase_from_path(dir_path)` (will create Folder, not File)
5. If Folder created successfully:
   - Add to `added` list (if not already present, check by path)
   - Add path to `known_paths` HashSet
6. Handle any errors gracefully (log warning, continue monitoring)

**Recursive Behavior**: The new monitor will automatically handle nested directory creation within this directory, creating monitors for subdirectories recursively.

#### Private Method: `handle_file_created(string file_path)`

**Purpose**: Track creation of a new file and add File to `added` list.

**Parameters**:
- `file_path` (string): Absolute path to the newly created file

**Implementation**:
1. Normalize path (resolve any symlinks, ensure absolute)
2. Check if path already exists in `known_paths` HashSet
3. If not in `known_paths`:
   - Create File object using `create_filebase_from_path(file_path)`
   - If File created successfully:
     - Add to `added` list (if not already present, check by path)
     - Add path to `known_paths` HashSet
4. If file was in `known_paths` but not in `added`, it might have been deleted and recreated - handle appropriately

**Note**: A file that is created and then immediately modified will appear in both `added` and `updated`. This is acceptable - the caller can deduplicate if needed.

#### Private Method: `handle_file_modified(string file_path)`

**Purpose**: Track modification of an existing file and add File to `updated` list (from ProjectFiles).

**Parameters**:
- `file_path` (string): Absolute path to the modified file

**Implementation**:
1. Normalize path (resolve any symlinks, ensure absolute)
2. Check if path is in `known_paths` HashSet
3. Look up file in ProjectManager's active project:
   - Get `active_project` from `project_manager`
   - If active_project exists, use `project_files.get_by_path(file_path)` to get existing File
   - If File found in ProjectFiles:
     - Add to `updated` list (if not already present, check by path)
     - Add path to `known_paths` HashSet if not already there
4. If not found in ProjectFiles:
   - This is a file that existed before monitoring started but isn't in database
   - Create File object using `create_filebase_from_path(file_path)`
   - If File created successfully:
     - Add to `updated` list (if not already present)
     - Add path to `known_paths` HashSet
5. Do NOT remove from `added` if it's there (file can be both new and modified)

**Note**: Files that are created and then modified will appear in both `added` and `updated`. This is by design - it indicates the file was both created and written to during execution.

#### Private Method: `handle_file_deleted(string file_path)`

**Purpose**: Track deletion of a file and add FileBase to `removed` list.

**Parameters**:
- `file_path` (string): Absolute path to the deleted file

**Implementation**:
1. Normalize path (resolve any symlinks, ensure absolute)
2. Check if path is in `known_paths` HashSet
3. If in `known_paths`:
   - Remove from `known_paths` HashSet
   - Remove from `added` if present (file was created then deleted)
   - Remove from `updated` if present
4. Look up file in ProjectManager's active project:
   - Get `active_project` from `project_manager`
   - If active_project exists, use `project_files.get_by_path(file_path)` to get existing FileBase
   - If FileBase found in ProjectFiles:
     - Add to `removed` list (if not already present, check by path)
5. If not found in ProjectFiles:
   - This is a file that existed before monitoring started but isn't in database
   - Create FileBase object using `create_filebase_from_path(file_path)` (determine if File or Folder)
   - If FileBase created successfully:
     - Add to `removed` list (if not already present)

**Note**: Files that are created and then deleted will appear in `removed` but not in `added` (since we remove them from `added` when deleted).

#### Private Method: `create_filebase_from_path(string file_path)`

**Purpose**: Create a FileBase object (File or Folder) from a filesystem path. The object is created but NOT inserted into the database (id = 0).

**Parameters**:
- `file_path` (string): Absolute path to the file or directory

**Returns**: `FileBase?` - File or Folder object, or `null` if creation fails

**Implementation**:
1. Check if path exists using `GLib.FileUtils.test(file_path, GLib.FileTest.EXISTS)`
2. If path doesn't exist, return `null`
3. Determine if path is directory or file:
   - Use `GLib.FileUtils.test(file_path, GLib.FileTest.IS_DIR)` for directory
   - Use `GLib.FileUtils.test(file_path, GLib.FileTest.IS_REGULAR)` for file
4. Query FileInfo from disk:
   - Create `GLib.File` object from path
   - Query FileInfo with attributes: `STANDARD_CONTENT_TYPE`, `TIME_MODIFIED`
5. Create appropriate FileBase object:
   - If directory: Create `new Folder(project_manager)` and set properties from FileInfo
   - If file: Create `new File(project_manager)` and set properties from FileInfo
6. Set properties:
   - `path = file_path`
   - `id = 0` (new file, not in database)
   - `parent = null` (will be set later if needed)
   - `parent_id = 0`
   - `last_modified` from FileInfo modification time
   - For File: `is_text` from content type
7. Return created FileBase object

**Note**: These objects are created for tracking purposes only. They are NOT saved to the database. For `updated` items, use existing files from ProjectFiles instead.

### Dynamic Recursive Directory Monitoring

The Monitor class implements dynamic recursive monitoring to handle directories that are created during command execution.

#### How It Works

1. **Initial State**: The root directory monitor is created with `start()`. At this point, only the root directory is being monitored. The root monitor is stored in `monitors` HashMap.

2. **Directory Creation Detection**: When a directory creation event is detected (`G_FILE_MONITOR_EVENT_CREATED` for a directory):
   - The `on_file_changed()` handler calls `handle_directory_created()`
   - A new `Monitor` instance is created for the new directory (with same `project_manager`)
   - The new monitor's `start()` method is called immediately
   - The new monitor is stored in `monitors` HashMap (same HashMap as root monitor)

3. **Recursive Behavior**: The new subdirectory monitor will:
   - Monitor its own directory for changes
   - Automatically create monitors for any subdirectories created within it
   - This creates a recursive tree of monitors
   - All monitors (root and subdirectories) are stored in the same `monitors` HashMap

4. **Cleanup**: When `stop()` is called:
   - All subdirectory monitors are recursively stopped
   - The `monitors` HashMap is cleared (except the current monitor entry)
   - All monitors are properly cancelled

#### Data Structure

- **`monitors`**: `Gee.HashMap<string, Monitor>`
  - Key: Absolute path to the directory being monitored
  - Value: Monitor instance for that directory
  - Used to track all active monitors (root and subdirectories) for cleanup
  - Root monitor is stored with its path as the key

#### Example Flow

```
1. Monitor created for /tmp/test
2. start() called → monitor added to monitors HashMap
3. Command creates /tmp/test/subdir/
4. Event detected → handle_directory_created("/tmp/test/subdir")
5. New Monitor created for /tmp/test/subdir and started
6. New monitor added to monitors HashMap
7. Command creates /tmp/test/subdir/nested/
8. Event detected by subdirectory monitor → handle_directory_created("/tmp/test/subdir/nested")
9. New Monitor created for /tmp/test/subdir/nested and started
10. New monitor added to monitors HashMap
11. stop() called → all monitors stopped recursively, HashMap cleared
```

### Simple Change Tracking

The Monitor class maintains simple lists of FileBase objects rather than detailed event logs. This approach is sufficient for the use case and easier to work with.

#### Change Lists

- **`added`**: `Gee.ArrayList<OLLMfiles.FileBase>`
  - Contains File or Folder objects that were created during monitoring
  - Objects are created but NOT inserted into database (id = 0)
  - Files and directories are both tracked here
  - Objects are removed from this list if they're later deleted

- **`removed`**: `Gee.ArrayList<OLLMfiles.FileBase>`
  - Contains File or Folder objects that were deleted during monitoring
  - For files in ProjectFiles: Uses existing FileBase from ProjectFiles
  - For files not in ProjectFiles: Creates FileBase object (id = 0, not in database)
  - Includes files that existed before monitoring started

- **`updated`**: `Gee.ArrayList<OLLMfiles.FileBase>`
  - Contains File objects that were modified during monitoring
  - Objects come from ProjectFiles (existing files in database)
  - Only files that exist in the active project's ProjectFiles are tracked here
  - Files may appear here even if they're also in `added` (created then modified)

#### Tracking Logic

1. **File/Directory Creation**: When a file or directory is created:
   - Create FileBase object using `create_filebase_from_path()` (id = 0, not in database)
   - Add to `added` list
   - Add path to `known_paths` HashSet

2. **File Modification**: When a file is modified:
   - Look up file in ProjectFiles using `project_files.get_by_path()`
   - If found in ProjectFiles: Add existing FileBase to `updated` list
   - If not found: Create FileBase object and add to `updated` list
   - Do NOT remove from `added` if present (file can be both new and modified)

3. **File/Directory Deletion**: When a file or directory is deleted:
   - Remove from `known_paths` HashSet
   - Remove from `added` if present (was created then deleted)
   - Remove from `updated` if present
   - Look up in ProjectFiles, or create FileBase object
   - Add to `removed` list

4. **Deduplication**: Lists are deduplicated in `stop()` method to ensure each FileBase object appears only once (by path).

#### FileBase Object Creation

- **For `added` and `removed`**: Objects are created using `create_filebase_from_path()` but NOT saved to database (id = 0)
- **For `updated`**: Objects come from ProjectFiles (existing files in database with id > 0)
- All FileBase objects have `path` set to absolute normalized path
- Objects can be File, Folder, or FileAlias depending on filesystem type

### inotify Events

The Monitor class uses `GLib.FileMonitor` which provides a Vala-friendly API over inotify (on Linux).

#### Event Types Monitored

- **`G_FILE_MONITOR_EVENT_CREATED`**: 
  - File or directory creation
  - Handled by checking if path is directory or file
  - Triggers `handle_directory_created()` or `handle_file_created()`

- **`G_FILE_MONITOR_EVENT_CHANGED`**:
  - File modification (content changed)
  - Only handled for files (not directories)
  - Triggers `handle_file_modified()`

- **`G_FILE_MONITOR_EVENT_DELETED`**:
  - File or directory deletion
  - Handled by `handle_file_deleted()`
  - Note: Directory deletion will stop the subdirectory monitor automatically

#### Event Handling Considerations

1. **Event Queue**: Events may arrive after `stop()` is called. The `stop()` method should process any pending events before finalizing.

2. **Rapid Changes**: Multiple events for the same file may arrive quickly. The implementation should handle this gracefully (deduplication in lists).

3. **Event Ordering**: Events may not arrive in chronological order. The implementation should be resilient to this.

4. **Missing Events**: Some events may be missed if the system is under heavy load. This is acceptable for the use case - we're tracking changes, not creating an audit log.

#### GLib.FileMonitor API

```vala
// Create monitor
var file = GLib.File.new_for_path(path);
var monitor = file.monitor_directory(
    GLib.FileMonitorFlags.WATCH_MOVES
);

// Connect to changed signal
monitor.changed.connect(on_file_changed);

// Cancel monitor
monitor.cancel();
```

**FileMonitorFlags**:
- `WATCH_MOVES`: Monitor for move/rename events (optional, for future use)
- Default flags are sufficient for basic monitoring

## Integration and Usage

### Integration with RunCommand

The Monitor class will be integrated with the RunCommand tool in Phase 3 (overlay support). For Phase 2, it can be tested independently.

#### Future Integration (Phase 3)

```vala
// In Bubble.exec() or Request.execute_tool_async()
var overlay = new Overlay(project);
var monitor = new Monitor(overlay.upper_directory_path, project_manager);

monitor.start();
var output = yield bubble.exec(command);
monitor.stop();

// Access change lists
var added = monitor.added;
var removed = monitor.removed;
var updated = monitor.updated;
// ... use change lists for file copying ...
```

#### Standalone Testing (Phase 2)

```vala
// Test example
var monitor = new Monitor("/tmp/test-monitor", project_manager);
monitor.start();

// Execute test command that creates/modifies files
// ...

monitor.stop();

// Check results
print("Added files: %d\n", monitor.added.size);
foreach (var filebase in monitor.added) {
    print("  %s (%s)\n", filebase.path, filebase.base_type);
}
```

### Error Handling

#### Constructor Errors

- **Directory doesn't exist**: Throw `GLib.IOError.NOT_FOUND`
- **Path is not a directory**: Throw `GLib.IOError.INVALID_ARGUMENT`
- **Permission denied**: Throw `GLib.IOError.PERMISSION_DENIED`

#### start() Errors

- **Monitoring already started**: Return early (idempotent)
- **Cannot create monitor**: Throw `GLib.IOError.FAILED` with descriptive message
- **Permission denied**: Throw `GLib.IOError.PERMISSION_DENIED`

#### Event Handler Errors

- **File operations fail**: Log warning, continue monitoring (don't crash)
- **Subdirectory monitor creation fails**: Log warning, continue monitoring parent
- **Path resolution fails**: Skip event, log warning

#### stop() Behavior

- **Already stopped**: Return early (idempotent)
- **Monitor cancellation fails**: Log warning, continue cleanup
- **Subdirectory stop fails**: Log warning, continue with other monitors

### Edge Cases and Considerations

#### Rapid File Changes

- **Multiple events for same file**: Lists handle duplicates (check before adding by path)
- **Create-then-delete quickly**: File removed from `added`, added to `removed`
- **Modify-then-delete**: File removed from `updated`, added to `removed`

#### Large Numbers of Files

- **Memory usage**: Lists grow with number of changes (acceptable for typical use)
- **Event processing**: GLib's event loop handles events efficiently
- **Performance**: inotify is efficient even with many files

#### Deep Directory Structures

- **Recursive monitoring**: Each level creates a monitor (acceptable overhead)
- **Path length limits**: Handle very long paths gracefully
- **Nested directory creation**: Automatically handled by recursive monitors

#### Concurrent Access

- **Thread safety**: Monitor is not thread-safe (use from single thread)
- **Event handler**: Called from GLib's main event loop (thread-safe)
- **Property access**: Properties should only be accessed after `stop()` is called

#### Filesystem Limitations

- **inotify limits**: System may have limits on number of watches (handle gracefully)
- **Network filesystems**: May not support inotify (fall back gracefully)
- **Symlinks**: Resolve to real paths for consistent tracking

## Implementation Tasks

- [ ] Create `Monitor` class skeleton with constructor
- [ ] Implement `start()` method with GLib.FileMonitor setup
- [ ] Implement `stop()` method with cleanup logic
- [ ] Implement `on_file_changed()` event handler
- [ ] Implement `handle_directory_created()` with recursive monitoring
- [ ] Implement `handle_file_created()` with list management
- [ ] Implement `handle_file_modified()` with list management
- [ ] Implement `handle_file_deleted()` with list management
- [ ] Implement `create_filebase_from_path()` helper method
- [ ] Add path normalization logic
- [ ] Add error handling throughout
- [ ] Add logging for debugging
- [ ] Test inotify monitoring on empty directory
- [ ] Test dynamic directory creation and monitoring
- [ ] Test file creation/modification/deletion detection
- [ ] Test error handling (permissions, missing directories, etc.)
- [ ] Test edge cases (rapid changes, large numbers of files, deep structures)

## Implementation Sequence

### Step-by-Step Implementation

1. **Create basic class structure**
   - Define namespace and class
   - Add properties (lists and private fields)
   - Implement constructor with validation

2. **Implement basic monitoring**
   - Implement `start()` method
   - Create GLib.FileMonitor
   - Connect to `changed` signal
   - Implement basic `on_file_changed()` handler

3. **Implement file change tracking**
   - Implement `handle_file_created()`
   - Implement `handle_file_modified()`
   - Implement `handle_file_deleted()`
   - Test with simple file operations

4. **Implement directory monitoring**
   - Implement `handle_directory_created()`
   - Test with directory creation

5. **Implement recursive monitoring**
   - Add `monitors` HashMap (for all monitors including root)
   - Create monitors for new directories in `handle_directory_created()`
   - Test with nested directory creation

6. **Implement FileBase object creation**
   - Implement `create_filebase_from_path()` method
   - Create File/Folder objects for `added` and `removed` lists
   - Look up files in ProjectFiles for `updated` list
   - Test with various file types

7. **Implement cleanup**
   - Implement `stop()` method
   - Recursively stop all monitors in `monitors` HashMap
   - Finalize and deduplicate change lists (by path)

8. **Add error handling**
   - Add error handling to constructor
   - Add error handling to `start()`
   - Add error handling to event handlers
   - Add logging for debugging

9. **Add path normalization**
   - Normalize all paths to absolute
   - Handle symlinks consistently
   - Ensure path format consistency

### Data Flow

```
1. Monitor created → Constructor validates directory
2. start() called → GLib.FileMonitor created, signal connected
3. Command executes → Filesystem events occur
4. Events arrive → on_file_changed() called by GLib
5. Event handler → Routes to appropriate handle_*() method
6. Handle method → Updates change lists (added/removed/updated) and known_paths
7. Directory created → New Monitor created and started (recursive), Folder added to `added`
8. stop() called → All monitors stopped, lists finalized
9. Properties accessed → Change lists (FileBase objects) available for use
```

### State Transitions

```
[Uninitialized]
    ↓ (Constructor)
[Initialized] (is_monitoring = false)
    ↓ (start())
[Monitoring] (is_monitoring = true, root_monitor active)
    ↓ (Directory created)
[Monitoring + Subdirectories] (subdirectory_monitors populated)
    ↓ (stop())
[Stopped] (is_monitoring = false, lists finalized)
```

## Testing

### Unit Tests

#### Test 1: Basic File Creation
- Create Monitor for empty directory
- Start monitoring
- Create a file in the directory
- Stop monitoring
- Verify file appears in `new_files` list

#### Test 2: File Modification
- Create Monitor for directory with existing file
- Start monitoring
- Modify the existing file
- Stop monitoring
- Verify file appears in `modified_files` list

#### Test 3: File Deletion
- Create Monitor for directory with existing file
- Start monitoring
- Delete the file
- Stop monitoring
- Verify file appears in `deleted_files` list

#### Test 4: Directory Creation
- Create Monitor for empty directory
- Start monitoring
- Create a subdirectory
- Stop monitoring
- Verify directory appears in `new_directories` list
- Verify subdirectory monitor was created

#### Test 5: Nested Directory Creation
- Create Monitor for empty directory
- Start monitoring
- Create nested directories: `subdir/nested/deep/`
- Stop monitoring
- Verify all directories appear in `new_directories` list
- Verify monitors were created for each level

#### Test 6: Rapid File Changes
- Create Monitor for empty directory
- Start monitoring
- Rapidly create, modify, and delete files
- Stop monitoring
- Verify lists are correct (no duplicates, proper state)

#### Test 7: Large Number of Files
- Create Monitor for empty directory
- Start monitoring
- Create 1000 files
- Stop monitoring
- Verify all files appear in `new_files` list
- Verify performance is acceptable

#### Test 8: Deep Directory Structure
- Create Monitor for empty directory
- Start monitoring
- Create directory structure 10 levels deep
- Create files at various levels
- Stop monitoring
- Verify all directories and files are tracked correctly

#### Test 9: Error Handling
- Test constructor with non-existent directory (should throw)
- Test constructor with file path (should throw)
- Test start() with permission denied (should throw)
- Test event handler with invalid paths (should handle gracefully)

#### Test 10: Edge Cases
- Create file, modify it, then delete it (verify proper list state)
- Create directory, create file in it, delete directory (verify cleanup)
- Modify file multiple times (verify single entry in modified_files)
- Create and delete same file multiple times (verify final state)

### Integration Tests

#### Test 1: With Command Execution
- Create Monitor for test directory
- Start monitoring
- Execute shell command that creates/modifies files
- Stop monitoring
- Verify change lists match expected files

#### Test 2: With Overlay (Phase 3)
- Create Overlay instance
- Create Monitor for overlay upper directory
- Start monitoring
- Execute command in overlay
- Stop monitoring
- Verify change lists contain overlay paths

### Performance Tests

- Test with 10,000 file operations
- Test with 100-level deep directory structure
- Test with rapid event bursts (1000 events/second)
- Measure memory usage with large change lists
- Measure CPU usage during monitoring

## Summary

### What This Phase Implements

This phase creates a standalone `Monitor` class that uses inotify (via GLib.FileMonitor) to track filesystem changes during command execution. The class:

1. **Monitors a directory** for file and directory changes
2. **Dynamically creates recursive monitors** for newly created subdirectories
3. **Maintains simple change lists** (new files, modified files, deleted files, new directories)
4. **Provides a clean API** for starting/stopping monitoring and accessing results

### Key Design Decisions

1. **Simple Lists vs. Event Logs**: We maintain simple lists of changed paths rather than detailed event logs. This is sufficient for the use case and easier to work with.

2. **Recursive Monitoring**: We create monitors dynamically for new directories rather than pre-scanning. This is efficient for overlay directories that start empty.

3. **Path Normalization**: All paths are normalized to absolute paths for consistency and easier path manipulation in later phases.

4. **Idempotent Operations**: `start()` and `stop()` are idempotent - they can be called multiple times safely.

5. **Error Resilience**: Event handlers are designed to handle errors gracefully without crashing the monitoring system.

### Integration Points

- **Phase 2 (Current)**: Standalone Monitor class, tested independently
- **Phase 3**: Monitor integrated with Overlay class to track changes in overlay upper directory
- **Phase 4**: Change lists used to determine which files to copy from overlay to live system
- **Phase 5**: Change lists used to determine which files need backups

### Dependencies

- **GLib.FileMonitor**: Provided by GLib (part of Vala standard library)
- **Gee Collections**: Used for lists and maps (HashMap, ArrayList, HashSet)
- **No external dependencies**: Uses only standard Vala/GLib libraries

### Future Enhancements (Not in This Phase)

- Move/rename event handling (for Phase 4+)
- Event filtering (ignore certain file patterns)
- Change statistics (count of changes, total bytes changed)
- Event replay/debugging (detailed event logs for troubleshooting)

## Notes

- This phase only implements monitoring - no overlay or backup support yet
- Monitor will be integrated with overlay in Phase 3
- Change lists will be used for file copying in Phase 3
- The Monitor class is designed to be reusable and testable independently
- All paths are normalized to absolute paths for consistency

