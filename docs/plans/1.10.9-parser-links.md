# Parser of links (1.10.9)

**DO NOT start changing the code base until all of this plan is approved.**

- **Goal:** Parse markdown links (inline `[text](url)` and reference-style `[text][ref]` / `[text][]`), and emit parser events so the renderer can display link text and use the URL for click/hover.
- **Current:** Links are not parsed; the renderer's `on_a()` is a stub (see plan 1.10.10 for rendering).

**Status: open.**

---

## Goal

- Parse markdown links:
  - **Inline:** `[link text](url)` and optional `[link text](url "title")`.
  - **Reference-style:** `[text][ref]` and `[text][]` (ref empty = use link text as ref).
- Emit (same for both styles):
  - `on_a(true, href, title, is_reference)` — for reference-style, **href** is the reference label (not the URL); **is_reference** is true so the consumer can resolve the ref to a URL. The parser does **not** resolve reference targets.
  - `on_text(link_text)` (the content between `[` and `]`)
  - `on_a(false, href, title, is_reference)`
- **Reference-style:** Parser only parses syntax and emits; it does **not** know about or resolve link reference definitions. For `[text][ref]` or `[text][]`, emit with **is_reference = true** and **href =** the ref label (or normalized link text for `[]`). The consumer (e.g. renderer) resolves the label to a URL if it has definitions.

---

## Investigation: two passes and eat() — short vs longer format

- **Current behaviour:**
  - **MarkerMap.eat()** and **FormatMap** use exact string keys: `[`, `[x`, `[X`, `[ `, `[ ]`, `[x]`, `[X]`.
  - No wildcard.
- **Short vs long:**
  - For `[`: `mp["["] = INVALID` → 1‑char match is INVALID, does not update `max_match_length`.
  - For `[ ]`: exact 3‑char key → TASK_LIST.
  - For `[a`: loop builds sequence `"[a]"`; `map.has_key("[a]")` is false → eat() returns `max_match_length` (0).
  - **eat() has an early return:** `if (last_char.isalpha() && last_char.tolower() != 'x') return max_match_length;`
  - So after the second character `a` we never get to a third character; we never consider a 3‑char sequence like `[ab` for a link.
- **Implication:**
  - Option (1): extend format/eat path with a **wildcard** so a 3‑char "link start" can be recognised (e.g. `[??` = `[` + any + any).
  - Option (2): handle links entirely in the parser when we see `[` and eat() gives no match.
  - This plan chooses (1): add a **lead match** `[??` (3 chars, `?` = any character), **real characters matched first** (exact keys `[ ]`, `[x]`, `[X]` take precedence), and do the rest in the **handler** for that format type.

---

## Lead match: `[??` (3 chars, `?` = any character)

- **Wildcard:**
  - We do **not** have wildcarding in the map today.
  - Use **`?` to mean "any character"** in the key.
  - Link **lead match** = **`[??`** — same length as other 3‑char markers (e.g. `***`, `[ ]`, `[x]`).
- **`[?` (2 chars) = indeterminate / need more characters:**
  - With 2 chars starting with `[`, we cannot yet tell if the third char will be task list (`[ ]`, `[x]`, `[X]`) or link (`[??`).
  - So **open bracket + any character** (including `[x`, `[X`, `[ `) is indeterminate.
  - Add key **`[?`** (2 chars, `?` = any); when matched, **eat() returns -1** so the parser defers.
  - We **don't need** separate exact 2‑char keys for `[x`, `[X`, `[ `` — wildcard `[?` covers them.
- **Real characters first:**
  - Exact keys must win.
  - When the 3‑char sequence is `[ ]`, `[x]`, or `[X]` → use TASK_LIST / TASK_LIST_DONE as now.
  - Only when there is **no exact key** for the current 3‑char sequence do we try a key that contains `?`.
  - If the key is `[??`: match when first character is `[` and the next two are any characters (so `[ab`, `[xy`, etc. match; `[ ]`, `[x]`, `[X]` already matched by exact keys).
- **`[` is "incomplete":**
  - In the code, `[` alone is INVALID.
  - We do **not** want to treat a single `[` as the start of a link.
  - **Minimum** commit is 3 characters: `[??`.
  - Lead match = exactly 3 characters; the rest of the link is parsed in the **handler** (see below).

**Implementation in MarkerMap / FormatMap:**

- **FormatMap:**
  - Add a new FormatType (e.g. `LINK` or `LINK_START`) and a key `"[??"` mapped to it.
  - Add **`[?`** (2 chars) for **indeterminate / need more characters** (matches open bracket + any character; eat() returns -1 when this wildcard matches). No need for separate 2‑char exact keys — open bracket x / X / space are indeterminate anyway.
  - Optionally allow keys to contain a literal `?` and treat `?` in a key as "match any character" when doing lookup.
- **MarkerMap.eat():**
  - **Store a wildcard match string** (starts blank). Build it in parallel with `sequence`: when we append to `sequence`, we append to the wildcard string — if the character is alphabetic we append `"?"`, otherwise the same as for `sequence` (digit → `"1"`, else the char). So the wildcard string is `sequence` with every alphabetic character replaced by `?` (e.g. `[a` → `[?`, `[ab` → `[??`).
  - **Do two lookups:** (1) against the regular set — `map.has_key(sequence)`; (2) against the wildcard — `map.has_key(wildcard_sequence)`. If the wildcard lookup returns INVALID, set matched_type to that and return -1 (need more characters). Otherwise use the matched type and length.
  - **Remove the alpha early-return** from its current place (before the lookups) so we can build 2- and 3-char sequences like `[a` and `[ab`. The alpha early-return runs **after** the two lookups (so we still bail for non-wildcard alpha when there’s no match).

---

## Handler for link format: three outcomes

- **Context:** When eat() returns a match for LINK (the `[??` lead), the parser has consumed **3 bytes** (the opening `[` and two "any" characters). The **handler** (code that runs for this format type, analogous to HTML or block handling) must then parse the rest of the link.
- **Three possible outcomes:**
  1. **Not completed yet:** We don't have enough input to decide (e.g. chunk ends before we see `]` or `](`).
     - → Set **leftover_chunk** and return (like HTML or fenced blocks).
  2. **No match:** We have enough input to see it's not a link (e.g. newline before `](`, or the pattern doesn't match).
     - → Treat the 3 consumed characters as literal (emit as text; do not open a link).
     - Optionally backtrack chunk_pos or re‑emit the 3 chars.
  3. **Match:** We find either:
     - **Inline:** `](url)` or `](url "title")` → parse link text, destination, optional title. Emit with **is_reference = false**; href = URL.
     - **Reference-style:** `][ref]` or `][]` → parse link text and ref label (empty ref = use normalized link text as ref). Emit with **is_reference = true**, **href = ref label**. Parser does **not** resolve the ref to a URL.
     - → Emit `on_a(true, href, title, is_reference)`, `on_text(link_text)` (via process_inline_content), `on_a(false, ...)` and advance past the whole link.
  - Regex (or character rules) once past the third character can match either inline or reference-style in one pass.
- **Where:** In the format-handling path: process result of formatmap.eat() when matched type is LINK (same pattern as HTML after eat() returns HTML).

---

## Line break and formatting

- **Intended behaviour (inline format vs newline):**
  - On newline we call **handle_line_break**.
  - It should: (1) **Reset state_stack** — close any open bold, italic, code span (CommonMark: inline scoped per block). (2) Flush text (`str`), end current block, send newline as text.
  - So: **reset state_stack on newline, before we reset/clear the block.**
- **Current behaviour (to fix):** handle_line_break does **not** clear state_stack today; only **start()** does. Add step 1 above.
- **For links:**
  - Line break **before `](`** → link did not complete.
  - In link handler: **newline before `](`** = "no match" — emit consumed chars as literal text; do not open a link.
  - End of chunk and next chunk might have `](url)` → "incomplete". Newline before `](` → definitive "no match."

---

## Characters allowed in link text and URL

- CommonMark specifies link label (link text), link destination (URL), and reference label in section 6.3.
- For a simple implementation, **use GLib.Regex** (no character loops):
  - Link text: e.g. characters until `]` (with escaped `]` allowed).
  - **Inline:** URL = either `<...>` or a restricted set (no unescaped spaces, no `)`).
  - **Reference-style:** Ref label after `][` until `]` (with escaped `]` allowed); empty `][]` = use link text as ref.
- Align with CommonMark 6.3 where practical.

---

## Interaction with task list

- FormatMap already has `[`, `[x`, `[X`, `[ `, `[ ]`, `[x]`, `[X]`.
- We add **`?`** as **indeterminate (need more characters)**:
  - **`[?`** (2 chars): matches **open bracket + any character** (including x, X, space). When matched, eat() returns **-1** so the parser defers. We **don't need** separate 2‑char exact keys for `[x`, `[X`, `[ ` — they're indeterminate anyway, so the wildcard `[?` covers them all.
- For **3 chars**, matching **real characters first** (exact keys) ensures that `[ ]`, `[x]`, `[X]` are always TASK_LIST / TASK_LIST_DONE.
- The wildcard `[??` is only used when the 3‑char sequence is **not** one of those.
- Task list behaviour is unchanged.

---

## Implementation

- **Chosen approach:** extend FormatMap / MarkerMap eat() (lead match + handler). Do **not** add link parsing inline in Parser.add — add is already too large.
- Add `[??` as 3‑char wildcard key in FormatMap (LINK).
- Extend MarkerMap.eat() to support wildcard; allow building 3 chars when prefix is `[`.
- When eat() returns LINK, handler implements: incomplete (leftover_chunk), no match (emit 3 chars as text), or match (parse full link, emit on_a / on_text / on_a).
- Don't change current design where already approved. For **new** link-parsing code: use **GLib.Regex** for link destination/title and for finding link extent; no character loops (CODING_STANDARDS.md). See CommonMark 6.3.

---

## Concrete code (for review and approval)

All changes below are the exact code to apply. Implementation must not deviate from these.

**Code must follow** `.cursor/rules/CODING_STANDARDS.md`:
- Brace style: inline for control structures.
- `this.` for instance members.
- No character loops; use `GLib.Regex` or string methods.
- `Gee.HashMap` via `.set()` / `.get()`.
- No one-line if-with-body; avoid nullable where possible.

### 1. FormatType enum (libocmarkdown/Parser.vala)

Add one enum value:

- **After `TASK_LIST_DONE`:** `LINK` (wildcard `"[??"` → link lead match).

- `"[?"` (2 chars, need more) uses existing **INVALID**; when that wildcard matches, eat() returns -1.
- No new enum for need-more.

```vala
		// ... unchanged ...
		TASK_LIST,
		TASK_LIST_DONE,
		LINK,
		DEFINITION_LIST,
```

### 2. FormatMap init (libocmarkdown/FormatMap.vala)

- **Remove** 2-char task-list keys `[x`, `[X`, `[ `` — wildcard `[?` covers "open bracket + any"; eat() returns -1 for those.
- **Keep** `[` (INVALID) and 3-char exact keys `[ ]`, `[x]`, `[X]` for TASK_LIST / TASK_LIST_DONE.
- **Add** link wildcard keys `[?` and `[??`.

Replace the existing task-list block (use `Gee.HashMap` `.set()` per CODING_STANDARDS):

```vala
			// Task list checkboxes: [ ], [x] (GFM)
			mp.set("[", FormatType.INVALID);
			mp.set("[x", FormatType.INVALID);
			mp.set("[X", FormatType.INVALID);
			mp.set("[ ", FormatType.INVALID);
			mp.set("[ ]", FormatType.TASK_LIST);
			mp.set("[x]", FormatType.TASK_LIST_DONE);
			mp.set("[X]", FormatType.TASK_LIST_DONE);

			mp.set("<", FormatType.HTML);
```

with:

```vala
			// Task list checkboxes: [ ], [x], [X] (GFM). Link lead: "[?" → eat() -1; "[??" → LINK
			mp.set("[", FormatType.INVALID);
			mp.set("[?", FormatType.INVALID);
			mp.set("[??", FormatType.LINK);
			mp.set("[ ]", FormatType.TASK_LIST);
			mp.set("[x]", FormatType.TASK_LIST_DONE);
			mp.set("[X]", FormatType.TASK_LIST_DONE);

			mp.set("<", FormatType.HTML);
```

### 3. MarkerMap.eat() (libocmarkdown/MarkerMap.vala)

**3a. Full existing loop** (for context). Current loop body and what follows. We will add `wildcard_sequence = ""` before the loop and build it each iteration (alpha → `"?"`, else same as sequence); see 3b/3c.

```vala
			for (var cp = chunk_pos; cp < chunk.length; ) {
				var char_at_cp = chunk.get_char(cp);
				sequence += char_at_cp.isdigit() ? "1" : char_at_cp.to_string();
				cp += char_at_cp.to_string().length;
				char_count++;

				var last_char = char_at_cp;
				if (last_char.isalpha() && last_char.tolower() != 'x') {
					return max_match_length;
				}

				if (!map.has_key(sequence)) {
					return max_match_length;
				}

				matched_type = map.get(sequence);

				if (matched_type != FormatType.INVALID) {
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
				}
			}

			// Reached end of chunk (no more characters to eat)
			if (!is_end_of_chunks) {
				// Wildcard INVALID (e.g. "[?") means need more characters to decide
				if (map.has_key(wildcard_sequence) && map.get(wildcard_sequence) == FormatType.INVALID) {
					return -1;
				}
				// Longest possible format marker for * and _ is 3 chars (BOLD_ITALIC)
				if (char_count >= 3) {
					return max_match_length;
				}
				return -1;
			}
			return max_match_length;
```

**3b. Change: maintain a wildcard sequence (starts blank) and do two lookups.**
- Key is the **alpha check (lines 210–212)**: don't return early for alpha; use it to build a **wildcard match string** in parallel with `sequence`.
- **Two lookups:** (1) regular — `map.has_key(sequence)`; (2) wildcard — `map.has_key(wildcard_sequence)`.
- When wildcard returns INVALID → **continue** (let the loop eat another character).
- When we **exit the loop** with no more characters and wildcard match is INVALID → return -1.

- **Wildcard sequence:** Start blank (`wildcard_sequence = ""`). Each time we append to `sequence`, append to `wildcard_sequence`: if the character is alphabetic append `"?"`, else same as `sequence` (digit → `"1"`, else the char). So `wildcard_sequence` is `sequence` with every alphabetic char replaced by `?` (e.g. `[a` → `[?`, `[ab` → `[??`).
- **Remove the alpha early-return** from its current place so we can build 2- and 3-char sequences like `[a` and `[ab`.
- **First lookup:** `map.has_key(sequence)`. If found, set matched_type; if INVALID `continue`, else update max_match_length / byte_length and `continue`.
- **Second lookup:** `map.has_key(wildcard_sequence)`. If found, set matched_type = map.get(wildcard_sequence). If INVALID, **continue** (let the loop eat another character). Else update max_match_length / byte_length and **break** (exit loop; end-of-loop returns max_match_length).
- **Then** the alpha early-return: if we didn’t match and `last_char.isalpha() && last_char.tolower() != 'x'`, return max_match_length.
- **End of loop (reached end of chunk):** When we have no more characters to eat, do the **wildcard check** as well: if `!is_end_of_chunks` and `map.has_key(wildcard_sequence)` and `map.get(wildcard_sequence) == FormatType.INVALID`, return -1 (need more characters). Then the existing logic (char_count >= 3 → return max_match_length, else return -1).

**3c. Concrete change.**

1. **Before the loop** (with `sequence = ""`), add `wildcard_sequence = ""`.
2. **In the loop**, when appending to `sequence`, also append to `wildcard_sequence`: alphabetic → `"?"`, else same as `sequence` (digit → `"1"`, else char). So: `wildcard_sequence += char_at_cp.isalpha() ? "?" : (char_at_cp.isdigit() ? "1" : char_at_cp.to_string());`
3. **Replace** the block from `var last_char` through `matched_type = map.get(sequence);` and the INVALID check with:

```vala
				var last_char = char_at_cp;
				wildcard_sequence += char_at_cp.isalpha() ? "?" : (char_at_cp.isdigit() ? "1" : char_at_cp.to_string());

				if (map.has_key(sequence)) {
					matched_type = map.get(sequence);
					if (matched_type == FormatType.INVALID) {
						continue; // e.g. "[" alone: keep building to try "[a", "[ ]", etc.
					}
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
					continue; // try next char for longer match (e.g. * → ** → ***)
				}
				if (map.has_key(wildcard_sequence)) {
					matched_type = map.get(wildcard_sequence);
					if (matched_type == FormatType.INVALID) {
						continue; // let the loop eat another character
					}
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
					break; // exit loop; end-of-loop returns max_match_length
				}
				if (matched_type != FormatType.NONE) {
					break;
				}
				if (last_char.isalpha() && last_char.tolower() != 'x') {
					return max_match_length;
				}
				return max_match_length;
```

So we **remove** the alpha early-return from the top; we **add** building `wildcard_sequence` each iteration; we do **two** lookups (regular, then wildcard). When wildcard match is INVALID we **continue** (let the loop eat another character). **4. Modify the end of the loop** (“Reached end of chunk”): when `!is_end_of_chunks`, first check `map.has_key(wildcard_sequence) && map.get(wildcard_sequence) == FormatType.INVALID` → return -1; then the existing logic (char_count >= 3 → return max_match_length, else return -1).

We must **not** return early for alpha before trying lookups, so we can build 2- and 3-char sequences like `[a` and `[ab`. The alpha early-return runs only after we've tried exact match and the built lookup key; so we remove it from its current place (before the `has_key` check) and keep it at the end of the block above.

No `wildcard_key_matches` helper — we build a lookup key (first char + `?` / `??` when 2nd/3rd are alpha) and do a normal map lookup. Old **3b. Helper:** `wildcard_key_matches(key, sequence)` (no longer used) — same character length; at each position, key’s character is `?` (matches any) or equals sequence’s character. Used only for the two fixed keys `"[?"` and `"[??"` (2–3 chars), so a short position-wise check is appropriate.

(No separate helper — we maintain wildcard_sequence and do two normal map lookups.)

### 4. handle_line_break — reset state_stack (libocmarkdown/Parser.vala)

In `handle_line_break`, after the two early returns (fenced code, table) and before flushing `str`, reset the formatting stack. Insert **before** `if (str != "")`:

```vala
			// Reset inline formatting so next block starts clean (CommonMark: inline scoped per block)
			this.state_stack.clear();
			if (str != "") {
```

### 5. handle_format_result — LINK branch (libocmarkdown/Parser.vala)

After flushing `str` and computing `seq_pos` (loop that advances past `match_len` characters), **before** `if (matched_format != FormatType.HTML)`:
- Call **eat_link** (parse/consume only; no renderer). If matched, call **handle_link** with the verified link data, then advance `chunk_pos`.

**eat_link return convention** (standard -1 / 0 / >0):
- **-1** = need more — caller sets `leftover_chunk` and returns true.
- **0** = no match — caller emits the 3 lead chars as text, sets `chunk_pos = seq_pos`, returns false.
- **>0** = matched — byte offset after the consumed link; caller calls **handle_link(chunk, chunk_pos, seq_pos, link_result)** so handle_link extracts the verified strings and emits.

```vala
			if (matched_format == FormatType.LINK) {
				var link_result = this.formatmap.eat_link(chunk, chunk_pos, seq_pos, is_end_of_chunks);
				if (link_result == -1) {
					this.leftover_chunk = chunk.substring(chunk_pos, chunk.length - chunk_pos);
					return true;
				}
				if (link_result == 0) {
					this.renderer.on_text(chunk.substring(chunk_pos, seq_pos - chunk_pos));
					chunk_pos = seq_pos;
					return false;
				}
				this.handle_link(chunk, chunk_pos, seq_pos, link_result);
				chunk_pos = link_result;
				return false;
			}
```

### 5a. process_inline_content (libocmarkdown/Parser.vala)

**Purpose:** Parse a string as inline content only (no block handling). Same logic as table cell content — used for link text and table cells. Uses formatmap.eat(), on_text, got_format, add_html; at end pops state_stack and emits closing format callbacks.

**Concrete code** (add this internal method to Parser, e.g. before do_block):

```vala
		/**
		 * Parse a string as inline content only (no block handling). Uses formatmap.eat(),
		 * on_text, got_format, add_html; at end pops state_stack and emits closing format callbacks.
		 * Same logic as table cell content — used for link text and table cells.
		 */
		internal void process_inline_content(string text)
		{
			var pos = 0;
			var str = "";
			while (pos < text.length) {
				var matched_format = FormatType.NONE;
				var byte_length = 0;
				var match_len = this.formatmap.eat(text, pos, true, out matched_format, out byte_length);
				if (match_len == -1) {
					this.renderer.on_text(str);
					str = "";
					var c = text.get_char(pos);
					this.renderer.on_text(c.to_string());
					pos += c.to_string().length;
					continue;
				}
				if (match_len == 0) {
					var c = text.get_char(pos);
					str += c.to_string();
					pos += c.to_string().length;
					continue;
				}
				this.renderer.on_text(str);
				str = "";
				if (matched_format != FormatType.HTML) {
					this.got_format(matched_format);
					pos += byte_length;
					continue;
				}
				var sub = text.substring(pos + byte_length);
				var rest = this.add_html(sub);
				pos += byte_length + (sub.length - rest.length);
			}
			for (var i = this.state_stack.size - 1; i >= 0; i--) {
				this.do_format(false, this.state_stack.get(i));
			}
			this.state_stack.clear();
			if (str != "") {
				this.renderer.on_text(str);
			}
		}
```

### 5b. Inner link content: same path as table cell content

**Purpose:** Link text (e.g. `[**bold**](url)`) must be parsed as inline content so bold, italic, etc. are emitted between `on_a(true)` and `on_a(false)` — not raw `on_text(link_text)`.

- **Example:** The table parser already does this for cell content: **TableState.process_cell** runs the inline loop. We use the same path for link text via **process_inline_content** (see 5a).
- **Shared method:** Parser has **process_inline_content(string text)** (5a). TableState **emit_row** calls **parser.process_inline_content(cells[i])** directly (5e); handle_link calls **process_inline_content(link_text)** (5d).

### 5c. Link callback: remove is_autolink, add is_reference (libocmarkdown/RenderBase.vala and all renderers)

**Purpose:** The parser does not resolve reference targets. For reference-style links it emits the **ref label** as href and **is_reference = true** so the consumer (e.g. renderer) can resolve the ref to a URL if it has link reference definitions.

- **API change:** Remove **is_autolink** (irrelevant for the renderer; autolink `<url>` is a separate syntax not parsed here). Add **is_reference**.
- **Signature:** `on_a(bool is_start, string href, string title, bool is_reference)`
  - **is_reference:** true for reference-style `[text][ref]` / `[text][]`; then **href** is the reference label (not the URL). Consumer resolves if needed.

Update **RenderBase**, **HtmlRender**, **PangoRender**, **DummyRenderer**, **libocmarkdowngtk/Render.vala**: remove `bool is_autolink` from `on_a`; add `bool is_reference`. Existing call sites pass `false` until the parser emits links.

### 5d. handle_link (libocmarkdown/Parser.vala)

**Purpose:** Given the chunk and the consumed link range `[chunk_pos, end_offset)`, extract link text, href, title, and inline vs reference; emit to the renderer. **eat_link** only parses; **handle_link** extracts and renders.

- **Interleaved form:** Emit `on_a(true, href, title, is_reference)`, then **process_inline_content(link_text)**, then `on_a(false, ...)`.
- **Inline:** character after `]` is `(` → href = URL substring, title = "" or parsed title, **is_reference = false**.
- **Reference-style:** character after `]` is `[` → href = ref label (content between `][` and `]`; empty `][]` = normalized link text), title = "", **is_reference = true**.

**Concrete code:**

- **Parser class:** Add static field (lazy-initialized in handle_link; Regex throws only on invalid pattern at construction, not on match — no try/catch needed for match_full):

```vala
		private static GLib.Regex? title_regex = null;
```

- Add this private method to Parser:

```vala
		/**
		 * Extract verified link data from chunk[chunk_pos..end_offset) and emit to renderer.
		 * seq_pos = byte after the 3-char lead [??; end_offset = byte after the link (e.g. after ')' for inline, after ']' for reference).
		 * Sets is_reference true for reference-style; then href is the ref label (consumer resolves to URL).
		 */
		private void handle_link(string chunk, int chunk_pos, int seq_pos, int end_offset)
		{
			var rest = chunk.substring(seq_pos, end_offset - seq_pos);
			var close_idx = rest.index_of_char(']');
			var link_text = chunk.substring(chunk_pos + 1, (seq_pos + close_idx) - (chunk_pos + 1));
			var after_close = seq_pos + close_idx + 1;
			var c1 = chunk.get_char(after_close);
			// Default: inline ](url); href = URL, is_reference = false
			var href = chunk.substring(after_close + 1, (end_offset - 1) - (after_close + 1)).strip();
			var title = "";
			var is_reference = false;
			if (c1 != '(') {
				// Reference-style: ][ref] or ][]; end_offset = byte after closing ]
				is_reference = true;
				var ref_start = after_close + 1;
				var ref_end_byte = end_offset - 1;
				href = ref_end_byte > ref_start
					? chunk.substring(ref_start, ref_end_byte - ref_start).strip()
					: link_text.strip().down(); // [] = use link text as ref (normalized)
			}
			if (title_regex == null) {
				title_regex = new GLib.Regex(
					"^\\s*" +
					"(<[^>]*>|[^\\s\"'()]+)" +
					"(?:\\s+(\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|\\([^)]*\\)))?" +
					"\\s*$");
			}
			GLib.MatchInfo mi;
			if (c1 == '(' && title_regex.match_full(href, -1, 0, 0, out mi)) {
				var dest = mi.fetch(1);
				href = dest.has_prefix("<") ? dest.substring(1, dest.length - 2) : dest.strip();
				var t = mi.fetch(2);
				if (t != null && t.length >= 2) {
					var raw = t.substring(1, t.length - 2);
					title = raw.replace("\\\\", "\\")
						.replace("\\\"", "\"")
						.replace("\\'", "'")
						.replace("\\\)", ")");
				}
			}
			this.renderer.on_a(true, href, title, is_reference);
			this.process_inline_content(link_text);
			this.renderer.on_a(false, href, title, is_reference);
		}
```

### 5e. TableState — inline cell content through parser (libocmarkdown/TableState.vala)

**Purpose:** Use the same inline path as link text. Remove the **process_cell** method entirely and call **parser.process_inline_content(cell_text)** directly where cell content is emitted.

**Concrete code:**

1. **Remove** the entire **process_cell** method (the full inline loop and the method).
2. In **emit_row**, where we currently call `this.process_cell(cells[i])`, call **this.parser.process_inline_content(cells[i])** instead:

```vala
		// In emit_row, for each cell:
		if (is_header) {
			this.parser.renderer.on_table_hcell(true, align);
		} else {
			this.parser.renderer.on_table_cell(true, align);
		}
		this.parser.process_inline_content(cells[i]);
		if (is_header) {
			this.parser.renderer.on_table_hcell(false, align);
		} else {
			this.parser.renderer.on_table_cell(false, align);
		}
```

### 6. eat_link (libocmarkdown/FormatMap.vala)

**Purpose:** Only parse and consume the chunk; do **not** call the renderer or extract link_text/href/title (that is **handle_link**’s job). Return -1 / 0 / >0 (byte offset after the consumed link when matched).

- **Signature:** `public int eat_link(string chunk, int chunk_pos, int seq_pos, bool is_end_of_chunks)`
- **Returns:** -1 need more, 0 no match, >0 byte offset in `chunk` after the consumed link.
- Use **GLib.Regex** for inline link (match full `](...)` so matching `)` is handled by the pattern); no character loops.

**Concrete code:**

- **FormatMap class:** Add static field (lazy-initialized in eat_link; Regex throws only on invalid pattern at construction, not on match — no try/catch needed):

```vala
		private static GLib.Regex? inline_link_regex = null;
```

- Add this method to FormatMap, inside the class, before the constructor:

```vala
		/**
		 * Parse and consume a link after the 3-char lead [??. Only eats the chunk; does not extract strings.
		 * Caller uses returned end offset and passes (chunk, chunk_pos, seq_pos, end_offset) to handle_link.
		 * @return -1 need more input, 0 no match, >0 byte offset in chunk after the consumed link
		 */
		public int eat_link(
			string chunk,
			int chunk_pos,
			int seq_pos,
			bool is_end_of_chunks
		) {
			var rest = chunk.substring(seq_pos, chunk.length - seq_pos);
			var close_idx = rest.index_of_char(']');
			if (close_idx == -1) {
				if (!is_end_of_chunks) {
					return -1;
				}
				return 0;
			}
			// Newline inside link text [..\n..] → not a link (CommonMark); return no match. Newline after the link is valid (no check).
			if (rest.substring(0, close_idx).index_of_char('\n') != -1) {
				return 0;
			}
			var after_close = seq_pos + close_idx + 1;
			if (chunk.length - after_close < 2) {
				if (!is_end_of_chunks) {
					return -1;
				}
				return 0;
			}
			var c1 = chunk.get_char(after_close);
			if (c1 != '(' && c1 != '[') {
				return 0;
			}
			if (c1 == '(') {
				// Match full inline link ](dest "title") or ](dest 'title') or ](dest (title)) with regex; no character loop
				if (inline_link_regex == null) {
					inline_link_regex = new GLib.Regex(
						"^\\s*\\(" +
						"(<[^>]*>|[^\\s\"'()]+)" +
						"(?:\\s+(\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|\\([^)]*\\)))?" +
						"\\s*\\)");
				}
				var rest_link = chunk.substring(after_close, chunk.length - after_close);
				GLib.MatchInfo mi;
				if (inline_link_regex.match_full(rest_link, -1, 0, 0, out mi)) {
					var matched = mi.fetch(0);
					return after_close + matched.length;
				}
				if (!is_end_of_chunks) {
					return -1;
				}
				return 0;
			}
			// c1 == '[' — reference-style: ][ref] or ][]. Parser does not resolve refs; just return end offset.
			var ref_start = after_close + 1;
			var ref_end = chunk.index_of_char(']', ref_start);
			if (ref_end == -1) {
				if (!is_end_of_chunks) {
					return -1;
				}
				return 0;
			}
			return ref_end + 1; // Match; handle_link will set is_reference true and href = ref label
		}
```

### 7. do_format — LINK (libocmarkdown/Parser.vala)

In `do_format`, add a case so LINK is not treated as unknown (no-op; link is handled in `formatmap.eat_link`):

```vala
				case FormatType.LINK:
					// Handled in formatmap.eat_link(); no stack push
					break;
				case FormatType.INVALID:
```

(Add before `case FormatType.INVALID:`.)

### 8. got_format — LINK (libocmarkdown/Parser.vala)

- LINK is never pushed via `got_format` (we branch in `handle_format_result` before `got_format`; link parsing is in `formatmap.eat_link`).
- Optional: in `got_format` add `case FormatType.LINK: return;` to be defensive.

---

## Summary

Implementation must follow the **Concrete code** section above; no design changes beyond what is approved there.

| File | Change |
|------|--------|
| **libocmarkdown/RenderBase.vala** (and all renderers) | Remove **is_autolink** from **on_a**; add **is_reference**. Signature: `on_a(bool is_start, string href, string title, bool is_reference)`. When **is_reference** is true, href is the ref label; consumer resolves to URL (see 5c). |
| **libocmarkdown/Parser.vala** | **handle_line_break**: reset **state_stack** before flushing text. Add **process_inline_content(string text)** (5a). When eat() returns LINK, call **eat_link**; when >0 call **handle_link**. Add **handle_link**: extract link_text/href/title and inline vs reference; emit **on_a(..., is_reference)** and **process_inline_content(link_text)** (5d). Add do_format/got_format LINK cases (7, 8). |
| **libocmarkdown/FormatMap.vala** | Remove 2‑char keys `[x`, `[X`, `[ `; add `"[?"` and `"[??"` (LINK). Add **eat_link**: returns -1/0/>0; for reference-style return byte offset after `]` so handle_link can set is_reference true and href = ref label. |
| **libocmarkdown/MarkerMap.vala** | In eat(): maintain **wildcard_sequence** (starts blank; build in parallel with sequence — alphabetic → `?`). **Two lookups:** (1) `map.has_key(sequence)`, (2) `map.has_key(wildcard_sequence)`. If wildcard match is INVALID, return -1. Remove alpha early-return from top; do two lookups, then alpha return at end. |
| **libocmarkdown/TableState.vala** | Remove **process_cell** method. In **emit_row**, call **this.parser.process_inline_content(cells[i])** where each cell’s content is emitted (see 5e). |

---

## Outstanding / to decide

These are mentioned in Goal or Verification but **not** fully specified in the concrete code. Decide how to handle them before or during implementation.

### 1. Optional title: `](url "title")` — implemented

- **Goal:** "optional `[link text](url "title")`"; Verification: "ensure `on_a(..., title)` receives the title."
- **Implemented in §5d handle_link and §6 eat_link:** `handle_link` parses inner content with **GLib.Regex**: destination (angle-bracket `<...>` or bare until space/quote/paren) then optional title in `"..."`, `'...'`, or `(...)` with unescape. `eat_link` for inline link finds the **matching** closing `)` via **regex** (no character loop / depth scan).

**CommonMark 6.3 semantics (we implement via regex):**

1. **Inner content** = everything between `(` and the **matching** `)` (counting nested parens if title uses `(title)`).
2. **Destination:**  
   - If inner content starts with `<`, destination = from `<` to the next `>` (angle-bracket form; can contain spaces).  
   - Else destination = run of characters until first space or first `"` or `'` or `(` (bare form; no spaces).
3. **Optional title:** After destination, skip optional whitespace. If next char is `"`, `'`, or `(`, then title is the content until the **matching** closing `"`, `'`, or `)`. Unescape backslashes inside title.
4. **Implementation:** Use **GLib.Regex** only for parsing inner content and for finding the extent of the inline link; no character loops, no index_of_char–based scanning of link content. The concrete code in §5d (handle_link) and §6 (eat_link) uses regex patterns for this.

**Concrete:** The parsing in **handle_link** when `c1 == '('` uses the regex given in §5d. **eat_link** must return the correct end offset (byte after the matching `)`); for title in `(...)` the matching `)` is the link’s closing paren, so end_offset is already that. For bare URL + `"title"` or `'title'`, end_offset is byte after the closing `)` of the link. No change to eat_link return convention; handle_link receives the full range and parses inner.

### 2. Reference-style: `][ref]` and `][]` — decided

- **Decision:** Parser does **not** resolve reference targets. Add **is_reference** to **on_a**. For `[text][ref]` or `[text][]`, parser emits **is_reference = true** and **href =** ref label (or normalized link text for `[]`). Consumer (e.g. renderer) resolves the ref to a URL if it has link reference definitions. **eat_link** returns end offset for reference-style; **handle_link** sets is_reference and href = ref label (see 5c, 5d, §6).

### 3. Verification (post-implementation)

- Not missing implementation — just run the Verification section after implementing. No design decision; ensure tests exist or are added for: `[OpenAI](url)`, task list `[ ]`/`[x]`, streaming chunk boundary.

---

## Verification

- Parser tests: input `[OpenAI](https://openai.com)` and confirm the parser emits `on_a(true, "https://openai.com", null, false)`, `on_text("OpenAI")`, `on_a(false, ...)`.
- Test with title: `[text](url "title")` and ensure `on_a(..., title)` receives the title.
- Test reference-style: `[text][ref]` and `[text][]` (with link reference definition for ref) emit correct href/title.
- Test that task list `[ ]` and `[x]` are still recognized and not consumed as links.
- Test streaming: chunk ending with `[some text` defers correctly until next chunk with `](url)` or `][ref]`.

---

## Dependencies

- None beyond current parser. Rendering of links is in plan 1.10.10.
