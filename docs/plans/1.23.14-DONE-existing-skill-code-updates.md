# 1.23.14 Updates to existing skill code

**Note:** Do not add sentences to this plan unless specifically asked — only bullet points or nested bullet points.

**Coding standards:** Follow `.cursor/rules/CODING_STANDARDS.md`. This plan uses: **this.** for instance members; **var** for initializers where type not required; fill() with one key, value per line; no trailing null (Vala adds for varargs); **GLib.Error**; no underscore names; no get_* for simple accessors.

---

## Overview

- Sub-plan of **1.23.11**. Updates to existing skill classes: Runner, PromptTemplate, Factory, Manager, Definition.
- Task-related types (TaskList, TaskStep, Task, parsers) are in **1.23.13**.

**Status:** Partially implemented. Completed work is in **1.23.14-outstanding** (definition fetching, resolving references, current file, validate tasks, skill catalog). Remainder → **1.23.18-tail-end-issues**.

**Done (per 1.23.14-outstanding):**
- **reference_content(href)** — Implemented on Runner (#anchor from user_request.headings); Details uses it and reference_link_contents(link, contents). File refs in Details via project manager.
- **project_manager / current_file** — On **Skill.Factory**, not Runner. Factory.current_file() returns File?; Runner and Details use sr_factory.project_manager and sr_factory.current_file().
- **Task definition resolution** — Details uses **skill_manager.fetch(this)** (alias to runner.sr_factory.skill_manager); Manager.fetch(Task) and validate(Task) per 1.23.14-outstanding §1.
- **Validate skills** — List.validate_skills(); send_async flow uncommented.

**Remaining (→ 1.23.18-tail-end-issues):**
- **validate_task_list_reference_lengths(TaskList)** — Runner method; align with Details resolution. See 1.23.18-tail-end-issues §3.
- **Naming:** run_until_user_approval → run_until_writer; has_tasks_requiring_approval → has_writer_tasks. See 1.23.18-tail-end-issues §4.
- **Task naming and output references** (#slug-number-results, output: resolution). See 1.23.18-tail-end-issues §1.
- **validate_reference_targets** #anchor validation. See 1.23.18-tail-end-issues §2.

**Other:** PromptTemplate per **1.23.17**. Task refinements (List, Step, Details, ResultParser) → **1.23.15**.

**Dependencies:** 1.23.11 (parent), 1.23.13 (task-related code, DONE), 1.23.15 (task refinements), 1.23.17 (template changes), 1.23.2, 1.23.3–1.23.6 (formats), 1.23.1 (existing Runner/Manager/Definition).

---

## Runner (`liboccoder/Skill/Runner.vala`)

- **Prompt templates**
  - Use PromptTemplate per **1.23.17** (template(filename) returns new instance; fill stores rendered). No hashmap in Runner.
- **Entry and loop**
  - Entry: **prepare_tasks** (loop until valid task list **and** skills validated **and** reference lengths validated) → rounds (refine started, run_until_writer, writer approval gate, run_all_tasks, run_task_list_iteration) → loop or conclude.
  - **Validate skills before refinement:** Inside prepare_tasks, after parsing (check **parser.issues == ""** for success; no parser.valid), **TaskList.validate_skills()** checks that every task's skill_name exists (using its Runner reference). If any task references a missing skill, it returns an issues string; Runner appends to parser.issues and retries.
  - **Validate reference content length:** Not yet implemented. When added, Runner **validate_task_list_reference_lengths(TaskList)** per 1.23.18-tail-end-issues §3.
  - **Before sending to LLM:** After building user_content (template fill), create **this.user_request** from user_content — parse user_content into a Markdown.Document. Task/Details use **runner.reference_content(href)** (which uses user_request.headings.get(anchor).to_markdown_with_content()).
  - Loop: `for (var i = 0; i < 5; i++)`. If **!this.task_list.has_pending_exec()** break; else **refine**, run_until_user_approval (align to run_until_writer per 1.23.18 §4), writer approval gate, run_all_tasks, run_task_list_iteration. After loop, if hit max rounds and still pending, add_message "Max rounds reached."
  - TaskList API: see **1.23.13**.
- **Fields**
  - **task_list** — Result from task creation or task list iteration (1.23.3 format). Type: **TaskList** (see 1.23.13). Completed outputs: task.exec_done is true when executor finishes; output data on task.result (summary, details_path). (previous_proposal / previous_proposal_issues are **not** on TaskList; they are locals in **send_async** only.)
  - **user_request** — Markdown.Document created from user_content (the filled template string), right before sending to the LLM. Task/Details resolve refs via **this.user_request.headings.get(anchor).to_markdown_with_content()** (Runner.reference_content(href)).
  - **writer_approval** — True once user has approved running writer (modify) tasks this run.
  - **Project manager / current file** — On **Skill.Factory**, not Runner (1.23.14-outstanding §4). Runner and Details use **sr_factory.project_manager** and **sr_factory.current_file()**.
  - Max rounds: literal 5 with a comment; after loop, flag (e.g. hit_max_rounds) for "Max rounds reached."

- **task_creation(user_prompt, previous_proposal, previous_proposal_issues)** — Returns the PromptTemplate for `task_creation_initial.md`. Performs the fill (tpl.fill(…) and tpl.system_fill(…) with user_prompt, env(), project description, previous_proposal, previous_proposal_issues, skill_catalog). Caller uses tpl.filled_user and tpl.filled_system (1.23.17).
- **Planned test class** — Call task_creation() with controlled inputs; assert on tpl.filled_user and tpl.filled_system to verify template fills.

**task_creation()** — Implemented per 1.23.14-outstanding §4: uses **sr_factory.current_file()**, fill keys user_prompt, environment, project_description (stubbed ""), current_file, open_files, previous_proposal, previous_proposal_issues, skill_catalog (sr_factory.skill_manager.to_markdown()). No system_fill; single fill() with headers per template.

**Proposed code — send_async and handle_task_list** (naming run_until_writer / has_writer_tasks to be aligned per 1.23.18-tail-end-issues §4; current code uses run_until_user_approval / has_tasks_requiring_approval):

```vala
/** Entry point. Sends user request only; when finished calls handle_task_list. */
public async void send_async(string user_prompt, GLib.Cancellable? cancellable = null) throws GLib.Error
{
	var previous_proposal = "";
	var previous_proposal_issues = "";
	for (var try_count = 0; try_count < 5; try_count++) {
		var tpl = this.task_creation(user_prompt, previous_proposal, previous_proposal_issues);
		this.user_request = tpl.user_to_document();
		var messages = new Gee.ArrayList<OLLMchat.Message>();
		messages.add(new OLLMchat.Message("system", tpl.filled_system));
		messages.add(new OLLMchat.Message("user", tpl.filled_user));
		var response = yield this.chat_call.send(messages, cancellable);
		var parser = new ResultParser(this, response);
		parser.parse_task_list();
		if (parser.issues == "") {
			var skill_issues = parser.task_list.validate_skills();
			if (skill_issues == "") {
				this.task_list = parser.task_list;
				yield this.handle_task_list();
				return;
			}
			parser.issues = skill_issues;
		}
		previous_proposal = parser.proposal;
		previous_proposal_issues = parser.issues;
	}
	this.task_list = new TaskList();
	this.add_message(new OLLMchat.Message("ui", "Could not build valid task list after 5 tries."));
}

/** Deals with the task list only. Called by send_async when it has a valid task_list. */
private async void handle_task_list() throws GLib.Error
{
	this.writer_approval = false;
	var hit_max_rounds = true;
	for (var i = 0; i < 5; i++) {
		if (!this.task_list.has_pending_exec()) {
			hit_max_rounds = false;
			break;
		}
		this.task_list.refine(this);
		yield this.task_list.run_until_writer(this);
		if (this.task_list.has_writer_tasks() && !this.writer_approval) {
			var approved = yield this.request_writer_approval();
			if (!approved) {
				this.add_message(new OLLMchat.Message("ui", "User declined writer approval."));
				return;
			}
			this.writer_approval = true;
		}
		yield this.task_list.run_all_tasks();
		yield this.run_task_list_iteration();
	}
	if (hit_max_rounds && this.task_list.has_pending_exec()) {
		this.add_message(new OLLMchat.Message("ui", "Max rounds reached."));
	}
}
```

- **TaskList.validate_skills()** — Implemented (1.23.14-outstanding §5). Returns string; Runner sets parser.issues when non-empty.
- **validate_task_list_reference_lengths(TaskList)** — Not implemented. See **1.23.18-tail-end-issues** §3.
- **Task-resolved definition:** Details uses **skill_manager.fetch(this)** (alias to runner.sr_factory.skill_manager). No get_definition on Runner; Manager.fetch(Task) and validate(Task) per 1.23.14-outstanding §1.
- **Task sends as agent (1.23.13):** Task extends OLLMchat.Agent.Base; Runner creates Task with (this, factory, session). Task uses **this.chat_call.send(messages)** for refine and post_evaluate. Runner does **not** provide send_system_user.
- **Refinement / Executor / Task list iteration** — Invoked from TaskList (task.refine, task.run_tools, task.post_evaluate) or Runner calls run_task_list_iteration() directly (no TaskList method). See 1.23.13 for Task behaviour. Runner uses template keys **"task_refinement"**, **"task_execution"**, **"task_list_iteration"** (no Runner state; key passed explicitly).
- **Request writer approval** — When task_list.has_writer_tasks() and !writer_approval: yield request_writer_approval(); on approve set this.writer_approval = true; on deny this.add_message(new OLLMchat.Message("ui", "User declined writer approval.")) and return. **request_writer_approval()** — async, returns bool (true = approved, false = denied).
- **UI messages** — Runner extends Agent.Base; use **this.add_message(new OLLMchat.Message("ui", text))** (or "ui-warning" for warnings). Session displays via message_added; no separate send method.
- **Template** — Use PromptTemplate per **1.23.17**; then tpl.system_fill(…) and tpl.fill(…) with placeholders for that key.

**Runner API for Task (implemented per 1.23.14-outstanding)**

- **project_manager / current_file** — On **Skill.Factory**, not Runner. Details and Runner use **sr_factory.project_manager** and **sr_factory.current_file()**.
- **reference_content(string href)** — Implemented (§3): #anchor → user_request.headings.get(anchor).to_markdown_with_content(); output:/http(s) return "". See 1.23.14-outstanding §3.
- **env()** — Uses sr_factory.project_manager for workspace path.
- **Skill definition** — Details use **skill_manager.fetch(this)** (Manager.fetch(Task)); no Runner.get_definition(). See 1.23.14-outstanding §1.

---

## PromptTemplate (`liboccoder/Skill/PromptTemplate.vala`)

- **Template API, fill behaviour, resource location, optional sections:** See **1.23.17**. Runner and Details use PromptTemplate.template(filename) and fill per 1.23.17 (filename = e.g. `task_creation_initial.md`; fill stores rendered; optional {tag/start},{tag/end}).
- **Proposed code** for Runner/Details: `var tpl = PromptTemplate.template("task_creation_initial.md");` (or agreed key); `tpl.fill(…)`, `tpl.system_fill(…)` per 1.23.17. Full PromptTemplate implementation is specified in **1.23.17**.

---

## Factory (`liboccoder/Skill/Factory.vala`)

- Support **skill-prompts** directory as well as **resources/skills**
  - Prompts for creation/refinement/post-completion/execution live in `skill-prompts`.
  - Executor skill files in `resources/skills`.
  - Manager/PromptTemplate handle both as needed.
- Ensure Runner can be created for the send_async flow (not only "one skill by name").
  - Entry from app/agent for planner mode vs current single-skill mode.

---

## Manager (`liboccoder/Skill/Manager.vala`)

- **Skill catalog**
  - Provide a form suitable for task-creation prompt: name + description from each executor skill's frontmatter (from `resources/skills`). Single string or structured list for `{skill_catalog}`.
- **Resolve by name**
  - Already has `by_name`; ensure executor skills in `resources/skills` are scanned and available. Runner loads skill definition by task's Skill field and runs tools by name.

---

## Definition (`liboccoder/Skill/Definition.vala`)

- **Refinement**
  - Expose "skill input requirements" (e.g. a designated section of the body) so Runner/Task can pass it to the refinement prompt. If already derivable from body/full_content, document it; otherwise add a simple accessor or parse.
- **Executor**
  - Runner/Task uses `full_content` (or body) as `{skill_definition}` for the interpreter. No change if that contract is already satisfied.

---

## Prompt refinements (task list format) — 1.23.13 parser

- **Task creation (initial) and post-completion prompts** must require the format expected by the parser (1.23.13):
  - Under each **### Task section N**, use **one list per task with a break between each**: a top-level list where **each list item is one task** (blank line or structural break between items).
  - Within each list item: a **nested list** with **What is needed**, **Skill**, **References**, **Expected output**.
  - Update **task_creation_initial.md** and **task_list_iteration.md** (and any continuation prompt) so the LLM outputs this structure. Example: Task section 1 → list item 1 (task 1) with nested list of fields; list item 2 (task 2) with nested list; etc.

---

## References

- 1.23.11 (parent); 1.23.13 (task-related code); 1.23.2, 1.23.3–1.23.6 (formats); 1.23.1 (existing Skill Runner).
- **1.23.14-outstanding** — Implemented work (definition fetching, resolving references, current file, validate tasks, skill catalog, reference_link_contents).
- **1.23.18-tail-end-issues** — Remaining tasks (task naming, validate_reference_targets #anchor, validate_task_list_reference_lengths, naming alignment).
