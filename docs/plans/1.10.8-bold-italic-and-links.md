# Bold+Italic and link support (1.10.8)

- **Bold+Italic:** We do not currently support `***bold italic***` / `___bold italic___`. The parser has `FormatType.BOLD_ITALIC` and `do_format` correctly calls `on_strong(true)`, `on_em(true)` and on close `on_em(false)`, `on_strong(false)`. The bug is in **MarkerMap.eat()**: when the loop consumes the whole chunk (e.g. `"***"`), it always returns `-1` if `!is_end_of_chunks`, so the 3‑char match is never committed and bold+italic never opens.
- **Links:** Markdown links `[text](url)` are not parsed; the GTK renderer’s `on_a()` is a stub that shows the href as text and does not store the URL on the tag or handle click/hover.

**Status: open.**

---

## Part A: Bold+Italic (*** / ___)

### Goal

Support `***bold italic***` and `___bold italic___` so that opening and closing are recognized and the renderer receives `on_strong(true)`, `on_em(true)` and later `on_em(false)`, `on_strong(false)`.

### Root cause

In **libocmarkdown/MarkerMap.vala**, `eat()` builds the longest matching prefix in a loop. When the loop exits because `cp >= chunk.length` (end of chunk), the code does:

```vala
// Reached end of chunk
if (!is_end_of_chunks) {
    return -1;
}
return max_match_length;
```

So for `"***"` at the start of a chunk when more data may follow, `eat()` always returns `-1` and the parser defers the rest of the chunk; the 3‑char BOLD_ITALIC match is never applied.

### Fix (MarkerMap.eat)

After the loop, when we have reached the end of the chunk:

- If `is_end_of_chunks`: return `max_match_length` (current behaviour when at end of stream).
- If `!is_end_of_chunks` but the sequence we built is the **longest possible** for this marker (e.g. 3 characters for `*` and `_`), return `max_match_length` so we commit the match instead of deferring.
- Otherwise (e.g. `"**"` at end of chunk with more data coming) return `-1` so we can still see `"***"` in a later chunk.

Concretely: after the loop, keep a variable for the current sequence length (e.g. use `char_count` or `sequence.length`). Then:

- If `is_end_of_chunks`: `return max_match_length;`
- If `char_count >= 3`: `return max_match_length;` (no 4‑char format marker in FormatMap)
- Else: `return -1;`

So `"***"` always returns 3; `"**"` at end of chunk returns -1 until we see the next character or end of stream.

### Files (Part A)

| File | Change |
|------|--------|
| **libocmarkdown/MarkerMap.vala** | After the loop, when at end of chunk: if `is_end_of_chunks` return `max_match_length`; else if `char_count >= 3` return `max_match_length`; else return `-1`. |

### Verification

- Add or extend tests (e.g. in **examples/oc-test-gtkmd.vala** or parser tests) for `***bold italic***` and `___bold italic___` so that both open and close correctly and render as bold+italic.

---

## Part B: Links [text](url)

### Goal

- Parse markdown links `[link text](url)` and optional `[link text](url "title")`.
- Render as styled text (e.g. blue, underline) showing the **link text**, not the URL.
- Store the **URL** so that click opens it and hover can show it (e.g. tooltip).

Event handling for click and hover must live on the widget that displays the text (the render box or each TextView). The handler gets the buffer position under the pointer, finds the tag(s) there, and if a tag is a “link” tag, uses the stored URL (open on click, show on hover).

### B.1 Parser: emit link events

- **Syntax:** `[link text](url)` or `[link text](url "title")`. No support required in this plan for reference-style `[text][ref]` or `[text][]`.
- **Interaction with `[`:** FormatMap uses `[` for task lists (`[ ]`, `[x]`, etc.). Link parsing must not consume those. So at `[` we need to peek: if the rest of the chunk (or after accumulating) matches ` ]` or `x]` or `X]` (task list), use existing behaviour; else look for `](url)` or `](url "title")` for a link.
- **Flow:** When we recognize a link:
  1. Emit `on_a(true, href, title, false)`.
  2. Emit `on_text(link_text)` (the content between `[` and `]`).
  3. Emit `on_a(false, href, title, false)`.

Implementation options:

- **Option 1 (inline in Parser.add):** When we see `[` and it’s not a task-list marker, try to parse up to `](`, then `url`, then optional ` "title"`, then `)`. If that fails (e.g. no `](` before newline or end of chunk), treat `[` as literal or defer (leftover_chunk). This is similar to how HTML or fenced blocks are handled.
- **Option 2 (FormatMap / MarkerMap):** Add a link “marker” that doesn’t fit the single-character eat() model well; links are variable-length and have structure. So link parsing is better as a separate branch in the parser (like HTML) rather than in FormatMap.eat().

Recommended: implement link parsing in **Parser** (or a small helper used by Parser): when at `[`, if not task list, scan for `](url)` / `](url "title")` and emit the three callbacks above; otherwise treat `[` as normal (or flush and continue). Handle streaming by deferring with `leftover_chunk` when the chunk ends before we can tell (e.g. `[some text` at end of chunk).

### B.2 GTK Renderer: store URL on the tag

- **Current behaviour:** **libocmarkdowngtk/Render.vala** `on_a()` adds a state with blue + underline but then immediately adds the **href** as text and closes the state. So the link text is wrong and the URL is not stored for events.
- **Target behaviour:**
  - On `on_a(true, href, title, false)`: open a link state (styled: e.g. blue, underline), and **associate this state’s tag with the URL** so we can resolve it on click/hover. Do **not** add href as text; do not close the state.
  - The following `on_text(link_text)` will be rendered inside this state (so the user sees the link text).
  - On `on_a(false, ...)`: close the link state as today.

To associate the tag with the URL:

- **Option A:** In **Render**, keep a `Gee.HashMap<Gtk.TextTag, string>` (e.g. `link_url_by_tag`). When we create the link state in `on_a(true, href, ...)`, after `add_state()` do `link_url_by_tag[link_state.style] = href`. Event handlers can then look up the tag under the cursor in this map.
- **Option B:** Use `Gtk.TextTag` custom data (e.g. `tag.set_data("href", href)`) if available in Vala/GTK4; otherwise Option A is simpler and avoids binding quirks.

Recommendation: **Option A** — Render holds `Gee.HashMap<unowned Gtk.TextTag, string> link_url_by_tag` (or similar), register in `on_a(true, ...)`, and do not remove when the state closes (the tag remains applied to a range). Clear or prune the map only when the buffer/widget is destroyed or when a full re-render happens, as appropriate.

### B.3 Event handling: click and hover

- **Where:** The widget that actually displays the text must handle events. That is either:
  - The **Gtk.Box** that holds the TextViews (Render’s `box`), with logic to find which child TextView received the event and the position in that view, or
  - **Each Gtk.TextView** created by Render (in `create_textview()` and anywhere table cells get a TextView).

- **Click (open link):** On `button-release-event` (or similar), get the event coordinates, convert to buffer coordinates (e.g. `get_iter_at_position` / `get_iter_at_location`), get the list of tags at that iter, and for each tag check whether it is in `link_url_by_tag`. If so, open the URL (e.g. `Gtk.show_uri()` or app-specific handler) and stop.

- **Hover (show URL):** On `motion-notify-event`, get the iter at the pointer, look up tags in `link_url_by_tag`. If one is a link tag, set the widget tooltip to the URL (or “Open: &lt;url&gt;”); otherwise clear or set default tooltip. So the handler must be on the same widget that has the buffer (the TextView), or the box must delegate to the correct child and set tooltip on the appropriate widget.

Prefer connecting **per TextView** in Render when creating each TextView (and each table-cell TextView): connect `button-release-event` and `motion-notify-event`. The handler has direct access to that view’s buffer and can use Render’s `link_url_by_tag` to resolve tags. Render must expose or use `link_url_by_tag` in these handlers (e.g. pass Render reference or store it where the handler can read it). If the box is the only place we can attach signals (e.g. for dynamically added children), the box’s handler must find the child at the event coordinates and forward to the same logic using that child’s buffer.

- **Cursor:** Optionally set the cursor to a “pointer” when over a link (same tag lookup); reset when not over a link.

### B.4 Summary of link changes

| Component | Change |
|-----------|--------|
| **libocmarkdown/Parser.vala** | When at `[` and not task list, parse `[link text](url)` and optional ` "title"`. Emit `on_a(true, href, title, false)`, `on_text(link_text)`, `on_a(false, href, title, false)`. Use leftover_chunk when more input is needed. |
| **libocmarkdowngtk/Render.vala** | Add `Gee.HashMap<unowned Gtk.TextTag, string> link_url_by_tag`. In `on_a(true, href, ...)`: add link state (blue, underline), register `link_url_by_tag[link_state.style] = href`; do not add href as text or close state. In `on_a(false, ...)`: only close state. When creating each TextView (and table cell TextView), connect `button-release-event` and `motion-notify-event` to a handler that gets iter at position, looks up tags in `link_url_by_tag`, and on click opens the URL (e.g. `Gtk.show_uri`), on motion sets/clears tooltip and optionally cursor. |

### Verification (links)

- Manual or automated test: input `[OpenAI](https://openai.com)` and confirm the visible text is “OpenAI”, styled (e.g. blue, underline), and that click opens the URL and hover shows it (e.g. tooltip).
- Test with title: `[text](url "title")` and ensure title is handled (stored if needed; tooltip can show title or URL as desired).

---

## Dependencies

- Part A (Bold+Italic): none beyond current parser/renderer.
- Part B (Links): Part B.1 (parser) can be done first; B.2 and B.3 (renderer + events) depend on B.1.

---

## Files to touch (summary)

| File | Part A | Part B |
|------|--------|--------|
| **libocmarkdown/MarkerMap.vala** | Fix end-of-chunk return for 3‑char match | — |
| **libocmarkdown/Parser.vala** | — | Link parsing and `on_a` emission |
| **libocmarkdowngtk/Render.vala** | — | `link_url_by_tag`, fix `on_a`, connect click/hover per TextView |
| **examples/oc-test-gtkmd.vala** or tests | Optional: bold+italic + link examples | Optional: link examples |

This plan gives a clear path to fix bold+italic (1.10.8 Part A) and to add link parsing, storage of URL on the tag, and click/hover handling (1.10.8 Part B).
