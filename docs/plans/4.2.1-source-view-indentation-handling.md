# Source View Indentation Detection and Handling

## Overview

This plan covers implementing indentation detection and proper indentation handling for code inserted via edit mode in the source view editor. The goal is to:

1. Detect file indentation style (tabs vs spaces, and if spaces, how many)
2. Enable visual display of whitespace characters in the editor
3. Automatically adjust indentation when edit mode inserts code

## Requirements

### 1. Indentation Detection

**Location**: `liboccoder/SourceView.vala` and `liboccoder/GtkSourceFileBuffer.vala`

**Goal**: Detect indentation style from the source buffer once it's loaded.

**Approach**:
- After buffer is loaded (in `open_file()` or when buffer content is set), analyze the buffer content
- Scan first 100 lines in the buffer to detect indentation patterns
- Algorithm:
  1. Iterate through first 100 lines in the buffer (skip empty lines)
  2. For each non-empty line, check the leading whitespace:
     - Use `line.chug()` to remove leading whitespace, compare lengths to get prefix
     - Get prefix: `line.substring(0, line.length - line.chug().length)`
     - Count tabs in prefix: `prefix.replace(" ", "").length`
     - Count spaces in prefix: `prefix.replace("\t", "").length`
     - Use `line.has_prefix("\t")` to quickly detect tab usage
  3. Track statistics:
     - Count of lines using tabs
     - Count of lines using spaces
     - For space-indented lines, track the number of spaces used
  4. Early termination:
     - Stop scanning once we find 10 lines with tabs OR 10 lines with spaces
     - This provides enough data to make a determination without scanning all 100 lines
  5. Determine indentation style:
     - If tabs are used in any line, prefer tabs
     - If only spaces are used, determine the most common space count (could be 2, 4, 8, etc.)
     - Store this information per file/buffer

**Implementation Details**:
- Add properties to `GtkSourceFileBuffer`:
  - `bool uses_tabs { get; private set; default = true; }`
  - `int indent_size { get; private set; default = 4; }` (number of spaces per indent level, or 0 if using tabs)
- Add method `detect_indentation()` that analyzes first 100 lines of buffer content
- Call `detect_indentation()` after buffer is loaded in:
  - `GtkSourceFileBuffer.read_async()` after setting text
  - `SourceView.open_file()` after buffer is loaded
- Follow coding standards: minimal temp vars, avoid else, use continue/return early

**Edge Cases**:
- Empty file: Use defaults (tabs, 4-space equivalent)
- Mixed indentation: Prefer tabs if any tabs found, otherwise use most common space count
- Files with only empty lines: Use defaults
- Files with fewer than 100 lines: Analyze all available lines

### 2. Display Whitespace Characters

**Location**: `liboccoder/SourceView.vala`

**Goal**: Enable visual display of spaces and tabs in the source view editor.

**Approach**:
- Use GtkSource.View's `draw_spaces` property to show spaces
- Use GtkSource.View's `draw_tabs` property to show tabs
- Enable these properties in the SourceView constructor

**Implementation Details**:
- In `SourceView` constructor (around line 162), after creating `GtkSource.View`:
  ```vala
  // Enable whitespace display
  this.source_view.draw_spaces = GtkSource.DrawSpacesFlags.ALL;
  this.source_view.draw_tabs = true;
  
  // Set tab width to 4 spaces (fixed)
  this.source_view.tab_width = 4;
  ```
- Or use more granular control for draw_spaces:
  ```vala
  this.source_view.draw_spaces = GtkSource.DrawSpacesFlags.SPACE | 
                                  GtkSource.DrawSpacesFlags.TAB |
                                  GtkSource.DrawSpacesFlags.NEWLINE |
                                  GtkSource.DrawSpacesFlags.NBSP;
  ```

**Note**: 
- Check GtkSource API documentation for exact property names and enum values. The property might be `draw_spaces` with flags, or separate `show_spaces`/`show_tabs` boolean properties.
- Tab width is fixed at 4 spaces to match the default indent_size. This ensures tabs are displayed consistently.

### 3. Edit Mode Indentation Handling

**Location**: `liboccoder/GtkSourceFileBuffer.vala` (in `apply_edits()` method)

**Goal**: Automatically adjust indentation when code is inserted via edit mode.

#### 3a. Modifying Lines (Insertion/Replacement)

**Scenario**: When edit mode inserts code that modifies existing lines.

**Approach**:
1. For each `FileChange` in `apply_edits()`:
   - If `change.start == change.end` (insertion):
     - Get the line before insertion point (`change.start - 1`)
     - Extract leading whitespace from that line
     - Use that as the base indentation
   - If `change.start != change.end` (replacement):
     - Get the first line being replaced (`change.start`)
     - Extract leading whitespace from that line
     - Use that as the base indentation
2. Process the replacement text:
   - Split replacement text into lines
   - Find the minimum leading whitespace across all non-empty lines in the replacement
   - Remove that minimum whitespace from all lines (normalize to no indentation)
   - Prepend the base indentation to each line
3. Apply the adjusted replacement text

**Implementation Details**:
- Add method to `FileChange` class (`libocfiles/FileChange.vala`):
  ```vala
  /**
   * Normalize indentation of replacement text based on base indentation.
   * 
   * Removes minimum leading whitespace from all lines, then prepends base_indent.
   * 
   * @param base_indent The base indentation string to prepend to each line
   */
  public void normalize_indentation(string base_indent)
  {
      if (this.replacement.length == 0) {
          return;
      }
      
      var lines = this.replacement.split("\n");
      var normalized_lines = new Gee.ArrayList<string>();
      
      // Find minimum leading whitespace
      int min_indent = int.MAX;
      foreach (var line in lines) {
          if (line.strip().length == 0) {
              continue;
          }
          // Use chug to find prefix length
          var original_length = line.length;
          var chugged = line.chug();
          var prefix_length = original_length - chugged.length;
          if (prefix_length < min_indent) {
              min_indent = prefix_length;
          }
      }
      
      if (min_indent == int.MAX) {
          // All lines empty, just prepend base_indent to each
          foreach (var line in lines) {
              normalized_lines.add(base_indent);
          }
          this.replacement = string.joinv("\n", normalized_lines.to_array());
          return;
      }
      
      // Remove minimum indent and prepend base indent
      foreach (var line in lines) {
          if (line.strip().length == 0) {
              normalized_lines.add(base_indent);
              continue;
          }
          // Remove min_indent characters from start
          var stripped = line.substring(min_indent);
          normalized_lines.add(base_indent + stripped);
      }
      
      this.replacement = string.joinv("\n", normalized_lines.to_array());
  }
  ```

- Modify `apply_edits()` in `GtkSourceFileBuffer` to:
  1. Get base indentation from the appropriate line (before insertion point or first replaced line):
     - Extract leading whitespace inline using `chug()` and `substring()`
  2. Call `change.normalize_indentation(base_indent)` to normalize the replacement
  3. Use the normalized replacement text (already updated in change.replacement)

**Edge Cases**:
- Empty replacement text: No change needed
- Replacement with only empty lines: Preserve base indentation
- Mixed tabs/spaces in replacement: Convert to detected file style
- Insertion at end of file: Use indentation from line before (if no line before, use empty string or default)

#### 3b. Replacing Code

**Scenario**: When edit mode replaces existing code (start != end).

**Approach**:
- Same as 3a, but specifically:
  - Get the first line being replaced (`change.start`)
  - Extract its leading whitespace as base indentation
  - Normalize replacement text and prepend base indentation

**Implementation Details**:
- In `apply_edits()`, for each change:
  1. Get the appropriate line to extract base indentation:
     - For insertion (`change.start == change.end`): Get line at `change.start - 1` (line before insertion)
     - For replacement (`change.start != change.end`): Get line at `change.start - 1` (first line being replaced)
  2. Extract leading whitespace inline:
     ```vala
     var line = this.get_line(line_number);
     var chugged = line.chug();
     var prefix_length = line.length - chugged.length;
     var base_indent = (prefix_length == 0) ? "" : line.substring(0, prefix_length);
     ```
  3. Call `change.normalize_indentation(base_indent)` to normalize the replacement
  4. Apply normalized text (already updated in change.replacement)

## Implementation Steps

1. **Add indentation detection to GtkSourceFileBuffer**
   - Add properties: `uses_tabs` (default: true), `indent_size` (default: 4)
   - Implement `detect_indentation()` method (analyze first 100 lines)
   - Use Vala string functions: `has_prefix()`, `chug()`, `replace()`
   - Call detection after buffer loads

2. **Enable whitespace display and configure tab width in SourceView**
   - Set `draw_spaces` and `draw_tabs` properties in constructor
   - Set `tab_width` to 4 (fixed) to match default indent_size

3. **Add indentation normalization to FileChange**
   - Add `normalize_indentation(string base_indent)` method to `FileChange` class
   - Modify `apply_edits()` to get base indentation (inline extraction) and call `change.normalize_indentation()`

4. **Testing**
   - Test with files using tabs
   - Test with files using 2, 4, 8 spaces
   - Test with mixed indentation
   - Test insertion at various positions
   - Test replacement of code blocks
   - Test edge cases (empty files, empty replacements, etc.)

## Files to Modify

1. `libocfiles/FileChange.vala`
   - Add `normalize_indentation(string base_indent)` method

2. `liboccoder/GtkSourceFileBuffer.vala`
   - Add indentation detection properties and method
   - Modify `apply_edits()` to get base indentation (inline extraction) and call `change.normalize_indentation()`

3. `liboccoder/SourceView.vala`
   - Enable whitespace display in constructor

## API Reference

### GtkSource.View Properties
- `draw_spaces`: `GtkSource.DrawSpacesFlags` - Controls which whitespace characters are drawn
- `draw_tabs`: `bool` - Whether to draw tab characters (may be part of draw_spaces flags)
- `tab_width`: `int` - Number of spaces a tab character should be displayed as (set to 4, fixed)

### GtkSource.DrawSpacesFlags
- `SPACE`: Show space characters
- `TAB`: Show tab characters  
- `NEWLINE`: Show newline characters
- `NBSP`: Show non-breaking spaces
- `ALL`: Show all whitespace characters

**Note**: Verify exact API in GtkSource documentation or by inspecting the vapi files.

## Future Enhancements

1. **User Preference**: Allow users to configure default indentation (tabs vs spaces, space count)
2. **Auto-convert**: Option to automatically convert mixed indentation to detected style
3. **Indentation Indicator**: Show detected indentation style in UI (e.g., "Tabs" or "4 spaces" in status bar)
4. **Smart Indentation**: Detect indentation per-block/scope (e.g., Python uses different indentation levels)

## Related Files

- `libocfiles/FileChange.vala` - FileChange class with normalization method
- `liboccoder/SourceView.vala` - Main source view editor
- `liboccoder/GtkSourceFileBuffer.vala` - Buffer implementation with edit application
- `liboctools/EditMode/Request.vala` - Edit mode request handler
- `liboctools/EditMode/Tool.vala` - Edit mode tool
