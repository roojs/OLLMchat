# 2.18. Agent Tool

## Status

✅ **Phase 1 COMPLETE** - Foundation classes created and building successfully
✅ **Phase 2 COMPLETE** - Agent execution implementation complete
✅ **Phase 3 COMPLETE** - Tool filtering implementation complete
✅ **Phase 4 COMPLETE** - Streaming implementation complete (uses existing session infrastructure)
✅ **Phase 5 COMPLETE** - Integration complete (Config class, scan_and_register, Window integration)

## Purpose

Create a dynamic tool system that automatically registers tools for each agent definition in `resources/agents/`. Each agent is registered as a separate tool (e.g., `codebase-locator`, `codebase-analyzer`, etc.), so they appear as individual tools to the LLM. Each agent tool allows the LLM to invoke specialized agents with streaming output and the ability for agents to call their own tools.

## Requirements

1. **Dynamic Tool Registration**: Automatically scan `resources/agents/` directory and register a tool for each agent file
2. **Tool Naming**: Tool name based on the `name:` field in agent frontmatter (e.g., `codebase-locator` → `codebase-locator` tool)
3. **Single Parameter**: Each agent tool accepts only a `query` parameter (string)
4. **Streaming Output**: While the agent tool runs, stream output to the UI in real-time
5. **Final Content Return**: When agent execution completes, return the final content to the user
6. **Tool Access**: Agent tools can call tools listed in the agent's `tools:` field in frontmatter

## Agent File Format

Agent files in `resources/agents/` use frontmatter format:

```markdown
---
name: codebase-locator
description: Locates files, directories, and components relevant to a feature or task.
tools: Grep, Glob, LS, codebase_search
model: sonnet
---

[Agent instructions and prompt...]
```

**Key Fields:**
- `name` (required): Used as the tool name
- `description` (required): Used as the tool description
- `tools` (optional): Comma-separated list of tool names the agent can use
- `model` (optional): Model preference for the agent (defaults to session model)

## Architecture

### Child.Tool

**Location**: `liboctools/Child/Tool.vala`

Main tool class that executes agent requests.

**Class Structure:**
```vala
namespace OLLMtools.Child
{
	public class Tool : OLLMchat.Tool.BaseTool
	{
		public string agent_name { get; private set; }
		public string agent_description { get; private set; }
		public Gee.ArrayList<string> agent_tools { get; private set; }
		public string agent_model { get; private set; }
		public string agent_instructions { get; private set; }
		
		public override string name { get { return this.agent_name; } }
		
		public override Type config_class() { return typeof(Config); }
		
		/**
		 * Sets up the agent tool configuration with default connection.
		 * 
		 * Creates an AgentToolConfig in `Config2.tools[agent_name]` if it doesn't exist.
		 * The config class has a default ModelUsage property that can be configured.
		 */
		public override void setup_tool_config(OLLMchat.Settings.Config2 config)
		{
			if (config.tools.has_key(this.agent_name)) {
				return;
			}
			
			var tool_config = new Config();
			var default_connection = config.default_connection();
			if (default_connection != null) {
				tool_config.model_usage = new OLLMchat.Settings.ModelUsage() {
					connection = default_connection.url,
					model = this.agent_model != "" ? this.agent_model : ""
				};
			}
			config.tools.set(this.agent_name, tool_config);
		}
		
		public override string description { get {
			return this.agent_description;
		} }
		
		public override string parameter_description { get {
			return """
@param query {string} [required] The query or prompt to send to the agent.""";
		} }
		
		/**
		 * ProjectManager instance for accessing project context.
		 * Optional - set to null if not available.
		 */
		public OLLMfiles.ProjectManager? project_manager { get; set; default = null; }
		
		public Tool(
			string name,
			string description,
			Gee.ArrayList<string> tools,
			string model,
			string instructions,
			OLLMfiles.ProjectManager? project_manager = null
		)
		{
			base();
			this.agent_name = name;
			this.agent_description = description;
			this.agent_tools = tools;
			this.agent_model = model;
			this.agent_instructions = instructions;
			this.project_manager = project_manager;
			this.title = "Agent: " + name;
		}
		
		public OLLMchat.Tool.BaseTool? clone()
		{
			return new Tool(
				this.agent_name,
				this.agent_description,
				this.agent_tools,
				this.agent_model,
				this.agent_instructions,
				this.project_manager
			);
		}
		
		protected override OLLMchat.Tool.RequestBase? deserialize(Json.Node parameters_node)
		{
			return Json.gobject_deserialize(typeof(Request), parameters_node) as OLLMchat.Tool.RequestBase;
		}
	}
}
```

### Child.Request

**Location**: `liboctools/Child/Request.vala`

Handles agent tool execution with streaming support.

**Key Features:**
- Creates a Chat instance with agent's system prompt
- Configures tools based on agent's `tools:` field
- Streams output to UI during execution
- Returns final content when complete

**Class Structure:**
```vala
namespace OLLMtools.Agent {
    public class Request : OLLMchat.Tool.RequestBase {
        private Tool agent_tool;
        private string query;
        private OLLMchat.Message? streaming_message = null;
        
        public override async string execute() throws Error {
            // Store original session before agent tool execution
            var original_session = this.chat_call.agent.session;
            var manager = original_session.manager;
            
            // Create agent factory for this agent
            var factory = new Factory(
                this.agent_tool.agent_name,
                this.agent_tool.agent_instructions,
                this.agent_tool.agent_tools
            );
            
            // Create session for agent execution
            var agent_session = this.create_agent_session(factory);
            
            // Activate agent tool session so its messages/streaming reach the UI
            // Note: This will deactivate the original session, but we'll restore it after
            // We don't need to use switch_to_session() - just activate/deactivate directly
            var was_original_active = original_session.is_active;
            if (was_original_active) {
                original_session.deactivate();
            }
            agent_session.activate();
            
            // Create agent instance (this creates Chat internally)
            var agent = factory.create_agent(agent_session);
            
            // Replace placeholders in instructions if needed
            var instructions = this.replace_placeholders(agent.factory.system_message(agent));
            
            // Create user message with query
            var user_message = new OLLMchat.Message("user", this.query);
            
            // Get cancellable from outer session's chat to propagate cancellation
            // This supports nested agent tools: if outer session is cancelled, all nested
            // agent tools will also be cancelled (each agent tool passes its cancellable down)
            // Chain: Outer Session -> Agent Tool 1 -> Agent Tool 2 -> ... (all share same cancellable)
            var outer_cancellable = this.chat_call.cancellable;
            
            // Send message through session (standard agent flow)
            // Agent tool session is now active, so streaming goes to UI
            // Pass outer session's cancellable so cancellation propagates through nested calls
            yield agent_session.send(user_message, outer_cancellable);
            
            // Get final response from session messages
            // The agent will have added assistant message to session.messages
            string result = "";
            foreach (var msg in agent_session.messages) {
                if (msg.role == "assistant" && msg.content != "") {
                    result = msg.content;
                    break;
                }
            }
            
            // Restore original session state after agent tool completes
            agent_session.deactivate();
            if (was_original_active) {
                original_session.activate();
            }
            
            return result;
        }
        
        /**
         * Creates a session for agent tool execution.
         * 
         * Creates a real session that:
         * - Is registered with Manager (has access to tools, config, etc.)
         * - Is logged and tracked (messages stored in session.messages)
         * - Is saved to database (full history tracking)
         * - Is NOT added to manager.sessions list (hidden from UI session list)
         * - Works with standard agent infrastructure (session-agent-chatcall)
         * 
         * The session is a real Session, just not visible in the user's session list.
         * We prevent it from being added to manager.sessions by setting a flag that
         * Session.on_message_created() checks before adding to the list.
         * 
         * @param factory The agent factory
         * @return A session for agent execution (hidden from UI)
         */
        private OLLMchat.History.SessionBase create_agent_session(Factory factory) {
            // Get manager from current session (via chat_call.agent.session.manager)
            var manager = this.chat_call.agent.session.manager;
            
            // Create real Session (not temporary - it's logged and saved)
            var session = new OLLMchat.History.Session(manager) {
                agent_name = factory.name,
                model_usage = this.get_model_usage_for_agent()
            };
            
            // Mark as agent tool session (UI will filter these out from session list)
            session.tool_session = true;
            
            // Save to database (so it's logged)
            session.saveToDB();
            
            // Session will be added to manager.sessions normally when messages are created
            // UI will filter out sessions where tool_session == true
            
            return session;
        }
        
        /**
         * Gets model usage for agent tool execution.
         * Uses agent's model preference from config if available, otherwise uses current session's model.
         */
        private OLLMchat.Settings.ModelUsage get_model_usage_for_agent() {
            // Check if agent tool has model_usage configured
            var manager = this.chat_call.agent.session.manager;
            if (manager.config.tools.has_key(this.agent_tool.agent_name)) {
                var tool_config = manager.config.tools.get(this.agent_tool.agent_name) as Config;
                if (tool_config != null && tool_config.model_usage.model != "") {
                    return tool_config.model_usage;
                }
            }
            
            // Fall back to current session's model_usage
            return this.chat_call.agent.session.model_usage;
        }
        
        /**
         * Replaces placeholders in instructions with actual values.
         */
        private string replace_placeholders(string instructions) {
            // TODO: Replace placeholders like {workspace_path}, {open_files}, etc.
            // with actual values from current context
            return instructions;
        }
        
        private void start_streaming() {
            // Create initial UI message for streaming
            this.streaming_message = new OLLMchat.Message(
                this.chat_call,
                "ui",
                "```\n[Agent: " + this.agent_tool.agent_name + "]\n"
            );
            this.chat_call.client.tool_message(this.streaming_message);
        }
        
        private async void stream_response(OLLMchat.Response.Chat response) {
            // Monitor response for chunks and update streaming_message
            // Append chunks to streaming_message.content
            // Call client.tool_message() to update UI
        }
    }
}
```

### Child.Factory

**Location**: `liboctools/Child/Factory.vala`

Factory class that creates agent instances and handles scanning/building agent tools.

**Class Structure:**
```vala
namespace OLLMtools.Child {
    public class Factory : OLLMchat.Agent.Factory {
        private string instructions;
        private Gee.ArrayList<string> allowed_tools;
        
        public Factory(string name, string instructions, Gee.ArrayList<string> allowed_tools) {
            this.name = name;
            this.title = name;
            this.instructions = instructions;
            this.allowed_tools = allowed_tools;
        }
        
        public override string system_message(OLLMchat.Agent.Base? handler = null) throws Error {
            return this.instructions;
        }
        
        public override OLLMchat.Agent.Base create_agent(OLLMchat.History.SessionBase session) {
            return new Agent(this, session, this.allowed_tools);
        }
        
        /**
         * Selects a model for an agent tool using the model selection logic.
         * 
         * Steps:
         * 1. Check if config exists and has model_usage.model set
         * 2. Try to use model listed in agent frontmatter (if not embedding model)
         * 3. Fallback to system default (but not embedding models)
         * 
         * @param agent_name The agent tool name
         * @param frontmatter_model The model name from agent frontmatter (may be empty)
         * @param config The config instance
         * @param connection_models The connection models instance
         * @return Selected ModelUsage, or null if no valid model found
         */
        private static OLLMchat.Settings.ModelUsage? select_model_for_agent(
            string agent_name,
            string frontmatter_model,
            OLLMchat.Settings.Config2 config,
            OLLMchat.Settings.ConnectionModels connection_models
        ) {
            // Step 1: Check if config exists and has model_usage.model set
            if (config.tools.has_key(agent_name)) {
                var existing_config = config.tools.get(agent_name) as Config;
                if (existing_config != null && existing_config.model_usage.model != "") {
                    return existing_config.model_usage;
                }
            }
            
            // Step 2: Try to use model listed in agent frontmatter
            var model_usage = frontmatter_model == "" ? null : connection_models.find_model_by_name(frontmatter_model);
            if (model_usage != null && model_usage.model_obj != null && !model_usage.model_obj.is_embedding()) {
                // Create/update config with model_usage
                var tool_config = new Config();
                tool_config.model_usage = new OLLMchat.Settings.ModelUsage() {
                    connection = model_usage.connection,
                    model = model_usage.model,
                    model_obj = model_usage.model_obj
                };
                config.tools.set(agent_name, tool_config);
                return tool_config.model_usage;
            }
            
            // Step 3: Fallback to system default (but not embedding models)
            var default_connection = config.default_connection();
            // Use connection_map for O(1) lookup instead of iterating all items
            var connection_models_map = default_connection == null ? null : connection_models.connection_map.get(default_connection.url);
            // Get first model from default connection (if any) - if it's embedding, give up
            if (connection_models_map != null && connection_models_map.size > 0) {
                // Get first model from the map (iterate once to get first value)
                foreach (var model_usage in connection_models_map.values) {
                    // If it's not an embedding model, use it; otherwise give up
                    if (model_usage.model_obj != null && !model_usage.model_obj.is_embedding()) {
                        return model_usage;
                    }
                    // If first model is embedding, give up (don't check others)
                    return null;
                }
            }
            
            // No valid model found
            return null;
        }
        
        
        // Static method to scan and register all agent tools
        public static void scan_and_register(
            Gee.HashMap<string, OLLMchat.Tool.BaseTool> tools,
            OLLMfiles.ProjectManager? project_manager,
            OLLMchat.Settings.Config2 config,
            OLLMchat.Settings.ConnectionModels connection_models
        ) {
            // Enumerate children in /agents/ resource directory
            // Only support resource:// initially (filesystem support can be added later)
            string[] children;
            try {
                children = GLib.resources_enumerate_children("/agents", GLib.ResourceLookupFlags.NONE);
            } catch (GLib.Error e) {
                GLib.warning("Cannot enumerate resource directory /agents: %s", e.message);
                return;
            }
            
            foreach (var child_name in children) {
                if (!child_name.has_suffix(".md")) {
                    continue;
                }
                
                // Parse agent file (create new parser for each file - don't reuse)
                var parser = new Parser();
                if (!parser.parse_file("/agents/" + child_name)) {
                    GLib.warning("Failed to parse /agents/%s, skipping", child_name);
                    continue;
                }
                
                // Validate required fields
                if (parser.name == "" || parser.description == "") {
                    GLib.warning("Missing required fields (name or description) in /agents/%s, skipping", child_name);
                    continue;
                }
                
                // Check for duplicate tool names
                if (tools.has_key(parser.name)) {
                    GLib.critical("Tool name '%s' already exists, skipping agent tool from /agents/%s", parser.name, child_name);
                    continue;
                }
                
                // Model selection and config setup
                // This must happen before creating the Tool instance
                var selected_model_usage = select_model_for_agent(
                    parser.name,
                    parser.model,
                    config,
                    connection_models
                );
                
                // If no valid model found, disable the tool
                if (selected_model_usage == null) {
                    GLib.warning("No valid model found for agent tool '%s' (from /agents/%s), disabling tool", parser.name, child_name);
                    continue; // Skip registration
                }
                
                // Save config if we created/updated it during model selection
                if (config.tools.has_key(parser.name)) {
                    try {
                        config.save();
                    } catch (Error e) {
                        GLib.warning("Failed to save config for agent tool '%s': %s", parser.name, e.message);
                    }
                }
                
                // Create and register agent tool
                // Each agent is registered as a separate tool, so they appear as individual tools to the LLM
                var agent_tool = new Tool(
                    parser.name,
                    parser.description,
                    parser.tools,
                    parser.model,
                    parser.instructions,
                    project_manager
                );
                tools.set(parser.name, agent_tool);
            }
        }
    }
    
    public class Agent : OLLMchat.Agent.Base {
        private Gee.ArrayList<string> allowed_tools;
        
        public Agent(Factory factory, OLLMchat.History.SessionBase session, Gee.ArrayList<string> allowed_tools) {
            base(factory, session);
            this.allowed_tools = allowed_tools;
        }
        
        // Override configure_tools to filter tools based on allowed_tools
        public override void configure_tools(OLLMchat.Call.Chat chat) {
            // Only add tools listed in allowed_tools
            // Remove tools not in the list
        }
    }
}
```

### Child.Config

**Location**: `liboctools/Child/Config.vala`

Tool-specific configuration for agent tools with model usage.

**Class Structure:**
```vala
namespace OLLMtools.Child
{
	/**
	 * Tool-specific configuration for agent tools with model usage.
	 *
	 * This configuration class extends BaseToolConfig and adds a ModelUsage
	 * property for configuring the model used by the agent tool.
	 *
	 * All properties must be GObject properties with proper metadata for
	 * Phase 2 UI generation via property introspection.
	 */
	public class Config : OLLMchat.Settings.BaseToolConfig
	{
		/**
		 * Model configuration (connection, model, options).
		 *
		 * Used for the agent tool's model preference. If not configured,
		 * falls back to the session's model.
		 */
		public OLLMchat.Settings.ModelUsage model_usage { get; set; default = new OLLMchat.Settings.ModelUsage(); }

		/**
		 * Default constructor.
		 */
		public Config()
		{
		}
	}
}
```

### Child.Parser

**Location**: `liboctools/Child/Parser.vala`

Parser class for parsing agent file frontmatter. Uses instance properties like `ParamParser`.

**Class Structure:**
```vala
namespace OLLMtools.Child {
    public class Parser : Object {
        public string name { get; private set; default = ""; }
        public string description { get; private set; default = ""; }
        public Gee.ArrayList<string> tools { 
				get; private set; default = new Gee.ArrayList<string>(); }
        public string model { get; private set; default = ""; }
        public string instructions { get; private set; default = ""; }
        public Gee.ArrayList<string> placeholders { get; private set; default = new Gee.ArrayList<string>(); }
        
        /**
         * Parses an agent file from resource path and populates properties.
         *
         * @param resource_path The resource path (e.g., "/agents/codebase-locator.md")
         * @return true if parsing succeeded, false otherwise
         */
        public bool parse_file(string resource_path) {
            
            // Read file content using resource:// URI
            string contents;
            try {
                var resource_uri = "resource://" + resource_path;
                var file = GLib.File.new_for_uri(resource_uri);
                if (!file.query_exists()) {
                    GLib.warning("Agent resource does not exist: %s", resource_path);
                    return false;
                }
                
                uint8[] data;
                string etag;
                file.load_contents(null, out data, out etag);
                contents = (string)data;
            } catch (GLib.Error e) {
                GLib.warning("Failed to read agent resource %s: %s", resource_path, e.message);
                return false;
            }
            
            // Find frontmatter block (between --- markers)
            // Parse key: value pairs
            // Extract tools as comma-separated list
            // Store everything after frontmatter as instructions
            
            // Extract placeholders from instructions
            this.extract_placeholders(contents);
            
            return true; // If parsing succeeded
        }
        
        /**
         * Extracts placeholders from text (format: {placeholder_name}, case-insensitive).
         *
         * @param text The text to search for placeholders
         */
        private void extract_placeholders(string text) {
            try {
                // Case-insensitive regex to find {placeholder} patterns
                var regex = new GLib.Regex("\\{([a-zA-Z_]+)\\}", GLib.RegexCompileFlags.CASELESS);
                MatchInfo match_info;
                
                if (!regex.match_all(text, 0, out match_info)) {
                    return;
                }
                
                do {
                    var placeholder = match_info.fetch(1);
                    if (placeholder != null && !this.placeholders.contains(placeholder)) {
                        this.placeholders.add(placeholder);
                    }
                } while (match_info.next());
            } catch (GLib.RegexError e) {
                // Regex error - continue without extracting placeholders
                GLib.warning("Failed to extract placeholders: %s", e.message);
            }
        }
    }
}
```

## Frontmatter Parsing

The `Child.Parser` class handles parsing YAML frontmatter from agent files.

**Parser Logic:**
- Find frontmatter block (between `---` markers)
- Parse `key: value` pairs using simple regex
- Extract `tools` as comma-separated list
- Return everything after frontmatter as instructions
- Extract placeholders from instructions using regex pattern `\{([a-z_]+)\}` (format: `{placeholder_name}`)

**Placeholder Format:**
- Placeholders use format: `{placeholder_name}` (case-insensitive, alphanumeric and underscores)
- Examples: `{workspace_path}`, `{open_files}`, `{project_name}`, `{WORKSPACE_PATH}` (all valid)
- Matches the format used elsewhere in the codebase (e.g., `{arguments}`, `{code}`, `{file_basename}`)
- Placeholders are extracted and stored in `placeholders` array for later replacement
- Extraction is done via `extract_placeholders()` method using case-insensitive regex

**Recommended**: Simple regex parser for `key: value` pairs, since agent frontmatter is simple.

## Tool Configuration

When an agent tool executes, it needs to:

1. **Create Agent Session**: Create a real session for agent execution
   - Is registered with Manager (has access to tools, config, etc.)
   - Is logged and tracked (messages stored in session.messages)
   - Is saved to database (full history tracking)
   - Is NOT added to manager.sessions list (hidden from UI session list)
   - Works with standard agent infrastructure (session-agent-chatcall flow)
   - Agent behaves exactly like a standard agent with session-agent-chatcall
   - The session is a real Session, just not visible in the user's session list
   - **Implementation**: Add `tool_session` boolean property (default false) to SessionBase
     - Set `tool_session = true` when creating agent tool sessions
     - Session is added to `manager.sessions` normally (for logging/tracking)
     - UI filters out sessions where `tool_session == true` when displaying the session list

2. **Filter Tools**: Only make available tools listed in agent's `tools:` field (via `Agent.configure_tools()`)

3. **Set Model**: Use agent's model_usage from config if configured, otherwise use current session's model

4. **Replace Placeholders**: Replace placeholders in instructions (e.g., `{workspace_path}`, `{open_files}`) with actual values

5. **Stream Output**: Send streaming updates to UI during execution (via session's handle_stream_chunk)

## Streaming Implementation

Agent tools work through the normal session-agent-chatcall flow. The agent sends messages through the session, and the session handles streaming via its normal infrastructure.

**Streaming Flow:**
1. Store original session state before agent tool execution
2. Create agent tool session
3. Activate agent tool session (deactivates original if it was active)
4. Agent sends user message through `session.send()`
5. Session's agent handles the request and creates Chat instance
6. Chat streams response chunks
7. Agent's `handle_stream_chunk()` is called for each chunk
8. Agent relays to session's `handle_stream_chunk()`
9. Session checks `is_active` - if true, relays to Manager signals (which UI listens to)
10. When complete, agent's final response is in session.messages
11. Tool extracts final content from session messages
12. Deactivate agent tool session and restore original session state
13. Return result to caller

**Active Session Management:**
- `is_active` flag on SessionBase controls whether messages/streaming reach the UI
- `Session.on_message_created()` only relays to Manager if `is_active == true`
- `Session.handle_stream_chunk()` only relays to Manager if `is_active == true`
- `SessionBase.add_message()` only relays to Manager if `is_active == true`
- When agent tool runs: activate agent tool session (so its output reaches UI)
- When agent tool completes: deactivate agent tool session and restore original session
- We don't need to use `Manager.switch_to_session()` - just activate/deactivate directly
- This avoids changing `Manager.session` (which tracks the user's selected session)

**Cancellation Handling (Tiered/Nested):**
- When outer session is cancelled, cancellation must propagate to all nested agent tool sessions
- Get cancellable from outer session's chat: `this.chat_call.cancellable`
- Pass it to agent tool session when sending: `agent_session.send(user_message, outer_cancellable)`
- **Nested agent tools**: If an agent tool calls another agent tool, it passes the same cancellable down
- This creates a cancellation chain: Outer Session -> Agent Tool 1 -> Agent Tool 2 -> Agent Tool 3...
- All agent tools in the chain share the same cancellable, so cancelling the outer session cancels all nested tools
- The cancellable is checked during streaming at each level, so cancellation propagates through the entire chain
- Example: User clicks "Stop" on outer session → all nested agent tools are cancelled in sequence

## Integration Points

### Tool Registration

**Location**: `ollmapp/Window.vala` in `register_tools()`

Add after wrapped tools registration:
```vala
// Register agent tools from resources/agents/
OLLMtools.Child.Factory.scan_and_register(
    this.history_manager.tools,
    this.project_manager,
    this.history_manager.config,
    this.history_manager.connection_models
);

GLib.debug("Window.register_tools: Registered agent tools (total tools: %d)", 
    this.history_manager.tools.size);
```

### Resource Directory

Uses `GLib.resources_enumerate_children()` to scan `/agents/` resource directory, same pattern as `ToolBuilder` uses for `/wrapped-tools/`. Files are loaded using `resource://` URIs.

## Files to Create

### Core Tool Files
- `liboctools/Child/Tool.vala` - Main tool class
- `liboctools/Child/Request.vala` - Request handler with streaming
- `liboctools/Child/Factory.vala` - Agent factory (includes scan_and_register static method)
- `liboctools/Child/Agent.vala` - Agent instance class
- `liboctools/Child/Parser.vala` - Frontmatter parser
- `liboctools/Child/Config.vala` - Tool configuration class with ModelUsage

### Build Files
- `liboctools/meson.build` - Add new files to build

### Documentation
- Update `docs/plans/` with implementation notes

## Implementation Phases

### Phase 1: Foundation ✅ COMPLETE
- ✅ Create `Child.Parser` class for frontmatter parsing
  - Parses YAML frontmatter (name, description, tools, model)
  - Extracts instructions (content after frontmatter)
  - Extracts placeholders using regex pattern `\{([a-zA-Z_]+)\}`
  - Single-pass parsing (no double loops)
- ✅ Create basic `Child.Tool` class
  - Extends `OLLMchat.Tool.BaseTool`
  - Uses object initializer syntax for construction
  - Properties are settable (agent_name, agent_description, agent_tools, agent_model, agent_instructions)
  - Does not implement WrapInterface (no clone() method needed)
- ✅ Add new files to `liboctools/meson.build` (Child/Tool.vala, Child/Parser.vala)
- ✅ Add new files to `docs/meson.build` for valadoc documentation (Child/Tool.vala, Child/Parser.vala)
- ✅ Verify build completes successfully
- ⏳ Test parsing agent files (manual testing pending)

### Phase 2: Agent Execution
- Create `Child.Factory` and `Child.Agent`
- Implement `Child.Request.execute()`
- Add new files to `liboctools/meson.build` (Child/Factory.vala, Child/Agent.vala, Child/Request.vala)
- Add new files to `docs/meson.build` for valadoc documentation (Child/Factory.vala, Child/Agent.vala, Child/Request.vala)
- Verify build completes successfully
- Create agent session and Chat instance
- Test basic agent execution

### Phase 3: Tool Filtering ✅ COMPLETE

**Purpose**: Restrict agent tools to only use the tools specified in the agent's `tools:` frontmatter field. This provides security and prevents agents from accessing tools they shouldn't use.

**Implementation Location**: `Child.Factory.configure_tools()` (not `Child.Runner` - that was a typo)

**How It Works**:

1. **Tool Filtering Mechanism**:
   - When an agent tool executes, `Factory.configure_tools()` is called during agent initialization (in `Agent.Base` constructor)
   - The method receives a `Chat` call that initially has all tools from `Manager.tools`
   - `configure_tools()` clears all tools from the Chat call: `call.tools.clear()`
   - Then it iterates through `agent_tool.agent_tools` (the list parsed from the agent's `tools:` frontmatter field)
   - For each tool name in the allowed list, it checks if the tool exists in `Manager.tools`
   - If the tool exists, it adds it to the Chat call via `call.add_tool(tool)`
   - If a requested tool doesn't exist, it logs a warning and continues (doesn't fail)

2. **Tool Name Matching**:
   - Tool names in the agent's `tools:` field must exactly match tool names in `Manager.tools`
   - Tool names are case-sensitive and must match exactly (e.g., `codebase_search` not `CodebaseSearch`)
   - The `tools:` field is parsed as a comma-separated list: `tools: Grep, Glob, LS, codebase_search`

3. **Empty Tools List**:
   - If an agent's `tools:` field is empty or missing, the agent will have no tools available
   - This is intentional - agents without tools can still function (they just can't call tools)

4. **Error Handling**:
   - If an agent requests a tool that doesn't exist in `Manager.tools`, a warning is logged but execution continues
   - The missing tool is simply not added to the Chat call
   - This allows agents to work even if some requested tools are unavailable (graceful degradation)

**Current Status**: 
- ✅ Implementation complete in `Child.Factory.configure_tools()` (lines 62-85)
- ✅ Tool filtering logic implemented and verified

### Phase 5: Integration ✅ COMPLETE
- ✅ Create `Child.Config` class
- ✅ Add `Child.Config.vala` to `liboctools/meson.build`
- ✅ Add `Child.Config.vala` to `docs/meson.build` for valadoc documentation
- ✅ Implement `Child.Factory.scan_and_register()` static method
- ✅ Integrate into `Window.register_tools()`
- ✅ Verify build completes successfully
- ⏳ Test tool registration (moved to Phase 6)
- ⏳ Verify all agent tools are available (moved to Phase 6)

### Phase 6: Testing
- Test agent file parsing with various frontmatter formats
- Test tool registration (verify all agents create tools)
- Test agent execution with simple queries
- Test tool filtering:
  - Create an agent with `tools: Grep, Glob` in frontmatter
  - Verify that when the agent executes, only `Grep` and `Glob` tools are available
  - Verify that other tools (e.g., `LS`, `codebase_search`) are NOT available to the agent
  - Test empty tools list (agent with no `tools:` field)
  - Test missing tool handling (agent requests non-existent tool - should log warning and continue)
  - Test case-sensitive tool name matching
  - Execute an agent tool that calls one of its allowed tools (verify success)
  - Try to have agent call a tool not in its allowed list (should fail or not be available)
- Test streaming output during execution
- Test error cases: missing files, invalid frontmatter, duplicate tool names, etc.

## Error Handling

### Definition File Errors
- Missing required fields (`name`, `description`): Log error, skip file
- Invalid frontmatter format: Log error with file path, skip file
- Duplicate tool names: Log warning, use first definition found
- Agent file not found: Return error if agent file doesn't exist

### Execution Errors
- Missing query parameter: Return error message
- Agent execution failure: Return error with details
- Tool not available: Return error if agent requests unavailable tool
- Streaming errors: Log error, continue with non-streaming fallback

## Testing Considerations

1. **Agent File Parsing**: Test with various frontmatter formats
2. **Tool Registration**: Verify all agents create tools
3. **Agent Execution**: Test agent with simple queries
4. **Tool Filtering**: Verify only specified tools are available
5. **Streaming**: Test streaming output during execution
6. **Error Cases**: Test missing files, invalid frontmatter, etc.

## Related Plans

- 2.16-DONE-wrapped-tools.md - Wrapped tools infrastructure (similar scanning pattern)
- 2.17-create-task-tool.md - Task tool (different tool type)
- 1.7-DONE-agent-management.md - Agent system architecture

## Model Selection and Tool Registration

### Model Selection Logic (at Registration)

When registering an agent tool, the following model selection logic is applied:

1. **Check if config exists and has model_usage.model set:**
   - If config exists and `model_usage.model` is not empty, use that model
   - Skip to step 4

2. **Try to use model listed in agent frontmatter:**
   - If agent has `model:` field in frontmatter, try to find it using `ConnectionModels.find_model_by_name()`
   - If found:
     - Create/update config with `model_usage` filled in (connection and model)
     - Save the config
     - Use this model
     - Skip to step 4

3. **Fallback to system default (but not embedding models):**
   - Try to use the first model from the default connection
   - **Important**: Check if model is an embedding model using `model_obj.is_embedding()` method
   - If the first model is an embedding model, give up (return null, tool will be disabled)
   - If first model is not embedding, use it

4. **Tool Disabling:**
   - If no valid model is found after all attempts, the tool is disabled
   - Log a warning/error and skip registration
   - Tool will not appear in available tools list

**Implementation Notes:**
- All model selection logic happens during `Child.Factory.scan_and_register()`
- Model validation uses `model_obj.is_embedding()` method (to be added to `Response.Model` class, similar to `is_thinking` and `can_call`)
- Use `ConnectionModels.find_model_by_name()` to locate models
- Use `ConnectionModels.connection_map` for O(1) lookup by connection URL
- Config is created/updated and saved during registration

### Tool Name Conflicts

If an agent name conflicts with an existing tool name:
- Use `GLib.critical()` to log the error
- Do not register the tool (skip it)
- Continue processing other agent files

### Resource Loading

**Initial Implementation:**
- Only support `resource://` URI for loading agent files
- Use `GLib.resources_enumerate_children()` to scan `/agents/` resource directory
- Future enhancement: Add support for `datadir/agents/` filesystem path (trivial to add later)

### Streaming Granularity

- Streaming is instant (sends on each chunk from Chat response)
- No concurrent tools currently, so not an issue
- Future enhancement: May give each tool a textview for output (not in this version)

## Context Information

### Agent Context Injection

Some agent definitions should have the ability to inject information about the user's state and open files, similar to how the code-assistant agent includes context about open files, workspace path, etc.

**Implementation Considerations:**
- Agents can optionally include context sections that are dynamically populated
- Context could include:
  - Currently open files
  - Active project information
  - Workspace path
  - Recent file changes
  - Selected text
- This would be similar to how `AgentFactory.generate_user_prompt()` includes context sections

## Implementation Notes

### Phase 1 Implementation Details

**Parser Implementation:**
- Single-pass parsing with optimized loop structure
- Handles frontmatter delimiters (`---`)
- Parses key:value pairs directly in the loop
- Builds instructions string incrementally (no double buffering)
- Extracts placeholders using case-insensitive regex: `\{([a-zA-Z_]+)\}`

**Tool Implementation:**
- Uses object initializer syntax for clean construction:
  ```vala
  new Tool(project_manager) {
      agent_name = parser.name,
      agent_description = parser.description,
      agent_tools = parser.tools,
      agent_model = parser.model,
      agent_instructions = parser.instructions,
      title = "Agent: " + parser.name
  }
  ```
- Properties are settable (not private set) to support object initializers
- Does not implement `WrapInterface` - these tools are not wrapped
- No `clone()` method needed

**Build Integration:**
- Files added to `liboctools/meson.build`
- Files added to `docs/meson.build` for valadoc documentation
- Build completes successfully with no errors
