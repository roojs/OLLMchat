# 1.23.14 Updates to existing skill code

**Note:** Do not add sentences to this plan unless specifically asked — only bullet points or nested bullet points.

**Coding standards:** Follow `.cursor/rules/CODING_STANDARDS.md`. This plan uses: **this.** for instance members; **var** for initializers where type not required; fill() with one key, value per line; no trailing null (Vala adds for varargs); **GLib.Error**; no underscore names; no get_* for simple accessors.

---

## Overview

- Sub-plan of **1.23.11**. Updates to existing skill classes: Runner, PromptTemplate, Factory, Manager, Definition.
- Task-related types (TaskList, TaskStep, Task, parsers) are in **1.23.13**.

**Status:** PLAN — Implementation not started.

**Dependencies:** 1.23.11 (parent), 1.23.13 (task-related code), 1.23.2, 1.23.3–1.23.6 (formats), 1.23.1 (existing Runner/Manager/Definition).

---

## Runner (`liboccoder/Skill/Runner.vala`)

- **Prompt templates**
  - Use `PromptTemplate.template(key)` by explicit key (no Runner state). No hashmap in Runner; PromptTemplate caches templates and exposes template(key).
- **Entry and loop**
  - Entry: **prepare_tasks** (loop until valid task list **and** skills validated **and** reference lengths validated) → rounds (refine started, run_until_writer, writer approval gate, run_all_tasks, run_post_completion) → loop or conclude.
  - **Validate skills before refinement:** Inside prepare_tasks, after parsing (check **parser.issues == ""** for success; no parser.valid), Runner **validates** that every task's skill_name exists in the skill manager. If any task references a missing skill, append to parser.issues (e.g. "Section X, task N: Skill Y not found") and retry.
  - **Validate reference content length:** After skills are valid, Runner **validates** that no task's resolved reference content exceeds a maximum length. If any task's total reference content is too long, append to parser.issues so task creation retries. Only when issues == "", all skills exist, and all reference lengths are within limit does Runner **populate task_definition** and return.
  - Loop: `for (var i = 0; i < 5; i++)` (comment only; no const/variable for 5). If **!this.task_list.has_pending_exec()** break; else yield **refine(this)** (start refinement for all tasks; returns immediately — we do **not** wait for all refined), then run_until_writer, writer approval gate, run_all_tasks, run_post_completion. Execution can start while later tasks are still refining. After loop, if hit max rounds and still pending, add_message "Max rounds reached."
  - TaskList API: see **1.23.13**.
- **Fields**
  - **task_list** — Result from task creation or post completion (1.23.3 format). Type: **TaskList** (see 1.23.13). Completed outputs: task.exec_done is true when executor finishes; output data on task.result (summary, details_path). (previous_proposal / previous_proposal_issues are **not** on TaskList; they are locals in **prepare_tasks** only.)
  - **writer_approval** — True once user has approved running writer (modify) tasks this run.
  - **Project manager** — Runner uses project manager for **this.project_manager.active_project.summary()** (project's responsibility; empty string when no active project or summary not yet in DB per 2.20.5).
  - Max rounds: literal 5 with a comment; after loop, flag (e.g. hit_max_rounds) for "Max rounds reached."

**Proposed code — Runner (excerpts):**

```vala
private TaskList task_list { get; set; default = new TaskList(); }
private bool writer_approval = false;

public async void run_async(string user_prompt, GLib.Cancellable? cancellable = null) throws GLib.Error
{
	this.writer_approval = false;
	yield this.prepare_tasks(user_prompt);

	var hit_max_rounds = true;
	for (var i = 0; i < 5; i++) {  // max rounds
		if (!this.task_list.has_pending_exec()) {
			hit_max_rounds = false;
			break;
		}
		yield this.task_list.refine(this);
		yield this.task_list.run_until_writer(this);
		if (this.task_list.has_writer_tasks() && !this.writer_approval) {
			yield this.request_writer_approval();
		}
		yield this.task_list.run_all_tasks(this);
		yield this.run_post_completion();
	}
	if (hit_max_rounds && this.task_list.has_pending_exec()) {
		// add_message(ui, "Max rounds reached.");
	}
}

private async void prepare_tasks(string user_prompt_text) throws GLib.Error
{
	var previous_proposal = "";
	var previous_proposal_issues = "";
	for (var try_count = 0; try_count < 5; try_count++) {  // max 5 tries
		var tpl = PromptTemplate.template("task_creation_initial");
		var user_content = tpl.fill(
			"environment", this.env(),
			"project_description", this.project_manager.active_project != null ? this.project_manager.active_project.summary() : "",
			"previous_proposal", previous_proposal,
			"previous_proposal_issues", previous_proposal_issues,
			"user_prompt", user_prompt_text);
		var system_content = tpl.system_fill(
			"skill_catalog", this.sr_factory.skill_manager.skill_catalog_string());
		// Build messages, send LLM, get response
		var parser = new TaskResultParser(response);
		parser.parse_task_list(this);
		if (parser.issues == "") {
			// Validate skills: every task's skill_name must exist; else treat as invalid and retry
			var skill_issues = this.validate_task_list_skills(parser.task_list);
			if (skill_issues == null) {
				this.task_list = parser.task_list;
				this.populate_task_definitions();
				return;
			}
			parser.append_issue(skill_issues);
			parser.issues = skill_issues;
		}
		previous_proposal = parser.proposal;
		previous_proposal_issues = parser.issues;
	}
	this.task_list = new TaskList();
	// add_message(ui, "Could not build valid task list after 5 tries.");
}
```

- **validate_task_list_skills(TaskList)** — Returns null if every task's skill_name exists in skill_manager.by_name; otherwise returns a string (issues, with context per task) so prepare_tasks can append to parser.issues and retry.
- **validate_task_list_reference_lengths(TaskList)** — For each task, sum content_for_reference(target).length over its reference_targets. If any task's total exceeds **max reference content length**, return an issues string (with context). Prepare_tasks appends to parser.issues and retry. Returns null if all tasks are within limit.
- **populate_task_definitions()** — After a valid task list with skills and reference lengths validated, fill task_definition map: for each task, task_definition.set(task, skill_manager.by_name.get(task.skill_name)). So refine() can assume task_definition.get(this) is non-null.
- **Task sends as agent (1.23.13):** Task extends OLLMchat.Agent.Base; Runner creates Task with (this, factory, session). Task uses **this.chat_call.send(messages)** for refine and post_evaluate. Runner does **not** provide send_system_user.
- **Refinement / Executor / Post completion** — Invoked from TaskList (task.refine, task.run_tools, task.post_evaluate) or Runner calls run_post_completion() directly (no TaskList method). See 1.23.13 for Task behaviour. Runner uses template keys **"task_refinement"**, **"task_execution"**, **"task_post_completion"** (no Runner state; key passed explicitly).
- **Request writer approval** — When task_list.has_writer_tasks() and !writer_approval: yield request_writer_approval(); on approve set this.writer_approval = true.
- **Template by key** — Use PromptTemplate.template(template_key); then tpl.system_fill(…) and tpl.fill(…) with placeholders for that key.

---

## PromptTemplate (`liboccoder/Skill/PromptTemplate.vala`)

- **Resource location**
  - Skill-prompts location hard-coded in PromptTemplate (resource:// or project resource dir for the 4 prompt files). No path argument passed from Runner.
- **load_dir() (no argument)**
  - Loads all .md templates from the hard-coded resource dir; caches inside PromptTemplate (key = filename without `.md`). Called lazily when needed.
- **template(key)**
  - Static (or class) method: returns the cached PromptTemplate for key (e.g. `task_creation_initial`, `task_refinement`, `task_post_completion`, `task_execution`). Caller passes key explicitly.
- **Split system/user**
  - For these prompts, content before first `---` = system message, after = user message; fill placeholders in each part. Support placeholders per 1.23.3, 1.23.4, 1.23.5, 1.23.6.

**Proposed code — PromptTemplate:**

```vala
private const string RESOURCE_DIR = "resource:///...";  // or project resource path

private static bool templates_loaded = false;
private static Gee.HashMap<string, PromptTemplate> template_cache = new Gee.HashMap<string, PromptTemplate>();

private static void ensure_loaded() throws GLib.Error
{
	if (templates_loaded) {
		return;
	}
	// Enumerate RESOURCE_DIR, for each .md: key = name without ".md", load template, template_cache.set(key, t)
	templates_loaded = true;
}

public static PromptTemplate template(string key) throws GLib.Error
{
	ensure_loaded();
	if (!template_cache.has_key(key)) {
		throw new GLib.IOError.NOT_FOUND("No prompt template for state: " + key);
	}
	return template_cache.get(key);
}
```

---

## Factory (`liboccoder/Skill/Factory.vala`)

- Support **skill-prompts** directory as well as **resources/skills**
  - Prompts for creation/refinement/post-completion/execution live in `skill-prompts`.
  - Executor skill files in `resources/skills`.
  - Manager/PromptTemplate handle both as needed.
- Ensure Runner can be created for the run_async flow (not only "one skill by name").
  - Entry from app/agent for planner mode vs current single-skill mode.

---

## Manager (`liboccoder/Skill/Manager.vala`)

- **Skill catalog**
  - Provide a form suitable for task-creation prompt: name + description from each executor skill's frontmatter (from `resources/skills`). Single string or structured list for `{skill_catalog}`.
- **Resolve by name**
  - Already has `by_name`; ensure executor skills in `resources/skills` are scanned and available. Runner loads skill definition by task's Skill field and runs tools by name.

---

## Definition (`liboccoder/Skill/Definition.vala`)

- **Refinement**
  - Expose "skill input requirements" (e.g. a designated section of the body) so Runner/Task can pass it to the refinement prompt. If already derivable from body/full_content, document it; otherwise add a simple accessor or parse.
- **Executor**
  - Runner/Task uses `full_content` (or body) as `{skill_definition}` for the interpreter. No change if that contract is already satisfied.

---

## Prompt refinements (task list format) — 1.23.13 parser

- **Task creation (initial) and post-completion prompts** must require the format expected by the parser (1.23.13):
  - Under each **### Task section N**, use **one list per task with a break between each**: a top-level list where **each list item is one task** (blank line or structural break between items).
  - Within each list item: a **nested list** with **What is needed**, **Skill**, **References**, **Expected output**.
  - Update **task_creation_initial.md** and **task_post_completion.md** (and any continuation prompt) so the LLM outputs this structure. Example: Task section 1 → list item 1 (task 1) with nested list of fields; list item 2 (task 2) with nested list; etc.

---

## References

- 1.23.11 (parent); 1.23.13 (task-related code); 1.23.2, 1.23.3–1.23.6 (formats); 1.23.1 (existing Skill Runner).
