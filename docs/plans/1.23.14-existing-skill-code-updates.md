# 1.23.14 Updates to existing skill code

**Note:** Do not add sentences to this plan unless specifically asked — only bullet points or nested bullet points.

**Coding standards:** Follow `.cursor/rules/CODING_STANDARDS.md`. This plan uses: **this.** for instance members; **var** for initializers where type not required; fill() with one key, value per line; no trailing null (Vala adds for varargs); **GLib.Error**; no underscore names; no get_* for simple accessors.

---

## Overview

- Sub-plan of **1.23.11**. Updates to existing skill classes: Runner, PromptTemplate, Factory, Manager, Definition.
- Task-related types (TaskList, TaskStep, Task, parsers) are in **1.23.13**.

**Status:** PLAN — Implementation not started.

**Outstanding issues (to address in this plan):**
- **Runner:** Implement **reference_content(href)** for non-file refs (#section, output:task). Details calls it; file refs are resolved in Details via project manager / File.new_fake. See 1.23.13 Overview.
- **Runner:** **validate_task_list_reference_lengths(TaskList)** must use the same resolution as Details (Runner.reference_content for non-file refs; project manager / File for absolute paths). Align with reference_content when implemented.
- **Runner:** Align method names with 1.23.13 (e.g. **run_until_user_approval**, **has_tasks_requiring_approval**); ensure writer_approval gate and run_until_writer naming are consistent with plan.
- **PromptTemplate:** See **1.23.17** (template API, fill stores rendered, optional sections, template(filename) returns new instance).
- **Task-class refinements:** Bugs and alignment in List, Step, Details, ResultParser only → **1.23.15**.

**Dependencies:** 1.23.11 (parent), 1.23.13 (task-related code, DONE), 1.23.15 (task refinements), 1.23.17 (template changes), 1.23.2, 1.23.3–1.23.6 (formats), 1.23.1 (existing Runner/Manager/Definition).

---

## Runner (`liboccoder/Skill/Runner.vala`)

- **Prompt templates**
  - Use PromptTemplate per **1.23.17** (template(filename) returns new instance; fill stores rendered). No hashmap in Runner.
- **Entry and loop**
  - Entry: **prepare_tasks** (loop until valid task list **and** skills validated **and** reference lengths validated) → rounds (refine started, run_until_writer, writer approval gate, run_all_tasks, run_post_completion) → loop or conclude.
  - **Validate skills before refinement:** Inside prepare_tasks, after parsing (check **parser.issues == ""** for success; no parser.valid), **TaskList.validate_skills()** checks that every task's skill_name exists (using its Runner reference). If any task references a missing skill, it returns an issues string; Runner appends to parser.issues and retries.
  - **Validate reference content length:** After skills are valid, Runner **validates** that no task's resolved reference content exceeds a maximum length. If any task's total reference content is too long, append to parser.issues so task creation retries. Only when issues == "", all skills exist, and all reference lengths are within limit does Runner return (no **populate_task_definitions**; task resolves its own definition via **get_definition(skill_name)**).
  - **Before sending to LLM:** After building user_content (template fill), create **this.user_request** from user_content — parse user_content into a Markdown.Document. Task/Details then use **this.headers(anchor).to_markdown_with_content()** (template must output markdown with section headings so parsed doc has anchor-keyed sections per 1.23.16).
  - Loop: `for (var i = 0; i < 5; i++)` (comment only; no const/variable for 5). If **!this.task_list.has_pending_exec()** break; else **refine(this)** (sync; start refinement for all tasks via .begin; returns immediately — we do **not** wait for all refined), then run_until_writer, writer approval gate, run_all_tasks, run_post_completion. Execution can start while later tasks are still refining. After loop, if hit max rounds and still pending, add_message "Max rounds reached."
  - TaskList API: see **1.23.13**.
- **Fields**
  - **task_list** — Result from task creation or post completion (1.23.3 format). Type: **TaskList** (see 1.23.13). Completed outputs: task.exec_done is true when executor finishes; output data on task.result (summary, details_path). (previous_proposal / previous_proposal_issues are **not** on TaskList; they are locals in **send_async** only.)
  - **user_request** — Markdown.Document created from user_content (the filled template string), right before sending to the LLM. Task/Details use **this.headers(anchor).to_markdown_with_content()**.
  - **writer_approval** — True once user has approved running writer (modify) tasks this run.
  - **Project manager** — Runner uses project manager in send_async fill; task code reads from this.user_request via headers(anchor).
  - Max rounds: literal 5 with a comment; after loop, flag (e.g. hit_max_rounds) for "Max rounds reached."

- **task_creation(user_prompt, previous_proposal, previous_proposal_issues)** — Returns the PromptTemplate for `task_creation_initial.md`. Performs the fill (tpl.fill(…) and tpl.system_fill(…) with user_prompt, env(), project description, previous_proposal, previous_proposal_issues, skill_catalog). Caller uses tpl.filled_user and tpl.filled_system (1.23.17).
- **Planned test class** — Call task_creation() with controlled inputs; assert on tpl.filled_user and tpl.filled_system to verify template fills.

**task_creation() — code sample for review:**

```vala
private PromptTemplate task_creation(string user_prompt, string previous_proposal, string previous_proposal_issues)
{
	var tpl = PromptTemplate.template("task_creation_initial.md");
	tpl.fill(
		"user_prompt", user_prompt,
		"environment", this.env(),
		"project_description", this.project_manager.active_project != null ? this.project_manager.active_project.summary() : "",
		"previous_proposal", previous_proposal,
		"previous_proposal_issues", previous_proposal_issues);
	tpl.system_fill(
		"skill_catalog", this.sr_factory.skill_manager.skill_catalog_string());
	return tpl;
}
```

**Proposed code — send_async and handle_task_list (leave existing prepare_tasks / run_async as-is):**

```vala
/** Entry point. Sends user request only; when finished calls handle_task_list. */
public async void send_async(string user_prompt, GLib.Cancellable? cancellable = null) throws GLib.Error
{
	var previous_proposal = "";
	var previous_proposal_issues = "";
	for (var try_count = 0; try_count < 5; try_count++) {
		var tpl = this.task_creation(user_prompt, previous_proposal, previous_proposal_issues);
		this.user_request = tpl.user_to_document();
		var messages = new Gee.ArrayList<OLLMchat.Message>();
		messages.add(new OLLMchat.Message("system", tpl.filled_system));
		messages.add(new OLLMchat.Message("user", tpl.filled_user));
		var response = yield this.chat_call.send(messages, cancellable);
		var parser = new ResultParser(this, response);
		parser.parse_task_list();
		if (parser.issues == "") {
			var skill_issues = parser.task_list.validate_skills();
			if (skill_issues == "") {
				this.task_list = parser.task_list;
				yield this.handle_task_list();
				return;
			}
			parser.issues = skill_issues;
		}
		previous_proposal = parser.proposal;
		previous_proposal_issues = parser.issues;
	}
	this.task_list = new TaskList();
	this.add_message(new OLLMchat.Message("ui", "Could not build valid task list after 5 tries."));
}

/** Deals with the task list only. Called by send_async when it has a valid task_list. */
private async void handle_task_list() throws GLib.Error
{
	this.writer_approval = false;
	var hit_max_rounds = true;
	for (var i = 0; i < 5; i++) {
		if (!this.task_list.has_pending_exec()) {
			hit_max_rounds = false;
			break;
		}
		this.task_list.refine(this);
		yield this.task_list.run_until_writer(this);
		if (this.task_list.has_writer_tasks() && !this.writer_approval) {
			var approved = yield this.request_writer_approval();
			if (!approved) {
				this.add_message(new OLLMchat.Message("ui", "User declined writer approval."));
				return;
			}
			this.writer_approval = true;
		}
		yield this.task_list.run_all_tasks();
		yield this.run_post_completion();
	}
	if (hit_max_rounds && this.task_list.has_pending_exec()) {
		this.add_message(new OLLMchat.Message("ui", "Max rounds reached."));
	}
}
```

- **TaskList.validate_skills()** — TaskList is responsible for skill validation; it has access to Runner (from its tasks or when built). Returns **string**: "" when every task's skill_name exists (e.g. runner.get_definition(skill_name) != null); otherwise returns issues string (with context per task). Runner sets **parser.issues = skill_issues** so the next iteration gets them as previous_proposal_issues (ResultParser has no append_issue; it uses this.issues += "\n" + msg internally; Runner assigns when feeding validation results).
- **validate_task_list_reference_lengths(TaskList)** — For each task, sum resolved reference content length over its reference_targets (Details gets content via project manager / reference_content). If any task's total exceeds **max reference content length**, return an issues string (with context). send_async appends to parser.issues and retry. Returns null if all tasks are within limit. **NEEDS FIXING:** align with **reference_content** (Runner) for non-file refs.
- **Task-resolved definition:** No task_definition map on Runner; no populate_task_definitions(). Details gets skill name from task_data.get("Skill").to_markdown().strip() and calls **runner.get_definition(skill_name)** when needed (refine, fill_model, post_evaluate). Runner exposes **get_definition(string)**; see Runner API below.
- **Task sends as agent (1.23.13):** Task extends OLLMchat.Agent.Base; Runner creates Task with (this, factory, session). Task uses **this.chat_call.send(messages)** for refine and post_evaluate. Runner does **not** provide send_system_user.
- **Refinement / Executor / Post completion** — Invoked from TaskList (task.refine, task.run_tools, task.post_evaluate) or Runner calls run_post_completion() directly (no TaskList method). See 1.23.13 for Task behaviour. Runner uses template keys **"task_refinement"**, **"task_execution"**, **"task_post_completion"** (no Runner state; key passed explicitly).
- **Request writer approval** — When task_list.has_writer_tasks() and !writer_approval: yield request_writer_approval(); on approve set this.writer_approval = true; on deny this.add_message(new OLLMchat.Message("ui", "User declined writer approval.")) and return. **request_writer_approval()** — async, returns bool (true = approved, false = denied).
- **UI messages** — Runner extends Agent.Base; use **this.add_message(new OLLMchat.Message("ui", text))** (or "ui-warning" for warnings). Session displays via message_added; no separate send method.
- **Template** — Use PromptTemplate per **1.23.17**; then tpl.system_fill(…) and tpl.fill(…) with placeholders for that key.

**Runner API for Task (get_definition, project_manager, current_file, reference_content)**

- Required so Details and Task code compile; 1.23.16 §4 (add Task to meson) depends on this. Implement in this plan.
- **Section heading lookup** — Inline only: use **this.user_request.headings.get(anchor)** (e.g. "project-description", "current-file") and **.to_markdown_with_content()** on the block. No wrapper method.

**Runner — properties and methods:**

```vala
public OLLMfiles.ProjectManager project_manager { get; set; }
public string current_file { get; set; default = ""; }

/** Used by Details to resolve its skill definition from task_data "Skill". */
public Definition? get_definition(string skill_name)
{
	return this.sr_factory.skill_manager.by_name.get(skill_name);
}

/** Used only in send_async when filling task_creation_initial (before user_request exists). Format: date, shell, workspace path from project_manager when available. */
public string env()
{
	var lines = new Gee.ArrayList<string>();
	lines.add("Date: " + new DateTime.now_local().format("%Y-%m-%d"));
	var shell = GLib.Environment.get_variable("SHELL");
	if (shell != null && shell != "") lines.add("Shell: " + shell);
	if (this.project_manager != null && this.project_manager.active_project != null)
		lines.add("Workspace: " + this.project_manager.active_project.path);
	return string.joinv("\n", lines.to_array());
}

/** Resolve non-file reference for Details.reference_contents(). Only # anchors supported; no underscore names (e.g. #project-description, #current-file). */
public string reference_content(string href)
{
	if (this.user_request == null) return "";
	if (href == "#project-description") {
		var block = this.user_request.headings.has_key("project-description") ? this.user_request.headings.get("project-description") : null;
		return block != null ? block.to_markdown_with_content() : "";
	}
	if (href == "#current-file") {
		var block = this.user_request.headings.has_key("current-file") ? this.user_request.headings.get("current-file") : null;
		return block != null ? block.to_markdown_with_content() : "";
	}
	return "";
}
```

**href values for reference_content:** Only `#`-style anchors (e.g. `#project-description`, `#current-file`). We do not support underscore names.

**Details (liboccoder/Task/Details.vala) — task-resolved definition:**

```vala
private string skill_name { get { return this.task_data.get("Skill").to_markdown().strip(); } }

// Replace every: this.runner.task_definition.get(this)
// with:
this.runner.get_definition(this.skill_name)
// Validation in send_user_request ensures skill exists; Details may cast or assume non-null.
```

---

## PromptTemplate (`liboccoder/Skill/PromptTemplate.vala`)

- **Template API, fill behaviour, resource location, optional sections:** See **1.23.17**. Runner and Details use PromptTemplate.template(filename) and fill per 1.23.17 (filename = e.g. `task_creation_initial.md`; fill stores rendered; optional {tag/start},{tag/end}).
- **Proposed code** for Runner/Details: `var tpl = PromptTemplate.template("task_creation_initial.md");` (or agreed key); `tpl.fill(…)`, `tpl.system_fill(…)` per 1.23.17. Full PromptTemplate implementation is specified in **1.23.17**.

---

## Factory (`liboccoder/Skill/Factory.vala`)

- Support **skill-prompts** directory as well as **resources/skills**
  - Prompts for creation/refinement/post-completion/execution live in `skill-prompts`.
  - Executor skill files in `resources/skills`.
  - Manager/PromptTemplate handle both as needed.
- Ensure Runner can be created for the send_async flow (not only "one skill by name").
  - Entry from app/agent for planner mode vs current single-skill mode.

---

## Manager (`liboccoder/Skill/Manager.vala`)

- **Skill catalog**
  - Provide a form suitable for task-creation prompt: name + description from each executor skill's frontmatter (from `resources/skills`). Single string or structured list for `{skill_catalog}`.
- **Resolve by name**
  - Already has `by_name`; ensure executor skills in `resources/skills` are scanned and available. Runner loads skill definition by task's Skill field and runs tools by name.

---

## Definition (`liboccoder/Skill/Definition.vala`)

- **Refinement**
  - Expose "skill input requirements" (e.g. a designated section of the body) so Runner/Task can pass it to the refinement prompt. If already derivable from body/full_content, document it; otherwise add a simple accessor or parse.
- **Executor**
  - Runner/Task uses `full_content` (or body) as `{skill_definition}` for the interpreter. No change if that contract is already satisfied.

---

## Prompt refinements (task list format) — 1.23.13 parser

- **Task creation (initial) and post-completion prompts** must require the format expected by the parser (1.23.13):
  - Under each **### Task section N**, use **one list per task with a break between each**: a top-level list where **each list item is one task** (blank line or structural break between items).
  - Within each list item: a **nested list** with **What is needed**, **Skill**, **References**, **Expected output**.
  - Update **task_creation_initial.md** and **task_post_completion.md** (and any continuation prompt) so the LLM outputs this structure. Example: Task section 1 → list item 1 (task 1) with nested list of fields; list item 2 (task 2) with nested list; etc.

---

## References

- 1.23.11 (parent); 1.23.13 (task-related code); 1.23.2, 1.23.3–1.23.6 (formats); 1.23.1 (existing Skill Runner).
