# 1.23.14 Updates to existing skill code

**Note:** Do not add sentences to this plan unless specifically asked — only bullet points or nested bullet points.

**Coding standards:** Follow `.cursor/rules/CODING_STANDARDS.md`. This plan uses: **this.** for instance members; **var** for initializers where type not required; fill() with one key, value per line; no trailing null (Vala adds for varargs); **GLib.Error**; no underscore names; no get_* for simple accessors.

---

## Overview

- Sub-plan of **1.23.11**. Updates to existing skill classes: Runner, PromptTemplate, Factory, Manager, Definition.
- Task-related types (TaskList, TaskStep, Task, parsers) are in **1.23.13**.

**Status:** PLAN — Implementation not started.

**Outstanding issues (to address in this plan):**
- **Runner:** Implement **reference_content(href)** for non-file refs (#section, output:task). Details calls it; file refs are resolved in Details via project manager / File.new_fake. See 1.23.13 Overview.
- **Runner:** **validate_task_list_reference_lengths(TaskList)** must use the same resolution as Details (Runner.reference_content for non-file refs; project manager / File for absolute paths). Align with reference_content when implemented.
- **Runner:** Align method names with 1.23.13 (e.g. **run_until_user_approval**, **has_tasks_requiring_approval**); ensure writer_approval gate and run_until_writer naming are consistent with plan.
- **PromptTemplate:** See **1.23.17** (template API, fill stores rendered, optional sections, template(filename) returns new instance).
- **Task-class refinements:** Bugs and alignment in List, Step, Details, ResultParser only → **1.23.15**.

**Dependencies:** 1.23.11 (parent), 1.23.13 (task-related code, DONE), 1.23.15 (task refinements), 1.23.17 (template changes), 1.23.2, 1.23.3–1.23.6 (formats), 1.23.1 (existing Runner/Manager/Definition).

---

## Runner (`liboccoder/Skill/Runner.vala`)

- **Prompt templates**
  - Use PromptTemplate per **1.23.17** (template(filename) returns new instance; fill stores rendered). No hashmap in Runner.
- **Entry and loop**
  - Entry: **prepare_tasks** (loop until valid task list **and** skills validated **and** reference lengths validated) → rounds (refine started, run_until_writer, writer approval gate, run_all_tasks, run_post_completion) → loop or conclude.
  - **Validate skills before refinement:** Inside prepare_tasks, after parsing (check **parser.issues == ""** for success; no parser.valid), Runner **validates** that every task's skill_name exists in the skill manager. If any task references a missing skill, append to parser.issues (e.g. "Section X, task N: Skill Y not found") and retry.
  - **Validate reference content length:** After skills are valid, Runner **validates** that no task's resolved reference content exceeds a maximum length. If any task's total reference content is too long, append to parser.issues so task creation retries. Only when issues == "", all skills exist, and all reference lengths are within limit does Runner return (no **populate_task_definitions**; task resolves its own definition via **get_definition(skill_name)**).
  - **Before sending to LLM:** After building user_content (template fill), create **this.user_request** from user_content — parse user_content into a Markdown.Document. Task/Details then use **this.headers(anchor).to_markdown_with_content()** (template must output markdown with section headings so parsed doc has anchor-keyed sections per 1.23.16).
  - Loop: `for (var i = 0; i < 5; i++)` (comment only; no const/variable for 5). If **!this.task_list.has_pending_exec()** break; else **refine(this)** (sync; start refinement for all tasks via .begin; returns immediately — we do **not** wait for all refined), then run_until_writer, writer approval gate, run_all_tasks, run_post_completion. Execution can start while later tasks are still refining. After loop, if hit max rounds and still pending, add_message "Max rounds reached."
  - TaskList API: see **1.23.13**.
- **Fields**
  - **task_list** — Result from task creation or post completion (1.23.3 format). Type: **TaskList** (see 1.23.13). Completed outputs: task.exec_done is true when executor finishes; output data on task.result (summary, details_path). (previous_proposal / previous_proposal_issues are **not** on TaskList; they are locals in **send_async** only.)
  - **user_request** — Markdown.Document created from user_content (the filled template string), right before sending to the LLM. Task/Details use **this.headers(anchor).to_markdown_with_content()**.
  - **writer_approval** — True once user has approved running writer (modify) tasks this run.
  - **Project manager** — Runner uses project manager in send_async fill; task code reads from this.user_request via headers(anchor).
  - Max rounds: literal 5 with a comment; after loop, flag (e.g. hit_max_rounds) for "Max rounds reached."

**Proposed code — two new methods (leave existing prepare_tasks / run_async as-is):**

```vala
/** Entry point. Sends user request only; when finished calls handle_task_list. */
public async void send_async(string user_prompt, GLib.Cancellable? cancellable = null) throws GLib.Error
{
	var previous_proposal = "";
	var previous_proposal_issues = "";
	for (var try_count = 0; try_count < 5; try_count++) {  // max 5 tries
		var tpl = PromptTemplate.template("task_creation_initial.md");  // per 1.23.17
		var user_content = tpl.fill(
			"environment", this.env(),
			"project_description", this.project_manager.active_project != null ? this.project_manager.active_project.summary() : "",
			"previous_proposal", previous_proposal,
			"previous_proposal_issues", previous_proposal_issues,
			"user_prompt", user_prompt);
		var system_content = tpl.system_fill(
			"skill_catalog", this.sr_factory.skill_manager.skill_catalog_string());
		this.user_request = Markdown.Document.from_markdown(user_content);
		// Build messages, send LLM, get response
		var parser = new ResultParser(this, response);
		parser.parse_task_list();
		if (parser.issues == "") {
			var skill_issues = this.validate_task_list_skills(parser.task_list);
			if (skill_issues == null) {
				this.task_list = parser.task_list;
				yield this.handle_task_list();
				return;
			}
			parser.append_issue(skill_issues);
			parser.issues = skill_issues;
		}
		previous_proposal = parser.proposal;
		previous_proposal_issues = parser.issues;
	}
	this.task_list = new TaskList();
	// add_message(ui, "Could not build valid task list after 5 tries.");
}

/** Deals with the task list only. Called by send_async when it has a valid task_list. */
private async void handle_task_list() throws GLib.Error
{
	this.writer_approval = false;
	var hit_max_rounds = true;
	for (var i = 0; i < 5; i++) {  // max rounds
		if (!this.task_list.has_pending_exec()) {
			hit_max_rounds = false;
			break;
		}
		this.task_list.refine(this);
		yield this.task_list.run_until_writer(this);
		if (this.task_list.has_writer_tasks() && !this.writer_approval) {
			var approved = yield this.request_writer_approval();
			if (!approved) {
				// add_message(ui, "User declined writer approval.");
				return;
			}
			this.writer_approval = true;
		}
		yield this.task_list.run_all_tasks();
		yield this.run_post_completion();
	}
	if (hit_max_rounds && this.task_list.has_pending_exec()) {
		// add_message(ui, "Max rounds reached.");
	}
}
```

- **validate_task_list_skills(TaskList)** — Returns null if every task's skill_name exists in skill_manager.by_name; otherwise returns a string (issues, with context per task) so send_user_request can append to parser.issues and retry.
- **validate_task_list_reference_lengths(TaskList)** — For each task, sum resolved reference content length over its reference_targets (Details gets content via project manager / reference_content). If any task's total exceeds **max reference content length**, return an issues string (with context). send_async appends to parser.issues and retry. Returns null if all tasks are within limit. **NEEDS FIXING:** align with **reference_content** (Runner) for non-file refs.
- **Task-resolved definition:** No task_definition map on Runner; no populate_task_definitions(). Details gets skill name from task_data.get("Skill").to_markdown().strip() and calls **runner.get_definition(skill_name)** when needed (refine, fill_model, post_evaluate). Runner exposes **get_definition(string)**; see Runner API below.
- **Task sends as agent (1.23.13):** Task extends OLLMchat.Agent.Base; Runner creates Task with (this, factory, session). Task uses **this.chat_call.send(messages)** for refine and post_evaluate. Runner does **not** provide send_system_user.
- **Refinement / Executor / Post completion** — Invoked from TaskList (task.refine, task.run_tools, task.post_evaluate) or Runner calls run_post_completion() directly (no TaskList method). See 1.23.13 for Task behaviour. Runner uses template keys **"task_refinement"**, **"task_execution"**, **"task_post_completion"** (no Runner state; key passed explicitly).
- **Request writer approval** — When task_list.has_writer_tasks() and !writer_approval: yield request_writer_approval(); on approve set this.writer_approval = true; on deny add_message (e.g. "User declined writer approval") and return from run_async. **request_writer_approval()** — async, returns bool (true = approved, false = denied).
- **Template** — Use PromptTemplate per **1.23.17**; then tpl.system_fill(…) and tpl.fill(…) with placeholders for that key.

**Runner API for Task (get_definition, headers, project_manager, current_file, reference_content)**

- Required so Details and Task code compile; 1.23.16 §4 (add Task to meson) depends on this. Implement in this plan.
- **headers(string anchor)** — Returns the section heading Block from **this.user_request** for anchor (e.g. "project-description", "environment"). Caller uses **.to_markdown_with_content()** on that block to get heading + section body as markdown. Task/Details use this instead of calling env(), project_manager.summary(), etc. Block (or Runner) must expose **to_markdown_with_content()** (heading + block.contents() rendered to markdown); add on Block in libocmarkdown if not present.

**Runner — properties and methods:**

```vala
public OLLMfiles.ProjectManager project_manager { get; set; }
public string current_file { get; set; default = ""; }

/** Used by Details to resolve its skill definition from task_data "Skill". */
public Definition? get_definition(string skill_name)
{
	return this.sr_factory.skill_manager.by_name.get(skill_name);
}

/** Section heading Block from this.user_request for anchor (e.g. "project-description"). Task uses .to_markdown_with_content() for template placeholders. */
public Markdown.Document.Block? headers(string anchor)
{
	return this.user_request.headings.get(anchor) as Markdown.Document.Block;
}

/** Used only in send_async when filling task_creation_initial (before user_request exists). */
public string env()
{
	// e.g. format from session/factory/IDE context
	return "";
}

/** Resolve non-file reference for Details.reference_contents(). When possible use this.user_request: e.g. project_description / #project-description → headers("project-description").to_markdown_with_content(); current_file / #current-file → headers("current-file").to_markdown_with_content(). Else href: #section (plan doc), output:task, plan:... */
public string reference_content(string href)
{
	if (href == "project_description" || href == "#project-description") {
		var block = this.headers("project-description");
		return block != null ? block.to_markdown_with_content() : "";
	}
	if (href == "current_file" || href == "#current-file") {
		var block = this.headers("current-file");
		return block != null ? block.to_markdown_with_content() : "";
	}
	// #section: look up in plan document by anchor; output:task: look up task output; plan:...: as needed
	return "";
}
```

**href values for reference_content:** `project_description`, `current_file`, `#section` (GFM anchor), `output:task` / `output:<task_id>`, `plan:...` (see task list References format).

**Details (liboccoder/Task/Details.vala) — task-resolved definition:**

```vala
private string skill_name { get { return this.task_data.get("Skill").to_markdown().strip(); } }

// Replace every: this.runner.task_definition.get(this)
// with:
this.runner.get_definition(this.skill_name)
// Validation in send_user_request ensures skill exists; Details may cast or assume non-null.
```

---

## PromptTemplate (`liboccoder/Skill/PromptTemplate.vala`)

- **Template API, fill behaviour, resource location, optional sections:** See **1.23.17**. Runner and Details use PromptTemplate.template(filename) and fill per 1.23.17 (filename = e.g. `task_creation_initial.md`; fill stores rendered; optional {tag/start},{tag/end}).
- **Proposed code** for Runner/Details: `var tpl = PromptTemplate.template("task_creation_initial.md");` (or agreed key); `tpl.fill(…)`, `tpl.system_fill(…)` per 1.23.17. Full PromptTemplate implementation is specified in **1.23.17**.

---

## Factory (`liboccoder/Skill/Factory.vala`)

- Support **skill-prompts** directory as well as **resources/skills**
  - Prompts for creation/refinement/post-completion/execution live in `skill-prompts`.
  - Executor skill files in `resources/skills`.
  - Manager/PromptTemplate handle both as needed.
- Ensure Runner can be created for the send_async flow (not only "one skill by name").
  - Entry from app/agent for planner mode vs current single-skill mode.

---

## Manager (`liboccoder/Skill/Manager.vala`)

- **Skill catalog**
  - Provide a form suitable for task-creation prompt: name + description from each executor skill's frontmatter (from `resources/skills`). Single string or structured list for `{skill_catalog}`.
- **Resolve by name**
  - Already has `by_name`; ensure executor skills in `resources/skills` are scanned and available. Runner loads skill definition by task's Skill field and runs tools by name.

---

## Definition (`liboccoder/Skill/Definition.vala`)

- **Refinement**
  - Expose "skill input requirements" (e.g. a designated section of the body) so Runner/Task can pass it to the refinement prompt. If already derivable from body/full_content, document it; otherwise add a simple accessor or parse.
- **Executor**
  - Runner/Task uses `full_content` (or body) as `{skill_definition}` for the interpreter. No change if that contract is already satisfied.

---

## Prompt refinements (task list format) — 1.23.13 parser

- **Task creation (initial) and post-completion prompts** must require the format expected by the parser (1.23.13):
  - Under each **### Task section N**, use **one list per task with a break between each**: a top-level list where **each list item is one task** (blank line or structural break between items).
  - Within each list item: a **nested list** with **What is needed**, **Skill**, **References**, **Expected output**.
  - Update **task_creation_initial.md** and **task_post_completion.md** (and any continuation prompt) so the LLM outputs this structure. Example: Task section 1 → list item 1 (task 1) with nested list of fields; list item 2 (task 2) with nested list; etc.

---

## References

- 1.23.11 (parent); 1.23.13 (task-related code); 1.23.2, 1.23.3–1.23.6 (formats); 1.23.1 (existing Skill Runner).
