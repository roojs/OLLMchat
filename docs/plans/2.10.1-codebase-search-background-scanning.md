# BackgroundScan Thread-Safe ProjectManager Implementation

## Overview
Create a separate ProjectManager instance for the background thread to avoid thread-safety issues. Use a `BackgroundScanItem` struct to track both project_path and file_path when queuing files, eliminating the need to search through all projects to find which one contains a file. Add optimization in `Folder.load_files_from_db()` to skip reloading if database hasn't changed.

## Key Points

1. **No file scanning needed**: After loading files from DB, the database already has current data. The caller manages file=db sync, so we don't need to call `read_dir()` or scan filesystem.

2. **Project scan behavior**: Project scan just adds files to the queue - it does NOT emit a completion signal. Completion is tracked via `scan_update` signal.

3. **File queue progress**: The file queue emits `scan_update(queue_size, current_file)` at the start of each file scan, and `scan_update(0, "")` when the queue becomes empty.

4. **Track project context**: Use `BackgroundScanItem` struct to track both project_path and file_path, avoiding inefficient project searching.

5. **Reload project state**: When processing files in `startQueue()`, reload project files from DB to ensure we have current state (database may have been updated since file was queued).

6. **Optimization in Folder**: Add helper methods to `Folder` class to check if reload is needed by comparing project.last_scan with max last_modified in database. This check happens at the start of `load_files_from_db()`.

## Changes Required

### 1. BackgroundScanItem Struct

**Add new struct:**
```vala
private struct BackgroundScanItem {
    string project_path;
    string file_path;
}
```

**Purpose**: Tracks which project a file belongs to, so we don't need to search through all projects when processing the queue.

### 2. BackgroundScan Class Structure

**Remove from constructor:**
- Remove `project_manager` parameter (keep `sql_db`)

**Add new fields:**
- `private OLLMfiles.ProjectManager? worker_project_manager = null;` - ProjectManager instance for background thread
- `private OLLMfiles.Folder? active_project = null;` - Track currently active project in background thread (for memory management)
- Change queue type: `private Gee.ArrayDeque<BackgroundScanItem> file_queue;` (instead of `ArrayDeque<string>`)

**Add helper methods:**
- `private void ensure_project_manager()` - Creates ProjectManager in background thread if not already created
- `private void set_active_project(Folder? project)` - Sets active project and clears files from previous active project to free memory (does NOT update database - that's main thread's responsibility)

### 3. Folder Class Changes (libocfiles/Folder.vala)

**Add helper methods to Folder class:**

**clear_data() method:**
```vala
public void clear_data() {
    // Clear hierarchical tree structure
    this.children.remove_all();
    // Clear flat file list (for projects)
    this.project_files.remove_all();
    // Reset last_scan to 0 so that needs_reload() will return true
    // This ensures the next load_files_from_db() call will reload all data
    this.last_scan = 0;
}
```

**Purpose**: Clears all in-memory data (children, project_files) and resets last_scan to 0. This will cause needs_reload() to return true on the next access, forcing a reload from the database. Used for memory management when switching projects.

**needs_reload() method:**
```vala
private bool needs_reload() {
    if (this.manager.db == null) {
        return false; // No DB, can't check
    }
    // Query: SELECT MAX(last_modified) FROM filebase
    // Execute query and get max_mtime (returns 0 if table is empty)
    int64 max_mtime = 0; // TODO: Execute SELECT MAX(last_modified) FROM filebase
    // If max mtime in DB is greater than project's last_scan, reload needed
    return max_mtime > this.last_scan;
}
```

**Update load_files_from_db() method:**
- Add check at the start: `if (!this.needs_reload()) { return; }`
- If reload not needed, skip the entire load operation
- This optimization applies to all callers of `load_files_from_db()`, not just BackgroundScan

**Note**: This checks max mtime across ALL files in database (not filtered by project). This is safe because:
- If any file changed, we reload (conservative approach)
- It's unlikely that other project updates will trigger unnecessary reloads
- Simpler query (no project filtering needed)

### 4. Project Loading (queueProject method)

**New approach:**
1. Ensure worker_project_manager exists (call `ensure_project_manager()`)
2. Load projects from database: `yield worker_project_manager.load_projects_from_db()`
3. Find project by path using: `worker_project_manager.projects.find_first((p) => p.path == path)`
4. If project not found, return early with warning
5. Load project files: `yield project.load_files_from_db()` 
   - **Note**: This will automatically check `needs_reload()` at the start and skip if no changes
   - This loads current data from DB. Since caller manages file=db sync, we don't need to do any file scanning (no `read_dir()` call needed).
6. Iterate through `project.project_files.items` (flat list, not hierarchical)
7. For each `ProjectFile` item:
   - Access file via `project_file.file`
   - Check if `file.last_scan < file.mtime_on_disk()`
   - If changed, create `BackgroundScanItem` with `project_path` and `file.path`, then queue: `this.queueFile(item)`
8. **Do NOT emit project_scan_completed** - project scan just queues files, completion is handled by file queue

### 5. File Queuing (queueFile method)

**Current signature:**
- `private void queueFile (string path)`

**New signature:**
- `private void queueFile (BackgroundScanItem item)` or
- `private void queueFile (string project_path, string file_path)` (creates item internally)

**Changes:**
- Queue `BackgroundScanItem` instead of just string path
- Update mutex-protected queue operations to use `BackgroundScanItem`

### 6. File Processing (startQueue method)

**New approach:**
1. Make method `async` (needs `yield` for database operations)
2. Track queue state: Add a flag or counter to know when queue becomes empty
3. For each `BackgroundScanItem` in queue:
4. Find the project by `item.project_path`:
   - Use: `worker_project_manager.projects.find_first((p) => p.path == item.project_path)`
   - If project not found, skip this item (continue to next)
5. **Reload project files from database** (state may have changed since queued):
   - `yield project.load_files_from_db()`
   - This will automatically check `needs_reload()` and skip if no changes
   - This ensures we have the latest state from the database
6. Find file in that project:
   - Use: `project.project_files.child_map.get(item.file_path)`
   - If not found, skip (file doesn't exist in project - may have been deleted or moved)
7. If file found:
   - Get File via `project_file.file`
   - Emit `scan_update(queue_size, file_path)` signal at start of scan (before indexing)
   - Use the File object for indexing
   - Call `indexer.index_file(file)`
   - Emit `file_scanned(file_path)` signal
8. When queue becomes empty:
   - Emit `scan_update(0, "")` signal to indicate queue is empty and scanning is complete

### 7. Public API Changes

**scanProject() method:**
- No changes needed - it already has the project object, extracts path, and calls `queueProject(path)`

**scanFile() method:**
- **CHANGE REQUIRED**: Caller must provide project context explicitly
- New signature: `public void scanFile (OLLMfiles.File file, OLLMfiles.Project project)` or
- Alternative: `public void scanFile (string file_path, string project_path)`
- Extract both paths and create `BackgroundScanItem` when queuing
- **Decision**: Project must be passed explicitly (cannot be determined from file's parent relationship)

### 8. Signal Updates

**Current signals:**
- `file_scanned(string file_path)` - Keep as is
- `project_scan_started(string project_path)` - Keep as is  
- `project_scan_completed(string project_path, int files_indexed)` - **Remove**: Project scan doesn't emit completion

**New signal:**
- `scan_update(int queue_size, string current_file)` - Emitted at the start of each file scan
  - `queue_size`: Current size of the file queue (number of files remaining)
  - `current_file`: Path of the file currently being scanned (empty string "" when queue is empty)
  - When queue becomes empty, emit `scan_update(0, "")` to signal completion

### 9. Implementation Details

**ensure_project_manager() method:**
```vala
private void ensure_project_manager() {
    if (this.worker_project_manager == null) {
        // Create ProjectManager in background thread context
        // Use same sql_db (thread-safe in serialized mode)
        this.worker_project_manager = new OLLMfiles.ProjectManager(this.sql_db);
        // Default providers are fine - we only need to read from DB
    }
}
```

**set_active_project() method:**
```vala
private void set_active_project(Folder? project) {
    // If switching to a different project, clear files from previous project
    if (this.active_project != null && this.active_project != project) {
        // Clear all in-memory data (children, project_files, and resets last_scan to 0)
        // This will cause needs_reload() to return true on next access, forcing a reload
        this.active_project.clear_data();
        // Note: We do NOT update database (is_active flag) - that's the main thread's responsibility
        // The background worker only manages memory, not database state
    }
    this.active_project = project;
}
```

**Note on active_project tracking:**
- The main thread's ProjectManager tracks `active_project` and updates the database when it changes (saves `is_active` flag)
- The background worker's ProjectManager should track its own `active_project` for memory management purposes only
- When switching active projects in the background worker, we clear files from the previous project to free memory
- We do NOT call `activate_project()` on the worker's ProjectManager (that would update the database)
- We do NOT save `is_active` to the database from the background thread
- The background worker only needs to load projects temporarily to process files, then can clear them

**queueProject() changes:**
- Make method `async` (needs `yield` for database operations)
- Load projects: `yield this.worker_project_manager.load_projects_from_db()`
- Find project: `var project = this.worker_project_manager.projects.find_first((p) => p.path == path)`
- Set as active project: `this.set_active_project(project)` (clears previous project's files if different)
- Load files: `yield project.load_files_from_db()` (will check needs_reload() internally)
- Iterate: `foreach (var project_file in project.project_files.items)`
- Access file: `var file = project_file.file`
- Queue with project context:
  ```vala
  var item = BackgroundScanItem() {
      project_path = project.path,
      file_path = file.path
  };
  this.queueFile(item);
  ```
- **Remove**: `emit_project_scan_completed()` call

**queueFile() changes:**
- Accept `BackgroundScanItem` instead of `string path`
- Queue the item: `this.file_queue.offer_tail(item)`

**startQueue() changes:**
- Make method `async` (needs `yield` for `load_files_from_db()`)
- Process `BackgroundScanItem` objects instead of strings
- For each item:
  - Find project by `item.project_path` (single lookup, not iteration)
  - Set as active project: `this.set_active_project(project)` (clears previous project's files if different)
  - Reload: `yield project.load_files_from_db()` (will check needs_reload() internally)
  - Find file in that project's `project_files.child_map`
  - If not found in project, skip (continue to next)
  - If found:
    - Get current queue size (while holding mutex)
    - Emit `scan_update(queue_size, item.file_path)` signal at start of scan
    - Proceed with indexing
- After processing all items (queue is empty):
  - Emit `scan_update(0, "")` signal to indicate completion

### 10. Thread Safety Notes

- SQLite database connection is shared but safe (serialized mode)
- Each ProjectManager has its own `file_cache` and state
- No cross-thread object passing (only strings in struct)
- All database operations happen in background thread context

## Files to Modify

- [libocfiles/Folder.vala](libocfiles/Folder.vala)
  - Add `clear_data()` public method (clears children, project_files, resets last_scan to 0)
  - Add `needs_reload()` instance method (queries MAX(last_modified) from database and compares with last_scan)
  - Update `load_files_from_db()` to check `needs_reload()` at the start and return early if not needed

- [libocvector/BackgroundScan.vala](libocvector/BackgroundScan.vala)
  - Add `BackgroundScanItem` struct
  - Remove `project_manager` parameter from constructor
  - Change `file_queue` type to `ArrayDeque<BackgroundScanItem>`
  - Add `worker_project_manager` field
  - Add `active_project` field (for memory management, does NOT update database)
  - Add `ensure_project_manager()` method
  - Add `set_active_project()` method (clears files from previous project, does NOT update database)
  - Update `queueProject()` to be async, use project_files, create BackgroundScanItem, call `set_active_project()`, remove completion signal
  - Update `queueFile()` to accept BackgroundScanItem
  - Update `startQueue()` to be async, process BackgroundScanItem, find project by path, call `set_active_project()`, reload project files (will use Folder's optimization), find file in project, emit `scan_update()` signals
  - Update `scanFile()` signature to require project context (project must be passed explicitly)
  - Remove `project_scan_completed` signal
  - Add `scan_update(int queue_size, string current_file)` signal

## Decisions Made

1. **scanFile() signature**: Project must be passed explicitly (cannot be determined from file's parent relationship)
2. **File queue completion**: Use `scan_update(int queue_size, string current_file)` signal:
   - Emit at start of each file scan with current queue size and file path
   - Emit `scan_update(0, "")` when queue becomes empty to signal completion
3. **project_scan_completed signal**: Removed entirely (project scan just queues files, completion is tracked via `scan_update` signal)

