# BackgroundScan Thread-Safe ProjectManager Implementation

## Overview
Create a separate ProjectManager instance for the background thread to avoid thread-safety issues. Use a `BackgroundScanItem` struct to track both project_path and file_path when queuing files, eliminating the need to search through all projects to find which one contains a file. Add optimization in `Folder.load_files_from_db()` to skip reloading if database hasn't changed.

## Key Points

1. **No file scanning needed**: After loading files from DB, the database already has current data. The caller manages file=db sync, so we don't need to call `read_dir()` or scan filesystem.

2. **Project scan behavior**: Project scan just adds files to the queue - it does NOT emit a completion signal with file count.

3. **File queue completion**: The file queue can emit a completion signal when it becomes empty (after processing all queued files).

4. **Track project context**: Use `BackgroundScanItem` struct to track both project_path and file_path, avoiding inefficient project searching.

5. **Reload project state**: When processing files in `startQueue()`, reload project files from DB to ensure we have current state (database may have been updated since file was queued).

6. **Optimization in Folder**: Add helper methods to `Folder` class to check if reload is needed by comparing project.last_scan with max last_modified in database. This check happens at the start of `load_files_from_db()`.

## Changes Required

### 1. BackgroundScanItem Struct

**Add new struct:**
```vala
private struct BackgroundScanItem {
    string project_path;
    string file_path;
}
```

**Purpose**: Tracks which project a file belongs to, so we don't need to search through all projects when processing the queue.

### 2. BackgroundScan Class Structure

**Remove from constructor:**
- Remove `project_manager` parameter (keep `sql_db`)

**Add new fields:**
- `private OLLMfiles.ProjectManager? worker_project_manager = null;` - ProjectManager instance for background thread
- `private OLLMfiles.Folder? active_project = null;` - Track currently active project in background thread (for memory management)
- Change queue type: `private Gee.ArrayDeque<BackgroundScanItem> file_queue;` (instead of `ArrayDeque<string>`)

**Add helper methods:**
- `private void ensure_project_manager()` - Creates ProjectManager in background thread if not already created
- `private void set_active_project(Folder? project)` - Sets active project and clears files from previous active project to free memory (does NOT update database - that's main thread's responsibility)

### 3. Folder Class Changes (libocfiles/Folder.vala)

**Add helper methods to Folder class:**

**get_max_last_modified() method:**
```vala
private int64 get_max_last_modified(SQ.Database db) {
    // Query: SELECT MAX(last_modified) FROM filebase
    // Returns max last_modified timestamp, or 0 if no files
    // Execute query and return result
    // Handle case where table is empty (return 0)
}
```

**needs_reload() method:**
```vala
private bool needs_reload() {
    if (this.manager.db == null) {
        return false; // No DB, can't check
    }
    var max_mtime = this.get_max_last_modified(this.manager.db);
    // If max mtime in DB is greater than project's last_scan, reload needed
    return max_mtime > this.last_scan;
}
```

**Update load_files_from_db() method:**
- Add check at the start: `if (!this.needs_reload()) { return; }`
- If reload not needed, skip the entire load operation
- This optimization applies to all callers of `load_files_from_db()`, not just BackgroundScan

**Note**: This checks max mtime across ALL files in database (not filtered by project). This is safe because:
- If any file changed, we reload (conservative approach)
- It's unlikely that other project updates will trigger unnecessary reloads
- Simpler query (no project filtering needed)

### 4. Project Loading (queueProject method)

**New approach:**
1. Ensure worker_project_manager exists (call `ensure_project_manager()`)
2. Load projects from database: `yield worker_project_manager.load_projects_from_db()`
3. Find project by path using: `worker_project_manager.projects.find_first((p) => p.path == path)`
4. If project not found, return early with warning
5. Load project files: `yield project.load_files_from_db()` 
   - **Note**: This will automatically check `needs_reload()` at the start and skip if no changes
   - This loads current data from DB. Since caller manages file=db sync, we don't need to do any file scanning (no `read_dir()` call needed).
6. Iterate through `project.project_files.items` (flat list, not hierarchical)
7. For each `ProjectFile` item:
   - Access file via `project_file.file`
   - Check if `file.last_scan < file.mtime_on_disk()`
   - If changed, create `BackgroundScanItem` with `project_path` and `file.path`, then queue: `this.queueFile(item)`
8. **Do NOT emit project_scan_completed** - project scan just queues files, completion is handled by file queue

### 5. File Queuing (queueFile method)

**Current signature:**
- `private void queueFile (string path)`

**New signature:**
- `private void queueFile (BackgroundScanItem item)` or
- `private void queueFile (string project_path, string file_path)` (creates item internally)

**Changes:**
- Queue `BackgroundScanItem` instead of just string path
- Update mutex-protected queue operations to use `BackgroundScanItem`

### 6. File Processing (startQueue method)

**New approach:**
1. Make method `async` (needs `yield` for database operations)
2. Track queue state: Add a flag or counter to know when queue becomes empty
3. For each `BackgroundScanItem` in queue:
4. Find the project by `item.project_path`:
   - Use: `worker_project_manager.projects.find_first((p) => p.path == item.project_path)`
   - If project not found, skip this item (continue to next)
5. **Reload project files from database** (state may have changed since queued):
   - `yield project.load_files_from_db()`
   - This will automatically check `needs_reload()` and skip if no changes
   - This ensures we have the latest state from the database
6. Find file in that project:
   - Use: `project.project_files.child_map.get(item.file_path)`
   - If not found, skip (file doesn't exist in project - may have been deleted or moved)
7. If file found:
   - Get File via `project_file.file`
   - Use the File object for indexing
   - Call `indexer.index_file(file)`
   - Emit `file_scanned(file_path)` signal
8. When queue becomes empty:
   - Emit completion signal (if needed) - **Question**: Do we need a new signal like `queue_empty()` or should we track this differently?

### 7. Public API Changes

**scanProject() method:**
- No changes needed - it already has the project object, extracts path, and calls `queueProject(path)`

**scanFile() method:**
- **CHANGE REQUIRED**: Caller must provide project context
- New signature: `public void scanFile (OLLMfiles.File file, OLLMfiles.Project project)` or
- Alternative: `public void scanFile (string file_path, string project_path)`
- Extract both paths and create `BackgroundScanItem` when queuing

**Question for user**: Should `scanFile()` require the caller to pass the project, or can we determine it from the file? Files have a `parent` property that might lead to the project.

### 8. Signal Updates

**Current signals:**
- `file_scanned(string file_path)` - Keep as is
- `project_scan_started(string project_path)` - Keep as is  
- `project_scan_completed(string project_path, int files_indexed)` - **Remove or change**: Project scan doesn't emit completion

**Options for file queue completion:**
- Option A: Add new signal `queue_empty()` when file queue becomes empty
- Option B: Track queue size and emit updates (but user asked if we already do this)
- Option C: No completion signal - just rely on individual `file_scanned` signals

### 9. Implementation Details

**ensure_project_manager() method:**
```vala
private void ensure_project_manager() {
    if (this.worker_project_manager == null) {
        // Create ProjectManager in background thread context
        // Use same sql_db (thread-safe in serialized mode)
        this.worker_project_manager = new OLLMfiles.ProjectManager(this.sql_db);
        // Default providers are fine - we only need to read from DB
    }
}
```

**queueProject() changes:**
- Make method `async` (needs `yield` for database operations)
- Load projects: `yield this.worker_project_manager.load_projects_from_db()`
- Find project: `var project = this.worker_project_manager.projects.find_first((p) => p.path == path)`
- Load files: `yield project.load_files_from_db()` (will check needs_reload() internally)
- Iterate: `foreach (var project_file in project.project_files.items)`
- Access file: `var file = project_file.file`
- Queue with project context:
  ```vala
  var item = BackgroundScanItem() {
      project_path = project.path,
      file_path = file.path
  };
  this.queueFile(item);
  ```
- **Remove**: `emit_project_scan_completed()` call

**queueFile() changes:**
- Accept `BackgroundScanItem` instead of `string path`
- Queue the item: `this.file_queue.offer_tail(item)`

**startQueue() changes:**
- Make method `async` (needs `yield` for `load_files_from_db()`)
- Process `BackgroundScanItem` objects instead of strings
- For each item:
  - Find project by `item.project_path` (single lookup, not iteration)
  - Reload: `yield project.load_files_from_db()` (will check needs_reload() internally)
  - Find file in that project's `project_files.child_map`
  - If not found in project, skip (continue to next)
  - If found, proceed with indexing

### 10. Thread Safety Notes

- SQLite database connection is shared but safe (serialized mode)
- Each ProjectManager has its own `file_cache` and state
- No cross-thread object passing (only strings in struct)
- All database operations happen in background thread context

## Files to Modify

- [libocfiles/Folder.vala](libocfiles/Folder.vala)
  - Add `get_max_last_modified()` instance method
  - Add `needs_reload()` instance method
  - Update `load_files_from_db()` to check `needs_reload()` at the start and return early if not needed

- [libocvector/BackgroundScan.vala](libocvector/BackgroundScan.vala)
  - Add `BackgroundScanItem` struct
  - Remove `project_manager` parameter from constructor
  - Change `file_queue` type to `ArrayDeque<BackgroundScanItem>`
  - Add `worker_project_manager` field
  - Add `ensure_project_manager()` method
  - Update `queueProject()` to be async, use project_files, create BackgroundScanItem, remove completion signal
  - Update `queueFile()` to accept BackgroundScanItem
  - Update `startQueue()` to be async, process BackgroundScanItem, find project by path, reload project files (will use Folder's optimization), find file in project
  - Update `scanFile()` signature to require project context
  - Consider signal changes (remove/modify `project_scan_completed`)

## Open Questions

1. **scanFile() signature**: Should it require the project to be passed explicitly, or can we determine it from the file's parent/project relationship?
2. **File queue completion**: Do we need a signal when queue becomes empty? Or do we already track queue size updates?
3. **project_scan_completed signal**: Should it be removed entirely, or changed to not include file count?

