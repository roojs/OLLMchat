# 1.8.1 Document renderer — structured markdown data model

- **Goal:** Add a new markdown renderer that builds a simple, extensible data structure (document + block + format + list) from parser callbacks, for future editing, task-based LLM document passing, and extension.
- **Status:** open.
- **Parent:** 1.8 (markdown outstanding issues); builds on existing Parser and RenderBase.
- **Depends on plan 1.8.2:** The render pipeline is simplified so that the parser calls `on_node(FormatType, bool, string, string, string)` for most callbacks. DocumentRender **overrides on_node only** and implements a single long switch to deliver most of this functionality; it does not override the many protected methods. DocumentRender also overrides the few callbacks that remain public (on_task_list, on_code, on_ul, on_ol, on_quote, on_table_hcell, on_table_cell, on_a).

---

## Coding standards and JSON serialization

- **Coding standards:** All new code must follow `.cursor/rules/CODING_STANDARDS.md`: `this.` prefix, brace style (line breaks for namespace/class/method, inline for control structures), no `@"..."` except multi-line help/docs, no trivial temporaries, fully-qualified `GLib.*`, property defaults (`get; set; default =`), `Gee.ArrayList`/`Gee.HashMap` via `.get()`/`.set()`/`.add()` (not `[]`), early returns to reduce nesting. Use **Vala secondary constructors** for alternative creation: `ClassName.from_*(...)` (e.g. `DocFormat.from_text(string s)`) instead of static factory methods; call with `new DocFormat.from_text(str)`.
- **JSON serialization:** The document and every component must be **Json.Serializable** and round-trip: serialize to JSON and deserialize back to an equivalent tree. All of **DocDocument**, **DocBlock**, **DocFormat**, **DocList**, and **DocListItem** implement `Object, Json.Serializable`. Use `serialize_property` / `deserialize_property` for: enums (serialize as string, e.g. `"PARAGRAPH"`); `Gee.ArrayList` of custom types (array of objects via `Json.gobject_serialize` / `Json.gobject_deserialize`). The library already depends on `json-glib-1.0`.

---

## Scope

1. **DocumentRender** — A `RenderBase` subclass that receives parser callbacks and builds an in-memory document tree. It uses the plan 1.8.2 pipeline: **override on_node only** with a long switch on `FormatType` to handle most events (TEXT, IMAGE, PARAGRAPH, HEADING_1..6, LIST_ITEM, ITALIC, BOLD, CODE, STRIKETHROUGH, U, HTML, OTHER, FENCED_CODE_QUOTE/TILD, TABLE, TABLE_ROW, BR, CODE_TEXT, HORIZONTAL_RULE). It also overrides the callbacks that stay public in 1.8.2: on_task_list, on_code, on_ul, on_ol, on_quote, on_table_hcell, on_table_cell, on_a (and on_softbr, on_entity if still called by the parser).
2. **Data types** (in the same file as the renderer): **DocDocument** (root), **DocBlock** (block-level nodes), **DocFormat** (inline/formatting nodes), **DocList** (lists and list items). No separate source files for the node types.
3. **Concrete code** — Full mapping from every `RenderBase` callback to the document model so the tree is complete and ready to extend.
4. **Json.Serializable** — All document types implement `Json.Serializable` with round-trip (to JSON and back) so the structure can be passed to LLM task systems or stored/restored.

---

## Intended use (later)

- **Editing:** Use the structure to drive editing (e.g. “replace this block”, “change this run of formatting”).
- **Task-based LLM:** Pass document (or sub-ranges) to the LLM as structured input/output.
- **Extension:** Add fields (e.g. source offsets, IDs) or new node kinds without changing the parser.

---

## Data model

Use a **single `children` property** on every container (no separate `blocks`, `lists`, `inlines`, `items`). Add **`parent`** on node types that form the main tree so the tree can be traversed upward; omit or leave unset for **DocFormat** (overkill for inline elements).

### DocNode (abstract base)

- **parent:** `DocNode?` — set when the node is added to a container; null for root-level nodes. Not set for **DocFormat** when building (optional / overkill for format-only traversal).
- **children:** `Gee.ArrayList<DocNode>` — single list of child nodes (block, list, list item, or format depending on container).
- Subclasses: **DocDocument**, **DocBlock**, **DocList**, **DocListItem**, **DocFormat**. All extend DocNode so that any container can hold a uniform `children` list and traversal (up via `parent`, down via `children`) works.

### DocDocument (root)

- Extends **DocNode**. Root of the tree: **parent** is null.
- **children:** block-level nodes only at root (DocBlock, DocList) in document order.

### DocBlock (block-level node)

- **kind:** FormatType (PARAGRAPH, HEADING_1..6, FENCED_CODE_QUOTE/TILD, BLOCKQUOTE, HORIZONTAL_RULE, TABLE, TABLE_ROW, TABLE_HCELL, TABLE_CELL, LIST_ITEM).
- **Attributes:** level, lang, align, task_checked, code_text (for code blocks).
- **children:** For paragraph/heading/table cell: DocFormat (inline content). For blockquote/table/row: DocBlock (and DocList where applicable). For list item: DocBlock and DocList. Order preserved.

### DocList (list structure)

- **ordered**, **indentation**.
- **children:** **DocListItem** only (one child per list item).

### DocListItem (list item)

- **task_checked**.
- **children:** **DocBlock** and **DocList** (content of the item; multiple blocks and nested lists allowed).

### DocFormat (inline / formatting node)

- **kind:** FormatType (TEXT, ITALIC, BOLD, CODE, STRIKETHROUGH, LINK, IMAGE, HTML, OTHER, U, BR). Attributes: text, href, title, src, tag, tag_attributes, tag_name, is_reference.
- **children:** **DocFormat** only (nested inline content). **parent** is typically not set when building (overkill for format-only traversal).

**JSON:** Serialize `children` as a single array. Because children are polymorphic (DocBlock | DocList | DocListItem | DocFormat), use a **type discriminator** per element (e.g. `"node_type": "block"|"list"|"list_item"|"format"`) or a wrapper `{ "type": "...", "value": { ... } }` so deserialization can call the correct `Json.gobject_deserialize(typeof(DocBlock), ...)` etc. Round-trip must reproduce the tree.

---

## Callback → structure mapping

| Parser callback | Action |
|-----------------|--------|
| `on_p(is_start)` | On start: push DocBlock(FormatType.PARAGRAPH); on end: pop, add to parent. |
| `on_h(is_start, level)` | On start: push DocBlock(HEADING_1..HEADING_6 from level, level); on end: pop. |
| `on_ul(is_start, indentation)` | On start: push DocList(ordered=false, indentation); on end: pop. |
| `on_ol(is_start, indentation)` | On start: push DocList(ordered=true, indentation); on end: pop. |
| `on_li(is_start)` | On start: push new DocListItem (under current DocList); on end: pop item. |
| `on_task_list(is_start, is_checked)` | Record task_checked on current list item (or next on_li). |
| `on_code(is_start, lang, fence_char)` / `on_code_block(is_start, lang)` | On start: push DocBlock(FENCED_CODE_QUOTE or FENCED_CODE_TILD, lang); on end: pop. |
| `on_code_text(string)` | Append to current fenced-code block’s text content. |
| `on_quote(is_start, level)` | On start: push DocBlock(BLOCKQUOTE, level); on end: pop. |
| `on_hr()` | Add DocBlock(HORIZONTAL_RULE) to current container (no push/pop). |
| `on_table(is_start)` | On start: push DocBlock(TABLE); on end: pop. |
| `on_table_row(is_start)` | On start: push DocBlock(TABLE_ROW) under table; on end: pop. |
| `on_table_hcell(is_start, align)` | On start: push DocBlock(TABLE_HCELL, align); on end: pop. |
| `on_table_cell(is_start, align)` | On start: push DocBlock(TABLE_CELL, align); on end: pop. |
| `on_text(string)` | Add DocFormat(TEXT, string) to current block’s inline content (or append to current text node if coalescing). |
| `on_em(is_start)` | On start: push DocFormat(ITALIC); on end: pop format. |
| `on_strong(is_start)` | On start: push DocFormat(BOLD); on end: pop. |
| `on_code_span(is_start)` | On start: push DocFormat(CODE); on end: pop. |
| `on_del(is_start)` | On start: push DocFormat(STRIKETHROUGH); on end: pop. |
| `on_u(is_start)` | On start: push DocFormat(U); on end: pop. |
| `on_a(is_start, href, title, is_reference)` | On start: push DocFormat(LINK, href, title, is_reference); on end: pop. |
| `on_img(src, title)` | Add DocFormat(IMAGE, src, title) to current inline content (leaf). |
| `on_html(is_start, tag, attributes)` | On start: push DocFormat(HTML, tag, attributes); on end: pop. |
| `on_other(is_start, tag_name)` | On start: push DocFormat(OTHER, tag_name); on end: pop. |
| `on_br()` | Add DocFormat(BR) to current inline content. |
| `on_softbr()` | Same as on_br for structure (or normalize to newline in text). |
| `on_entity(string)` | Add as DocFormat(TEXT) with decoded entity. |

Stack discipline: maintain a stack of “current container” (document root, block, list, list item) and a stack of “current inline format” (for nested em/strong/link etc.). Block/list push-pop drives where the next block or list item goes; format push-pop drives where the next inline content goes. Text and leaf nodes (image, entity) are always added to the current inline container (top of format stack or current block’s inline list).

---

## Reusing the Parser’s FormatType

Do **not** define separate document enums (**DocBlockKind** / **DocFormatKind**). Use the existing **FormatType** enum in `libocmarkdown/Parser.vala` for both block and inline kinds.

- **Extend FormatType in Parser.vala** with values the document model needs and the parser does not yet expose:
  - **Block (table/list structure):** `TABLE_ROW`, `TABLE_HCELL`, `TABLE_CELL`, `LIST_ITEM`.
  - **Inline (content/leaves):** `TEXT`, `IMAGE`, `BR`, `U`, `OTHER`.
- **DocBlock.kind** and **DocFormat.kind** are typed as **FormatType**. Use existing values where they match: e.g. `PARAGRAPH`, `HEADING_1`..`HEADING_6`, `BLOCKQUOTE`, `HORIZONTAL_RULE`, `TABLE`, `FENCED_CODE_QUOTE`/`FENCED_CODE_TILD`, `UNORDERED_LIST`, `ORDERED_LIST`, `ITALIC`, `BOLD`, `CODE`, `STRIKETHROUGH`, `LINK`, `HTML`. For headings, store level in **DocBlock** (1–6) as now; it can be derived from `HEADING_1`..`HEADING_6` when needed. For fenced code, use `FENCED_CODE_QUOTE` or `FENCED_CODE_TILD` as the block kind.
- **JSON:** Serialize `kind` as the enum name string (e.g. `"PARAGRAPH"`, `"ITALIC"`). Add **FormatType.from_string(string s)** in **Parser.vala** (switch on all enum names including the new ones; return a sensible default for unknown) and use it in document deserialize_property so round-trip works without a separate document enum.

**Parser.vala changes (concrete):**

1. **Extend FormatType** — After `TABLE` add: `TABLE_ROW`, `TABLE_HCELL`, `TABLE_CELL`, `LIST_ITEM`. After `LINK` (or at end of enum) add: `TEXT`, `IMAGE`, `BR`, `U`, `OTHER`.
2. **Add static from_string** — e.g. `public static FormatType from_string(string s)` with a switch over every enum name (NONE, ITALIC, BOLD, … TABLE_ROW, TABLE_HCELL, TABLE_CELL, LIST_ITEM, TEXT, IMAGE, BR, U, OTHER); default return `FormatType.NONE` or `FormatType.PARAGRAPH` for unknown.

---

## File and class layout

- **Parser.vala:** Extend **FormatType** with `TABLE_ROW`, `TABLE_HCELL`, `TABLE_CELL`, `LIST_ITEM`, `TEXT`, `IMAGE`, `BR`, `U`, `OTHER`; add static **FormatType.from_string(string s)** for JSON deserialization.
- **Subfolder:** `libocmarkdown/document/` — one file per class:
  - **DocNode.vala** — Abstract base: `parent`, `children`, `node_type`, `adopt()`.
  - **DocFormat.vala** — Inline/format node (FormatType, text, href, src, tag, etc.; `from_text` secondary ctor).
  - **DocBlock.vala** — Block node (FormatType kind, level, lang, align, task_checked, code_text); polymorphic children deserialization.
  - **DocListItem.vala** — List item (task_checked); children are DocBlock | DocList.
  - **DocList.vala** — List (ordered, indentation); children are DocListItem.
  - **DocDocument.vala** — Root (parent null); children are DocBlock | DocList in order.
  - **DocumentRender.vala** — Renderer extending **RenderBase**; overrides **on_node** with a long switch (plan 1.8.2) to build the document; overrides the remaining public callbacks (on_task_list, on_code, on_ul, on_ol, on_quote, on_table_hcell, on_table_cell, on_a). Uses `adopt()` and `children.add()`.
- **Build:** Add all files under `libocmarkdown/document/` to `libocmarkdown/meson.build` in `ocmarkdown_src` (order: DocNode, DocFormat, DocBlock, DocListItem, DocList, DocDocument, DocumentRender). Update valadoc input in `docs/meson.build` if present.
- **Dependencies:** `Gee`, `GLib`, `json-glib-1.0` (already a dependency of libocmarkdown). No new dependency.

---

## Concrete code (skeleton)

Implement as **one file per class** in `libocmarkdown/document/`. The skeleton below is split by file (see comment headers). Coding standards: `this.` prefix, brace style (line breaks for namespace/class/method, inline for control structures), `Gee.ArrayList` via `.get()`/`.add()`/`.remove_at()`, property defaults. All document types implement **Json.Serializable** with enums as strings, **node_type** and **parent** (exclude parent from JSON); round-trip reproduces the tree.

**File order for meson.build:** DocNode.vala, DocFormat.vala, DocBlock.vala, DocListItem.vala, DocList.vala, DocDocument.vala, DocumentRender.vala.

---

### document/DocNode.vala

```vala
namespace Markdown
{

public abstract class DocNode : Object, Json.Serializable
{
	/** Set when added to a container; null for root. Exclude from JSON to avoid cycles. */
	public DocNode? parent { get; set; }
	public Gee.ArrayList<DocNode> children { get; set; default = new Gee.ArrayList<DocNode>(); }

	/** For JSON polymorphic deserialization of children (subclasses return "block", "list", "list_item", "format"). */
	public abstract string node_type { get; }

	/** Call when adding a child: child.parent = this (omit for DocFormat if desired). */
	protected void adopt(DocNode child)
	{
		this.children.add(child);
		child.parent = this;
	}
}
```

---

### document/DocFormat.vala

```vala
namespace Markdown
{

public class DocFormat : DocNode
{
	public override string node_type { get { return "format"; } }
	public FormatType kind { get; set; }
	public string text { get; set; default = ""; }
	public string href { get; set; default = ""; }
	public string title { get; set; default = ""; }
	public bool is_reference { get; set; }
	public string src { get; set; default = ""; }
	public string tag { get; set; default = ""; }
	public string tag_attributes { get; set; default = ""; }
	public string tag_name { get; set; default = ""; }

	public DocFormat(FormatType k)
	{
		this.kind = k;
	}

	/** Secondary constructor: text run (FormatType.TEXT). */
	public DocFormat.from_text(string s)
	{
		this.kind = FormatType.TEXT;
		this.text = s;
	}

	public override Json.Node serialize_property(string property_name, GLib.Value value, GLib.ParamSpec pspec)
	{
		switch (property_name) {
			case "parent":
				return null;
			case "node_type":
				var n0 = new Json.Node(Json.NodeType.VALUE);
				n0.set_string("format");
				return n0;
			case "kind":
				var node = new Json.Node(Json.NodeType.VALUE);
				node.set_string(this.kind.to_string());
				return node;
			case "children":
				var arr = new Json.Array();
				for (int i = 0; i < this.children.size; i++) {
					arr.add_element(Json.gobject_serialize(this.children.get(i)));
				}
				var n = new Json.Node(Json.NodeType.ARRAY);
				n.init_array(arr);
				return n;
			default:
				return default_serialize_property(property_name, value, pspec);
		}
	}

	public override bool deserialize_property(string property_name, out GLib.Value value, GLib.ParamSpec pspec, Json.Node property_node)
	{
		switch (property_name) {
			case "parent":
				return false;
			case "kind":
				value = GLib.Value(typeof(FormatType));
				value.set_enum((int)FormatType.from_string(property_node.get_string()));
				return true;
			case "children":
				this.children.remove_range(0, this.children.size);
				var json_arr = property_node.get_array();
				for (uint i = 0; i < json_arr.get_length(); i++) {
					var child = Json.gobject_deserialize(typeof(DocFormat), json_arr.get_element(i)) as DocFormat;
					this.children.add(child);
					child.parent = this;
				}
				value = GLib.Value(typeof(Gee.ArrayList));
				value.set_object(this.children);
				return true;
			default:
				return default_deserialize_property(property_name, out value, pspec, property_node);
		}
	}
}
```

---

### document/DocBlock.vala

```vala
namespace Markdown
{

public class DocBlock : DocNode
{
	public override string node_type { get { return "block"; } }
	public FormatType kind { get; set; }
	public uint level { get; set; }
	public string lang { get; set; default = ""; }
	public int align { get; set; }
	public bool task_checked { get; set; }
	public string code_text { get; set; default = ""; }

	public DocBlock(FormatType k)
	{
		this.kind = k;
	}

	public override Json.Node serialize_property(string property_name, GLib.Value value, GLib.ParamSpec pspec)
	{
		switch (property_name) {
			case "parent":
				return null;
			case "node_type":
				var nt = new Json.Node(Json.NodeType.VALUE);
				nt.set_string("block");
				return nt;
			case "kind":
				var node = new Json.Node(Json.NodeType.VALUE);
				node.set_string(this.kind.to_string());
				return node;
			case "children":
				var arr = new Json.Array();
				for (int i = 0; i < this.children.size; i++) {
					arr.add_element(Json.gobject_serialize(this.children.get(i)));
				}
				var n = new Json.Node(Json.NodeType.ARRAY);
				n.init_array(arr);
				return n;
			default:
				return default_serialize_property(property_name, value, pspec);
		}
	}

	public override bool deserialize_property(string property_name, out GLib.Value value, GLib.ParamSpec pspec, Json.Node property_node)
	{
		switch (property_name) {
			case "parent":
				return false;
			case "kind":
				value = GLib.Value(typeof(FormatType));
				value.set_enum((int)FormatType.from_string(property_node.get_string()));
				return true;
			case "children":
				this.children.remove_range(0, this.children.size);
				deserialize_children(property_node.get_array(), this);
				value = GLib.Value(typeof(Gee.ArrayList));
				value.set_object(this.children);
				return true;
			default:
				return default_deserialize_property(property_name, out value, pspec, property_node);
		}
	}

	private void deserialize_children(Json.Array json_arr, DocNode parent_node)
	{
		for (uint i = 0; i < json_arr.get_length(); i++) {
			var elem = json_arr.get_element(i);
			var obj = elem.get_object();
			var type_node = obj.get_member("node_type");
			DocNode? child = null;
			if (type_node != null && type_node.get_node_type() == Json.NodeType.VALUE) {
				var type_str = type_node.get_string();
				if (type_str == "block") {
					child = Json.gobject_deserialize(typeof(DocBlock), elem) as DocBlock;
				} else if (type_str == "list") {
					child = Json.gobject_deserialize(typeof(DocList), elem) as DocList;
				} else if (type_str == "list_item") {
					child = Json.gobject_deserialize(typeof(DocListItem), elem) as DocListItem;
				} else if (type_str == "format") {
					child = Json.gobject_deserialize(typeof(DocFormat), elem) as DocFormat;
				}
			}
			if (child != null) {
				child.parent = parent_node;
				parent_node.children.add(child);
			}
		}
	}
}
```

---

### document/DocListItem.vala

```vala
namespace Markdown
{

public class DocListItem : DocNode
{
	public override string node_type { get { return "list_item"; } }
	public bool task_checked { get; set; }

	public override Json.Node serialize_property(string property_name, GLib.Value value, GLib.ParamSpec pspec)
	{
		switch (property_name) {
			case "parent":
				return null;
			case "node_type":
				var nt = new Json.Node(Json.NodeType.VALUE);
				nt.set_string("list_item");
				return nt;
			case "children":
				var arr = new Json.Array();
				for (int i = 0; i < this.children.size; i++) {
					arr.add_element(Json.gobject_serialize(this.children.get(i)));
				}
				var n = new Json.Node(Json.NodeType.ARRAY);
				n.init_array(arr);
				return n;
			default:
				return default_serialize_property(property_name, value, pspec);
		}
	}

	public override bool deserialize_property(string property_name, out GLib.Value value, GLib.ParamSpec pspec, Json.Node property_node)
	{
		if (property_name == "parent") {
			return false;
		}
		if (property_name == "children") {
			this.children.remove_range(0, this.children.size);
			var json_arr = property_node.get_array();
			for (uint i = 0; i < json_arr.get_length(); i++) {
				var elem = json_arr.get_element(i);
				var obj = elem.get_object();
				var type_node = obj.get_member("node_type");
				DocNode? child = null;
				if (type_node != null) {
					var type_str = type_node.get_string();
					if (type_str == "block") {
						child = Json.gobject_deserialize(typeof(DocBlock), elem) as DocBlock;
					} else if (type_str == "list") {
						child = Json.gobject_deserialize(typeof(DocList), elem) as DocList;
					}
				}
				if (child != null) {
					child.parent = this;
					this.children.add(child);
				}
			}
			value = GLib.Value(typeof(Gee.ArrayList));
			value.set_object(this.children);
			return true;
		}
		return default_deserialize_property(property_name, out value, pspec, property_node);
	}
}
```

---

### document/DocList.vala

```vala
namespace Markdown
{

public class DocList : DocNode
{
	public override string node_type { get { return "list"; } }
	public bool ordered { get; set; }
	public uint indentation { get; set; }

	public override Json.Node serialize_property(string property_name, GLib.Value value, GLib.ParamSpec pspec)
	{
		switch (property_name) {
			case "parent":
				return null;
			case "node_type":
				var nt = new Json.Node(Json.NodeType.VALUE);
				nt.set_string("list");
				return nt;
			case "children":
				var arr = new Json.Array();
				for (int i = 0; i < this.children.size; i++) {
					arr.add_element(Json.gobject_serialize(this.children.get(i)));
				}
				var n = new Json.Node(Json.NodeType.ARRAY);
				n.init_array(arr);
				return n;
			default:
				return default_serialize_property(property_name, value, pspec);
		}
	}

	public override bool deserialize_property(string property_name, out GLib.Value value, GLib.ParamSpec pspec, Json.Node property_node)
	{
		if (property_name == "parent") {
			return false;
		}
		if (property_name == "children") {
			this.children.remove_range(0, this.children.size);
			var json_arr = property_node.get_array();
			for (uint i = 0; i < json_arr.get_length(); i++) {
				var child = Json.gobject_deserialize(typeof(DocListItem), json_arr.get_element(i)) as DocListItem;
				child.parent = this;
				this.children.add(child);
			}
			value = GLib.Value(typeof(Gee.ArrayList));
			value.set_object(this.children);
			return true;
		}
		return default_deserialize_property(property_name, out value, pspec, property_node);
	}
}
```

---

### document/DocDocument.vala

```vala
namespace Markdown
{

public class DocDocument : DocNode
{
	public override string node_type { get { return "document"; } }

	public override Json.Node serialize_property(string property_name, GLib.Value value, GLib.ParamSpec pspec)
	{
		switch (property_name) {
			case "parent":
				return null;
			case "node_type":
				var nt = new Json.Node(Json.NodeType.VALUE);
				nt.set_string("document");
				return nt;
			case "children":
				var arr = new Json.Array();
				for (int i = 0; i < this.children.size; i++) {
					arr.add_element(Json.gobject_serialize(this.children.get(i)));
				}
				var n = new Json.Node(Json.NodeType.ARRAY);
				n.init_array(arr);
				return n;
			default:
				return default_serialize_property(property_name, value, pspec);
		}
	}

	public override bool deserialize_property(string property_name, out GLib.Value value, GLib.ParamSpec pspec, Json.Node property_node)
	{
		if (property_name == "parent") {
			return false;
		}
		if (property_name == "children") {
			this.children.remove_range(0, this.children.size);
			var json_arr = property_node.get_array();
			for (uint i = 0; i < json_arr.get_length(); i++) {
				var elem = json_arr.get_element(i);
				var obj = elem.get_object();
				var type_node = obj.get_member("node_type");
				DocNode? child = null;
				if (type_node != null) {
					var type_str = type_node.get_string();
					if (type_str == "block") {
						child = Json.gobject_deserialize(typeof(DocBlock), elem) as DocBlock;
					} else if (type_str == "list") {
						child = Json.gobject_deserialize(typeof(DocList), elem) as DocList;
					}
				}
				if (child != null) {
					child.parent = this;
					this.children.add(child);
				}
			}
			value = GLib.Value(typeof(Gee.ArrayList));
			value.set_object(this.children);
			return true;
		}
		return default_deserialize_property(property_name, out value, pspec, property_node);
	}
}
```

---

### document/DocumentRender.vala

```vala
namespace Markdown
{

public class DocumentRender : RenderBase
{
	public DocDocument document { get; private set; }

	private Gee.ArrayList<Object> block_stack = new Gee.ArrayList<Object>();
	private Gee.ArrayList<DocFormat> format_stack = new Gee.ArrayList<DocFormat>();
	private DocBlock? current_block_with_inlines = null;
	private DocListItem? current_list_item = null;
	private bool last_task_checked = false;

	public DocumentRender()
	{
		base();
		this.document = new DocDocument();
		this.block_stack.add(this.document);
	}

	private void push_inline(DocFormat f)
	{
		this.format_stack.add(f);
	}

	private void pop_inline()
	{
		if (this.format_stack.size == 0) {
			return;
		}
		var top = this.format_stack.get(this.format_stack.size - 1);
		this.format_stack.remove_at(this.format_stack.size - 1);
		this.add_format_to_current(top);
	}

	private void add_format_to_current(DocFormat f)
	{
		if (this.format_stack.size > 0) {
			this.format_stack.get(this.format_stack.size - 1).children.add(f);
		} else if (this.current_block_with_inlines != null) {
			this.current_block_with_inlines.children.add(f);
		}
	}

	private void add_block_to_current(DocBlock b)
	{
		var parent = this.block_stack.get(this.block_stack.size - 1) as DocNode;
		parent.adopt(b);
	}

	private void push_block(DocBlock b)
	{
		this.add_block_to_current(b);
		this.block_stack.add(b);
		if (b.kind == FormatType.PARAGRAPH || b.kind >= FormatType.HEADING_1 && b.kind <= FormatType.HEADING_6 ||
		    b.kind == FormatType.TABLE_CELL || b.kind == FormatType.TABLE_HCELL) {
			this.current_block_with_inlines = b;
		}
	}

	private void push_list(DocList list)
	{
		var parent = this.block_stack.get(this.block_stack.size - 1) as DocNode;
		parent.adopt(list);
		this.block_stack.add(list);
	}

	private void pop_block()
	{
		if (this.block_stack.size <= 1) {
			return;
		}
		var top = this.block_stack.get(this.block_stack.size - 1);
		this.block_stack.remove_at(this.block_stack.size - 1);
		if (top == this.current_block_with_inlines) {
			this.current_block_with_inlines = null;
		}
	}

	private void pop_list()
	{
		if (this.block_stack.size <= 1) {
			return;
		}
		this.block_stack.remove_at(this.block_stack.size - 1);
		this.current_list_item = null;
	}

	/** Delivers most callbacks via plan 1.8.2 pipeline: one switch on type. */
	public override void on_node(FormatType type, bool is_start, string s1 = "", string s2 = "", string s3 = "")
	{
		switch (type) {
			case FormatType.TEXT:
				this.add_format_to_current(new DocFormat.from_text(s1));
				return;
			case FormatType.IMAGE:
				var img = new DocFormat(FormatType.IMAGE);
				img.src = s1;
				img.title = s2;
				this.add_format_to_current(img);
				return;
			case FormatType.PARAGRAPH:
				if (is_start) {
					this.push_block(new DocBlock(FormatType.PARAGRAPH));
				} else {
					this.pop_block();
				}
				return;
			case FormatType.HEADING_1:
			case FormatType.HEADING_2:
			case FormatType.HEADING_3:
			case FormatType.HEADING_4:
			case FormatType.HEADING_5:
			case FormatType.HEADING_6:
				if (is_start) {
					uint level = (uint)(type - FormatType.HEADING_1 + 1);
					var b = new DocBlock(type);
					b.level = level;
					this.push_block(b);
				} else {
					this.pop_block();
				}
				return;
			case FormatType.LIST_ITEM:
				if (is_start) {
					var item = new DocListItem();
					item.task_checked = this.last_task_checked;
					this.last_task_checked = false;
					var parent = this.block_stack.get(this.block_stack.size - 1) as DocList;
					parent.adopt(item);
					this.block_stack.add(item);
					this.current_list_item = item;
				} else {
					this.block_stack.remove_at(this.block_stack.size - 1);
					this.current_list_item = null;
				}
				return;
			case FormatType.ITALIC:
				if (is_start) {
					this.push_inline(new DocFormat(FormatType.ITALIC));
				} else {
					this.pop_inline();
				}
				return;
			case FormatType.BOLD:
				if (is_start) {
					this.push_inline(new DocFormat(FormatType.BOLD));
				} else {
					this.pop_inline();
				}
				return;
			case FormatType.CODE:
				if (is_start) {
					this.push_inline(new DocFormat(FormatType.CODE));
				} else {
					this.pop_inline();
				}
				return;
			case FormatType.STRIKETHROUGH:
				if (is_start) {
					this.push_inline(new DocFormat(FormatType.STRIKETHROUGH));
				} else {
					this.pop_inline();
				}
				return;
			case FormatType.U:
				if (is_start) {
					this.push_inline(new DocFormat(FormatType.U));
				} else {
					this.pop_inline();
				}
				return;
			case FormatType.HTML:
				if (is_start) {
					var f = new DocFormat(FormatType.HTML);
					f.tag = s1;
					f.tag_attributes = s2;
					this.push_inline(f);
				} else {
					this.pop_inline();
				}
				return;
			case FormatType.OTHER:
				if (is_start) {
					var f = new DocFormat(FormatType.OTHER);
					f.tag_name = s1;
					this.push_inline(f);
				} else {
					this.pop_inline();
				}
				return;
			case FormatType.FENCED_CODE_QUOTE:
			case FormatType.FENCED_CODE_TILD:
				if (is_start) {
					var b = new DocBlock(FormatType.FENCED_CODE_QUOTE);
					b.lang = s1;
					this.push_block(b);
				} else {
					this.pop_block();
				}
				return;
			case FormatType.TABLE:
				if (is_start) {
					this.push_block(new DocBlock(FormatType.TABLE));
				} else {
					this.pop_block();
				}
				return;
			case FormatType.TABLE_ROW:
				if (is_start) {
					var row = new DocBlock(FormatType.TABLE_ROW);
					var table = this.block_stack.get(this.block_stack.size - 1) as DocNode;
					table.adopt(row);
					this.block_stack.add(row);
				} else {
					this.pop_block();
				}
				return;
			case FormatType.BR:
				this.add_format_to_current(new DocFormat(FormatType.BR));
				return;
			case FormatType.CODE_TEXT:
				var code_parent = this.block_stack.get(this.block_stack.size - 1);
				if (code_parent is DocBlock) {
					var pb = (DocBlock)code_parent;
					if (pb.kind == FormatType.FENCED_CODE_QUOTE || pb.kind == FormatType.FENCED_CODE_TILD) {
						pb.code_text += s1;
					}
				}
				return;
			case FormatType.HORIZONTAL_RULE:
				this.add_block_to_current(new DocBlock(FormatType.HORIZONTAL_RULE));
				return;
			default:
				return;
		}
	}

	/** Callbacks that remain public in plan 1.8.2 (not routed through on_node). */
	public override void on_ul(bool is_start, uint indentation)
	{
		if (is_start) {
			var list = new DocList();
			list.ordered = false;
			list.indentation = indentation;
			this.push_list(list);
		} else {
			this.pop_list();
		}
	}

	public override void on_ol(bool is_start, uint indentation)
	{
		if (is_start) {
			var list = new DocList();
			list.ordered = true;
			list.indentation = indentation;
			this.push_list(list);
		} else {
			this.pop_list();
		}
	}

	public override void on_task_list(bool is_start, bool is_checked)
	{
		if (is_start) {
			this.last_task_checked = is_checked;
		}
	}

	public override void on_code(bool is_start, string? lang, char fence_char)
	{
		if (is_start) {
			var b = new DocBlock(FormatType.FENCED_CODE_QUOTE);  // or FENCED_CODE_TILD from fence_char
			b.lang = lang ?? "";
			this.push_block(b);
		} else {
			this.pop_block();
		}
	}

	public override void on_quote(bool is_start, uint level)
	{
		if (is_start) {
			var b = new DocBlock(FormatType.BLOCKQUOTE);
			b.level = level;
			this.push_block(b);
		} else {
			this.pop_block();
		}
	}

	public override void on_table_hcell(bool is_start, int align)
	{
		if (is_start) {
			var cell = new DocBlock(FormatType.TABLE_HCELL);
			cell.align = align;
			this.push_block(cell);
		} else {
			this.pop_block();
		}
	}

	public override void on_table_cell(bool is_start, int align)
	{
		if (is_start) {
			var cell = new DocBlock(FormatType.TABLE_CELL);
			cell.align = align;
			this.push_block(cell);
		} else {
			this.pop_block();
		}
	}

	public override void on_a(bool is_start, string href, string title, bool is_reference)
	{
		if (is_start) {
			var f = new DocFormat(FormatType.LINK);
			f.href = href;
			f.title = title;
			f.is_reference = is_reference;
			this.push_inline(f);
		} else {
			this.pop_inline();
		}
	}

	public override void on_softbr()
	{
		this.add_format_to_current(new DocFormat.from_text("\n"));
	}

	public override void on_entity(string text)
	{
		this.add_format_to_current(new DocFormat.from_text(text));
	}
}
}
```

**Enum deserialization:** Implement **FormatType.from_string(string s)** in Parser.vala and use it in DocBlock/DocFormat deserialize_property for the `kind` property. Serialize with `this.kind.to_string()` as in the skeleton.

---

## Design notes

1. **Unified children and parent:** The skeleton uses both `document.blocks` and `document.lists`. Alternatively use a single `Gee.ArrayList<DocNode>` with a common base type (e.g. `DocNode` with subclasses DocBlock, DocList) so that root order (block vs list) is preserved. That would require a small refactor to a base type and adding lists to the block stack as “block-like” containers.
2. **List inside list item:** When the parser opens a nested list (`on_ul`/`on_ol`) and the stack top is a DocListItem, the new DocList is added to that item’s `lists` (see `push_list`). So nested lists are stored under the list item.
3. **Table row/cell:** Table rows are added to the TABLE block’s `blocks` in `on_table_row(true)`. Table cells are added via `push_block(cell)`, so `add_block_to_current` runs with parent = TABLE_ROW; the existing logic `((DocBlock)parent).blocks.add(b)` correctly adds the cell to the row.
4. **Coalescing TEXT:** Optionally coalesce consecutive `on_text` into a single DocFormat(TEXT) to keep the tree smaller; the skeleton adds a new TEXT node per call for simplicity.

---

## Implementation checklist

- [ ] **Parser.vala:** Extend FormatType with TABLE_ROW, TABLE_HCELL, TABLE_CELL, LIST_ITEM, TEXT, IMAGE, BR, U, OTHER; add static `FormatType.from_string(string s)` (switch on all enum names; default NONE or PARAGRAPH for unknown).
- [ ] Create `libocmarkdown/document/` with **one file per class:** DocNode.vala, DocFormat.vala, DocBlock.vala, DocListItem.vala, DocList.vala, DocDocument.vala, DocumentRender.vala (each in namespace Markdown). Follow `.cursor/rules/CODING_STANDARDS.md` (e.g. `this.` prefix, brace style, `GLib.` prefix, `Gee.ArrayList` via `.get()`/`.add()`/`.remove_at()`).
- [ ] Implement **Json.Serializable** on DocDocument, DocBlock, DocFormat, DocList, DocListItem: serialize `kind` as string via `this.kind.to_string()`; deserialize via `FormatType.from_string(property_node.get_string())` and `Json.gobject_deserialize` for nested collections.
- [ ] Add all `libocmarkdown/document/*.vala` to `libocmarkdown/meson.build` in `ocmarkdown_src` (order: DocNode, DocFormat, DocBlock, DocListItem, DocList, DocDocument, DocumentRender); update `docs/meson.build` valadoc list if applicable.
- [ ] Implement a small test that runs `DocumentRender.start(); renderer.add("# Hi\n\nHello *world*."); renderer.flush();` and asserts `document.children.size == 2`, first child is DocBlock with kind HEADING_1, second is DocBlock PARAGRAPH with TEXT and nested ITALIC in children.
- [ ] Add a **round-trip test**: build a document, serialize with `Json.gobject_serialize(document)` and a `Json.Generator`, parse back with `Json.from_string()` and `Json.gobject_deserialize(typeof(DocDocument), root)`, then assert structure equality (same block/list counts and kinds, same inline content).
- [ ] Optionally: add a single root `children: Gee.ArrayList<DocNode>` to DocDocument (with DocNode base class for DocBlock and DocList) to preserve exact order of blocks and lists at root.

---

## Summary

| Item | Description |
|------|-------------|
| **Parser** | Extend `FormatType` with TABLE_ROW, TABLE_HCELL, TABLE_CELL, LIST_ITEM, TEXT, IMAGE, BR, U, OTHER; add `FormatType.from_string(string s)` |
| **New files** | `libocmarkdown/document/`: DocNode.vala, DocFormat.vala, DocBlock.vala, DocListItem.vala, DocList.vala, DocDocument.vala, DocumentRender.vala (one class per file); kinds use **FormatType** |
| **Extends** | `RenderBase`; receives all parser callbacks |
| **Output** | `DocDocument` (extends DocNode): single **children** (blocks + lists in order); each node has **parent** (null for root/format), **children**, **kind: FormatType** where applicable; tree traversable via parent/children |
| **Next steps** | Use document tree for editing triggers and task-based LLM document passing; extend with offsets/IDs as needed |
