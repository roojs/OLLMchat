# 1.8.1 Document renderer — structured markdown data model

- **Goal:** Add a new markdown renderer that builds a simple, extensible data structure (document + block + format + list) from parser callbacks, for future editing, task-based LLM document passing, and extension.
- **Status:** open.
- **Parent:** 1.8 (markdown outstanding issues); builds on existing Parser and RenderBase.

---

## Scope

1. **DocumentRender** — A `RenderBase` subclass that receives all parser callbacks and builds an in-memory document tree.
2. **Data types** (in the same file as the renderer): **DocDocument** (root), **DocBlock** (block-level nodes), **DocFormat** (inline/formatting nodes), **DocList** (lists and list items). No separate source files for the node types.
3. **Concrete code** — Full mapping from every `RenderBase` callback to the document model so the tree is complete and ready to extend.

---

## Intended use (later)

- **Editing:** Use the structure to drive editing (e.g. “replace this block”, “change this run of formatting”).
- **Task-based LLM:** Pass document (or sub-ranges) to the LLM as structured input/output.
- **Extension:** Add fields (e.g. source offsets, IDs) or new node kinds without changing the parser.

---

## Data model

### DocDocument (root)

- Holds the root sequence of block-level content.
- **Children:** `Gee.ArrayList<DocNode>` where `DocNode` is either a **DocBlock** or a **DocList** (top-level only; lists and blocks are siblings at root).

### DocBlock (block-level node)

- One block: paragraph, heading, code block, blockquote, horizontal rule, table, table row, table header cell, table cell, or list item.
- **Kind:** enum or string (e.g. `PARAGRAPH`, `HEADING`, `CODE_BLOCK`, `BLOCKQUOTE`, `HR`, `TABLE`, `TABLE_ROW`, `TABLE_HCELL`, `TABLE_CELL`, `LIST_ITEM`).
- **Attributes:** level (heading/blockquote), lang (code block), align (table cells), task_checked (list item).
- **Content:**
  - Paragraph, heading, table cell: list of **DocFormat** (inline content).
  - Code block: single string (literal lines).
  - Blockquote: list of **DocBlock** (nested blocks).
  - Table: list of rows; each row is a DocBlock (TABLE_ROW) whose “content” is list of DocBlock (TABLE_HCELL/TABLE_CELL).
  - List item: list of **DocBlock** (paragraphs, nested lists, etc.).

### DocFormat (inline / formatting node)

- One inline span: text, em, strong, code_span, del, link, image, html, other.
- **Kind:** e.g. `TEXT`, `EM`, `STRONG`, `CODE_SPAN`, `DEL`, `LINK`, `IMAGE`, `HTML`, `OTHER`, `U`.
- **Attributes:** href, title, is_reference (link); src, title (image); tag, attributes (html); tag_name (other).
- **Content:** For leaves (TEXT, IMAGE): string or (src, title). For containers: list of **DocFormat** (nested).

### DocList (list structure)

- Unordered or ordered list with indentation.
- **Attributes:** `ordered: bool`, `indentation: uint`.
- **Children:** list of **DocListItem**. Each **DocListItem** holds a list of **DocBlock** (the content of one item; multiple blocks per item allowed).

---

## Callback → structure mapping

| Parser callback | Action |
|-----------------|--------|
| `on_p(is_start)` | On start: push DocBlock(PARAGRAPH); on end: pop, add to parent. |
| `on_h(is_start, level)` | On start: push DocBlock(HEADING, level); on end: pop. |
| `on_ul(is_start, indentation)` | On start: push DocList(ordered=false, indentation); on end: pop. |
| `on_ol(is_start, indentation)` | On start: push DocList(ordered=true, indentation); on end: pop. |
| `on_li(is_start)` | On start: push new DocListItem (under current DocList); on end: pop item. |
| `on_task_list(is_start, is_checked)` | Record task_checked on current list item (or next on_li). |
| `on_code(is_start, lang, fence_char)` / `on_code_block(is_start, lang)` | On start: push DocBlock(CODE_BLOCK, lang); on end: pop. |
| `on_code_text(string)` | Append to current CODE_BLOCK’s text content. |
| `on_quote(is_start, level)` | On start: push DocBlock(BLOCKQUOTE, level); on end: pop. |
| `on_hr()` | Add DocBlock(HR) to current container (no push/pop). |
| `on_table(is_start)` | On start: push DocBlock(TABLE); on end: pop. |
| `on_table_row(is_start)` | On start: push DocBlock(TABLE_ROW) under table; on end: pop. |
| `on_table_hcell(is_start, align)` | On start: push DocBlock(TABLE_HCELL, align); on end: pop. |
| `on_table_cell(is_start, align)` | On start: push DocBlock(TABLE_CELL, align); on end: pop. |
| `on_text(string)` | Add DocFormat(TEXT, string) to current block’s inline content (or append to current text node if coalescing). |
| `on_em(is_start)` | On start: push DocFormat(EM); on end: pop format. |
| `on_strong(is_start)` | On start: push DocFormat(STRONG); on end: pop. |
| `on_code_span(is_start)` | On start: push DocFormat(CODE_SPAN); on end: pop. |
| `on_del(is_start)` | On start: push DocFormat(DEL); on end: pop. |
| `on_u(is_start)` | On start: push DocFormat(U); on end: pop. |
| `on_a(is_start, href, title, is_reference)` | On start: push DocFormat(LINK, href, title, is_reference); on end: pop. |
| `on_img(src, title)` | Add DocFormat(IMAGE, src, title) to current inline content (leaf). |
| `on_html(is_start, tag, attributes)` | On start: push DocFormat(HTML, tag, attributes); on end: pop. |
| `on_other(is_start, tag_name)` | On start: push DocFormat(OTHER, tag_name); on end: pop. |
| `on_br()` | Add DocFormat(BR) or equivalent (e.g. TEXT "\n") as needed. |
| `on_softbr()` | Same as on_br for structure (or normalize to newline in text). |
| `on_entity(string)` | Add as DocFormat(TEXT) with decoded entity. |

Stack discipline: maintain a stack of “current container” (document root, block, list, list item) and a stack of “current inline format” (for nested em/strong/link etc.). Block/list push-pop drives where the next block or list item goes; format push-pop drives where the next inline content goes. Text and leaf nodes (image, entity) are always added to the current inline container (top of format stack or current block’s inline list).

---

## File and class layout

- **Single new file:** `libocmarkdown/DocumentRender.vala`
  - Contains: **DocDocument**, **DocBlock**, **DocFormat**, **DocList**, **DocListItem** (and any enums), plus **DocumentRender** class extending **RenderBase**.
- **Build:** Add `DocumentRender.vala` to `libocmarkdown/meson.build` in `ocmarkdown_src` (and to valadoc input in `docs/meson.build` if present).

No new dependency: use only `Gee` and `GLib` (and existing parser/render base).

---

## Concrete code (skeleton)

Below is a concrete Vala skeleton: data types plus DocumentRender implementing every RenderBase callback and building the tree. It uses a block stack and a format stack; “current block” is the top block that accepts inline content (paragraph, heading, table cell, etc.).

```vala
// DocumentRender.vala - all in one file
namespace Markdown {

// --- Document node kinds ---
public enum DocBlockKind {
	PARAGRAPH,
	HEADING,
	CODE_BLOCK,
	BLOCKQUOTE,
	HR,
	TABLE,
	TABLE_ROW,
	TABLE_HCELL,
	TABLE_CELL,
	LIST_ITEM
}

public enum DocFormatKind {
	TEXT,
	EM,
	STRONG,
	CODE_SPAN,
	DEL,
	U,
	LINK,
	IMAGE,
	HTML,
	OTHER,
	BR
}

// --- Inline node (format) ---
public class DocFormat : Object {
	public DocFormatKind kind { get; set; }
	public string text { get; set; default = ""; }           // TEXT, or content for CODE_SPAN etc.
	public string href { get; set; default = ""; }
	public string title { get; set; default = ""; }
	public bool is_reference { get; set; }
	public string src { get; set; default = ""; }            // IMAGE
	public string tag { get; set; default = ""; }            // HTML
	public string tag_attributes { get; set; default = ""; }
	public string tag_name { get; set; default = ""; }       // OTHER
	public Gee.ArrayList<DocFormat> children { get; default = new Gee.ArrayList<DocFormat>(); }

	public DocFormat(DocFormatKind k) { kind = k; }
	public static DocFormat text(string s) {
		var f = new DocFormat(DocFormatKind.TEXT);
		f.text = s;
		return f;
	}
}

// --- Block-level node ---
public class DocBlock : Object {
	public DocBlockKind kind { get; set; }
	public uint level { get; set; }
	public string lang { get; set; default = ""; }
	public int align { get; set; }
	public bool task_checked { get; set; }
	public string code_text { get; set; default = ""; }
	public Gee.ArrayList<DocFormat> inlines { get; default = new Gee.ArrayList<DocFormat>(); }
	public Gee.ArrayList<DocBlock> blocks { get; default = new Gee.ArrayList<DocBlock>(); }
	public Gee.ArrayList<DocList> lists { get; default = new Gee.ArrayList<DocList>(); }

	public DocBlock(DocBlockKind k) { kind = k; }
}

// --- List and list item ---
public class DocListItem : Object {
	public bool task_checked { get; set; }
	public Gee.ArrayList<DocBlock> blocks { get; default = new Gee.ArrayList<DocBlock>(); }
	public Gee.ArrayList<DocList> lists { get; default = new Gee.ArrayList<DocList>(); }
}

public class DocList : Object {
	public bool ordered { get; set; }
	public uint indentation { get; set; }
	public Gee.ArrayList<DocListItem> items { get; default = new Gee.ArrayList<DocListItem>(); }
}

// --- Document root ---
public class DocDocument : Object {
	public Gee.ArrayList<DocBlock> blocks { get; default = new Gee.ArrayList<DocBlock>(); }
	public Gee.ArrayList<DocList> lists { get; default = new Gee.ArrayList<DocList>(); }
	// Single flat 'children' is possible: Gee.ArrayList<DocNode> with union type or base type
}

// --- Renderer ---
public class DocumentRender : RenderBase {
	public DocDocument document { get; private set; }

	private Gee.ArrayList<Object> block_stack = new Gee.ArrayList<Object>();
	private Gee.ArrayList<DocFormat> format_stack = new Gee.ArrayList<DocFormat>();
	private DocBlock? current_block_with_inlines = null;
	private DocListItem? current_list_item = null;
	private bool last_task_checked = false;

	public DocumentRender() {
		base();
		document = new DocDocument();
		block_stack.add(document);
	}

	private void push_inline(DocFormat f) {
		format_stack.add(f);
	}

	private void pop_inline() {
		if (format_stack.size == 0) return;
		var top = format_stack[format_stack.size - 1];
		format_stack.remove_at(format_stack.size - 1);
		add_format_to_current(top);
	}

	private void add_format_to_current(DocFormat f) {
		if (format_stack.size > 0) {
			format_stack[format_stack.size - 1].children.add(f);
		} else if (current_block_with_inlines != null) {
			current_block_with_inlines.inlines.add(f);
		}
	}

	private void add_block_to_current(DocBlock b) {
		var parent = block_stack[block_stack.size - 1];
		if (parent is DocDocument) {
			document.blocks.add(b);
		} else if (parent is DocBlock) {
			((DocBlock)parent).blocks.add(b);
		} else if (parent is DocListItem) {
			((DocListItem)parent).blocks.add(b);
		}
	}

	private void push_block(DocBlock b) {
		add_block_to_current(b);
		block_stack.add(b);
		if (b.kind == DocBlockKind.PARAGRAPH || b.kind == DocBlockKind.HEADING ||
		    b.kind == DocBlockKind.TABLE_CELL || b.kind == DocBlockKind.TABLE_HCELL)
			current_block_with_inlines = b;
	}

	private void push_list(DocList list) {
		var parent = block_stack[block_stack.size - 1];
		if (parent is DocDocument)
			document.lists.add(list);
		else if (parent is DocBlock)
			((DocBlock)parent).lists.add(list);
		else if (parent is DocListItem)
			((DocListItem)parent).lists.add(list);
		block_stack.add(list);
	}

	private void pop_block() {
		if (block_stack.size <= 1) return;
		var top = block_stack[block_stack.size - 1];
		block_stack.remove_at(block_stack.size - 1);
		if (top == current_block_with_inlines)
			current_block_with_inlines = null;
	}

	private void pop_list() {
		if (block_stack.size <= 1) return;
		block_stack.remove_at(block_stack.size - 1);
		current_list_item = null;
	}

	// --- Required abstract callbacks ---
	public override void on_text(string text) {
		add_format_to_current(DocFormat.text(text));
	}

	public override void on_em(bool is_start) {
		if (is_start) push_inline(new DocFormat(DocFormatKind.EM));
		else pop_inline();
	}

	public override void on_strong(bool is_start) {
		if (is_start) push_inline(new DocFormat(DocFormatKind.STRONG));
		else pop_inline();
	}

	public override void on_code_span(bool is_start) {
		if (is_start) push_inline(new DocFormat(DocFormatKind.CODE_SPAN));
		else pop_inline();
	}

	public override void on_del(bool is_start) {
		if (is_start) push_inline(new DocFormat(DocFormatKind.DEL));
		else pop_inline();
	}

	public override void on_other(bool is_start, string tag_name) {
		if (is_start) {
			var f = new DocFormat(DocFormatKind.OTHER);
			f.tag_name = tag_name;
			push_inline(f);
		} else pop_inline();
	}

	public override void on_html(bool is_start, string tag, string attributes) {
		if (is_start) {
			var f = new DocFormat(DocFormatKind.HTML);
			f.tag = tag;
			f.tag_attributes = attributes;
			push_inline(f);
		} else pop_inline();
	}

	// --- Block callbacks ---
	public override void on_h(bool is_start, uint level) {
		if (is_start) {
			var b = new DocBlock(DocBlockKind.HEADING);
			b.level = level;
			push_block(b);
		} else pop_block();
	}

	public override void on_p(bool is_start) {
		if (is_start) push_block(new DocBlock(DocBlockKind.PARAGRAPH));
		else pop_block();
	}

	public override void on_ul(bool is_start, uint indentation) {
		if (is_start) {
			var list = new DocList();
			list.ordered = false;
			list.indentation = indentation;
			push_list(list);
		} else pop_list();
	}

	public override void on_ol(bool is_start, uint indentation) {
		if (is_start) {
			var list = new DocList();
			list.ordered = true;
			list.indentation = indentation;
			push_list(list);
		} else pop_list();
	}

	public override void on_li(bool is_start) {
		if (is_start) {
			var item = new DocListItem();
			item.task_checked = last_task_checked;
			last_task_checked = false;
			var parent = block_stack[block_stack.size - 1];
			if (parent is DocList)
				((DocList)parent).items.add(item);
			block_stack.add(item);
			current_list_item = item;
		} else {
			block_stack.remove_at(block_stack.size - 1);
			current_list_item = null;
		}
	}

	public override void on_task_list(bool is_start, bool is_checked) {
		if (is_start) last_task_checked = is_checked;
	}

	public override void on_code(bool is_start, string? lang, char fence_char) {
		if (is_start) {
			var b = new DocBlock(DocBlockKind.CODE_BLOCK);
			b.lang = lang ?? "";
			push_block(b);
		} else pop_block();
	}

	public override void on_code_text(string text) {
		var parent = block_stack[block_stack.size - 1];
		if (parent is DocBlock && ((DocBlock)parent).kind == DocBlockKind.CODE_BLOCK)
			((DocBlock)parent).code_text += text;
	}

	public override void on_code_block(bool is_start, string lang) {
		if (is_start) {
			var b = new DocBlock(DocBlockKind.CODE_BLOCK);
			b.lang = lang;
			push_block(b);
		} else pop_block();
	}

	public override void on_quote(bool is_start, uint level) {
		if (is_start) {
			var b = new DocBlock(DocBlockKind.BLOCKQUOTE);
			b.level = level;
			push_block(b);
		} else pop_block();
	}

	public override void on_hr() {
		add_block_to_current(new DocBlock(DocBlockKind.HR));
	}

	public override void on_table(bool is_start) {
		if (is_start) push_block(new DocBlock(DocBlockKind.TABLE));
		else pop_block();
	}

	public override void on_table_row(bool is_start) {
		if (is_start) {
			var row = new DocBlock(DocBlockKind.TABLE_ROW);
			var table = block_stack[block_stack.size - 1];
			if (table is DocBlock && ((DocBlock)table).kind == DocBlockKind.TABLE)
				((DocBlock)table).blocks.add(row);
			block_stack.add(row);
		} else pop_block();
	}

	public override void on_table_hcell(bool is_start, int align) {
		if (is_start) {
			var cell = new DocBlock(DocBlockKind.TABLE_HCELL);
			cell.align = align;
			push_block(cell);
		} else pop_block();
	}

	public override void on_table_cell(bool is_start, int align) {
		if (is_start) {
			var cell = new DocBlock(DocBlockKind.TABLE_CELL);
			cell.align = align;
			push_block(cell);
		} else pop_block();
	}

	public override void on_a(bool is_start, string href, string title, bool is_reference) {
		if (is_start) {
			var f = new DocFormat(DocFormatKind.LINK);
			f.href = href;
			f.title = title;
			f.is_reference = is_reference;
			push_inline(f);
		} else pop_inline();
	}

	public override void on_img(string src, string? title) {
		var f = new DocFormat(DocFormatKind.IMAGE);
		f.src = src;
		f.title = title ?? "";
		add_format_to_current(f);
	}

	public override void on_br() {
		add_format_to_current(new DocFormat(DocFormatKind.BR));
	}

	public override void on_softbr() {
		add_format_to_current(DocFormat.text("\n"));
	}

	public override void on_entity(string text) {
		add_format_to_current(DocFormat.text(text));
	}

	public override void on_u(bool is_start) {
		if (is_start) push_inline(new DocFormat(DocFormatKind.U));
		else pop_inline();
	}
}
}
```

---

## Design notes

1. **DocDocument children:** The skeleton uses both `document.blocks` and `document.lists`. Alternatively use a single `Gee.ArrayList<DocNode>` with a common base type (e.g. `DocNode` with subclasses DocBlock, DocList) so that root order (block vs list) is preserved. That would require a small refactor to a base type and adding lists to the block stack as “block-like” containers.
2. **List inside list item:** **DocListItem** has both `blocks` and `lists`. When the parser opens a nested list (`on_ul`/`on_ol`) and the stack top is a DocListItem, the new DocList is added to that item’s `lists` (see `push_list`). So nested lists are stored under the list item.
3. **Table row/cell parent:** Table rows are added to the TABLE block’s `blocks` in `on_table_row(true)`. Table cells are added via `push_block(cell)`, so `add_block_to_current` runs with parent = TABLE_ROW; the existing logic `((DocBlock)parent).blocks.add(b)` correctly adds the cell to the row.
4. **Coalescing TEXT:** Optionally coalesce consecutive `on_text` into a single DocFormat(TEXT) to keep the tree smaller; the skeleton adds a new TEXT node per call for simplicity.

---

## Implementation checklist

- [ ] Add `DocumentRender.vala` to `libocmarkdown/` with DocDocument, DocBlock, DocFormat, DocList, DocListItem and DocumentRender as above.
- [ ] Fix push_list / add_block_to_current so that: (a) a DocList under a DocListItem is stored in that item (e.g. `DocListItem.lists` or item’s first block as a “list holder”); (b) table cells are added to the current TABLE_ROW.
- [ ] Add `DocumentRender.vala` to `libocmarkdown/meson.build` and to `docs/meson.build` valadoc list if applicable.
- [ ] Implement a small test (e.g. in `examples/` or `tests/`) that runs `DocumentRender.start(); renderer.add("# Hi\n\nHello *world*."); renderer.flush();` and asserts `document.blocks.size == 2`, first block is HEADING with one inline child, second is PARAGRAPH with TEXT and nested EM.
- [ ] Optionally: add a single root `children: Gee.ArrayList<DocNode>` to DocDocument (with DocNode base class for DocBlock and DocList) to preserve exact order of blocks and lists at root.

---

## Summary

| Item | Description |
|------|-------------|
| **New file** | `libocmarkdown/DocumentRender.vala` (document + block + format + list types + DocumentRender) |
| **Extends** | `RenderBase`; receives all parser callbacks |
| **Output** | `DocDocument` with blocks/lists; each block has kind, attributes, inlines or nested blocks/lists |
| **Next steps** | Use document tree for editing triggers and task-based LLM document passing; extend with offsets/IDs as needed |
