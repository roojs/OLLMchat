# 1.8.1 Document renderer — structured markdown data model

- **Goal:** Add a new markdown renderer that builds a simple, extensible data structure (document + block + format + list) from parser callbacks, for future editing, task-based LLM document passing, and extension.
- **Status:** open.
- **Parent:** 1.8 (markdown outstanding issues); builds on existing Parser and RenderBase.
- **Depends on plan 1.8.2:** The render pipeline uses **on_node(FormatType, bool, string, string, string)** for string-based callbacks and **on_node_int(FormatType, bool, int)** for int/uint-based callbacks (lists, blockquote, table cells). Only **on_a** and **on_code** remain public and are called directly by the parser. **Render** (in namespace Markdown.Document) **overrides on_node** (single switch for TEXT, IMAGE, PARAGRAPH, HEADING_1..6, LIST_ITEM, ITALIC, BOLD, CODE, STRIKETHROUGH, U, HTML, OTHER, FENCED_CODE_QUOTE/TILD, TABLE, TABLE_ROW, BR, CODE_TEXT, HORIZONTAL_RULE, SOFTBR, ENTITY, TASK_LIST/TASK_LIST_DONE), **on_node_int** (UNORDERED_LIST, ORDERED_LIST, BLOCKQUOTE, TABLE_HCELL, TABLE_CELL), and the two public callbacks **on_a** and **on_code**. It does not override the protected methods.

---

## Coding standards and JSON serialization

- **Coding standards:** All new code must follow `.cursor/rules/CODING_STANDARDS.md`: `this.` prefix, brace style (line breaks for namespace/class/method, inline for control structures), no `@"..."` except multi-line help/docs, no trivial temporaries, fully-qualified `GLib.*`, property defaults (`get; set; default =`), `Gee.ArrayList`/`Gee.HashMap` via `.get()`/`.set()`/`.add()` (not `[]`), early returns to reduce nesting. Do **not** use `GLib.StringBuilder` unless building strings in loops with hundreds of iterations; use `+` concatenation and `string.joinv()` instead. Use **Vala secondary constructors** for alternative creation: `ClassName.from_*(...)` (e.g. `Format.from_text(string s)`); call with `new Format.from_text(str)`. Where an object is created and then given properties, use **Vala object initializer** syntax: `new Type() { prop = value, prop2 = value2 }` instead of separate assignment lines.
- **Namespace:** All document model types live in **Markdown.Document**. Class names have no Doc/Document prefix: **Node**, **Format**, **Block**, **ListItem**, **List**, **Document** (root), **Render** (renderer).
- **JSON serialization:** The document and every component must be **Json.Serializable** and round-trip: serialize to JSON and deserialize back to an equivalent tree. All of **Document**, **Block**, **Format**, **List**, and **ListItem** implement `Object, Json.Serializable`. Use `serialize_property` / `deserialize_property` for: enums (serialize as string, e.g. `"PARAGRAPH"`); `Gee.ArrayList` of custom types (array of objects via `Json.gobject_serialize` / `Json.gobject_deserialize`). The library already depends on `json-glib-1.0`. **Property names:** Emit and accept snake_case (e.g. `node_type`, `task_checked`). When deserializing, normalize keys by replacing `'-'` with `'_'` before the switch so kebab-case JSON (e.g. `node-type`) is accepted. When reading the type discriminator in `deserialize_child`, try `obj.get_member("node_type")` then `obj.get_member("node-type")`; the value is an int (FormatType), cast to enum for the switch.

---

## Scope

1. **Render** (Markdown.Document.Render) — A `RenderBase` subclass that receives parser callbacks and builds an in-memory document tree. It uses the current pipeline: **override on_node** with a switch on `FormatType` for TEXT, IMAGE, PARAGRAPH, HEADING_1..6, LIST_ITEM, ITALIC, BOLD, CODE, STRIKETHROUGH, U, HTML, OTHER, FENCED_CODE_QUOTE/TILD, TABLE, TABLE_ROW, BR, CODE_TEXT, HORIZONTAL_RULE, SOFTBR, ENTITY, TASK_LIST, TASK_LIST_DONE; **override on_node_int** for UNORDERED_LIST, ORDERED_LIST, BLOCKQUOTE, TABLE_HCELL, TABLE_CELL; and **override** the two remaining public callbacks **on_a** and **on_code**.
2. **Data types** in namespace **Markdown.Document**: **Document** (root), **Block** (block-level nodes), **Format** (inline/formatting nodes), **List** (lists), **ListItem** (list items). One file per class under `libocmarkdown/document/`.
3. **Concrete code** — Full mapping from every `RenderBase` callback to the document model so the tree is complete and ready to extend.
4. **Json.Serializable** — All document types implement `Json.Serializable` with round-trip (to JSON and back) so the structure can be passed to LLM task systems or stored/restored.

---

## Intended use (later)

- **Editing:** Use the structure to drive editing (e.g. “replace this block”, “change this run of formatting”).
- **Task-based LLM:** Pass document (or sub-ranges) to the LLM as structured input/output.
- **Extension:** Add fields (e.g. source offsets, IDs) or new node kinds without changing the parser.

---

## Data model

Use a **single `children` property** on every container (no separate `blocks`, `lists`, `inlines`, `items`). Add **`parent`** on node types that form the main tree so the tree can be traversed upward; omit or leave unset for **Format** (overkill for inline elements). All types live in namespace **Markdown.Document**.

### Node (abstract base)

- **parent:** `Node?` — set when the node is added to a container; null for root-level nodes. Not set for **Format** when building (optional / overkill for format-only traversal).
- **children:** `Gee.ArrayList<Node>` — single list of child nodes (block, list, list item, or format depending on container).
- **kind:** `FormatType` — default **NONE**; Block and Format set it (PARAGRAPH, HEADING_1..6, TEXT, ITALIC, etc.). Serialized as int in Node.
- Subclasses: **Document**, **Block**, **List**, **ListItem**, **Format**. All extend Node so that any container can hold a uniform `children` list and traversal (up via `parent`, down via `children`) works.

### Document (root)

- Extends **Node**. Root of the tree: **parent** is null.
- **children:** block-level nodes only at root (Block, List) in document order.

### Block (block-level node)

- **kind:** FormatType (PARAGRAPH, HEADING_1..6, FENCED_CODE_QUOTE/TILD, BLOCKQUOTE, HORIZONTAL_RULE, TABLE, TABLE_ROW, TABLE_HCELL, TABLE_CELL, LIST_ITEM).
- **Attributes:** level, lang, align, task_checked, code_text (for code blocks).
- **children:** For paragraph/heading/table cell: Format (inline content). For blockquote/table/row: Block (and List where applicable). For list item: Block and List. Order preserved.

### List (list structure)

- **ordered**, **indentation**.
- **children:** **ListItem** only (one child per list item).

### ListItem (list item)

- **task_checked**.
- **children:** **Block** and **List** (content of the item; multiple blocks and nested lists allowed).

### Format (inline / formatting node)

- **kind:** FormatType (TEXT, ITALIC, BOLD, CODE, STRIKETHROUGH, LINK, IMAGE, HTML, OTHER, U, BR). Attributes: text, href, title, src, tag, tag_attributes, tag_name, is_reference.
- **children:** **Format** only (nested inline content). **parent** is typically not set when building (overkill for format-only traversal).

**JSON:** Serialize `children` as a single array. Because children are polymorphic (Block | List | ListItem | Format), use a **type discriminator** per element: **node_type** is **FormatType** (DOCUMENT, BLOCK, LIST, LIST_ITEM, FORMAT), serialized as int, so deserialization can switch on the int and call the correct `Json.gobject_deserialize(typeof(Block), ...)` etc. Round-trip must reproduce the tree.

**Round-trip to markdown:** Every node implements **`string to_markdown()`** (virtual on Node, overridden in subclasses) so the structure can be converted back to markdown text. Document joins block/list children with `"\n\n"`. Block emits prefix/suffix by kind (e.g. `# ` for HEADING_1, `## ` for HEADING_2, ` ```lang\n` + code_text + `\n``` ` for fenced code, `> ` for blockquote, `---` for horizontal rule; paragraph/heading/table cell = children’s to_markdown()). List emits `- ` or `1. ` per item (by ordered). ListItem emits `[ ] ` / `[x] ` for task then children. Format emits inline syntax: TEXT = literal text, ITALIC = `*` + inner + `*`, BOLD = `**` + inner + `**`, CODE = `` ` `` + text + `` ` ``, LINK = `[` + inner + `](href "title")`, IMAGE = `![` + title + `](src "title")`, BR = `\n`, HTML/OTHER = raw tag; inner = concatenation of children’s to_markdown(). Escape special characters in text where required (e.g. backslash for `*`, `` ` ``, `[` in CODE/link context).

---

## Callback → structure mapping

| Parser callback | Action |
|-----------------|--------|
| `on_p(is_start)` | On start: push Block(FormatType.PARAGRAPH); on end: pop, add to parent. |
| `on_h(is_start, level)` | On start: push Block(HEADING_1..HEADING_6 from level, level); on end: pop. |
| `on_ul(is_start, indentation)` | On start: push List(ordered=false, indentation); on end: pop. |
| `on_ol(is_start, indentation)` | On start: push List(ordered=true, indentation); on end: pop. |
| `on_li(is_start)` | On start: push new ListItem (under current List); on end: pop item. |
| `on_task_list(is_start, is_checked)` | Record task_checked on current list item (or next on_li). |
| `on_code(is_start, lang, fence_char)` / `on_code_block(is_start, lang)` | On start: push Block(FENCED_CODE_QUOTE or FENCED_CODE_TILD, lang); on end: pop. |
| `on_code_text(string)` | Append to current fenced-code block’s text content. |
| `on_quote(is_start, level)` | On start: push Block(BLOCKQUOTE, level); on end: pop. |
| `on_hr()` | Add Block(HORIZONTAL_RULE) to current container (no push/pop). |
| `on_table(is_start)` | On start: push Block(TABLE); on end: pop. |
| `on_table_row(is_start)` | On start: push Block(TABLE_ROW) under table; on end: pop. |
| `on_table_hcell(is_start, align)` | On start: push Block(TABLE_HCELL, align); on end: pop. |
| `on_table_cell(is_start, align)` | On start: push Block(TABLE_CELL, align); on end: pop. |
| `on_text(string)` | Add Format(TEXT, string) to current block’s inline content (or append to current text node if coalescing). |
| `on_em(is_start)` | On start: push Format(ITALIC); on end: pop format. |
| `on_strong(is_start)` | On start: push Format(BOLD); on end: pop. |
| `on_code_span(is_start)` | On start: push Format(CODE); on end: pop. |
| `on_del(is_start)` | On start: push Format(STRIKETHROUGH); on end: pop. |
| `on_u(is_start)` | On start: push Format(U); on end: pop. |
| `on_a(is_start, href, title, is_reference)` | On start: push Format(LINK, href, title, is_reference); on end: pop. |
| `on_img(src, title)` | Add Format(IMAGE, src, title) to current inline content (leaf). |
| `on_html(is_start, tag, attributes)` | On start: push Format(HTML, tag, attributes); on end: pop. |
| `on_other(is_start, tag_name)` | On start: push Format(OTHER, tag_name); on end: pop. |
| `on_br()` | Add Format(BR) to current inline content. |
| `on_softbr()` | Same as on_br for structure (or normalize to newline in text). |
| `on_entity(string)` | Add as Format(TEXT) with decoded entity. |

Stack discipline: maintain a stack of “current container” (document root, block, list, list item) and a stack of “current inline format” (for nested em/strong/link etc.). Block/list push-pop drives where the next block or list item goes; format push-pop drives where the next inline content goes. Text and leaf nodes (image, entity) are always added to the current inline container (top of format stack or current block’s inline list).

---

## Reusing the Parser’s FormatType

Do **not** define separate document enums (**BlockKind** / **FormatKind**). Use the existing **FormatType** enum in `libocmarkdown/Parser.vala` for both block and inline kinds.

- **FormatType (current):** Plan 1.8.2 and the codebase already provide `TABLE_ROW`, `TABLE_HCELL`, `TABLE_CELL`, `LIST_ITEM`, `TEXT`, `IMAGE`, `BR`, `U`, `OTHER`, `CODE_TEXT`, `SOFTBR`, `ENTITY`. For the document model, add four values to **FormatType** for the polymorphic node discriminator: **DOCUMENT**, **BLOCK**, **LIST**, **FORMAT** (use existing **LIST_ITEM** for list item container). Then **node_type** is `FormatType`; each Node subclass returns the corresponding enum (Document → DOCUMENT, Block → BLOCK, List → LIST, ListItem → LIST_ITEM, Format → FORMAT). Serialize as int.
- **Node.kind** (default **FormatType.NONE**) is set by Block and Format. Use existing values where they match: e.g. `PARAGRAPH`, `HEADING_1`..`HEADING_6`, `BLOCKQUOTE`, `HORIZONTAL_RULE`, `TABLE`, `FENCED_CODE_QUOTE`/`FENCED_CODE_TILD`, `UNORDERED_LIST`, `ORDERED_LIST`, `ITALIC`, `BOLD`, `CODE`, `STRIKETHROUGH`, `LINK`, `HTML`. For headings, store level in **Block** (1–6) as now; it can be derived from `HEADING_1`..`HEADING_6` when needed. For fenced code, use `FENCED_CODE_QUOTE` or `FENCED_CODE_TILD` as the block kind.
- **JSON:** Serialize `kind` as an integer: cast the enum to int when serializing (`(int)this.kind`), and cast the int back to enum when deserializing (`value.set_enum(property_node.get_int())`). No parser change required.

---

## File and class layout

- **Parser.vala:** Add to **FormatType**: DOCUMENT, BLOCK, LIST, FORMAT (for node_type discriminator). kind and node_type are serialized as int.
- **Subfolder:** `libocmarkdown/document/` — one file per class, all in namespace **Markdown.Document**:
  - **Node.vala** — Abstract base: `parent`, `children`, `kind` (default NONE), `node_type`, `adopt()`, **`to_markdown()`**; serializes/deserializes kind as int.
  - **Format.vala** — Inline/format node (sets kind in constructor; text, href, src, tag, etc.; `from_text` secondary ctor).
  - **Block.vala** — Block node (sets kind in constructor; level, lang, align, task_checked, code_text).
  - **ListItem.vala** — List item (task_checked); children are Block | List.
  - **List.vala** — List (ordered, indentation); children are ListItem.
  - **Document.vala** — Root (parent null); children are Block | List in order.
  - **Render.vala** — Renderer extending **Markdown.RenderBase**; overrides **on_node**, **on_node_int**, **on_a**, **on_code**. Uses `adopt()` and `children.add()`. Emits **block_ended(document, block)** from `pop_block()` when a block is closed (so consumers can react to completed blocks).
- **Build:** Add all files under `libocmarkdown/document/` to `libocmarkdown/meson.build` in `ocmarkdown_src` (order: Node.vala, Format.vala, Block.vala, ListItem.vala, List.vala, Document.vala, Render.vala). Update valadoc input in `docs/meson.build` if present.
- **Dependencies:** `Gee`, `GLib`, `json-glib-1.0` (already a dependency of libocmarkdown). No new dependency.

---

## Concrete code (skeleton)

Implement as **one file per class** in `libocmarkdown/document/`. The skeleton below is split by file (see comment headers). Coding standards: `this.` prefix, brace style (line breaks for namespace/class/method, inline for control structures), `Gee.ArrayList` via `.get()`/`.add()`/`.remove_at()`, property defaults. In **switch** statements, return directly from each case (no `break`). All document types implement **Json.Serializable** with **node_type** (FormatType, serialized as int), **kind** (FormatType, as int where applicable), and **parent** (exclude from JSON); round-trip reproduces the tree.

**File order for meson.build:** Node.vala, Format.vala, Block.vala, ListItem.vala, List.vala, Document.vala, Render.vala.

---

### document/Node.vala

```vala
namespace Markdown.Document
{

	public abstract class Node : Object, Json.Serializable
	{
		/** Set when added to a container; null for root. Exclude from JSON to avoid cycles. */
		public Node? parent { get; set; }
		public Gee.ArrayList<Node> children { get; set; default = new Gee.ArrayList<Node>(); }

		/** Block/format kind (PARAGRAPH, HEADING_1..6, TEXT, ITALIC, etc.). Default NONE for Document, List, ListItem. */
		public FormatType kind { get; set; default = FormatType.NONE; }

		/** For JSON polymorphic deserialization of children (Document→DOCUMENT, Block→BLOCK, List→LIST, ListItem→LIST_ITEM, Format→FORMAT). */
		public virtual FormatType node_type { get; set; default = FormatType.NONE; }

		/** Call when adding a child: child.parent = this (omit for Format if desired). */
		protected void adopt(Node child)
		{
			this.children.add(child);
			child.parent = this;
		}

		/** Convert this node (and children) back to markdown text. Override in subclasses. */
		public virtual string to_markdown()
		{
			string result = "";
			for (int i = 0; i < this.children.size; i++) {
				result += this.children.get(i).to_markdown();
			}
			return result;
		}

		public override Json.Node serialize_property(string property_name, GLib.Value value, GLib.ParamSpec pspec)
		{
			switch (property_name) {
				case "parent":
					return null;
				case "node_type":
					var nt = new Json.Node(Json.NodeType.VALUE);
					nt.set_int((int)this.node_type);
					return nt;
				case "kind":
					var nk = new Json.Node(Json.NodeType.VALUE);
					nk.set_int((int)this.kind);
					return nk;
				case "children":
					var arr = new Json.Array();
					for (int i = 0; i < this.children.size; i++) {
						arr.add_element(Json.gobject_serialize(this.children.get(i)));
					}
					var n = new Json.Node(Json.NodeType.ARRAY);
					n.init_array(arr);
					return n;
				default:
					return default_serialize_property(property_name, value, pspec);
			}
		}

		public override bool deserialize_property(string property_name, out GLib.Value value, GLib.ParamSpec pspec, Json.Node property_node)
		{
			// Accept both snake_case (our format) and kebab-case (e.g. node-type, task-checked)
			var key = property_name.replace("-", "_");
			switch (key) {
				case "parent":
					return false;
				case "node_type":
					return false;
				case "kind":
					value = GLib.Value(typeof(FormatType));
					value.set_enum(property_node.get_int());
					return true;
				case "children":
					this.children.remove_range(0, this.children.size);
					var json_arr = property_node.get_array();
					for (uint i = 0; i < json_arr.get_length(); i++) {
						var child = deserialize_child(json_arr.get_element(i));
						child.parent = this;
						this.children.add(child);
					}
					value = GLib.Value(typeof(Gee.ArrayList));
					value.set_object(this.children);
					return true;
				default:
					return default_deserialize_property(property_name, out value, pspec, property_node);
			}
		}

		/** Polymorphic child deserialization: dispatch by node_type (FormatType) int. Shared by all subclasses. */
		protected virtual Node? deserialize_child(Json.Node elem)
		{
			var obj = elem.get_object();
			var type_node = obj.get_member("node_type");
			if (type_node == null) {
				type_node = obj.get_member("node-type");
			}
			var type_val = type_node != null ? (FormatType)type_node.get_int() : FormatType.NONE;
			switch (type_val) {
				case FormatType.DOCUMENT:
					return Json.gobject_deserialize(typeof(Document), elem) as Document;
				case FormatType.BLOCK:
					return Json.gobject_deserialize(typeof(Block), elem) as Block;
				case FormatType.LIST:
					return Json.gobject_deserialize(typeof(List), elem) as List;
				case FormatType.LIST_ITEM:
					return Json.gobject_deserialize(typeof(ListItem), elem) as ListItem;
				case FormatType.FORMAT:
					return Json.gobject_deserialize(typeof(Format), elem) as Format;
				default:
					return null;
			}
		}
	}
}
```

---

### document/Format.vala

```vala
namespace Markdown.Document
{

	public class Format : Node
	{
		public override FormatType node_type { get; set; default = FormatType.FORMAT; }
		public string text { get; set; default = ""; }
		public string href { get; set; default = ""; }
		public string title { get; set; default = ""; }
		public bool is_reference { get; set; }
		public string src { get; set; default = ""; }
		public string tag { get; set; default = ""; }
		public string tag_attributes { get; set; default = ""; }
		public string tag_name { get; set; default = ""; }

		public Format(FormatType k)
		{
			this.kind = k;
		}

		/** Secondary constructor: text run (FormatType.TEXT). */
		public Format.from_text(string s)
		{
			this.kind = FormatType.TEXT;
			this.text = s;
		}

		public override string to_markdown()
		{
			string inner = "";
			for (int i = 0; i < this.children.size; i++) {
				inner += this.children.get(i).to_markdown();
			}
			switch (this.kind) {
				case FormatType.TEXT:
					return this.text;
				case FormatType.ITALIC:
					return "*" + inner + "*";
				case FormatType.BOLD:
					return "**" + inner + "**";
				case FormatType.CODE:
					return "`" + (this.text != "" ? this.text : inner) + "`";
				case FormatType.STRIKETHROUGH:
					return "~~" + inner + "~~";
				case FormatType.U:
					return "<u>" + inner + "</u>";
				case FormatType.LINK:
					return "[" + inner + "](" + this.href + (this.title != "" ? " \"" + this.title + "\"" : "") + ")";
				case FormatType.IMAGE:
					return "![" + (this.title != "" ? this.title : "image") + "](" + this.src + (this.title != "" ? " \"" + this.title + "\"" : "") + ")";
				case FormatType.BR:
					return "\n";
				case FormatType.HTML:
					return "<" + this.tag + (this.tag_attributes != "" ? " " + this.tag_attributes : "") + ">" + inner + "</" + this.tag + ">";
				case FormatType.OTHER:
					return "<" + this.tag_name + ">" + inner + "</" + this.tag_name + ">";
				default:
					return inner;
			}
		}
	}
}
```

---

### document/Block.vala

```vala
namespace Markdown.Document
{

	public class Block : Node
	{
		public override FormatType node_type { get; set; default = FormatType.BLOCK; }
		public uint level { get; set; }
		public string lang { get; set; default = ""; }
		public int align { get; set; }
		public bool task_checked { get; set; }
		public string code_text { get; set; default = ""; }

		public Block(FormatType k)
		{
			this.kind = k;
		}

		public override string to_markdown()
		{
			string inner = "";
			for (int i = 0; i < this.children.size; i++) {
				inner += this.children.get(i).to_markdown();
			}
			switch (this.kind) {
				case FormatType.PARAGRAPH:
					return inner;
				case FormatType.HEADING_1:
				case FormatType.HEADING_2:
				case FormatType.HEADING_3:
				case FormatType.HEADING_4:
				case FormatType.HEADING_5:
				case FormatType.HEADING_6:
					var sharp = string.nfill((int)this.level, '#');
					return sharp + " " + inner;
				case FormatType.BLOCKQUOTE:
					return "> " + inner.replace("\n", "\n> ");
				case FormatType.FENCED_CODE_QUOTE:
				case FormatType.FENCED_CODE_TILD:
					var fence = this.kind == FormatType.FENCED_CODE_QUOTE ? "```" : "~~~";
					return fence + (this.lang != "" ? this.lang : "") + "\n" + this.code_text + "\n" + fence;
				case FormatType.HORIZONTAL_RULE:
					return "---";
				default:
					return inner;
			}
		}
	}
}
```

---

### document/ListItem.vala

```vala
namespace Markdown.Document
{

	public class ListItem : Node
	{
		public override FormatType node_type { get; set; default = FormatType.LIST_ITEM; }
		public bool task_checked { get; set; }

		public override string to_markdown()
		{
			string result = this.task_checked ? "[x] " : "[ ] ";
			for (int i = 0; i < this.children.size; i++) {
				result += this.children.get(i).to_markdown();
			}
			return result;
		}
	}
}
```

---

### document/List.vala

```vala
namespace Markdown.Document
{

	public class List : Node
	{
		public override FormatType node_type { get; set; default = FormatType.LIST; }
		public bool ordered { get; set; }
		public uint indentation { get; set; }
	}
}
```

---

### document/Document.vala

```vala
namespace Markdown.Document
{

	public class Document : Node
	{
		public override FormatType node_type { get; set; default = FormatType.DOCUMENT; }
	}
}
```

---

### document/Render.vala

```vala
namespace Markdown.Document
{

	public class Render : Markdown.RenderBase
	{
		public Document document { get; private set; }

		/** Emitted when a block is closed (fired from pop_block before removing from stack). */
		public signal void block_ended(Document document, Block block);

		private Gee.ArrayList<Object> block_stack = new Gee.ArrayList<Object>();
		private Gee.ArrayList<Format> format_stack = new Gee.ArrayList<Format>();
		private Block? current_block_with_inlines = null;
		private ListItem? current_list_item = null;
		private bool last_task_checked = false;

		public Render()
		{
			base();
			this.document = new Document();
			this.block_stack.add(this.document);
		}

		private void push_inline(Format f)
		{
			this.format_stack.add(f);
		}

		private void pop_inline()
		{
			if (this.format_stack.size == 0) {
				return;
			}
			var top = this.format_stack.get(this.format_stack.size - 1);
			this.format_stack.remove_at(this.format_stack.size - 1);
			this.add_format_to_current(top);
		}

		private void add_format_to_current(Format f)
		{
			if (this.format_stack.size > 0) {
				this.format_stack.get(this.format_stack.size - 1).children.add(f);
				return;
			}
			if (this.current_block_with_inlines != null) {
				this.current_block_with_inlines.children.add(f);
			}
		}

		private void add_block_to_current(Block b)
		{
			var parent = this.block_stack.get(this.block_stack.size - 1) as Node;
			parent.adopt(b);
		}

		private void push_block(Block b)
		{
			this.add_block_to_current(b);
			this.block_stack.add(b);
			if (b.kind == FormatType.PARAGRAPH || b.kind >= FormatType.HEADING_1 && b.kind <= FormatType.HEADING_6 ||
			    b.kind == FormatType.TABLE_CELL || b.kind == FormatType.TABLE_HCELL) {
				this.current_block_with_inlines = b;
			}
		}

		private void push_list(List list)
		{
			var parent = this.block_stack.get(this.block_stack.size - 1) as Node;
			parent.adopt(list);
			this.block_stack.add(list);
		}

		private void pop_block()
		{
			if (this.block_stack.size <= 1) {
				return;
			}
			var top = this.block_stack.get(this.block_stack.size - 1);
			if (top is Block) {
				this.block_ended(this.document, (Block)top);
			}
			this.block_stack.remove_at(this.block_stack.size - 1);
			if (top == this.current_block_with_inlines) {
				this.current_block_with_inlines = null;
			}
		}

		private void pop_list()
		{
			if (this.block_stack.size <= 1) {
				return;
			}
			this.block_stack.remove_at(this.block_stack.size - 1);
			this.current_list_item = null;
		}

		private void on_block(Block? node)
		{
			if (node == null) {
				this.pop_block();
				return;
			}
			this.push_block(node);
		}

		private void on_inline(Format? node)
		{
			if (node == null) {
				this.pop_inline();
				return;
			}
			this.push_inline(node);
		}

		/** Current RenderBase pipeline: one switch on type for string-based events. */
		public override void on_node(FormatType type, bool is_start, string s1 = "", string s2 = "", string s3 = "")
		{
			switch (type) {
				case FormatType.TEXT:
					if (s1 != "") {
						this.add_format_to_current(new Format.from_text(s1));
					}
					return;
				case FormatType.IMAGE:
					this.add_format_to_current(new Format(FormatType.IMAGE) { src = s1, title = s2 });
					return;
				case FormatType.PARAGRAPH:
					this.on_block(is_start ? new Block(FormatType.PARAGRAPH) : null);
					return;
				case FormatType.HEADING_1:
				case FormatType.HEADING_2:
				case FormatType.HEADING_3:
				case FormatType.HEADING_4:
				case FormatType.HEADING_5:
				case FormatType.HEADING_6:
					this.on_block(is_start ? new Block(type) { level = (uint)(type - FormatType.HEADING_1 + 1) } : null);
					return;
				case FormatType.LIST_ITEM:
					if (is_start) {
						var item = new ListItem() { task_checked = this.last_task_checked };
						this.last_task_checked = false;
						var parent = this.block_stack.get(this.block_stack.size - 1) as List;
						parent.adopt(item);
						this.block_stack.add(item);
						this.current_list_item = item;
					} else {
						this.block_stack.remove_at(this.block_stack.size - 1);
						this.current_list_item = null;
					}
					return;
				case FormatType.ITALIC:
				case FormatType.BOLD:
				case FormatType.CODE:
				case FormatType.STRIKETHROUGH:
				case FormatType.U:
					this.on_inline(is_start ? new Format(type) : null);
					return;
				case FormatType.HTML:
					this.on_inline(is_start ? new Format(FormatType.HTML) { tag = s1, tag_attributes = s2 } : null);
					return;
				case FormatType.OTHER:
					this.on_inline(is_start ? new Format(FormatType.OTHER) { tag_name = s1 } : null);
					return;
				case FormatType.FENCED_CODE_QUOTE:
				case FormatType.FENCED_CODE_TILD:
					this.on_block(is_start ? new Block(type) { lang = s1 } : null);
					return;
				case FormatType.TABLE:
					this.on_block(is_start ? new Block(FormatType.TABLE) : null);
					return;
				case FormatType.TABLE_ROW:
					if (is_start) {
						var row = new Block(FormatType.TABLE_ROW);
						var table = this.block_stack.get(this.block_stack.size - 1) as Node;
						table.adopt(row);
						this.block_stack.add(row);
					} else {
						this.pop_block();
					}
					return;
				case FormatType.BR:
					this.add_format_to_current(new Format(FormatType.BR));
					return;
				case FormatType.CODE_TEXT:
					var code_parent = this.block_stack.get(this.block_stack.size - 1);
					if (code_parent is Block) {
						var pb = (Block)code_parent;
						if (pb.kind == FormatType.FENCED_CODE_QUOTE || pb.kind == FormatType.FENCED_CODE_TILD) {
							pb.code_text += s1;
						}
					}
					return;
				case FormatType.HORIZONTAL_RULE:
					this.add_block_to_current(new Block(FormatType.HORIZONTAL_RULE));
					return;
				case FormatType.SOFTBR:
					this.add_format_to_current(new Format.from_text("\n"));
					return;
				case FormatType.ENTITY:
					this.add_format_to_current(new Format.from_text(s1));
					return;
				case FormatType.TASK_LIST:
					this.last_task_checked = false;
					return;
				case FormatType.TASK_LIST_DONE:
					this.last_task_checked = true;
					return;
				default:
					return;
			}
		}

		/** Int/uint-based callbacks (parser calls on_node_int). */
		public override void on_node_int(FormatType type, bool is_start, int v1 = 0)
		{
			switch (type) {
				case FormatType.UNORDERED_LIST:
				case FormatType.ORDERED_LIST:
					if (is_start) {
						this.push_list(new List() { ordered = (type == FormatType.ORDERED_LIST), indentation = (uint)v1 });
					} else {
						this.pop_list();
					}
					return;
				case FormatType.BLOCKQUOTE:
					this.on_block(is_start ? new Block(FormatType.BLOCKQUOTE) { level = (uint)v1 } : null);
					return;
				case FormatType.TABLE_HCELL:
				case FormatType.TABLE_CELL:
					this.on_block(is_start ? new Block(type) { align = v1 } : null);
					return;
				default:
					return;
			}
		}

		/** Only two callbacks remain public and are called directly by the parser. */
		public override void on_a(bool is_start, string href, string title, bool is_reference)
		{
			this.on_inline(is_start ? new Format(FormatType.LINK) { href = href, title = title, is_reference = is_reference } : null);
		}

		public override void on_code(bool is_start, string lang, char fence_char)
		{
			this.on_block(is_start ? new Block(FormatType.FENCED_CODE_QUOTE) { lang = lang } : null);  // or FENCED_CODE_TILD from fence_char
		}
	}
}
```

**Enum serialization:** In **Node**, serialize `kind` and `node_type` as int; deserialize `kind` in Node. Block and Format do not override serialize/deserialize for kind (they set `this.kind` in constructors). `kind` defaults to **FormatType.NONE** on Node. Parser adds DOCUMENT, BLOCK, LIST, FORMAT to FormatType for node_type.

---

## Design notes

1. **Unified children and parent:** The skeleton uses a single `children` on Node (and thus Document). Root order (blocks and lists) is preserved in `document.children`. The block stack holds document, blocks, and lists so `add_block_to_current` / `push_list` add to the correct parent.
2. **List inside list item:** When the parser opens a nested list (`on_ul`/`on_ol`) and the stack top is a ListItem, the new List is added to that item’s `lists` (see `push_list`). So nested lists are stored under the list item.
3. **Table row/cell:** Table rows are added to the TABLE block’s `blocks` in `on_table_row(true)`. Table cells are added via `push_block(cell)`, so `add_block_to_current` runs with parent = TABLE_ROW; the existing logic `((Block)parent).blocks.add(b)` correctly adds the cell to the row.
4. **Coalescing TEXT:** Optionally coalesce consecutive TEXT events (on_node(FormatType.TEXT, ...)) into a single Format(TEXT) to keep the tree smaller; the skeleton adds a new TEXT node per call for simplicity.
5. **Inline structure (e.g. "allaalal *lalal* alallaal"):** The format span (ITALIC) does **not** have left/right text as children. Block's inline list = [TEXT("allaalal "), ITALIC → [TEXT("lalal")], TEXT(" alallaal")]. The span has only the inner content as children; left and right text are **siblings** of the span. **Skip empty TEXT:** when `s1 == ""` in the TEXT case, do not call add_format_to_current (avoid empty text nodes).

---

## Implementation checklist

- [ ] Create `libocmarkdown/document/` with **one file per class:** Node.vala, Format.vala, Block.vala, ListItem.vala, List.vala, Document.vala, Render.vala (all in namespace **Markdown.Document**). Follow `.cursor/rules/CODING_STANDARDS.md` (e.g. `this.` prefix, brace style, `GLib.` prefix, `Gee.ArrayList` via `.get()`/`.add()`/`.remove_at()`).
- [ ] **Render:** Override **on_node** (full switch including TASK_LIST, TASK_LIST_DONE, SOFTBR, ENTITY), **on_node_int** (UNORDERED_LIST, ORDERED_LIST, BLOCKQUOTE, TABLE_HCELL, TABLE_CELL), and the two public callbacks **on_a** and **on_code**.
- [ ] Implement **Json.Serializable** on Document, Block, Format, List, ListItem: **Node** handles `kind` (default NONE) and `node_type` serialize/deserialize as int; use `Json.gobject_deserialize` for nested collections.
- [ ] Add all `libocmarkdown/document/*.vala` to `libocmarkdown/meson.build` in `ocmarkdown_src` (order: Node, Format, Block, ListItem, List, Document, Render); update `docs/meson.build` valadoc list if applicable.
- [ ] Implement a small test that runs `Render.start(); renderer.add("# Hi\n\nHello *world*."); renderer.flush();` and asserts `document.children.size == 2`, first child is Block with kind HEADING_1, second is Block PARAGRAPH with TEXT and nested ITALIC in children.
- [ ] Add a **round-trip test**: build a document tree, serialize with `Json.gobject_serialize(renderer.document)` and a `Json.Generator`, parse back with `Json.from_string()` and `Json.gobject_deserialize(typeof(Markdown.Document.Document), root)`, then assert structure equality (same block/list counts and kinds, same inline content).
- [ ] Optionally: add a single root `children: Gee.ArrayList<Node>` to Document (with Node base class for Block and List) to preserve exact order of blocks and lists at root.

---

## Summary

| Item | Description |
|------|-------------|
| **Parser** | Add to FormatType: DOCUMENT, BLOCK, LIST, FORMAT (for node_type). kind and node_type serialized as int. |
| **New files** | `libocmarkdown/document/`: Node.vala, Format.vala, Block.vala, ListItem.vala, List.vala, Document.vala, Render.vala (one class per file); kinds use **FormatType** |
| **Render API** | Overrides **on_node** (string-based events), **on_node_int** (lists, blockquote, table cells), and the two public callbacks **on_a** and **on_code** only. Matches current RenderBase pipeline. |
| **Output** | `Document` (extends Node): single **children** (blocks + lists in order); each node has **parent** (null for root/format), **children**, **kind: FormatType** where applicable; tree traversable via parent/children |
| **Next steps** | Use document tree for editing triggers and task-based LLM document passing; extend with offsets/IDs as needed |
