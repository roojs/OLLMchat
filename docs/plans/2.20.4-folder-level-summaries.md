# 2.20.4. Folder-Level Summaries

**Coding standards**: All code in this plan follows [.cursor/rules/CODING_STANDARDS.md](.cursor/rules/CODING_STANDARDS.md). Before implementation, verify: **null checks** — none unless really valid (this plan keeps only two: (1) external LLM API — `chat.send` may return null response/message; (2) FileBase.points_to from libocfiles). Message.content is non-nullable (`string` default `""`). Use `has_key()` then `get()` for map lookups; have `analyze()` return non-null `VectorMetadata` with description = "" on failure; assume `VectorMetadata.description` default "". Also: nullable types avoided, `this.` for instance members, `GLib.` prefix, Gee.HashMap/Gee.ArrayList use `.set()`/`.get()`, no `Gee.ArrayList<string>` when building arrays just to join (use `string[]`), brace placement, line breaking for long calls.

## Status

⏳ **PENDING**

## Purpose

Generate one-line descriptions for each directory/folder to help LLM understand code organization. Folders provide important organizational context that should be captured and made available.

## Problem Statement

Folders provide important organizational context, but currently there's no high-level description of what each folder contains.

## Folder Metadata

### Storage

- Stored in `vector_metadata` table
- `element_type = 'folder'`
- `file_id` references the folder's `FileBase.id` (folders are also in filebase table)
- `start_line = 0` and `end_line = 0` (no line numbers for folders)
- `vector_id = 0` (NOT stored in FAISS, not vectorized)
- `description` contains one-line folder description
- `ast_path = ''` (folders don't have AST paths)

### Analysis Process

1. Get child folders directly from folder structure:
   - Iterate through `folder.children.items`
   - Filter for `Folder` objects (subfolders)
   - For each child folder, query its description from `vector_metadata`:
     ```sql
     SELECT description FROM vector_metadata 
     WHERE file_id = ? AND element_type = 'folder'
     ```
2. Query `vector_metadata` for all files in the folder:
   ```sql
   SELECT element_name, description FROM vector_metadata 
   WHERE file_id IN (SELECT id FROM filebase WHERE parent_id = ? AND base_type = 'f')
   AND element_type = 'file'
   ```
3. Build context: folder path + list of files with their descriptions + list of child folders with their descriptions
4. Call Analysis layer with folder analysis prompt template (includes child folder summaries)
5. Generate one-line description (similar to element descriptions, but can reference child folders)
6. Store in `vector_metadata` with `element_type='folder'`

### Folder Processing Order

- **Bottom-up traversal**: Process child folders before parent folders
- Recursively collect all folders in the project
- Sort folders by depth (deepest folders first)
- Process folders in sorted order (deepest → shallowest)
- This ensures child folder descriptions are available when analyzing parent folders
- Parent folder analysis can include summaries of what child folders contain

### Prompt Template

- New resource file: `resources/ocvector/folder-prompt.txt`
- Similar structure to element analysis prompt
- Input includes:
  - Folder path
  - List of files with their descriptions
  - List of child folders with their descriptions (if any)
- Output: one-line description of folder contents (can reference child folders)

## Overview: Two Phases

The work is split into two phases:

1. **Phase 1 — Folder Analysis Creation**: Implement the standalone folder analysis layer (prompt template, `FolderAnalysis` class, metadata keymap contract). No Indexer or flow changes. Enables unit/standalone testing of folder description generation.

2. **Phase 2 — Integration**: Wire folder analysis into the Indexer (metadata keymap builder, `index_folders()`, `index_filebase()` flow), build system, and resources. End-to-end indexing runs folder analysis after file scanning.

---

## Phase 1: Folder Analysis Creation

### Metadata Keymap (id-indexed) — Design Contract

- **Collect** (Phase 2): existing vector metadata using the project's map/array of folders and files. The root folder's `project_files` has `folder_map` (all folders) and the list of `ProjectFile` (each has `.file.id` for files). Use these to build the set of file/folder ids for the bulk query — no recursive tree walk.
- **Store**: id-indexed `Gee.HashMap<int, VectorMetadata>` keyed by `(int)file_id`. Holds the full `VectorMetadata` object (do not copy out only the description).
- **Use** (Phase 1): when analyzing a folder, look up child folder/file `VectorMetadata` from the keymap and use `.description` / `.element_name` from the stored object. **Update** the keymap when a folder's analysis completes by storing the new `VectorMetadata` for that folder.

### FolderAnalysis Class and Traversal

Create `FolderAnalysis` (similar to `DocumentationAnalysis`):
- Extends `VectorBase`, owns folder prompt template (`folder-prompt.txt`).
- **Created once** for the top folder / tree (e.g. `new FolderAnalysis(config, sql_db)`). When an alias has `points_to == null`, do not try to resolve it — show `(alias) ` + alias.path and continue.
- **`analyze_children(folder, metadata_keymap)`** (main entry from Indexer in Phase 2):
  - For each direct child: if `Folder`, `yield analyze_children(child_folder, metadata_keymap)`; if alias (`base_type == "fa"`) and `points_to is Folder`, `yield analyze_children((Folder)points_to, metadata_keymap)` so alias→folder subtrees are analyzed.
  - After all children are done, call **`analyze(folder, metadata_keymap)`** on this folder (the single-folder LLM step). Do not name this “analyze_folder” in the traversal API, since the class is already the folder-analysis tool.
  - Writes the new folder `VectorMetadata` into `metadata_keymap.set((int)folder.id, meta)` and to the DB.
- **`analyze(folder, metadata_keymap)`** (internal, per-folder LLM):
  - Build context from `metadata_keymap`: get `VectorMetadata` by `(int)child.id` / `(int)file_id`; use basename for display. For **aliases**: when `points_to == null` show `(alias) ` + alias.path and do not try to resolve; when `points_to != null` use target's type for tag `(alias→folder)` or `(alias→file)` and target's id for keymap description.
  - Call LLM with folder prompt, get one-line description, save to DB and store the new `VectorMetadata` in the keymap.

### Phase 1 Deliverables

- [ ] Create `resources/ocvector/folder-prompt.txt` prompt template (includes child folder summaries)
- [ ] Create `FolderAnalysis` class:
  - Extends `VectorBase`, static folder prompt template
  - Ctor `(config, sql_db)` — no folder_map; when alias `points_to == null` we show `(alias) ` + alias.path and do not try to resolve
  - `analyze_children(folder, metadata_keymap)` — recurse into child folders first, then call `analyze()` on this folder; update keymap when done
  - `analyze(folder, metadata_keymap)` — build context from keymap; for aliases use `points_to` when non-null for `(alias→folder)` / `(alias→file)` and target's description; when null show `(alias) ` + alias.path
- [ ] Store folder metadata with `element_type='folder'` (from within `FolderAnalysis.analyze()`)
- [ ] Build system: add `FolderAnalysis.vala` to `libocvector/meson.build` and ensure folder prompt resource is available for loading
- [ ] Test folder description generation in isolation (e.g. manual call with a pre-filled keymap; verify child folders/files reflected in parent description)

### Phase 1 Code Changes

#### 1. New Prompt Template File

**File**: `resources/ocvector/folder-prompt.txt`

```text
You are a code analysis assistant. Your task is to generate a SHORT, ONE-LINE description of a directory/folder for semantic search indexing.

CRITICAL REQUIREMENTS:
- ONE LINE ONLY - do not write multiple sentences or paragraphs
- SHORT - keep it brief and concise (ideally under 20 words)
- NO DETAIL - do not go into implementation details, just state what the folder contains or organizes
- NO MARKDOWN - no formatting, no code blocks, no special characters
- NO EXPLANATIONS - just the description text, nothing else

Generate a single, short sentence that describes what the folder contains or organizes. Focus only on:
- The folder's primary purpose (what it contains, not how it's organized)
- What functionality or components it groups together
- You can reference child folders if they help describe the parent

Return ONLY the one-line description text - no explanations, no markdown, no JSON, no additional text, just the plain single-line description.
---
Analyze the following directory/folder and generate a SHORT ONE-LINE description:

IMPORTANT: Do not extract or infer any additional context beyond what is provided here. Only summarize based on the information given in this prompt - the folder path and the list of files and subfolders below.

You are analyzing the folder '{folder_path}'.

{folder_contents}

Generate a single, short one-line description that summarizes what this folder contains or organizes.
```

**Note**: The `{folder_contents}` placeholder is replaced with one list of lines, each prefixed by `(folder)`, `(file)`, or for aliases `(alias→folder)` / `(alias→file)` when `points_to != null`; when `points_to == null` show `(alias) ` + alias.path and do not try to resolve.

#### 2. New FolderAnalysis Class

**File**: `libocvector/Indexing/FolderAnalysis.vala` (NEW FILE)

Create a new class following the same pattern as `DocumentationAnalysis`:

```vala
/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMvector.Indexing
{
	/**
	 * Analysis layer for folder/directory processing.
	 * 
	 * Processes Folder objects and generates one-line descriptions using LLM.
	 * Analyzes folders by querying child folder descriptions and file descriptions
	 * from the database, then generates a summary of the folder's contents.
	 */
	public class FolderAnalysis : VectorBase
	{
		private SQ.Database sql_db;
		private static PromptTemplate? cached_folder_template = null;
		
		/**
		 * Static constructor - loads template at class initialization.
		 */
		static construct
		{
			try {
				cached_folder_template = new PromptTemplate("folder-prompt.txt");
				cached_folder_template.load();
			} catch (GLib.Error e) {
				GLib.critical("Failed to load folder prompt template in static constructor: %s", e.message);
			}
		}
		
		/**
		 * Constructor.
		 *
		 * @param config The Config2 instance containing tool configuration
		 * @param sql_db The SQLite database for syncing after folder processing
		 */
		public FolderAnalysis(OLLMchat.Settings.Config2 config, SQ.Database sql_db)
		{
			base(config);
			this.sql_db = sql_db;
		}
		
		/**
		 * Recursive entry: analyze children first, then this folder.
		 * 
		 * For each direct child that is a Folder, yields to analyze_children(child, metadata_keymap).
		 * For each alias (base_type "fa") whose points_to is a Folder, yields to analyze_children(points_to, metadata_keymap).
		 * Once all children are done, calls analyze(folder, metadata_keymap) and updates
		 * metadata_keymap with the new folder VectorMetadata (store full object, do not copy description).
		 * 
		 * @param folder The folder to process
		 * @param metadata_keymap Id-indexed map ((int)file_id → VectorMetadata); key type is int (cast from int64); updated when this folder is analyzed
		 * @return Number of folders analyzed in this subtree
		 */
		public async int analyze_children(OLLMfiles.Folder folder, Gee.HashMap<int, VectorMetadata> metadata_keymap) throws GLib.Error
		{
			int count = 0;
			
			// Recurse into child folders first (bottom-up). Include alias→folder: when points_to is a Folder, recurse into it.
			foreach (var child in folder.children.items) {
				if (child is OLLMfiles.Folder) {
					count += yield this.analyze_children((OLLMfiles.Folder)child, metadata_keymap);
					continue;
				}
				var fb = (OLLMfiles.FileBase)child;
				if (fb.base_type == "fa" && fb.points_to is OLLMfiles.Folder) {
					count += yield this.analyze_children((OLLMfiles.Folder)fb.points_to, metadata_keymap);
				}
			}
			
			// Then analyze this folder and update keymap with full VectorMetadata (analyze returns non-null; empty description = skip)
			var meta = yield this.analyze(folder, metadata_keymap);
			if (meta.description != "") {
				metadata_keymap.set((int)folder.id, meta);
				count++;
			}
			
			return count;
		}
		
		/**
		 * Per-folder analysis: build context from metadata_keymap, call LLM, save to DB, update keymap.
		 * 
		 * Builds context from metadata_keymap: get VectorMetadata by (int)child.id/(int)file_id, use
		 * .description and .element_name from the stored object (do not copy out description only).
		 * 
		 * @param folder The folder to analyze
		 * @param metadata_keymap Id-indexed map ((int)file_id → VectorMetadata); read for children/files, write for (int)folder.id when done
		 * @return VectorMetadata for this folder; on failure returns VectorMetadata with description = "" (never null)
		 */
		private async VectorMetadata analyze(OLLMfiles.Folder folder, Gee.HashMap<int, VectorMetadata> metadata_keymap) throws GLib.Error
		{
			// Build folder contents: one pass over children, each line tagged (folder), (file), or (alias) from base_type.
			// Descriptions from keymap are stored stripped when saved, so use vm.description as-is.
			string[] folder_contents_lines = {};
			foreach (var child in folder.children.items) {
				var fb = (OLLMfiles.FileBase)child;
				switch (fb.base_type) {
					case "d": {
						var c = (OLLMfiles.Folder)child;
						var name = GLib.Path.get_basename(c.path);
						if (!metadata_keymap.has_key((int)c.id)) {
							folder_contents_lines += "  - (folder) " + name;
							break;
						}
						var vm = metadata_keymap.get((int)c.id);
						if (vm.description == "") {
							folder_contents_lines += "  - (folder) " + name;
							break;
						}
						folder_contents_lines += "  - (folder) " + name + ": " + vm.description;
						break;
					}
					case "fa": {
						var alias = (OLLMfiles.File)child;
						// Resolve alias target (FileBase.points_to nullable per libocfiles API). When null, do not try to fix — handle and break.
						if (alias.points_to == null) {
							folder_contents_lines += "  - (alias) " + alias.path;
							break;
						}
						if (!metadata_keymap.has_key((int)alias.points_to.id)) {
							folder_contents_lines += "  - " + (alias.points_to is OLLMfiles.Folder ? "(alias→folder) " : "(alias→file) ")
								+ alias.points_to.path;
							break;
						}
						if (metadata_keymap.get((int)alias.points_to.id).description == "") {
							folder_contents_lines += "  - " + (alias.points_to is OLLMfiles.Folder ? "(alias→folder) " : "(alias→file) ")
								+ alias.points_to.path;
							break;
						}
						folder_contents_lines += "  - " + (alias.points_to is OLLMfiles.Folder ? "(alias→folder) " : "(alias→file) ")
							+ alias.points_to.path + ": " + metadata_keymap.get((int)alias.points_to.id).description;
						break;
					}
					case "f": {
						var c = (OLLMfiles.File)child;
						var name = GLib.Path.get_basename(c.path);
						if (!metadata_keymap.has_key((int)c.id)) {
							folder_contents_lines += "  - (file) " + name;
							break;
						}
						var vm = metadata_keymap.get((int)c.id);
						if (vm.description == "") {
							folder_contents_lines += "  - (file) " + name;
							break;
						}
						folder_contents_lines += "  - (file) " + name + ": " + vm.description;
						break;
					}
					default:
						continue;
				}
			}
			// Build user message from template (joinv on empty array yields "")
			var user_message = cached_folder_template.fill(
				"folder_path", folder.path != "" ? folder.path : "unknown",
				"folder_contents",  
					folder_contents_lines.length > 0 ? 
						 string.joinv("\n", folder_contents_lines) :
						  "(no contents found)"
			);
			
			// Call LLM to generate folder description
			GLib.debug("Folder: %s", folder.path);
			var folder_description = "";
			const int MAX_RETRIES = 2;
			
			for (int attempt = 0; attempt <= MAX_RETRIES; attempt++) {
				try {
					var analysis_conn = yield this.connection("analysis");
					var tool_config = this.config.tools.get("codebase_search") as OLLMvector.Tool.CodebaseSearchToolConfig;
					var chat = new OLLMchat.Call.Chat(
						analysis_conn,
						tool_config.analysis.model
					) {
						stream = false,
						options = tool_config.analysis.options
					};
					var messages = new Gee.ArrayList<OLLMchat.Message>();
					if (cached_folder_template.system_message != "") {
						messages.add(new OLLMchat.Message("system", cached_folder_template.system_message));
					}
					messages.add(new OLLMchat.Message("user", user_message));
					// Exception: external LLM API contract — chat.send may return null response/message/content
					OLLMchat.Response.Chat? response = yield chat.send(messages, null);
					if (response == null || response.message == null) {
						if (attempt < MAX_RETRIES) {
							continue;
						}
						folder_description = "";
						break;
					}
					folder_description = response.message.content.strip();
					if (folder_description != "") {
						GLib.debug("Result: %s", folder_description);
						break;
					}
					if (attempt < MAX_RETRIES) {
						continue;
					}
					folder_description = "";
					break;
				} catch (GLib.Error e) {
					if (attempt < MAX_RETRIES) {
						continue;
					}
					GLib.warning("Failed to analyze folder %s: %s", folder.path, e.message);
					folder_description = "";
					break;
				}
			}
			
			var folder_metadata = new VectorMetadata() {
				element_type = "folder",
				element_name = GLib.Path.get_basename(folder.path),
				start_line = 0,
				end_line = 0,
				description = folder_description,
				file_id = folder.id,
				vector_id = 0,
				ast_path = ""
			};
			folder_metadata.saveToDB(this.sql_db, false);
			this.sql_db.backupDB();
			GLib.debug("Complete for %s: description length %d", folder.path, folder_description.length);
			return folder_metadata;
		}
	}
}
```

**Note**: The static field `cached_folder_template` is private and accessed directly within the class, following the same pattern as `DocumentationAnalysis`.

#### 3. Build System (Phase 1)

**File**: `libocvector/meson.build`

Add the new `FolderAnalysis.vala` file to the `ocvector_src` list (around line 64, after `DocumentationAnalysis.vala`):

```meson
'Indexing/DocumentationAnalysis.vala',  # Documentation analysis layer
'Indexing/FolderAnalysis.vala',  # Folder analysis layer
'Indexing/DocumentationVectorBuilder.vala',  # Documentation vector generation and FAISS storage
```

**File**: `resources/gresources.xml` (if needed)

Add the new folder prompt template to the resource file (if not already auto-included):

```xml
<file>ocvector/folder-prompt.txt</file>
```

**Note**: Check if the build system automatically includes all files in `resources/ocvector/` directory. If so, this step may not be needed.

---

## Phase 2: Integration

### Indexer Modifications and Flow

`index_folders(root_folder, force)`:
1. **Build metadata keymap** via a single method: from `root_folder` collect all file/folder ids from `project_files.folder_map` and `project_files`, run one bulk query on `vector_metadata` for those ids, **return** `Gee.HashMap<int, VectorMetadata>` (key = (int)id, value = full VectorMetadata object; do not copy out description only).
2. **Create** a single `FolderAnalysis` instance for the top folder/tree.
3. **Call** `yield folder_analysis.analyze_children(root_folder, metadata_keymap)`.
4. Traversal is bottom-up by recursion (children first, then `analyze()` on the current folder); no separate depth-sort or flatten-and-loop.

### Updated Indexing Flow

```
index_filebase(folder, recurse, force):
  1. index_folder() → scans all files
  2. index_folders() → analyzes all folders (NEW)
  3. index_project() → analyzes project (Phase 5)
```

### Phase 2 Deliverables

- [ ] Add `Indexer.index_folders()`:
  - One helper: `build_metadata_keymap_from_project(root_folder)` — collects ids from `project_files.folder_map` and `project_files`, runs one bulk query on `vector_metadata`, returns `Gee.HashMap<int, VectorMetadata>` (store full VectorMetadata, do not copy out description)
  - Create one `FolderAnalysis(this.config, this.sql_db)`, call `analyze_children(root_folder, metadata_keymap)`
- [ ] Integrate folder analysis into indexing flow: call `index_folders()` from `index_filebase()` after `index_folder()` (after file scanning)
- [ ] Test folder description generation in full flow (verify child folders included in parent analysis)
- [ ] Verify folder metadata is queryable
- [ ] Test recursive bottom-up order (children completed before parent `analyze()`)

### Phase 2 Code Changes

#### 1. Indexer.vala - New Methods and Flow Updates

**File**: `libocvector/Indexing/Indexer.vala`

##### 1.1. Add Helper: Build Metadata Keymap from Project

Single private helper: collects all file/folder ids from the project's map/array, runs one bulk query, returns the keymap. Add after `index_folder()` (around line 396):

```vala
/**
 * Builds an id-indexed map of existing vector metadata from the project's folders and files.
 * Collects all file_id/folder id values from root_folder.project_files.folder_map and
 * root_folder.project_files, runs one bulk query on vector_metadata for those ids
 * (element_type IN ('file','folder')), returns Gee.HashMap<int, VectorMetadata> (key = (int)file_id,
 * value = full VectorMetadata object; do not copy out description only).
 *
 * @param root_folder The project folder (must have project_files populated)
 * @return Map from (int)file_id to VectorMetadata
 */
private async Gee.HashMap<int, VectorMetadata> build_metadata_keymap_from_project(OLLMfiles.Folder root_folder) throws GLib.Error
{
	var result = new Gee.HashMap<int, VectorMetadata>();
	string[] ids = {};
	ids += root_folder.id.to_string();
	foreach (var folder in root_folder.project_files.folder_map.values) {
		ids += folder.id.to_string();
	}
	foreach (var pf in root_folder.project_files) {
		ids += pf.file.id.to_string();
	}
	if (ids.length == 0) {
		return result;
	}
	var rows = new Gee.ArrayList<VectorMetadata>();
	yield VectorMetadata.query(this.sql_db).select_async(
		"WHERE file_id IN (" + string.joinv(",", ids) + ") AND element_type IN ('file','folder')",
		rows
	);
	foreach (var m in rows) {
		result.set((int)m.file_id, m);
	}
	return result;
}
```

##### 1.2. Add index_folders() Method

Add new method that builds keymap from project, creates one `FolderAnalysis`, and calls `analyze_children`:

```vala
/**
 * Analyzes all folders under the root using recursive bottom-up traversal.
 *
 * Builds metadata keymap from project (one method: collect ids + bulk query), creates
 * a single FolderAnalysis instance, then calls analyze_children(root_folder, metadata_keymap).
 * Children are completed before the parent is analyzed; the keymap is updated as each folder is done.
 *
 * @param root_folder The project folder to start analysis from (must have project_files populated)
 * @param force If true, re-analyze folders even if they already have descriptions (keymap is still pre-filled from DB)
 * @return Number of folders analyzed
 */
private async int index_folders(OLLMfiles.Folder root_folder, bool force = false) throws GLib.Error
{
	GLib.debug("Building metadata keymap from project_files");
	var metadata_keymap = yield this.build_metadata_keymap_from_project(root_folder);
	GLib.debug("Created FolderAnalysis for top folder, analyzing children recursively");
	var folder_analysis = new FolderAnalysis(this.config, this.sql_db);
	var count = yield folder_analysis.analyze_children(root_folder, metadata_keymap);
	GLib.debug("Completed: %d folders analyzed", count);
	return count;
}
```

**Note**: If `force` is to be respected, `FolderAnalysis.analyze_children` / `analyze` can take a `force` flag and skip re-analyzing when `!force && metadata_keymap.has_key((int)folder.id) && metadata_keymap.get((int)folder.id).description != ""`.

##### 1.3. Update index_filebase() Method

Update `index_filebase()` method (around line 409) to call `index_folders()` after `index_folder()`:

```vala
public async int index_filebase(OLLMfiles.FileBase filebase, bool recurse = false, bool force = false) throws GLib.Error
{
	// FileBase API (libocfiles): points_to is nullable for non-aliases; follow alias when set
	if (filebase.is_alias && filebase.points_to != null) {
		filebase = filebase.points_to;
	}
	
	if (filebase is OLLMfiles.File) {
		var file = (OLLMfiles.File)filebase;
		this.progress(1, 1, file.path, false);
		if (yield this.index_file(file, force)) {
			this.progress(1, 1, file.path, true);
			return 1;
		}
		return 0;
	}
	
	if (filebase is OLLMfiles.Folder) {
		var folder = (OLLMfiles.Folder)filebase;
		
		// Step 1: Index all files in the folder
		var files_indexed = yield this.index_folder(folder, recurse, force);
		
		// Step 2: Analyze all folders (bottom-up traversal)
		GLib.debug("Indexing complete: %d files indexed, %d folders analyzed",
		           files_indexed, yield this.index_folders(folder, force));
		
		return files_indexed;
	}
	
	throw new GLib.IOError.INVALID_ARGUMENT("FileBase is not a file or folder: " + filebase.path);
}
```

### 4. Build System Updates

**File**: `libocvector/meson.build`

Add the new `FolderAnalysis.vala` file to the `ocvector_src` list (around line 64, after `DocumentationAnalysis.vala`):

```meson
'Indexing/DocumentationAnalysis.vala',  # Documentation analysis layer
'Indexing/FolderAnalysis.vala',  # Folder analysis layer
'Indexing/DocumentationVectorBuilder.vala',  # Documentation vector generation and FAISS storage
```

### 5. Resource File Registration

**File**: `resources/gresources.xml`

Add the new folder prompt template to the resource file (if not already auto-included):

```xml
<file>ocvector/folder-prompt.txt</file>
```

**Note**: Check if the build system automatically includes all files in `resources/ocvector/` directory. If so, this step may not be needed.

### 6. Database Schema

**Note**: No schema changes needed. The existing `vector_metadata` table already supports:
- `element_type = 'folder'` (text field)
- `file_id` (references folder's FileBase.id)
- `start_line = 0`, `end_line = 0` (for folders)
- `vector_id = 0` (folders are not vectorized)
- `description` (stores folder description)
- `ast_path = ''` (empty for folders)

## Testing Checklist

### Phase 1

- [ ] Verify folder prompt template loads correctly
- [ ] Test `FolderAnalysis.analyze_children()` with folder containing files only (with pre-filled keymap)
- [ ] Test `FolderAnalysis.analyze_children()` with folder containing subfolders only
- [ ] Test `FolderAnalysis.analyze_children()` with folder containing both files and subfolders
- [ ] Test `FolderAnalysis.analyze_children()` with empty folder
- [ ] Verify child folder descriptions are included in parent folder analysis (via metadata keymap)
- [ ] Test recursive bottom-up traversal (children completed before parent `analyze()`)
- [ ] Test folder metadata is stored correctly in `vector_metadata` table from `FolderAnalysis.analyze()`

### Phase 2

- [ ] Test id-indexed keymap: pre-filled from bulk query, updated as folders are analyzed
- [ ] Verify folder metadata is queryable via SQL queries
- [ ] Test integration with `index_filebase()` flow
- [ ] Verify folder analysis works with `force=true` (re-analysis)
- [ ] Test with large folder hierarchies (performance)

## Related Plans

- 2.20-codebase-scanner-improvements.md - Parent plan
- 2.20.5-project-level-summaries.md - Project analysis (depends on folder summaries)
- 2.10-codebase-search-tool.md - Existing codebase search infrastructure
