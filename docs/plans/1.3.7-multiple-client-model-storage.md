# 1.3.7. Multiple Client Model Storage

## Overview

Create an `ConnectionModels` class (similar to `ProjectFiles`) that manages the list of available models from all configured connections. This class will be responsible for loading models from connections and can be used directly by dropdowns in the UI and configuration dialogs.

**Note**: This is different from the existing `AvailableModels` class which loads models from a cache/JSON file. This new class loads models directly from configured connections.

**Ownership**: `ConnectionModels` should be owned by `History.Manager` and accessed through it. Components that need to use it should get it from the history manager.

## Status

✅ **Phase 1 Complete** - ConnectionModels class created and integrated.
✅ **Phase 2 Complete** - ConnectionModels integrated with Window and History Manager.
✅ **Phase 3 Complete** - ConnectionModels integrated with ChatInput.
❌ **Phase 4 Not Done** - Integration with SettingsDialog.Rows.Model widget - needs proper implementation using ListModel signals instead of copying data.
❌ **Phase 5 Not Done** - Integration with ModelsPage - needs proper implementation using ListModel signals instead of copying data.
✅ **Phase 6 Complete** - ModelConfigDialog does not exist, no integration needed.

## Phase Checklist

### Phase 1: Create ConnectionModels Class ✅
- [x] Create `libollmchat/Settings/ConnectionModels.vala` class
- [x] Implement ListModel interface
- [x] Implement progressive refresh logic
- [x] Implement nested HashMap storage (`HashMap<connection_url, HashMap<model_name, ModelUsage>>`)
- [x] Add display methods to `libollmchat/Settings/ModelUsage.vala` (`display_name()`, `display_name_with_size()`)
- [x] Add `model_obj` field to `ModelUsage` to store `Response.Model` directly
- [ ] **Note**: Display methods (`display_markup()`) need sorting out later - removed from Response.Model, needs proper implementation
- [ ] **Note**: Connection filtering and sorting moved to UI layer (libollmchatgtk) - removed GTK-4 dependency from libollmchat

### Phase 2: Integration with Window and History Manager ✅
- [x] Add `connection_models` property to `libollmchat/History/Manager.vala`
- [x] Create ConnectionModels instance in History.Manager constructor
- [x] Update `ollmchat/Window.vala` to call `connection_models.refresh()` after connection validation

### Phase 3: Integration with ChatInput ✅
- [x] Replace `model_store` in `libollmchatgtk/ChatInput.vala` with ConnectionModels
- [x] Update model dropdown to use ConnectionModels ListModel
- [x] Use Response.Model objects from `ModelUsage.model_obj` for ChatInput display

### Phase 4: Integration with SettingsDialog.Rows.Model Widget
- [ ] Update `ollmchat/SettingsDialog/Rows/Model.vala` to use ConnectionModels with connection filter

**What this class does:**
The `Model` widget is a reusable settings row widget that creates a `Gtk.DropDown` for selecting a model from a specific connection. It's used in multiple places:
- **ModelUsage widget** (`SettingsDialog/Rows/ModelUsage.vala`): When editing a `ModelUsage` object, this widget is used for the `model` property. It needs to show models filtered by the selected connection (from the `connection` property in the same `ModelUsage`).
- **ToolRow widget** (`SettingsDialog/Rows/ToolRow.vala`): Tool configurations that have a `model` property use this widget to select which model the tool should use.

**Current implementation:**
The widget currently has partial ConnectionModels integration but may be copying data or not using ListModel signals properly. It creates:
- A `ModelUsageFilter` to filter models by connection URL
- A `FilterListModel` wrapping ConnectionModels
- A `SortedList` for sorted display
- A `ModelUsageFactory` for rendering model names in the dropdown

**How ConnectionModels will be used:**
1. **Get ConnectionModels instance**: Access `connection_models` from `dialog.parent.history_manager.connection_models` (already done in constructor).
2. **Create filtered ListModel**: When `load_models(connection_url, current_model)` is called:
   - Create a `ModelUsageFilter` with the connection URL
   - Wrap ConnectionModels with `Gtk.FilterListModel` using the filter
   - Create a `SortedList` with `ModelUsageSort` for sorted display
   - Set the `SortedList` as the dropdown's model (no copying - use ListModel directly)
3. **Automatic UI updates**: `Gtk.DropDown` automatically listens to the `items-changed` signal from its `model` (the `SortedList`). When models are added/removed/updated, the dropdown UI updates automatically - **no manual signal connection needed for basic updates**.
4. **Handle initial selection**: Use ConnectionModels' `find_model(connection_url, model_name)` method and `SortedList.find_position()` to set the selected model:
   - Call `connection_models.find_model(connection_url, current_model)` to get the `ModelUsage` object
   - Call `sorted_models.find_position(model_usage)` to get the position in the filtered/sorted ListModel
   - Set `dropdown.selected = sorted_models.find_position(model_usage)`
   - **How it works**: `SortedList.find_position()` uses the equality function (derived from the sorter: `sorter.compare(a, b) == Gtk.Ordering.EQUAL`) to find the position via `ArrayList.index_of()`. The equality function is automatically derived from the sorter passed to the constructor, so items are considered equal when the sorter returns `Gtk.Ordering.EQUAL`.
5. **Extract model name**: In `apply_property()`, get the selected `ModelUsage` from the ListModel using `sorted_models.get_item_typed(dropdown.selected)` and extract the `model` property (model name string) to save to config.

**Key points:**
- **No data copying**: Use the filtered/sorted ListModel directly - never copy ModelUsage objects into local arrays or lists.
- **No iteration**: Use `ConnectionModels.find_model(connection_url, model_name)` for O(1) lookup instead of iterating through the ListModel.
- **Automatic UI updates**: `Gtk.DropDown` automatically updates when its ListModel emits `items-changed` - no manual signal connection needed for the dropdown UI itself.
- **Connection filtering**: The filter ensures only models from the specified connection are shown.
- **Factory for display**: Use `ModelUsageFactory` to render model names in the dropdown (accesses `ModelUsage.model_obj` or uses `display_name()` method).

**Coding standards to follow:**
When implementing this phase, follow the coding standards in `.cursor/rules/CODING_STANDARDS.md`:

- **Temporary Variables**: Avoid single-use temporary variables. If a variable is only used once, inline it directly. Avoid temporary variables that are just pointers to object properties. Access the property directly instead.

- **Reducing Nesting**: Avoid nested code by using early returns, break/continue statements, and avoiding else clauses when possible. Put shorter code in if statements and return/continue if feasible.
- **Avoiding Nullable Types**: If possible, avoid using nullable types. Instead, create an object with a checkable value (like an `active` property defaulting to `false`) to indicate whether the object is in use.
- **Null Checks**: Avoid null checks unless there is an absolutely valid reason why an object will be null. Null checks tend to hide bugs. Avoid nullable parameters (`Type?`) at all costs. Design your APIs to not require nullable parameters.


### Phase 5: Integration with ModelsPage
- [ ] Update `ollmchat/SettingsDialog/ModelsPage.vala` to use ConnectionModels

**What this class does:**
The `ModelsPage` is the main "Models" tab in the settings dialog. It displays all available models from all configured connections, grouped by connection with section headers. For each model, it shows:
- Model name and details (from `Response.Model` object)
- Connection name (as section header)
- Expandable row with model-specific options configuration
- Search/filter functionality

Users can:
- View all models from all connections in one place
- Configure model-specific options (temperature, context size, etc.)
- See which connection each model belongs to
- Search/filter models by name

**Current implementation:**
The page currently:
- Has a reference to `ConnectionModels` from history manager
- Connects to `items_changed` signal to refresh when models change
- In `render_models()`, it calls `connection_models.refresh()` then **copies all ModelUsage objects into HashMaps** grouped by connection
- Iterates through the copied data to create/update `ModelRow` widgets
- This copying approach defeats the purpose of using ConnectionModels as a ListModel

**How ConnectionModels will be used:**
1. **Get ConnectionModels instance**: Already has `connection_models` from `dialog.parent.history_manager.connection_models` (already done in constructor).
2. **Connect to ConnectionModels.items_changed**: Already connected to refresh the page when ConnectionModels changes (already done). This triggers a full refresh when the underlying ConnectionModels changes.
3. **Create filtered/sorted ListModels per connection**: Instead of copying data, create and store filtered/sorted ListModels for each connection:
   - For each working connection in `config.connections`:
     - Create a `ModelUsageFilter` for that connection URL
     - Create a `FilterListModel` wrapping ConnectionModels with the filter
     - Create a `SortedList` with `ModelUsageSort` for sorted display
     - Store the `SortedList` in a `HashMap<string, SortedList>` keyed by connection URL
     - **Connect to the `SortedList.items_changed` signal to update UI incrementally** (this is required - see below)
4. **Manual UI updates required**: Unlike `Gtk.DropDown` which updates automatically, `ModelsPage` manually creates `ModelRow` widgets and adds them to a `Gtk.Box`. The UI does **NOT** update automatically. We must:
   - **Connect to each connection's `SortedList.items_changed` signal** to detect changes
   - When `items_changed(position, removed, added)` is emitted, use the signal parameters directly:
     - **Items added**: Use `get_item_typed(position)` through `get_item_typed(position + added - 1)` to get the added `ModelUsage` objects. Create new `ModelRow` widgets for each and insert them at the correct position in the `boxed_list` (accounting for section headers).
     - **Items removed**: The `removed` parameter tells us how many items were removed starting at `position`. Remove the corresponding `ModelRow` widgets from `boxed_list` and from the `model_rows` HashMap using the composite key `"%s#%s".printf(connection_url, model_usage.model)`.
     - **Items changed**: If items are updated in place, use `get_item_typed(position)` to get the updated `ModelUsage` and update the corresponding `ModelRow` widget.
   - **No iteration needed**: Use the `position, removed, added` parameters from `items_changed` signal directly - don't iterate through the entire ListModel.
5. **Initial render**: On first load or full refresh, use `get_n_items()` and `get_item_typed(i)` for each connection's `SortedList` to create initial `ModelRow` widgets. This is acceptable for initial render only - subsequent updates use `items_changed` signal parameters.
6. **Section headers**: Create/update section header widgets for each connection as needed. These are static and don't need to respond to `items_changed` signals.
7. **Lookup existing widgets**: Use `ConnectionModels.find_model(connection_url, model_name)` to get the `ModelUsage` object, then use the composite key `"%s#%s".printf(connection_url, model_usage.model)` to look up existing `ModelRow` widgets in the `model_rows` HashMap - no iteration needed.

**Key points:**
- **No data copying**: Never copy ModelUsage objects into HashMaps or ArrayLists. Use the filtered/sorted ListModels directly.
- **No iteration for updates**: Use `items_changed(position, removed, added)` signal parameters directly to update only the affected widgets. Don't iterate through the ListModel to find what changed.
- **Use lookup methods**: Use `ConnectionModels.find_model(connection_url, model_name)` for O(1) lookup instead of iterating to find models.
- **Manual UI updates required**: Unlike widgets that bind to ListModel (like `Gtk.DropDown`), `ModelsPage` manually creates widgets, so we **must** connect to `items_changed` signals and manually create/remove/update `ModelRow` widgets.
- **Incremental updates**: Use `items_changed(position, removed, added)` parameters to update only the affected widgets, not the entire page.
- **Per-connection ListModels**: Create one filtered/sorted ListModel per connection and store them for reuse.
- **Initial render only**: Iteration with `get_n_items()` and `get_item_typed()` is acceptable only for the initial render. All subsequent updates must use `items_changed` signal parameters.

### Phase 6: ModelConfigDialog (Not Applicable)
- [x] **File does not exist** - `ollmchat/SettingsDialog/ModelConfigDialog.vala` is not in the codebase. No integration needed.

## Related Plans

- **1.3** - Configuration Overview
- **1.3.1** - Configuration Classes
- **1.3.2** - Configuration Interface
- **1.4** - Client Configuration Setup

## Implementation Details

### ConnectionModels Class

Similar to `ProjectFiles`, this class should:

- **Implement ListModel interface**: Can be used directly by dropdowns as a list store
- **Store model references**: Use `ModelUsage` objects to store references to models (connection, model name, options)
- **Store Response.Model objects**: Also store the actual `Response.Model` objects for UI display (ChatInput needs these)
- **Internal storage**: Use `Gee.ArrayList` for the list and `Gee.HashMap` for quick lookups
- **Load all models**: Responsible for loading models from all configured connections (currently done in `ModelsPage` and `Model` widget)
- **Direct access**: Direct access to `items` ArrayList (no need for Traversable/Iterable interfaces)
- **Progressive updates**: When refreshing, add or remove missing models instead of clearing and reloading everything
- **Filtering**: Support filtering by connection URL
- **Sorting**: Provide default sorter that sorts by model family name (extracts family name from prefixed model names)
- **Display methods**: Provide methods to render model names for display in lists (factories will call these, no binding needed)

### Class Structure

```vala
public class ConnectionModels : Object, GLib.ListModel
{
    // Config2 instance (set via constructor)
    public Config2 config { get; construct; }
    
    // Backing store: ArrayList containing ModelUsage objects
    // Direct access to items (no need for Traversable/Iterable)
    public Gee.ArrayList<ModelUsage> items { get; private set; }
    
    // Internal hashmap for quick lookup (connection_url => HashMap<model_name, ModelUsage>)
    private Gee.HashMap<string, Gee.HashMap<string, ModelUsage>> connection_map { get; private set; }
    
    // Constructor
    public ConnectionModels(Config2 config)
    
    // Refresh models from all working connections (progressive update - adds/removes missing models)
    // Only processes connections where is_working = true
    public async void refresh()
    
    // Note: Connection filtering and sorting moved to UI layer (libollmchatgtk)
    // Use ModelUsageFilter and ModelUsageSort classes instead
    
    // ListModel interface methods
    public Type get_item_type() { return typeof(ModelUsage); }
    public uint get_n_items()
    public Object? get_item(uint position)
    
    // ListStore-compatible methods
    public void append(ModelUsage item)
    public void remove(ModelUsage item)
    public void remove_all()
    public bool contains(ModelUsage item)
}
```

### Responsibilities

This class will be responsible for:

1. **Loading models**: Fetch models from all working connections via `refresh()` using the Config2 instance from constructor (replaces current logic in `ModelsPage.render_models()` and `Model.load_models()`)
2. **Connection filtering**: Only processes connections where `is_working = true`, ignores non-working connections
3. **Progressive updates**: When `refresh()` is called, add new models and remove missing ones instead of clearing and reloading
4. **Model storage**: Store model references using `ModelUsage` objects
5. **Filtering**: Provide connection filter via `connection_filter()` that returns a `Gtk.Filter` for use with `Gtk.FilterListModel`
6. **Sorting**: Provide default sorter via `default_sorter()` that extracts family name from prefixed model names (e.g., "user/llama3" -> "llama3")
7. **UI integration**: Can be used directly by dropdowns as a `ListModel` (replaces current `Gtk.StringList` usage)
8. **Chat input**: Used by `ChatInput` model dropdown at the bottom of the window
9. **Configuration dialogs**: Used by `ModelConfigDialog` and other configuration dialogs for model selection

**Note**: Display methods (`display_name()`, `display_name_with_size()`, `display_markup()`) should be added to the `ModelUsage` class, not ConnectionModels. Factories can call these methods directly on ModelUsage objects.

## Implementation Phases

### Phase 1: Create ConnectionModels Class

**Files to Create:**
- `libollmchat/Settings/ConnectionModels.vala` - ConnectionModels class (similar to ProjectFiles pattern)

**Files to Modify:**
- `libollmchat/Settings/ModelUsage.vala` - Add display methods (`display_name()`, `display_name_with_size()`, `display_markup()`)

**Tasks:**
- Implement ConnectionModels class with ListModel interface
- Implement progressive refresh logic
- Implement connection filtering and sorting
- Add display methods to ModelUsage class

### Phase 2: Integration with Window and History Manager

**Files to Modify:**
- `libollmchat/History/Manager.vala` - Add `ConnectionModels` as a property, create it in constructor
- `ollmchat/Window.vala` - After connection validation at startup (version checks), call `connection_models.refresh()` to load all model data

**Tasks:**
- Add `connection_models` property to History.Manager
- Create ConnectionModels instance in History.Manager constructor
- Call `refresh()` from Window after connection validation completes

### Phase 3: Integration with ChatInput

**Files to Modify:**
- `libollmchatgtk/ChatInput.vala` - Use ConnectionModels from history manager for the model dropdown at the bottom (replaces current `model_store`)

**Tasks:**
- Replace current `model_store` with ConnectionModels from history manager
- Update model dropdown to use ConnectionModels ListModel
- Use Response.Model objects from `ModelUsage.model_obj` for ChatInput display

### Phase 4: Integration with SettingsDialog.Rows.Model Widget

**Files to Modify:**
- `ollmchat/SettingsDialog/Rows/Model.vala` - Use ConnectionModels from history manager with connection filter instead of loading models directly

**Tasks:**
- Replace direct model loading in Model widget with ConnectionModels filtered by connection
- Use filtered/sorted ListModel directly (no copying)
- Connect to ListModel `items_changed` signal for incremental updates
- Use `ModelUsageFactory` for rendering model names in dropdown

**Implementation Details:**
See Phase 4 section above for detailed explanation of what this class does and how ConnectionModels will be used.

### Phase 5: Integration with ModelsPage

**Files to Modify:**
- `ollmchat/SettingsDialog/ModelsPage.vala` - Use ConnectionModels from history manager instead of managing models directly

**Tasks:**
- Replace model management in ModelsPage with ConnectionModels
- Create filtered/sorted ListModels per connection (store in HashMap)
- Connect to ListModel `items_changed` signals for incremental UI updates
- Use ListModels directly - never copy ModelUsage objects into local data structures

**Implementation Details:**
See Phase 5 section above for detailed explanation of what this class does and how ConnectionModels will be used.

### Phase 6: ModelConfigDialog (Not Applicable)

**Files to Modify:**
- None - `ollmchat/SettingsDialog/ModelConfigDialog.vala` does not exist in the codebase

### Implementation Notes

- Review how `ProjectFiles` implements `ListModel` interface
- Constructor takes `Config2` object - no need to pass it to `refresh()` method
- **Avoid null checks**: Do not add null checks unless there is an absolutely valid reason why an object will be null. Null checks tend to hide bugs, which is why they're not put in the codebase. Only add null checks when explicitly required by the design.
- **Ownership**: `ConnectionModels` should be created and owned by `History.Manager`
- `History.Manager` should have a public property `connection_models` that exposes the ConnectionModels instance
- Components access ConnectionModels via `history_manager.connection_models` instead of creating their own instances
- **Startup sequence**: 
  - Window tests version on all connections at startup to verify they're working
  - After connection validation is complete, Window should call `connection_models.refresh()` to load all model data
- **Connection status**: `refresh()` should only process connections where `connection.is_working = true`, ignoring non-working connections
- **Connection observation**: The refresh logic should check `is_working` status for each connection before attempting to fetch models
- Direct access to `items` ArrayList (no Traversable/Iterable interfaces needed)
- Models will be stored as `ModelUsage` objects (connection, model name, options)
- `Response.Model` objects are stored in `ModelUsage.model_obj` property for UI components that need full model details (like ChatInput)
- When loading models, create ModelUsage and set `model_obj` property to the Response.Model object
- Access Response.Model objects directly via `ModelUsage.model_obj` property
- **Progressive updates**: When `refresh()` is called:
  - Only process connections where `connection.is_working = true`
  - Skip connections that are not working (don't attempt to fetch models from them)
  - Compare fetched models with existing models in the store
  - Add new models that don't exist
  - Remove models from connections that are no longer working or available
  - Don't clear and reload everything
- **Filtering**: Use `OLLMchatGtk.List.ModelUsageFilter` class to filter by connection URL:
  ```vala
  var filter = new OLLMchatGtk.List.ModelUsageFilter(connection_url);
  var filtered = new Gtk.FilterListModel(connection_models, filter);
  ```
- **Sorting**: Use `OLLMchatGtk.List.ModelUsageSort` class which extracts family name from model names:
  - Split by "/" and use the second part if present (e.g., "user/llama3" -> "llama3")
  - Otherwise use the full name
  - Sort case-insensitively by family name
- **Display methods**: Added to `ModelUsage` class:
  - `display_name()` - Returns just the model name
  - `display_name_with_size()` - Returns "model_name (size)" format (uses `model_obj.name_with_size` if available)
  - Access Response.Model via `ModelUsage.model_obj` property (stored when models are loaded)
  - Factories can access `model_obj` directly or use display methods on ModelUsage objects
- The class should handle loading models asynchronously from multiple connections
- Dropdowns can directly bind to this class as a `ListModel` or use filtered/sorted versions
- Consider caching model lists per connection to avoid repeated API calls
- This replaces the current model loading logic in:
  - `ModelsPage.render_models()` 
  - `Model.load_models()`
  - `ChatInput.update_models()` and `ChatInput.setup_model_dropdown()`

