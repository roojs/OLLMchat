# 1.23.17 Template changes

**Note:** Do not add sentences to this plan unless specifically asked — only bullet points or nested bullet points.

**Coding standards:** Follow `.cursor/rules/CODING_STANDARDS.md`.

---

## Overview

- Template formatting, fill behaviour, and PromptTemplate API.
- **Dependencies:** 1.23.11, 1.23.14 (Runner / send_async, user_request, headers), 1.23.16 (anchor keys). **Consolidates** all template-change references from 1.23.2, 1.23.11, 1.23.12, 1.23.13, 1.23.14; other plans point here for template API, fill behaviour, and block formatting.

**Status:** PLAN — Implementation not started.

---

## 1. New formatting for blocks

- **Not supported.** Block-format constants (BLOCK_FENCE_DEFAULT / BLOCK_FENCE_ALT) and fence-picking helper are out of scope for this plan.

---

## 2. Header + body → markdown header + wrapped body

- **Method** that turns a (header, body) pair into markdown: header line plus body wrapped (e.g. in a fenced block or indented).
- **Name:** **header(string heading, string body)**. Instance method (not static). Location: Task/Details or shared helper used by Task/Details/Runner. Used when building content for template placeholders (e.g. reference content, section content).
- Signature and behaviour: returns `"## Heading\n\n```\nbody\n```\n"` or equivalent; document fence/indent choice.
- Reference: 1.23.14 (Runner.headers(anchor).to_markdown_with_content(); Block.contents(); reference block format).

**Proposed code — instance method (e.g. on PromptTemplate or helper used by Details):**

```vala
/**
 * Returns a markdown heading line plus body in a fenced block.
 *
 * Format: {{{"## " + heading + "\n\n" + fence + "\n" + body + "\n" + fence}}}.
 * Uses {{{~~~}}} when body contains line-start {{{```}}} to avoid breaking the fence; otherwise {{{```}}}.
 *
 * @param heading heading text (e.g. GFM anchor)
 * @param body body text to wrap
 * @return the concatenated string
 */
public string header(string heading, string body)
{
	var fence = body.index_of("\n```") >= 0 ? "~~~~" : "```";
	return "## " + heading.strip() + "\n\n" + fence + "\n" + body + "\n" + fence + "\n";
}
```

- Call from Details when building reference block or section content for template placeholders (e.g. runner or template instance).

---

## 3. fill() stores rendered template

- When we call **fill()** (and **system_fill()**), store the rendered result on the template instance.
- **Property names:** **filled_user**, **filled_system** (strings; set after fill() and system_fill() respectively).
- Purpose: so callers or later steps can reuse the last rendered template without re-filling (e.g. for user_request, logging, or debugging).

**Proposed code — OLLMcoder.Skill.PromptTemplate:**

```vala
public string filled_user { get; private set; default = ""; }
public string filled_system { get; private set; default = ""; }

public new string fill(...)
{
	var result = base.fill(...);
	this.filled_user = result;
	return result;
}

public new string system_fill(...)
{
	var result = base.system_fill(...);
	this.filled_system = result;
	return result;
}
```

---

## 3b. system_to_document / user_to_document — parsed markdown from rendered content

- **system_to_document()** — Returns the markdown-parsed version of **filled_system**. **user_to_document()** — Returns the markdown-parsed version of **filled_user**. Both return **Markdown.Document.Document** (libocmarkdown). Call after system_fill() / fill() so the returned document reflects the filled message.
- **Use the existing libocmarkdown API**: there is no `Document.from_markdown(string)`; documents are built via **Markdown.Document.Render**: create a `Render`, call **parse(string)**, then use **render.document**.

**Proposed code — OLLMcoder.Skill.PromptTemplate:**

```vala
public Markdown.Document.Document system_to_document()
{
	var render = new Markdown.Document.Render();
	render.parse(this.filled_system);
	return render.document;
}

public Markdown.Document.Document user_to_document()
{
	var render = new Markdown.Document.Render();
	render.parse(this.filled_user);
	return render.document;
}
```

---

## 4. PromptTemplate: static template(filename) — cache template, clear filled, return cached

- **Static method** **template(string filename)**: if template for that filename is not in the cache, create it (new PromptTemplate(filename)), load(), store in cache. Store the **template as cached** (one cache: filename → PromptTemplate instance). **No separate system/user caches**; no helper function. When returning: **call load() on the cached template** (so it is up to date; we will introduce user template etc. eventually), then **clear filled_user and filled_system**, then return that same cached instance.
- Callers pass the filename (e.g. `"task_creation_initial.md"`). Assume template files exist.

**Proposed code — OLLMcoder.Skill.PromptTemplate:**

```vala
private static Gee.HashMap<string, PromptTemplate> cache = new Gee.HashMap<string, PromptTemplate>();

/** Returns cached template for filename; creates and loads if not cached. Always calls load() on the template before returning (for future user template etc.), then clears filled_user and filled_system. */
public static PromptTemplate template(string filename) throws GLib.Error
{
	if (!cache.has_key(filename)) {
		var t = new PromptTemplate(filename);
		cache.set(filename, t);
	}
	var t = cache.get(filename);
	t.load();
	t.filled_user = "";
	t.filled_system = "";
	return t;
}
```

- One cache (template instance per filename). Always load() before return so the instance is up to date; then clear filled values. No ensure_cached helper.

---

## 5. Optional sections in fill ({tag/start}, {tag/end}) — from 1.23.12

- **Extension of fill only:** Support **{tag/start}** and **{tag/end}** inside the same fill() / system_fill() loop. No map, no separate helper. For each key/value from varargs: if template contains **{key/start}** and **{key/end}**, then if value is "" remove that whole span (including markers); else replace **{key}** with value in that span and remove the two markers. Otherwise do normal **result = result.replace("{" + key + "}", value)**.
- **When {tag} is "" (empty):** Remove the section and both tags from the output. **When non-empty:** Replace **{tag}** in the section with the value and drop the start/end tags.
- Document so prompt authors can use optional sections (e.g. {previous_output/start} … {previous_output/end} in task_refinement).

**Proposed code — full fill() method.** Use the word **"DEFAULT"** as the sentinel (pass as value to mean "keep content, remove markers only"). For each key: if simple **{key}** exists, replace and continue. If value == "DEFAULT", do `result.replace("{key/start}", "").replace("{key/end}", "")` and continue (no position extraction). Otherwise extract idx/end_idx and replace whole section with value. Method shape and break style match existing `libollmchat/Prompt/Template.vala`. Value already checked for null before use. Coding standards: control-structure braces inline, body on next line; use continue to avoid else.

```vala
/**
 * Fills the user template with varargs key-value pairs.
 *
 * Call with alternating key and value strings, e.g. {{{fill("key1", value1, "key2", value2)}}}.
 * The caller does not need to pass null at the end; Vala terminates varargs with null automatically.
 *
 * For each key/value pair in order:
 *  * If the template contains simple ''{key}'', replace every occurrence with value and continue.
 *  * If value is the literal string "DEFAULT", remove the markers ''{key/start}'' and ''{key/end}'' from the result (content between them is kept); then continue.
 *  * Otherwise, if the template contains ''{key/start}'' and ''{key/end}'', replace the whole span (markers and content) with value.
 *  * If none of the above apply, do nothing for this pair.
 *
 * @return the filled template string
 */
public string fill(...)
{
	var result = this.user_template;
	var args = va_list();
	while (true) {
		unowned string? key = args.arg<string?>();
		if (key == null) {
			break;
		}
		unowned string? value = args.arg<string?>();
		if (value == null) {
			break;
		}

		if (result.index_of("{" + key + "}") >= 0) {
			result = result.replace("{" + key + "}", value);
			continue;
		}

		if (value == "DEFAULT") {
			result = result.replace("{" + key + "/start}", "").replace("{" + key + "/end}", "");
			continue;
		}

		var idx = result.index_of("{" + key + "/start}");
		var end_idx = (idx >= 0) ? result.index_of("{" + key + "/end}", idx) : -1;
		if (idx < 0 || end_idx < 0) {
			continue;
		}
		var section_end = end_idx + ("{" + key + "/end}").length;
		result = result.substring(0, idx) + value + result.substring(section_end);
	}
	return result;
}
```

Apply the same loop body in **system_fill()** (only `var result = this.system_message;` differs).

---

## 6. Resource location: resource:/// only (no file support) — from 1.23.14

- **Current update:** Disable file support for skill prompt loading; use **only resource:///**. Template load uses resource URI only (e.g. `resource:///skill-prompts/task_creation_initial.md`). No filesystem path or `file://` for skill templates.
- **Add skill-prompts to the build:** They must be registered in **resources/gresources.xml** and included in the **meson.build** that compiles resources. Without this, resource:/// URIs for skill-prompts will not resolve.
  - **resources/gresources.xml:** Add a `<gresource prefix="/skill-prompts">` block and list each template file (e.g. `task_creation_initial.md`, `task_refinement.md`, `task_post_completion.md`, `task_execution.md`) as `<file>` entries.
  - **meson.build** (the one that calls `gnome.compile_resources` for ollmchat-resources): Add `'../resources/skill-prompts'` (or the path where the files live) to the `source_dir` list so the compiler can find the files referenced in gresources.xml.
- **PromptTemplate (or OLLMcoder.Skill.PromptTemplate):** Constructor sets `source = "resource:///"` and `base_dir` to the resource path segment (e.g. `"skill-prompts"`) so load() resolves `resource:///skill-prompts/<filename>`. No file existence check for filesystem; only resource URI. If the base Template currently supports both file and resource, restrict skill templates to resource-only (e.g. subclass or branch that never uses file://).

*(Design context — split system/user is unchanged from base:)*

- **Split system/user:** Content **before first `---`** = system message, **after** = user message. Fill placeholders in each part separately (system_fill, fill). load() already in base: reads content, splits on first "---", sets system_message and user_template.
- **Placeholders:** Per 1.23.3–1.23.6 (e.g. system **{skill_catalog}**; user **{environment}**, **{project_description}**, **{current_file}**, **{user_prompt}**, **{previous_proposal}**, **{previous_proposal_issues}**; refinement **{skill_input_requirements}**, task reference block, etc.).

**Proposed code — resource-only (no file support):**

```vala
// Skill-prompts loaded only via resource:/// (no filesystem).
private const string SKILL_PROMPTS_PREFIX = "skill-prompts";

public PromptTemplate(string filename)
{
	base(filename);
	this.source = "resource:///";
	this.base_dir = SKILL_PROMPTS_PREFIX;
}
```

- load() in base uses `this.source + GLib.Path.build_filename(this.base_dir, this.filename)` → `resource:///skill-prompts/<filename>`. Ensure exists()/load() do not use file:// for this subclass.

**Proposed build changes — add skill-prompts to resources:**

In **resources/gresources.xml**, add a gresource block (e.g. before the closing `</gresources>`):

```xml
  <gresource prefix="/skill-prompts">
    <file>task_creation_initial.md</file>
    <file>task_refinement.md</file>
    <file>task_post_completion.md</file>
    <file>task_execution.md</file>
  </gresource>
```

In **libollmchat/meson.build**, add `'../resources/skill-prompts'` to the `source_dir` list of the `gnome.compile_resources` call for `ollmchat-resources` (so the listed files are found under `resources/skill-prompts/`).

---

## 7. Template file conventions — from 1.23.2 / 1.23.3–1.23.6

- Prompt files live in **resources/skill-prompts**: `task_creation_initial.md`, `task_refinement.md`, `task_post_completion.md`, `task_execution.md`.
- **No annotations below the divider:** In prompt-creation plans, content below `---` is exact prompt content only; placeholder meanings and annotations go above. Template code does not parse annotations — it just fills placeholders.

**Proposed code — no code change; enforce by convention and doc. Optional: list of known filenames used by template():**

```vala
// Call sites use these filenames; assume they exist in SKILL_PROMPTS_DIR.
// send_async: "task_creation_initial.md"
// Details (refine): "task_refinement.md"
// Details (post_evaluate): "task_post_completion.md"
// Details (executor): "task_execution.md"
```

---

## References

- 1.23.11 (parent); 1.23.14 (Runner, send_async, user_request, headers, fill); 1.23.16 (anchor keys, Block.contents()); 1.23.12 (optional sections, prompt refinements); 1.23.2 (conventions); 1.23.3–1.23.6 (formats, placeholder names per prompt).
