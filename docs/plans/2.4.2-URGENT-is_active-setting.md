# 2.4.2 URGENT - is_active Setting Issue

## Status: PLANNING

## Summary

**User's Observation**: When a tool request receives a 'done' message, the session's `is_active` flag appears to be set to `false`, preventing the session from sending data to the UI.

**Root Cause Found**: 
- ‚ùå **NOT `is_active`** - that's only set during session switching (correct behavior)
- ‚úÖ **IS `is_running`** - when tool reply is sent via `send_append()`, `is_running` is NOT set to `true`
- This makes the session appear "not running" even though it's still processing the LLM response after tool execution

**Investigation Findings**:
- ‚úÖ `is_active` is ONLY set in `SessionBase.activate()` (line 278) and `SessionBase.deactivate()` (line 297)
- ‚úÖ These methods are ONLY called from `Manager.switch_to_session()` during session switching
- ‚úÖ No incorrect assignments found in tool request handlers
- ‚ùå **BUG FOUND**: When `send_append()` is called (tool reply), `is_running` is never set to `true`
- ‚ùå `Chat.send()` (called by `send_append()`) does NOT call `Session.send()` which sets `is_running = true`

**Key Distinction**:
- `is_active`: Which session is visible in UI (user selection) - should NOT change when tool completes ‚úÖ
- `is_running`: Whether session is processing a request (streaming state) - SHOULD be set to `true` when tool reply continues conversation ‚ùå

**Stop/Send Button**: Controlled by `is_running`, NOT `is_active` ‚úÖ

## Problem Statement

When a tool request is created and receives a 'done' message, the session's `is_active` flag is being set to `false`, which prevents the session from sending data to the UI. This is incorrect behavior - `is_active` should only be set to `false` when the session is actually switched out (deactivated) by the user, not when a tool completes.

Additionally, we need to understand:
1. What exactly does `is_active` do and who uses it?
2. What causes the stop/send button to flip? Is it `is_active` or `is_running`?
3. When should `is_active` be set to `false` vs `true`?

## Current Understanding

### What is `is_active`?

**Definition**: `is_active` is a boolean property on `SessionBase` that indicates whether this session is the currently active session in the UI.

**Location**: `libollmchat/History/SessionBase.vala` line 42
```vala
public bool is_active { get; protected set; default = false; }
```

**Purpose**: Prevents inactive sessions from sending data to the UI. When a session is not active, it should not update the UI with messages or streaming chunks.

**Who Uses It**:

1. **SessionBase.add_message()** (line 368):
   - Only relays messages to Manager if `this.is_active == true`
   - Prevents inactive sessions from updating UI

2. **Session.on_message_created()** (line 139):
   - Only relays messages to Manager if `this.is_active == true`
   - Prevents inactive sessions from updating UI

3. **Session.handle_stream_chunk()** (line 228):
   - Only relays streaming chunks to Manager if `this.is_active == true`
   - If inactive, increments `unread_count` instead
   - Prevents inactive sessions from updating UI

4. **Window.vala** (line 489):
   - Checks `if (!this.is_active)` - but this appears to be for FileBase, not Session

**When is it Set**:

1. **Set to `true`**: 
   - `SessionBase.activate()` (line 278) - when session becomes active in UI
   - Called when user switches to this session

2. **Set to `false`**:
   - `SessionBase.deactivate()` (line 297) - when session is no longer active
   - Called when user switches away from this session

### What is `is_running`?

**Definition**: `is_running` is a boolean property on `SessionBase` that indicates whether the session is currently processing a request (streaming or waiting for response).

**Location**: `libollmchat/History/SessionBase.vala` line 43
```vala
public bool is_running { get; protected set; default = false; }
```

**Purpose**: Indicates whether the session is actively processing a request. Used by UI to show/hide spinner and control stop/send button.

**Who Uses It**:

1. **ChatInput.set_streaming()** (line 192):
   - Called with `session.is_running` to control button label (Send vs Stop)
   - Controls input field editability

2. **ChatWidget.on_session_activated()** (line 278):
   - Sets streaming state based on `session.is_running`
   - Updates button when switching to a session

3. **ChatWidget.on_stream_chunk_handler()** (line 404):
   - Checks `if (!this.manager.session.is_running)` to prevent processing chunks after request completes

4. **HistoryBrowser** (line 255-257):
   - Binds `is_running` to spinner visibility and spinning state

**When is it Set**:

1. **Set to `true`**:
   - `Session.send()` (line 655) - when user sends a message

2. **Set to `false`**:
   - `Session.finalize_streaming()` (line 272) - when response is done
   - `SessionBase.add_message()` (line 359) - when "done" message is received
   - `Session.cancel_current_request()` (line 502) - when user clicks stop

### The Problem: Tool Request "done" Handler

**User's Observation**: When a tool request is created, it has a 'done' handler that causes the session to flag `is_active = false`.

**Investigation Needed**:

1. **Where is the 'done' handler?**
   - Tool requests listen for "done" messages via `on_message_created()` callback
   - EditMode Request: `liboctools/EditMode/Request.vala` line 399
   - This handler processes the "done" message but should NOT affect `is_active`

2. **What happens when "done" is received?**
   - `Session.finalize_streaming()` creates a "done" message (line 256)
   - Adds it to `session.messages` (line 258)
   - Relays to Manager via `manager.message_added()` (line 260)
   - This triggers `SessionBase.add_message()` which sets `is_running = false` (line 359)
   - But `is_active` should NOT be affected

3. **Is `is_active` actually being set to false?**
   - Need to search for all places where `is_active = false` is set
   - Should only be in `SessionBase.deactivate()`
   - If it's being set elsewhere, that's the bug

### Stop/Send Button Behavior

**Current Implementation**:
- Button state is controlled by `ChatInput.set_streaming(bool streaming)` (line 192)
- Called with `session.is_running` (ChatWidget line 278)
- NOT controlled by `is_active`

**Conclusion**: The stop/send button flip is caused by `is_running`, NOT `is_active`.

## Investigation Tasks

### Task 1: Search for All `is_active = false` Assignments ‚úÖ COMPLETE

**Goal**: Find all places where `is_active` is set to `false` to identify if there's an incorrect assignment.

**Results**:
1. **SessionBase.is_active assignments** (CORRECT):
   - `libollmchat/History/SessionBase.vala` line 278: `this.is_active = true;` (in `activate()`)
   - `libollmchat/History/SessionBase.vala` line 297: `this.is_active = false;` (in `deactivate()`)
   - ‚úÖ These are the ONLY places where Session `is_active` is set

2. **Other `is_active` assignments** (NOT Session-related):
   - `libocfiles/ProjectManager.vala` - FileBase/Project `is_active` (different property)
   - `libocfiles/FileBase.vala` - FileBase `is_active` (different property)
   - These are for file/project activation, not session activation

3. **activate()/deactivate() calls**:
   - `libollmchat/History/Manager.vala` line 156: `this.session.activate()` (when creating new session)
   - `libollmchat/History/Manager.vala` line 215: `this.session.deactivate()` (when switching away)
   - `libollmchat/History/Manager.vala` line 231: `loaded_session.activate()` (when switching to session)
   - ‚úÖ All calls are in session switching logic, which is correct

**Conclusion**: No incorrect assignments found. `is_active` is only set in `activate()`/`deactivate()` methods, and these are only called during session switching.

**Next Step**: Need to verify if session switching is accidentally triggered when tool completes.

### Task 2: Trace Tool Request "done" Message Flow

**Goal**: Understand exactly what happens when a tool request receives a "done" message.

**Steps**:
1. Trace the flow from `Session.finalize_streaming()` creating "done" message
2. Follow `manager.message_added()` signal emission
3. Check if any handler calls `session.deactivate()` or sets `is_active = false`
4. Verify tool request `on_message_created()` doesn't affect `is_active`

**Flow to Trace**:
```
Session.finalize_streaming() 
  ‚Üí creates "done" message
  ‚Üí session.messages.add(done_msg)
  ‚Üí manager.message_added(done_msg, this)
    ‚Üí ChatWidget.on_message_created()?
    ‚Üí Tool Request.on_message_created()?
      ‚Üí Does this set is_active = false? (SHOULD NOT)
```

### Task 3: Verify Session Switching Logic ‚úÖ PARTIAL

**Goal**: Ensure `is_active` is only changed when user actually switches sessions.

**Results**:
1. **activate() calls**:
   - `Manager.vala` line 156: `this.session.activate()` - when creating new session
   - `Manager.vala` line 231: `loaded_session.activate()` - when switching to loaded session
   - ‚úÖ Both are in `switch_to_session()` method - correct

2. **deactivate() calls**:
   - `Manager.vala` line 215: `this.session.deactivate()` - when switching away from current session
   - ‚úÖ Called in `switch_to_session()` before activating new session - correct

3. **Need to verify**: Does `switch_to_session()` get called when tool completes?
   - Check if tool reply path calls `Manager.switch_to_session()`
   - Check if any signal handler triggers session switching

**Files to Check**:
- `libollmchat/History/Manager.vala` - `switch_to_session()` method (lines 200-240)
- `libollmchat/Call/Chat.vala` - `send_append()` method (does it trigger session switching?)
- `liboctools/EditMode/Request.vala` - `reply_with_errors()` method (does it affect session?)

### Task 4: Check if Tool Reply Affects Session State ‚úÖ FOUND THE ISSUE!

**Goal**: Verify that sending a tool reply doesn't accidentally deactivate the session.

**Results**:

1. **Tool Reply Flow**:
   - `Request.reply_with_errors()` calls `agent.chat().send_append()` (line 524)
   - `Chat.send_append()` calls `Chat.send()` (line 436)
   - `Chat.send()` sends directly via HTTP API - **does NOT call `Session.send()`**
   - ‚ùå **BUG**: `is_running` is never set to `true` when tool reply is sent!

2. **The Problem**:
   - When "done" message is received, `is_running` is set to `false` (SessionBase.add_message line 359)
   - When tool reply is sent via `send_append()`, it doesn't go through `Session.send()`
   - `Session.send()` is the only place that sets `is_running = true` (line 655)
   - So `is_running` stays `false` even though the session is still processing (waiting for LLM response)

3. **Why User Sees `is_active` Issue**:
   - User may be confusing `is_running` with `is_active`
   - OR: UI code checking `is_running == false` and incorrectly affecting UI state
   - OR: Button state (controlled by `is_running`) makes it appear session is inactive

**The Fix**:
- When `send_append()` is called (from tool reply), we need to set `is_running = true`
- This should happen in `Session.send()` OR we need to ensure `is_running` is set when tool reply continues

**Files to Check**:
- `liboctools/EditMode/Request.vala` - `reply_with_errors()` method
- `libollmchat/Call/Chat.vala` - `send_append()` method  
- `libollmchat/History/Session.vala` - `send()` method (sets `is_running = true`)
- `libollmchat/Agent/Base.vala` - `send_async()` method (calls `Chat.send()`)

## Root Cause Found! üéØ

**The Real Issue**: When tool reply is sent via `send_append()`, `is_running` is NOT set to `true`, so the session appears "not running" even though it's still processing the LLM response.

**Flow**:
1. Tool receives "done" message ‚Üí `is_running = false` (correct)
2. Tool sends reply via `send_append()` ‚Üí calls `Chat.send()` directly
3. `Chat.send()` does NOT call `Session.send()` ‚Üí `is_running` stays `false` ‚ùå
4. UI sees `is_running == false` ‚Üí button shows "Send" instead of "Stop"
5. User thinks session is inactive (but it's actually still processing)

**The Fix**: Set `is_running = true` when tool reply continues the conversation.

## Potential Solutions

### Solution 1: Set `is_running = true` in Agent.send_async() when Chat.send() is called

**Location**: `libollmchat/Agent/Base.vala` - `send_async()` method (line 276)

**Fix**: Before calling `this.chat_call.send()`, set `this.session.is_running = true`

```vala
public virtual async void send_async(Message message, GLib.Cancellable? cancellable = null) throws GLib.Error
{
    // ... existing code to build messages ...
    
    // Set running state to true when sending (for both initial sends and tool continuation)
    this.session.is_running = true;
    GLib.debug("Agent.send_async: Setting is_running=true for session %s", this.session.fid);
    
    // Send full message array using new send() method
    var response = yield this.chat_call.send(messages, cancellable);
    
    // ... rest of method ...
}
```

**Why This Works**:
- `send_async()` is called for both initial user messages AND tool continuation replies
- Setting `is_running = true` here ensures it's set for both cases
- This is the right place because it's the agent's responsibility to manage session state

### Solution 2: Set `is_running = true` in Chat.send() when agent is set

**Location**: `libollmchat/Call/Chat.vala` - `send()` method (line 449)

**Fix**: Check if `this.agent != null` and set `this.agent.session.is_running = true`

**Note**: This is less ideal because Chat shouldn't directly modify Session state - that's Agent's responsibility.

### Solution 3: Fix Incorrect `is_active` Assignment (if found)

**If we find**: Code that incorrectly sets `is_active = false` when tool completes

**Fix**: Remove the incorrect assignment. `is_active` should only be set in `activate()`/`deactivate()`.

**Location**: Depends on investigation results

### Solution 2: Ensure Tool Reply Doesn't Deactivate Session

**If we find**: Tool reply path accidentally calls `deactivate()`

**Fix**: Remove the `deactivate()` call from tool reply path.

**Location**: Likely in `Request.reply_with_errors()` or `Chat.send_append()`

### Solution 3: Clarify `is_active` vs `is_running` Usage

**If we find**: Code confusing `is_active` with `is_running`

**Fix**: 
- Use `is_running` for request state (streaming, processing)
- Use `is_active` only for session selection state (which session is visible)
- Update any incorrect usage

### Solution 4: Add Debug Logging

**Temporary fix**: Add debug logging to track when `is_active` changes

**Implementation**:
```vala
// In SessionBase.activate()
GLib.debug("SessionBase.activate: Setting is_active=true for session %s", this.fid);
this.is_active = true;

// In SessionBase.deactivate()
GLib.debug("SessionBase.deactivate: Setting is_active=false for session %s", this.fid);
this.is_active = false;
```

**Also add property notification**:
```vala
// In SessionBase
public bool is_active { 
    get { return _is_active; }
    protected set {
        if (_is_active != value) {
            GLib.debug("SessionBase.is_active: Changed from %s to %s for session %s", 
                _is_active.to_string(), value.to_string(), this.fid);
            _is_active = value;
            notify_property("is_active");
        }
    }
}
private bool _is_active = false;
```

## Implementation Plan

### Phase 1: Investigation (URGENT)

1. **Search for all `is_active` assignments**
   - Use grep to find all `is_active =` assignments
   - Document each location and verify correctness
   - Identify any incorrect assignments

2. **Trace "done" message flow**
   - Add temporary debug logging to track message flow
   - Verify no code sets `is_active = false` in this path
   - Document the complete flow

3. **Verify session switching logic**
   - Check all calls to `activate()` and `deactivate()`
   - Ensure they're only called during session switching
   - Document the session switching flow

### Phase 2: Fix (URGENT)

1. **Remove incorrect assignments**
   - Fix any code that incorrectly sets `is_active`
   - Ensure tool completion doesn't affect `is_active`

2. **Add property notification**
   - Convert `is_active` to use property notification
   - Add debug logging to track changes
   - This will help identify future issues

3. **Test**
   - Test tool execution with active session
   - Verify `is_active` remains `true` after tool completes
   - Verify stop/send button works correctly
   - Verify UI updates continue after tool completion

### Phase 3: Documentation

1. **Document `is_active` purpose**
   - Add comments explaining when it should be set
   - Document the difference between `is_active` and `is_running`
   - Add examples of correct usage

2. **Update related plans**
   - Update plan 2.4.1 if related
   - Document any findings in this plan

## Testing Checklist

- [ ] Tool execution doesn't change `is_active` from `true` to `false`
- [ ] Stop/send button state is controlled by `is_running`, not `is_active`
- [ ] Session switching correctly sets `is_active` (old session false, new session true)
- [ ] Inactive sessions don't update UI (messages, streaming chunks)
- [ ] Active session continues to update UI after tool completion
- [ ] Tool reply sends correctly without affecting session state

## Related Issues

- **2.4.1**: Fix CodeEdit After Refactor - Related tool execution issue
- **1.2.12**: Switch History Session Live - Related to `is_running` usage
- **1.2.7.18**: ChatView Append Complete Assistant Message - Related to `is_active` checks

## Notes

- `is_active` and `is_running` are separate concerns:
  - `is_active`: Which session is visible in the UI (user selection)
  - `is_running`: Whether the session is processing a request (streaming state)
- Tool completion should NOT affect `is_active`
- Tool completion SHOULD affect `is_running` (set to false when done)
- The stop/send button is controlled by `is_running`, not `is_active`
