# 2.6.1.3. Basic Overlay Support (String Copying)

## Overview

Implement overlay filesystem support to isolate writes during command execution. Files are copied from overlay to live system using simple string/file copying based on Monitor information.

**Note**: This phase designs the Overlay class for the eventual integrated system (Phase 4/5). The overlay will be integrated with Bubble in Phase 4, so this phase targets the final architecture where overlay is actually used by Bubble. This code will not be used with Phase 2 code - it's designed for the complete integrated workflow.

## Status

â³ **PLANNING** - Design phase.

## Prerequisites

- Phase 1 (2.6.1.1) must be completed
- Phase 2 (2.6.1.2) must be completed
- See main plan: `2.6.1-code-exec-improvements.md` for overlay architecture details

## Goals

1. Create `Overlay` class for overlay filesystem management
2. Implement overlay creation and mounting
3. Integrate Monitor with overlay upper directory
4. Copy files from overlay to live system after execution (string copying)

## Implementation Details

### Files to Create

- `liboctools/RunCommand/Overlay.vala` - Overlay filesystem creation and management

### Files to Modify

- `liboctools/RunCommand/Request.vala` - Integrate Overlay class
- `liboctools/meson.build` - Add `RunCommand/Overlay.vala` to `octools_src` list (after `RunCommand/Monitor.vala`)
- `docs/meson.build` - Add `RunCommand/Overlay.vala` to valadoc source list (after `RunCommand/Monitor.vala`)

**Note**: Don't forget to add `RunCommand/Overlay.vala` to both:
- The regular meson.build (`liboctools/meson.build`) in the `octools_src` list
- The valadoc meson.build (`docs/meson.build`) in the `valadoc_docs` input files list

Both should be added after `RunCommand/Monitor.vala` to maintain proper file ordering.

### Overlay Class Design

#### Class: `OLLMtools.RunCommand.Overlay`

**Namespace**: `OLLMtools.RunCommand`

**Inheritance**: `GLib.Object`

**Purpose**: Manages overlay filesystem creation, mounting, and cleanup for isolating writes during command execution.

#### Properties

```vala
/**
 * Project folder object (is_project = true) - the main project directory.
 */
private OLLMfiles.Folder project { get; private set; }

/**
 * Map of path -> Folder objects for project roots that need write access.
 * 
 * Contains all directories that need write access, as determined by project.build_roots().
 * Same structure as Bubble.roots: HashMap mapping paths to Folder objects.
 * Key: Project root path (e.g., "/home/alan/project")
 * Value: Folder object (typically the project Folder reference)
 */
private Gee.HashMap<string, OLLMfiles.Folder> roots { get; private set; }

/**
 * Base directory for overlay filesystem.
 * Path: ~/.cache/ollmchat/{overlay-datetime}/
 * Example: /home/alan/.cache/ollmchat/overlay-20250115-143022/
 * 
 * Derived paths:
 * - Upper directory: {overlay_dir}/upper/
 * - Work directory: {overlay_dir}/work/
 * - Mount point: {overlay_dir}/merged/
 */
private string overlay_dir { get; private set; }

/**
 * HashMap mapping overlay subdirectory names to real project root paths.
 * Key: Subdirectory name (e.g., "overlay1", "overlay2")
 * Value: Real project root path (e.g., "/home/alan/project")
 * Example:
 *   "overlay1" -> "/home/alan/project"
 *   "overlay2" -> "/home/alan/other-project"
 * 
 * Derived from roots HashMap during create().
 */
public Gee.HashMap<string, string> overlay_map { get; private set; }

/**
 * Overlay mount point path.
 * Path: {overlay_dir}/merged/
 * This is the path that should be bind-mounted into bwrap sandbox.
 */
public string mount_point {
    get {
        return GLib.Path.build_filename(overlay_dir, "merged");
    }
}

/**
 * Overlay upper directory path (for Monitor).
 * Path: {overlay_dir}/upper/
 * This is the path that Monitor should monitor for filesystem changes.
 */
public string base_path {
    get {
        return GLib.Path.build_filename(overlay_dir, "upper");
    }
}
```

#### Constructor

```vala
/**
 * Constructor.
 * 
 * Initializes an Overlay instance with the specified project folder.
 * The overlay structure will be created in ~/.cache/ollmchat/{overlay-datetime}/
 * 
 * @param project Project folder object (is_project = true) - the main project directory
 * @throws Error if project is invalid, build_roots() fails, or paths are not absolute
 */
public Overlay(OLLMfiles.Folder project) throws Error
```

**Implementation Details**:
- Store `project` parameter
- Initialize `roots` as empty HashMap
- Call `project.build_roots()` to get list of root folders
- For each folder in build_roots():
  - Add to `roots` HashMap: `roots.set(folder.path, project)` (same as Bubble)
- Generate unique timestamp-based directory name: `overlay-{YYYYMMDD}-{HHMMSS}`
- Set `overlay_dir` to `~/.cache/ollmchat/{overlay-datetime}/`
- Initialize `overlay_map` as empty HashMap (will be populated in create())

#### Methods

##### `create() throws Error`

```vala
/**
 * Create overlay directory structure with subdirectories for each project root.
 * 
 * Creates the following directory structure:
 * - {overlay_dir}/upper/overlay1/ (for first project root)
 * - {overlay_dir}/upper/overlay2/ (for second project root)
 * - {overlay_dir}/upper/overlay3/ (for third project root)
 * - etc.
 * - {overlay_dir}/work/ (work directory for overlayfs)
 * - {overlay_dir}/merged/ (mount point for overlayfs)
 * 
 * Also builds overlay_map HashMap mapping subdirectory names to real project paths.
 * 
 * @throws GLib.IOError if directory creation fails
 */
public void create() throws Error
```

**Implementation Details**:
- Create `overlay_dir` directory (with parents if needed)
- Create `{overlay_dir}/upper/` directory
- Create `{overlay_dir}/work/` directory
- Create `{overlay_dir}/merged/` directory
- Iterate over `roots.entries`:
  ```vala
  int index = 1;
  foreach (var entry in roots.entries) {
      var subdirectory_name = "overlay%d".printf(index);
      var subdirectory_path = GLib.Path.build_filename(overlay_dir, "upper", subdirectory_name);
      // Create subdirectory
      GLib.File.new_for_path(subdirectory_path).make_directory_with_parents(null);
      // Add to overlay_map
      overlay_map.set(subdirectory_name, entry.key);
      index++;
  }
  ```
- Handle errors: Wrap GLib.Error in GLib.IOError.FAILED with descriptive message

##### `mount() throws Error`

```vala
/**
 * Mount overlay filesystem using mount -t overlay.
 * 
 * Mounts the overlay filesystem at mount_point using the following structure:
 * - Lower: Original project directory (read-only)
 * - Upper: Upper directory (writable layer)
 * - Work: Work directory (for overlayfs internal operations)
 * 
 * The mount command format:
 * mount -t overlay overlay -o lowerdir={project.path},upperdir={overlay_dir}/upper,workdir={overlay_dir}/work {overlay_dir}/merged
 * 
 * @throws GLib.IOError if mount fails (e.g., permission denied, invalid arguments)
 */
public void mount() throws Error
```

**Implementation Details**:
- Build paths inline:
  - `lower_dir = project.path`
  - `upper_dir = GLib.Path.build_filename(overlay_dir, "upper")`
  - `work_dir = GLib.Path.build_filename(overlay_dir, "work")`
  - `mount_point = GLib.Path.build_filename(overlay_dir, "merged")`
- Build mount command string:
  - `command = "mount -t overlay overlay -o lowerdir=%s,upperdir=%s,workdir=%s %s".printf(lower_dir, upper_dir, work_dir, mount_point)`
- Execute mount command using `Process.spawn_command_line_sync()`:
  - Use `Process.spawn_command_line_sync(command, out stdout, out stderr, out exit_status)`
  - Check exit status: If non-zero, throw GLib.IOError.FAILED with stderr message
- Handle errors: Wrap Process errors in GLib.IOError.FAILED

##### `unmount() throws Error`

```vala
/**
 * Unmount overlay filesystem using umount.
 * 
 * Unmounts the overlay filesystem at mount_point.
 * 
 * The unmount command format:
 * umount {mount_point}
 * 
 * @throws GLib.IOError if unmount fails (e.g., busy, not mounted)
 */
public void unmount() throws Error
```

**Implementation Details**:
- Build mount point path inline: `mount_point = GLib.Path.build_filename(overlay_dir, "merged")`
- Build unmount command string:
  - `command = "umount %s".printf(mount_point)`
- Execute umount command using `Process.spawn_command_line_sync()`:
  - Use `Process.spawn_command_line_sync(command, out stdout, out stderr, out exit_status)`
  - Check exit status: If non-zero, throw GLib.IOError.FAILED with stderr message
- Handle errors: Wrap Process errors in GLib.IOError.FAILED

##### `cleanup() throws Error`

```vala
/**
 * Clean up overlay directory.
 * 
 * Unmounts the overlay filesystem (if mounted) and removes the overlay
 * directory structure. This should be called after command execution
 * is complete and files have been copied to the live system.
 * 
 * @throws GLib.IOError if unmount or directory removal fails
 */
public void cleanup() throws Error
```

**Implementation Details**:
- Call `unmount()` (may throw Error, but continue cleanup even if it fails)
- Remove overlay directory structure:
  - Use `GLib.File.new_for_path(overlay_dir)` to get File object
  - Use `file.delete()` to remove directory recursively
  - Handle errors: Wrap GLib.Error in GLib.IOError.FAILED

### Overlay Structure

- Create overlay temporary directory in `.cache/ollmchat/{overlay-datetime}/`
- Overlay structure (required by overlayfs):
  - Lower directory: Original project directory (read-only)
  - Upper directory: `.cache/ollmchat/{overlay-datetime}/upper/` (writable layer)
    - **Multiple folder structure**: Upper directory contains subdirectories for each project root:
      - `upper/overlay1/` - Writes for first project root
      - `upper/overlay2/` - Writes for second project root
      - `upper/overlay3/` - Writes for third project root
      - etc.
    - Each subdirectory name (overlay1, overlay2, etc.) maps to a project root path via `overlay_map`
  - Work directory: `.cache/ollmchat/{overlay-datetime}/work/` (required by overlayfs for internal atomic operations)
- Mount overlay filesystem (using `mount -t overlay`) before bwrap execution
- Bind-mount the overlay mount point into bwrap sandbox at project directory location
- **Overlay map**: HashMap mapping subdirectory names to real project paths:
  - `"overlay1" -> "/home/alan/project"`
  - `"overlay2" -> "/home/alan/other-project"`
  - Created from project root folders (from `project.build_roots()`)
  - Each project root gets a unique subdirectory name (overlay1, overlay2, etc.)
  - Used by Monitor to convert overlay paths to real paths
  - Example: File written to `upper/overlay1/src/main.c` maps to `/home/alan/project/src/main.c`

### Integration with Monitor

#### Monitor Setup

- Monitor overlay upper directory using Monitor class from Phase 2
- Pass `base_path` (upper directory path) and `overlay_map` to Monitor constructor
- Monitor converts overlay paths (e.g., `upper/overlay1/src/file.c`) to real paths (e.g., `/home/alan/project/src/file.c`)

**Implementation in Request.execute_tool_async()**:
```vala
// Create Overlay instance
var overlay = new Overlay(project);
overlay.create();
overlay.mount();

// Create Monitor instance
var monitor = new Monitor(
    project_folder: project,
    base_path: overlay.base_path,
    overlay_map: overlay.overlay_map
);

// Start monitoring before command execution
monitor.start();

// Execute command in bwrap (with overlay mount point bind-mounted)
// ... command execution ...

// Stop monitoring after command execution
yield monitor.stop();
```

#### File Copying from Overlay to Live System

After execution: Use Monitor change lists to copy files from overlay to live system.

**Method: `copy_files_from_overlay(Monitor monitor) throws Error`**

```vala
/**
 * Copy files from overlay to live system based on Monitor change lists.
 * 
 * Processes Monitor.added, Monitor.updated, and Monitor.removed HashMaps
 * to copy files from overlay upper directory to project directories.
 * 
 * @param monitor Monitor instance with change lists (has to_overlay_path() method)
 * @throws GLib.IOError if file operations fail
 */
private void copy_files_from_overlay(Monitor monitor) throws Error
```

**Implementation Details**:

1. **For modified files (Monitor.updated)**:
   - Iterate over `monitor.updated.entries`
   - For each entry:
     - Get real path: `entry.key` (already converted by Monitor)
     - Convert real path to overlay path: Use `monitor.to_overlay_path(real_path)` (returns overlay path or null)
     - If overlay path is null, skip file (not in overlay)
     - Check if overlay file exists
     - Copy file from overlay to real path:
       - Read file content: `string content = GLib.FileUtils.get_contents(overlay_path)`
       - Create parent directories: `GLib.File.new_for_path(GLib.Path.get_dirname(real_path)).make_directory_with_parents(null)`
       - Write file content: `GLib.FileUtils.set_contents(real_path, content)`
       - Handle errors: Wrap GLib.Error in GLib.IOError.FAILED

2. **For new files (Monitor.added)**:
   - Iterate over `monitor.added.entries`
   - For each entry:
     - Get real path: `entry.key` (already converted by Monitor)
     - Convert real path to overlay path: Use `monitor.to_overlay_path(real_path)` (returns overlay path or null)
     - If overlay path is null, skip file (not in overlay)
     - Check if overlay file exists
     - Copy file from overlay to real path:
       - Read file content: `string content = GLib.FileUtils.get_contents(overlay_path)`
       - Create parent directories: `GLib.File.new_for_path(GLib.Path.get_dirname(real_path)).make_directory_with_parents(null)`
       - Write file content: `GLib.FileUtils.set_contents(real_path, content)`
       - Handle errors: Wrap GLib.Error in GLib.IOError.FAILED

3. **For deleted files (Monitor.removed)**:
   - Iterate over `monitor.removed.entries`
   - For each entry:
     - Get real path: `entry.key` (already converted by Monitor)
     - Check if real file exists
     - Delete file from real path:
       - Use `GLib.File.new_for_path(real_path).delete()` to remove file
       - Handle directory removal if needed (for deleted directories)

**Note**: Add `to_overlay_path()` method to Monitor class (reverse of `to_real_path()`).

**Method to add to Monitor class: `to_overlay_path(string real_path) : string?`**

```vala
/**
 * Convert real project path to overlay upper directory path.
 * 
 * Reverse of to_real_path(). Finds which overlay subdirectory contains this file
 * and builds the overlay path.
 * 
 * @param real_path Real project path (e.g., "/home/alan/project/src/main.c")
 * @return Overlay path (e.g., "/home/alan/.cache/ollmchat/overlay-.../upper/overlay1/src/main.c") or null if not found
 */
private string? to_overlay_path(string real_path)
```

**Implementation Details**:
- Iterate over `overlay_map.entries`:
  ```vala
  foreach (var entry in overlay_map.entries) {
      if (real_path.has_prefix(entry.value)) {
          // Calculate relative path
          var relative_path = real_path.substring(entry.value.length);
          // Remove leading "/" if present
          if (relative_path.has_prefix("/")) {
              relative_path = relative_path.substring(1);
          }
          // Build overlay path
          return GLib.Path.build_filename(base_path, entry.key, relative_path);
      }
  }
  return null;
  ```

#### Permission Handling

After copying files: Check permissions on all files in Monitor change lists (added, updated, removed).

**Method: `copy_permissions_from_overlay(Monitor monitor) throws Error`**

```vala
/**
 * Copy file permissions from overlay to live system.
 * 
 * Compares permissions between overlay files and real project files.
 * If permissions differ, copies permissions from overlay to real files.
 * 
 * Note: Permission changes are NOT added to Monitor change lists.
 * Note: Permission changes are NOT approved (permissions are copied silently).
 * 
 * @param monitor Monitor instance with change lists (has to_overlay_path() method)
 * @throws GLib.IOError if permission operations fail
 */
private void copy_permissions_from_overlay(Monitor monitor) throws Error
```

**Implementation Details**:
- Collect all files from Monitor change lists:
  - Create HashSet of all file paths from `monitor.added.keys`, `monitor.updated.keys`, and `monitor.removed.keys`
  - Filter to only include files (not directories): Check `GLib.FileUtils.test(path, GLib.FileTest.IS_REGULAR)`
- For each file path:
  - Get overlay path: Use `monitor.to_overlay_path(real_path)` (returns overlay path or null)
  - If overlay path is null, skip (file not in overlay)
  - Get overlay file permissions:
    - Use `GLib.File.new_for_path(overlay_path).query_info(GLib.FileAttribute.UNIX_MODE, ...)`
    - Extract mode: `file_info.get_attribute_uint32(GLib.FileAttribute.UNIX_MODE)`
  - Get real file permissions:
    - Use `GLib.File.new_for_path(real_path).query_info(GLib.FileAttribute.UNIX_MODE, ...)`
    - Extract mode: `file_info.get_attribute_uint32(GLib.FileAttribute.UNIX_MODE)`
  - Compare permissions:
    - If overlay mode != real mode:
      - Set permissions on real file: Use `GLib.File.new_for_path(real_path).set_attribute_uint32(GLib.FileAttribute.UNIX_MODE, overlay_mode, ...)`
      - Handle errors: Wrap in GLib.IOError.FAILED
- Handle errors: Wrap GLib.Error in GLib.IOError.FAILED with descriptive message

### Integration with Request Class

#### Modifications to Request.execute_tool_async()

**Location**: `liboctools/RunCommand/Request.vala`

**Method**: `execute_tool_async() throws Error`

**Changes Required**:

1. **Create Overlay instance before command execution**:
```vala
// Get project folder from ProjectManager via tool
var run_command_tool = (Tool) this.tool;
var project_manager = run_command_tool.project_manager;
if (project_manager == null || project_manager.active_project == null) {
    throw new GLib.IOError.FAILED("No active project available for bubblewrap execution");
}
var project = project_manager.active_project;  // OLLMfiles.Folder

// Create Overlay instance
var overlay = new Overlay(project);
overlay.create();
overlay.mount();
```

2. **Create Monitor instance and start monitoring**:
```vala
// Create Monitor instance with overlay paths
var monitor = new Monitor(
    project_folder: project,
    base_path: overlay.base_path,
    overlay_map: overlay.overlay_map
);

// Start monitoring before command execution
monitor.start();
```

3. **Modify Bubble.exec() to use overlay mount point**:
   - **Note**: This phase does NOT modify Bubble class - overlay integration happens in Phase 4
   - For Phase 3: Overlay is created but NOT yet integrated with Bubble
   - Bubble continues to use direct project directory binds (from Phase 1)
   - Overlay mount point will be bind-mounted into Bubble in Phase 4

4. **Execute command (using existing Bubble.exec() for now)**:
```vala
// Create Bubble instance (still uses direct project directory binds in Phase 3)
var bubble = new Bubble(project, false);

// Execute command - simple string in, string out
var output = yield bubble.exec(this.command);
```

5. **Stop monitoring after command execution**:
```vala
// Stop monitoring after command execution
yield monitor.stop();
```

6. **Copy files from overlay to live system**:
```vala
// Copy files from overlay to live system
this.copy_files_from_overlay(monitor);
```

7. **Copy permissions from overlay to live system**:
```vala
// Copy permissions from overlay to live system
this.copy_permissions_from_overlay(monitor);
```

8. **Cleanup overlay**:
```vala
// Cleanup overlay (unmount and remove directory)
overlay.cleanup();
```

9. **Return output**:
```vala
// Truncate output if needed (same as Subprocess path)
output = this.truncate_output(output, 50);

// Send output as second message via message_created
this.send_ui("txt", "", output);

// Return output to LLM (already formatted with stdout + stderr + exit code)
return output;
```

**Complete Method Structure**:
```vala
private async string execute_tool_async() throws Error
{
    if (this.command == "") {
        throw new GLib.IOError.INVALID_ARGUMENT("Command cannot be empty");
    }
        
    // Check if bubblewrap can be used
    if (!Bubble.can_wrap()) {
        // Running in Flatpak or bwrap not available - use old permission system
        return yield this.execute_with_subprocess();
    }
    
    // Not in Flatpak and bwrap available - use bubblewrap with overlay
    // Get project folder from ProjectManager via tool
    var run_command_tool = (Tool) this.tool;
    var project_manager = run_command_tool.project_manager;
    if (project_manager == null || project_manager.active_project == null) {
        throw new GLib.IOError.FAILED("No active project available for bubblewrap execution");
    }
    var project = project_manager.active_project;  // OLLMfiles.Folder
    
    // Create Overlay instance
    var overlay = new Overlay(project);
    overlay.create();
    overlay.mount();
    
    // Create Monitor instance with overlay paths
    var monitor = new Monitor(
        project_folder: project,
        base_path: overlay.get_base_path(),
        overlay_map: overlay.get_overlay_map()
    );
    
    // Start monitoring before command execution
    monitor.start();
    
    // Create Bubble instance
    // Note: In Phase 4, Bubble will be modified to use overlay mount point instead of direct project directory binds
    // For now, this code is designed for the eventual integrated system where overlay is used
    var bubble = new Bubble(project, false);
    
    // Execute command - simple string in, string out
    var output = yield bubble.exec(this.command);
    
    // Stop monitoring after command execution
    yield monitor.stop();
    
    // Copy files from overlay to live system
    this.copy_files_from_overlay(monitor);
    
    // Copy permissions from overlay to live system
    this.copy_permissions_from_overlay(monitor);
    
    // Cleanup overlay (unmount and remove directory)
    overlay.cleanup();
    
    // Truncate output if needed (same as Subprocess path)
    output = this.truncate_output(output, 50);
    
    // Send output as second message via message_created
    this.send_ui("txt", "", output);
    
    // Return output to LLM (already formatted with stdout + stderr + exit code)
    return output;
}
```

#### New Private Methods in Request Class

Add the following private methods to `Request` class:

1. `copy_files_from_overlay(Monitor monitor) throws Error` - See detailed implementation above
2. `copy_permissions_from_overlay(Monitor monitor) throws Error` - See detailed implementation above

### File Copying Implementation

#### Simple File Copying Strategy

- Use simple file copying (read file content, write to destination)
- Handle directory creation if needed (for new files in new directories)
- No backup support yet - that comes in Phase 5

#### File Copying Algorithm

1. **Read file content**:
   - Use `GLib.FileUtils.get_contents()` to read entire file as string
   - Handles text and binary files (Vala strings can contain binary data)

2. **Create parent directories**:
   - Use `GLib.Path.get_dirname()` to get parent directory path
   - Use `GLib.File.new_for_path().make_directory_with_parents()` to create directories recursively
   - Handles nested directory creation (e.g., `src/subdir/newfile.c`)

3. **Write file content**:
   - Use `GLib.FileUtils.set_contents()` to write file content
   - Overwrites existing files (for modified files)
   - Creates new files (for added files)

4. **Error handling**:
   - Wrap all GLib.Error in GLib.IOError.FAILED with descriptive messages
   - Include file paths in error messages for debugging

#### Limitations in Phase 3

- **No backup support**: Files are copied directly without creating backups
- **No atomic operations**: File copying is not atomic (partial writes possible on failure)
- **No file metadata preservation**: Only file content and permissions are copied (timestamps, ownership, etc. are not preserved)
- **No transaction rollback**: If copying fails partway through, some files may be copied while others are not

## Implementation Tasks

- [ ] Create `Overlay` class for overlay filesystem management
- [ ] Implement overlay creation in `.cache/ollmchat/{overlay-datetime}/`
- [ ] Implement overlay structure (lower, upper, work directories)
- [ ] Create subdirectories in upper directory for each project root (overlay1, overlay2, etc.)
- [ ] Build overlay_map HashMap mapping subdirectory names to real project paths
- [ ] Mount overlay filesystem (using `mount -t overlay`) before bwrap execution
- [ ] Bind-mount the overlay mount point into bwrap sandbox at project directory location
- [ ] Integrate Monitor with overlay upper directory (pass base_path and overlay_map)
- [ ] After execution: Use Monitor info to copy files from overlay to live system
  - [ ] For modified files: Copy from overlay upper directory to project directory (string copying)
  - [ ] For new files: Copy from overlay upper directory to project directory
  - [ ] For deleted files: Remove from project directory
- [ ] After copying files: Check and copy permissions from overlay to real files
  - [ ] Compare permissions between overlay files and real project files for all files in Monitor change lists
  - [ ] If permissions differ, copy permissions from overlay to real files (e.g., chmod +x)
  - [ ] Do NOT add permission changes to Monitor change lists
  - [ ] Do NOT require approval for permission changes
- [ ] Test overlay filesystem creation and cleanup
- [ ] Test file copying from overlay to live system

## Testing

- Test overlay filesystem creation and cleanup
- Test file copying from overlay to live system
- Test with modified files
- Test with new files
- Test with deleted files
- Test with nested directories

## Error Handling

### Overlay Creation Errors

- **Directory creation fails**: Wrap in GLib.IOError.FAILED with message including path
- **Permission denied**: Wrap in GLib.IOError.FAILED with descriptive message
- **Disk full**: Wrap in GLib.IOError.FAILED with descriptive message

### Overlay Mount Errors

- **Mount command fails**: Read stderr from subprocess and include in error message
- **Permission denied (requires root)**: Overlayfs mount may require root privileges - handle gracefully
- **Invalid mount options**: Validate mount options before executing mount command

### Overlay Unmount Errors

- **Unmount command fails**: Read stderr from subprocess and include in error message
- **Device busy**: Overlay may be in use - handle gracefully (may need to retry or force unmount)
- **Not mounted**: umount will fail if not mounted - error will be in stderr

### File Copying Errors

- **Source file not found**: Skip file (log warning) - file may have been deleted after monitoring stopped
- **Destination directory creation fails**: Wrap in GLib.IOError.FAILED with message including path
- **File write fails**: Wrap in GLib.IOError.FAILED with message including source and destination paths
- **Permission denied**: Wrap in GLib.IOError.FAILED with descriptive message

### Permission Copying Errors

- **Overlay file not found**: Skip file (log warning) - file may have been deleted
- **Real file not found**: Skip file (log warning) - file may have been deleted
- **Permission query fails**: Skip file (log warning) - file may not support permission queries
- **Permission set fails**: Wrap in GLib.IOError.FAILED with descriptive message

### Cleanup Errors

- **Unmount fails during cleanup**: Log warning but continue with directory removal
- **Directory removal fails**: Wrap in GLib.IOError.FAILED with message including path
- **Partial cleanup**: If cleanup fails partway through, overlay directory may remain - log warning

## Edge Cases

### Multiple Project Roots

- **Overlay subdirectories**: Each project root gets its own subdirectory in upper directory
- **Path mapping**: Overlay map correctly maps each subdirectory to its project root
- **File copying**: Files from different project roots are copied to correct destinations

### Nested Directories

- **Directory creation**: Parent directories are created recursively when copying files
- **Deep nesting**: Handles deeply nested directory structures (e.g., `src/sub1/sub2/sub3/file.c`)

### Empty Files

- **Zero-length files**: Handled correctly by `GLib.FileUtils.get_contents()` and `set_contents()`
- **Empty directories**: Directories are created even if empty (for new directory structures)

### Symlinks

- **Symlink handling**: Symlinks in overlay are copied as regular files (not as symlinks)
- **Symlink targets**: Symlink targets are resolved during path conversion

### Concurrent Access

- **File modifications during copying**: Files may be modified during copying - no locking mechanism
- **Race conditions**: Monitor may detect changes after command execution completes - handled by async stop()

### Large Files

- **Memory usage**: Large files are read entirely into memory (may cause issues with very large files)
- **Performance**: File copying is synchronous and may be slow for large files

### Special Files

- **Device files**: Not handled (only regular files are copied)
- **Named pipes**: Not handled (only regular files are copied)
- **Sockets**: Not handled (only regular files are copied)

## Implementation Summary

### Class Structure

- **Overlay class**: Manages overlay filesystem lifecycle (create, mount, unmount, cleanup)
- **Properties**: Store overlay paths, mount state, and overlay map
- **Methods**: Create directory structure, mount/unmount filesystem, get paths, cleanup

### Integration Points

- **Request.execute_tool_async()**: Creates Overlay, starts Monitor, executes command, copies files, cleans up
- **Monitor class**: Monitors overlay upper directory for filesystem changes (from Phase 2, already supports overlay_map)
- **Bubble class**: Not modified in Phase 3 (overlay integration happens in Phase 4)
  - **Design target**: This code is designed for Phase 4/5 where Bubble will use overlay mount point
  - **Current state**: Bubble still uses direct project directory binds, but Overlay class is ready for integration

### File Operations

- **File copying**: Simple string-based copying (read content, write content)
- **Directory creation**: Recursive directory creation for new files
- **Permission copying**: Compare and copy file permissions from overlay to live system
- **File deletion**: Remove deleted files from live system

### Workflow

**Design target**: This workflow is designed for Phase 4/5 where overlay is fully integrated with Bubble.

1. Create overlay directory structure
2. Mount overlay filesystem
3. Start Monitor on overlay upper directory
4. Execute command in Bubble (in Phase 4, Bubble will use overlay mount point; Phase 3 designs for this)
5. Stop Monitor
6. Copy files from overlay to live system (modified, added, deleted)
7. Copy permissions from overlay to live system
8. Cleanup overlay (unmount and remove directory)

**Note**: In Phase 3, the overlay is created and the infrastructure is ready, but actual integration with Bubble happens in Phase 4. This phase targets the eventual design where all writes go through the overlay.

## Notes

- **Design target**: This phase designs the Overlay class for the eventual integrated system (Phase 4/5)
- **Not for Phase 2**: This code will not be used with Phase 2 code - it targets the final architecture
- **Integration**: Overlay will be integrated with Bubble in Phase 4 (overlay mount point will be bind-mounted into Bubble)
- **Current state**: In Phase 3, overlay infrastructure is created and ready, but actual Bubble integration happens in Phase 4
- **File copying**: Simple string/file copying - no backup support yet (backup support added in Phase 5)
- **Monitor**: Monitor (from Phase 2) already supports overlay_map and will track changes in overlay upper directory
- **File operations**: Files are copied from overlay to live system after command execution
- **Permissions**: Permissions are copied silently (no approval required)

