# 2.6.1.3. Basic Overlay Support (String Copying)

## Overview

Implement overlay filesystem support to isolate writes during command execution. Files are copied from overlay to live system using simple string/file copying based on Monitor information.

**Note**: This phase designs the Overlay class for the eventual integrated system (Phase 4/5). The overlay will be integrated with Bubble in Phase 4, so this phase targets the final architecture where overlay is actually used by Bubble. This code will not be used with Phase 2 code - it's designed for the complete integrated workflow.

## Status

‚è≥ **PLANNING** - Design phase.

## Prerequisites

- Phase 1 (2.6.1.1) must be completed
- Phase 2 (2.6.1.2) must be completed
- See main plan: `2.6.1-code-exec-improvements.md` for overlay architecture details

## Goals

1. Create `Overlay` class for overlay filesystem management
2. Implement overlay creation and mounting
3. Integrate Monitor with overlay upper directory
4. Copy files from overlay to live system after execution (string copying)

## Implementation Details

### Files to Create

- `liboctools/RunCommand/Overlay.vala` - Overlay filesystem creation and management

### Files to Modify

- `liboctools/RunCommand/Request.vala` - Integrate Overlay class

### Overlay Class Design

#### Class: `OLLMtools.RunCommand.Overlay`

**Namespace**: `OLLMtools.RunCommand`

**Inheritance**: `GLib.Object`

**Purpose**: Manages overlay filesystem creation, mounting, and cleanup for isolating writes during command execution.

#### Properties

```vala
/**
 * Project folder object (is_project = true) - the main project directory.
 */
private OLLMfiles.Folder project { get; private set; }

/**
 * List of project root folders that need write access (from project.build_roots()).
 */
private Gee.ArrayList<OLLMfiles.Folder> root_folders { get; private set; }

/**
 * Base directory for overlay filesystem.
 * Path: ~/.cache/ollmchat/{overlay-datetime}/
 * Example: /home/alan/.cache/ollmchat/overlay-20250115-143022/
 */
private string overlay_base_dir { get; private set; }

/**
 * Lower directory path (read-only source).
 * This is the original project directory path (from first root_folder).
 * Example: /home/alan/project
 */
private string lower_dir { get; private set; }

/**
 * Upper directory path (writable layer).
 * Path: {overlay_base_dir}/upper/
 * Example: /home/alan/.cache/ollmchat/overlay-20250115-143022/upper/
 */
private string upper_dir { get; private set; }

/**
 * Work directory path (required by overlayfs for internal operations).
 * Path: {overlay_base_dir}/work/
 * Example: /home/alan/.cache/ollmchat/overlay-20250115-143022/work/
 */
private string work_dir { get; private set; }

/**
 * Mount point path for the overlay filesystem.
 * Path: {overlay_base_dir}/merged/
 * Example: /home/alan/.cache/ollmchat/overlay-20250115-143022/merged/
 */
private string mount_point { get; private set; }

/**
 * HashMap mapping overlay subdirectory names to real project root paths.
 * Key: Subdirectory name (e.g., "overlay1", "overlay2")
 * Value: Real project root path (e.g., "/home/alan/project")
 * Example:
 *   "overlay1" -> "/home/alan/project"
 *   "overlay2" -> "/home/alan/other-project"
 */
private Gee.HashMap<string, string> overlay_map { get; private set; }

/**
 * Flag indicating if overlay is currently mounted.
 */
private bool is_mounted { get; private set; default = false; }
```

#### Constructor

```vala
/**
 * Constructor.
 * 
 * Initializes an Overlay instance with the specified project folder.
 * The overlay structure will be created in ~/.cache/ollmchat/{overlay-datetime}/
 * 
 * @param project Project folder object (is_project = true) - the main project directory
 * @throws Error if project is invalid, build_roots() fails, or paths are not absolute
 */
public Overlay(OLLMfiles.Folder project) throws Error
```

**Implementation Details**:
- Store `project` parameter
- Call `project.build_roots()` to get list of root folders
- Store root folders in `root_folders`
- Generate unique timestamp-based directory name: `overlay-{YYYYMMDD}-{HHMMSS}`
- Set `overlay_base_dir` to `~/.cache/ollmchat/{overlay-datetime}/`
- Set `lower_dir` to first root folder path (main project directory)
- Set `upper_dir` to `{overlay_base_dir}/upper/`
- Set `work_dir` to `{overlay_base_dir}/work/`
- Set `mount_point` to `{overlay_base_dir}/merged/`
- Initialize `overlay_map` as empty HashMap
- Set `is_mounted` to false

#### Methods

##### `create() throws Error`

```vala
/**
 * Create overlay directory structure with subdirectories for each project root.
 * 
 * Creates the following directory structure:
 * - {overlay_base_dir}/upper/overlay1/ (for first project root)
 * - {overlay_base_dir}/upper/overlay2/ (for second project root)
 * - {overlay_base_dir}/upper/overlay3/ (for third project root)
 * - etc.
 * - {overlay_base_dir}/work/ (work directory for overlayfs)
 * - {overlay_base_dir}/merged/ (mount point for overlayfs)
 * 
 * Also builds overlay_map HashMap mapping subdirectory names to real project paths.
 * 
 * @throws GLib.IOError if directory creation fails
 */
public void create() throws Error
```

**Implementation Details**:
- Create `overlay_base_dir` directory (with parents if needed)
- Create `upper_dir` directory
- Create `work_dir` directory
- Create `mount_point` directory
- Iterate over `root_folders`:
  - Generate subdirectory name: `"overlay" + (index + 1).to_string()` (overlay1, overlay2, etc.)
  - Create subdirectory: `{upper_dir}/{subdirectory_name}/`
  - Add to `overlay_map`: `overlay_map.set(subdirectory_name, folder.path)`
- Handle errors: Wrap GLib.Error in GLib.IOError.FAILED with descriptive message

##### `mount() throws Error`

```vala
/**
 * Mount overlay filesystem using mount -t overlay.
 * 
 * Mounts the overlay filesystem at mount_point using the following structure:
 * - Lower: Original project directory (read-only)
 * - Upper: Upper directory (writable layer)
 * - Work: Work directory (for overlayfs internal operations)
 * 
 * The mount command format:
 * mount -t overlay overlay -o lowerdir={lower_dir},upperdir={upper_dir},workdir={work_dir} {mount_point}
 * 
 * @throws GLib.IOError if mount fails (e.g., permission denied, invalid arguments)
 */
public void mount() throws Error
```

**Implementation Details**:
- Check if already mounted: If `is_mounted == true`, throw GLib.IOError.FAILED("Overlay already mounted")
- Build mount command:
  - Executable: `/bin/mount`
  - Arguments: `["-t", "overlay", "overlay", "-o", "lowerdir={lower_dir},upperdir={upper_dir},workdir={work_dir}", mount_point]`
- Execute mount command using GLib.Subprocess:
  - Use `GLib.SubprocessFlags.STDOUT_PIPE | GLib.SubprocessFlags.STDERR_PIPE`
  - Wait for completion synchronously (use `subprocess.wait()`)
  - Check exit status: If non-zero, read stderr and throw GLib.IOError.FAILED with error message
- Set `is_mounted = true`
- Handle errors: Wrap subprocess errors in GLib.IOError.FAILED

##### `unmount() throws Error`

```vala
/**
 * Unmount overlay filesystem using umount.
 * 
 * Unmounts the overlay filesystem at mount_point.
 * 
 * The unmount command format:
 * umount {mount_point}
 * 
 * @throws GLib.IOError if unmount fails (e.g., busy, not mounted)
 */
public void unmount() throws Error
```

**Implementation Details**:
- Check if mounted: If `is_mounted == false`, return early (no-op)
- Build unmount command:
  - Executable: `/bin/umount`
  - Arguments: `[mount_point]`
- Execute umount command using GLib.Subprocess:
  - Use `GLib.SubprocessFlags.STDOUT_PIPE | GLib.SubprocessFlags.STDERR_PIPE`
  - Wait for completion synchronously (use `subprocess.wait()`)
  - Check exit status: If non-zero, read stderr and throw GLib.IOError.FAILED with error message
- Set `is_mounted = false`
- Handle errors: Wrap subprocess errors in GLib.IOError.FAILED

##### `get_mount_point() : string`

```vala
/**
 * Get overlay mount point path.
 * 
 * Returns the path where the overlay filesystem is mounted.
 * This is the path that should be bind-mounted into bwrap sandbox.
 * 
 * @return Absolute path to overlay mount point
 */
public string get_mount_point()
```

**Implementation Details**:
- Return `mount_point` property

##### `get_base_path() : string`

```vala
/**
 * Get overlay upper directory path (for Monitor).
 * 
 * Returns the path to the upper directory where all writes are stored.
 * This is the path that Monitor should monitor for filesystem changes.
 * 
 * @return Absolute path to overlay upper directory
 */
public string get_base_path()
```

**Implementation Details**:
- Return `upper_dir` property

##### `get_overlay_map() : Gee.HashMap<string, string>`

```vala
/**
 * Get HashMap mapping overlay subdirectory names to real project paths.
 * 
 * Returns a copy of the overlay_map HashMap. The map is used by Monitor
 * to convert overlay paths to real project paths.
 * 
 * Example:
 *   "overlay1" -> "/home/alan/project"
 *   "overlay2" -> "/home/alan/other-project"
 * 
 * @return HashMap mapping subdirectory names to real project root paths
 */
public Gee.HashMap<string, string> get_overlay_map()
```

**Implementation Details**:
- Return a copy of `overlay_map` (create new HashMap and copy entries)

##### `cleanup() throws Error`

```vala
/**
 * Clean up overlay directory.
 * 
 * Unmounts the overlay filesystem (if mounted) and removes the overlay
 * directory structure. This should be called after command execution
 * is complete and files have been copied to the live system.
 * 
 * @throws GLib.IOError if unmount or directory removal fails
 */
public void cleanup() throws Error
```

**Implementation Details**:
- If `is_mounted == true`:
  - Call `unmount()` (may throw Error)
- Remove overlay directory structure:
  - Use `GLib.File.new_for_path(overlay_base_dir)` to get File object
  - Use `file.delete()` to remove directory recursively
  - Handle errors: Wrap GLib.Error in GLib.IOError.FAILED
- Reset `is_mounted = false`

### Overlay Structure

- Create overlay temporary directory in `.cache/ollmchat/{overlay-datetime}/`
- Overlay structure (required by overlayfs):
  - Lower directory: Original project directory (read-only)
  - Upper directory: `.cache/ollmchat/{overlay-datetime}/upper/` (writable layer)
    - **Multiple folder structure**: Upper directory contains subdirectories for each project root:
      - `upper/overlay1/` - Writes for first project root
      - `upper/overlay2/` - Writes for second project root
      - `upper/overlay3/` - Writes for third project root
      - etc.
    - Each subdirectory name (overlay1, overlay2, etc.) maps to a project root path via `overlay_map`
  - Work directory: `.cache/ollmchat/{overlay-datetime}/work/` (required by overlayfs for internal atomic operations)
- Mount overlay filesystem (using `mount -t overlay`) before bwrap execution
- Bind-mount the overlay mount point into bwrap sandbox at project directory location
- **Overlay map**: HashMap mapping subdirectory names to real project paths:
  - `"overlay1" -> "/home/alan/project"`
  - `"overlay2" -> "/home/alan/other-project"`
  - Created from project root folders (from `project.build_roots()`)
  - Each project root gets a unique subdirectory name (overlay1, overlay2, etc.)
  - Used by Monitor to convert overlay paths to real paths
  - Example: File written to `upper/overlay1/src/main.c` maps to `/home/alan/project/src/main.c`

### Integration with Monitor

#### Monitor Setup

- Monitor overlay upper directory using Monitor class from Phase 2
- Pass `base_path` (upper directory path) and `overlay_map` to Monitor constructor
- Monitor converts overlay paths (e.g., `upper/overlay1/src/file.c`) to real paths (e.g., `/home/alan/project/src/file.c`)

**Implementation in Request.execute_tool_async()**:
```vala
// Create Overlay instance
var overlay = new Overlay(project);
overlay.create();
overlay.mount();

// Create Monitor instance
var monitor = new Monitor(
    project_folder: project,
    base_path: overlay.get_base_path(),
    overlay_map: overlay.get_overlay_map()
);

// Start monitoring before command execution
monitor.start();

// Execute command in bwrap (with overlay mount point bind-mounted)
// ... command execution ...

// Stop monitoring after command execution
yield monitor.stop();
```

#### File Copying from Overlay to Live System

After execution: Use Monitor change lists to copy files from overlay to live system.

**Method: `copy_files_from_overlay(Monitor monitor, Overlay overlay) throws Error`**

```vala
/**
 * Copy files from overlay to live system based on Monitor change lists.
 * 
 * Processes Monitor.added, Monitor.updated, and Monitor.removed HashMaps
 * to copy files from overlay upper directory to project directories.
 * 
 * @param monitor Monitor instance with change lists
 * @param overlay Overlay instance with paths and overlay_map
 * @throws GLib.IOError if file operations fail
 */
private void copy_files_from_overlay(Monitor monitor, Overlay overlay) throws Error
```

**Implementation Details**:

1. **For modified files (Monitor.updated)**:
   - Iterate over `monitor.updated.entries`
   - For each entry:
     - Get real path: `entry.key` (already converted by Monitor)
     - Find overlay path: Convert real path back to overlay path using `overlay_map`
       - Find which overlay subdirectory contains this file (match path prefix)
       - Build overlay path: `{upper_dir}/{subdirectory}/{relative_path}`
     - Check if overlay file exists
     - Copy file from overlay to real path:
       - Read file content from overlay path
       - Write file content to real path (overwrites existing file)
       - Create parent directories if needed (use `GLib.File.make_directory_with_parents()`)

2. **For new files (Monitor.added)**:
   - Iterate over `monitor.added.entries`
   - For each entry:
     - Get real path: `entry.key` (already converted by Monitor)
     - Find overlay path: Convert real path back to overlay path using `overlay_map`
     - Check if overlay file exists
     - Copy file from overlay to real path:
       - Read file content from overlay path
       - Write file content to real path
       - Create parent directories if needed

3. **For deleted files (Monitor.removed)**:
   - Iterate over `monitor.removed.entries`
   - For each entry:
     - Get real path: `entry.key` (already converted by Monitor)
     - Check if real file exists
     - Delete file from real path:
       - Use `GLib.File.new_for_path(real_path).delete()` to remove file
       - Handle directory removal if needed (for deleted directories)

**Helper Method: `convert_real_path_to_overlay_path(string real_path, Overlay overlay) : string?`**

```vala
/**
 * Convert real project path to overlay upper directory path.
 * 
 * Finds which overlay subdirectory contains this file and builds the overlay path.
 * 
 * @param real_path Real project path (e.g., "/home/alan/project/src/main.c")
 * @param overlay Overlay instance with overlay_map
 * @return Overlay path (e.g., "/home/alan/.cache/ollmchat/overlay-.../upper/overlay1/src/main.c") or null if not found
 */
private string? convert_real_path_to_overlay_path(string real_path, Overlay overlay)
```

**Implementation Details**:
- Iterate over `overlay.get_overlay_map().entries`
- For each entry:
  - Check if `real_path.has_prefix(entry.value)` (real path starts with project root)
  - If match found:
    - Calculate relative path: `real_path.substring(entry.value.length)` (remove project root prefix)
    - Remove leading "/" from relative path if present
    - Build overlay path: `GLib.Path.build_filename(overlay.get_base_path(), entry.key, relative_path)`
    - Return overlay path
- Return null if no match found

**Helper Method: `copy_file(string source_path, string dest_path) throws Error`**

```vala
/**
 * Copy file from source to destination using simple string/file copying.
 * 
 * Reads file content as string and writes to destination.
 * Creates parent directories if needed.
 * 
 * @param source_path Source file path (overlay path)
 * @param dest_path Destination file path (real project path)
 * @throws GLib.IOError if file operations fail
 */
private void copy_file(string source_path, string dest_path) throws Error
```

**Implementation Details**:
- Read source file:
  - Use `GLib.FileUtils.get_contents(source_path)` to read file content as string
  - Handle errors: Wrap in GLib.IOError.FAILED
- Create parent directories:
  - Get parent directory: `GLib.Path.get_dirname(dest_path)`
  - Use `GLib.File.new_for_path(parent_dir).make_directory_with_parents(null)` to create directories
  - Handle errors: Wrap in GLib.IOError.FAILED
- Write destination file:
  - Use `GLib.FileUtils.set_contents(dest_path, content)` to write file content
  - Handle errors: Wrap in GLib.IOError.FAILED

#### Permission Handling

After copying files: Check permissions on all files in Monitor change lists (added, updated, removed).

**Method: `copy_permissions_from_overlay(Monitor monitor, Overlay overlay) throws Error`**

```vala
/**
 * Copy file permissions from overlay to live system.
 * 
 * Compares permissions between overlay files and real project files.
 * If permissions differ, copies permissions from overlay to real files.
 * 
 * Note: Permission changes are NOT added to Monitor change lists.
 * Note: Permission changes are NOT approved (permissions are copied silently).
 * 
 * @param monitor Monitor instance with change lists
 * @param overlay Overlay instance with paths and overlay_map
 * @throws GLib.IOError if permission operations fail
 */
private void copy_permissions_from_overlay(Monitor monitor, Overlay overlay) throws Error
```

**Implementation Details**:
- Collect all files from Monitor change lists:
  - Create HashSet of all file paths from `monitor.added.keys`, `monitor.updated.keys`, and `monitor.removed.keys`
  - Filter to only include files (not directories): Check `GLib.FileUtils.test(path, GLib.FileTest.IS_REGULAR)`
- For each file path:
  - Get overlay path: Use `convert_real_path_to_overlay_path(real_path, overlay)`
  - If overlay path is null, skip (file not in overlay)
  - Get overlay file permissions:
    - Use `GLib.File.new_for_path(overlay_path).query_info(GLib.FileAttribute.UNIX_MODE, ...)`
    - Extract mode: `file_info.get_attribute_uint32(GLib.FileAttribute.UNIX_MODE)`
  - Get real file permissions:
    - Use `GLib.File.new_for_path(real_path).query_info(GLib.FileAttribute.UNIX_MODE, ...)`
    - Extract mode: `file_info.get_attribute_uint32(GLib.FileAttribute.UNIX_MODE)`
  - Compare permissions:
    - If overlay mode != real mode:
      - Set permissions on real file: Use `GLib.File.new_for_path(real_path).set_attribute_uint32(GLib.FileAttribute.UNIX_MODE, overlay_mode, ...)`
      - Handle errors: Wrap in GLib.IOError.FAILED
- Handle errors: Wrap GLib.Error in GLib.IOError.FAILED with descriptive message

### Integration with Request Class

#### Modifications to Request.execute_tool_async()

**Location**: `liboctools/RunCommand/Request.vala`

**Method**: `execute_tool_async() throws Error`

**Changes Required**:

1. **Create Overlay instance before command execution**:
```vala
// Get project folder from ProjectManager via tool
var run_command_tool = (Tool) this.tool;
var project_manager = run_command_tool.project_manager;
if (project_manager == null || project_manager.active_project == null) {
    throw new GLib.IOError.FAILED("No active project available for bubblewrap execution");
}
var project = project_manager.active_project;  // OLLMfiles.Folder

// Create Overlay instance
var overlay = new Overlay(project);
overlay.create();
overlay.mount();
```

2. **Create Monitor instance and start monitoring**:
```vala
// Create Monitor instance with overlay paths
var monitor = new Monitor(
    project_folder: project,
    base_path: overlay.get_base_path(),
    overlay_map: overlay.get_overlay_map()
);

// Start monitoring before command execution
monitor.start();
```

3. **Modify Bubble.exec() to use overlay mount point**:
   - **Note**: This phase does NOT modify Bubble class - overlay integration happens in Phase 4
   - For Phase 3: Overlay is created but NOT yet integrated with Bubble
   - Bubble continues to use direct project directory binds (from Phase 1)
   - Overlay mount point will be bind-mounted into Bubble in Phase 4

4. **Execute command (using existing Bubble.exec() for now)**:
```vala
// Create Bubble instance (still uses direct project directory binds in Phase 3)
var bubble = new Bubble(project, false);

// Execute command - simple string in, string out
var output = yield bubble.exec(this.command);
```

5. **Stop monitoring after command execution**:
```vala
// Stop monitoring after command execution
yield monitor.stop();
```

6. **Copy files from overlay to live system**:
```vala
// Copy files from overlay to live system
this.copy_files_from_overlay(monitor, overlay);
```

7. **Copy permissions from overlay to live system**:
```vala
// Copy permissions from overlay to live system
this.copy_permissions_from_overlay(monitor, overlay);
```

8. **Cleanup overlay**:
```vala
// Cleanup overlay (unmount and remove directory)
overlay.cleanup();
```

9. **Return output**:
```vala
// Truncate output if needed (same as Subprocess path)
output = this.truncate_output(output, 50);

// Send output as second message via message_created
this.send_ui("txt", "", output);

// Return output to LLM (already formatted with stdout + stderr + exit code)
return output;
```

**Complete Method Structure**:
```vala
private async string execute_tool_async() throws Error
{
    if (this.command == "") {
        throw new GLib.IOError.INVALID_ARGUMENT("Command cannot be empty");
    }
        
    // Check if bubblewrap can be used
    if (!Bubble.can_wrap()) {
        // Running in Flatpak or bwrap not available - use old permission system
        return yield this.execute_with_subprocess();
    }
    
    // Not in Flatpak and bwrap available - use bubblewrap with overlay
    // Get project folder from ProjectManager via tool
    var run_command_tool = (Tool) this.tool;
    var project_manager = run_command_tool.project_manager;
    if (project_manager == null || project_manager.active_project == null) {
        throw new GLib.IOError.FAILED("No active project available for bubblewrap execution");
    }
    var project = project_manager.active_project;  // OLLMfiles.Folder
    
    // Create Overlay instance
    var overlay = new Overlay(project);
    overlay.create();
    overlay.mount();
    
    // Create Monitor instance with overlay paths
    var monitor = new Monitor(
        project_folder: project,
        base_path: overlay.get_base_path(),
        overlay_map: overlay.get_overlay_map()
    );
    
    // Start monitoring before command execution
    monitor.start();
    
    // Create Bubble instance
    // Note: In Phase 4, Bubble will be modified to use overlay mount point instead of direct project directory binds
    // For now, this code is designed for the eventual integrated system where overlay is used
    var bubble = new Bubble(project, false);
    
    // Execute command - simple string in, string out
    var output = yield bubble.exec(this.command);
    
    // Stop monitoring after command execution
    yield monitor.stop();
    
    // Copy files from overlay to live system
    this.copy_files_from_overlay(monitor, overlay);
    
    // Copy permissions from overlay to live system
    this.copy_permissions_from_overlay(monitor, overlay);
    
    // Cleanup overlay (unmount and remove directory)
    overlay.cleanup();
    
    // Truncate output if needed (same as Subprocess path)
    output = this.truncate_output(output, 50);
    
    // Send output as second message via message_created
    this.send_ui("txt", "", output);
    
    // Return output to LLM (already formatted with stdout + stderr + exit code)
    return output;
}
```

#### New Private Methods in Request Class

Add the following private methods to `Request` class:

1. `copy_files_from_overlay(Monitor monitor, Overlay overlay) throws Error` - See detailed implementation above
2. `convert_real_path_to_overlay_path(string real_path, Overlay overlay) : string?` - See detailed implementation above
3. `copy_file(string source_path, string dest_path) throws Error` - See detailed implementation above
4. `copy_permissions_from_overlay(Monitor monitor, Overlay overlay) throws Error` - See detailed implementation above

### File Copying Implementation

#### Simple File Copying Strategy

- Use simple file copying (read file content, write to destination)
- Handle directory creation if needed (for new files in new directories)
- No backup support yet - that comes in Phase 5

#### File Copying Algorithm

1. **Read file content**:
   - Use `GLib.FileUtils.get_contents()` to read entire file as string
   - Handles text and binary files (Vala strings can contain binary data)

2. **Create parent directories**:
   - Use `GLib.Path.get_dirname()` to get parent directory path
   - Use `GLib.File.new_for_path().make_directory_with_parents()` to create directories recursively
   - Handles nested directory creation (e.g., `src/subdir/newfile.c`)

3. **Write file content**:
   - Use `GLib.FileUtils.set_contents()` to write file content
   - Overwrites existing files (for modified files)
   - Creates new files (for added files)

4. **Error handling**:
   - Wrap all GLib.Error in GLib.IOError.FAILED with descriptive messages
   - Include file paths in error messages for debugging

#### Limitations in Phase 3

- **No backup support**: Files are copied directly without creating backups
- **No atomic operations**: File copying is not atomic (partial writes possible on failure)
- **No file metadata preservation**: Only file content and permissions are copied (timestamps, ownership, etc. are not preserved)
- **No transaction rollback**: If copying fails partway through, some files may be copied while others are not

## Implementation Tasks

- [ ] Create `Overlay` class for overlay filesystem management
- [ ] Implement overlay creation in `.cache/ollmchat/{overlay-datetime}/`
- [ ] Implement overlay structure (lower, upper, work directories)
- [ ] Create subdirectories in upper directory for each project root (overlay1, overlay2, etc.)
- [ ] Build overlay_map HashMap mapping subdirectory names to real project paths
- [ ] Mount overlay filesystem (using `mount -t overlay`) before bwrap execution
- [ ] Bind-mount the overlay mount point into bwrap sandbox at project directory location
- [ ] Integrate Monitor with overlay upper directory (pass base_path and overlay_map)
- [ ] After execution: Use Monitor info to copy files from overlay to live system
  - [ ] For modified files: Copy from overlay upper directory to project directory (string copying)
  - [ ] For new files: Copy from overlay upper directory to project directory
  - [ ] For deleted files: Remove from project directory
- [ ] After copying files: Check and copy permissions from overlay to real files
  - [ ] Compare permissions between overlay files and real project files for all files in Monitor change lists
  - [ ] If permissions differ, copy permissions from overlay to real files (e.g., chmod +x)
  - [ ] Do NOT add permission changes to Monitor change lists
  - [ ] Do NOT require approval for permission changes
- [ ] Test overlay filesystem creation and cleanup
- [ ] Test file copying from overlay to live system

## Testing

- Test overlay filesystem creation and cleanup
- Test file copying from overlay to live system
- Test with modified files
- Test with new files
- Test with deleted files
- Test with nested directories

## Error Handling

### Overlay Creation Errors

- **Directory creation fails**: Wrap in GLib.IOError.FAILED with message including path
- **Permission denied**: Wrap in GLib.IOError.FAILED with descriptive message
- **Disk full**: Wrap in GLib.IOError.FAILED with descriptive message

### Overlay Mount Errors

- **Mount command fails**: Read stderr from subprocess and include in error message
- **Permission denied (requires root)**: Overlayfs mount may require root privileges - handle gracefully
- **Overlay already mounted**: Check `is_mounted` flag before mounting, throw error if already mounted
- **Invalid mount options**: Validate mount options before executing mount command

### Overlay Unmount Errors

- **Unmount command fails**: Read stderr from subprocess and include in error message
- **Device busy**: Overlay may be in use - handle gracefully (may need to retry or force unmount)
- **Not mounted**: Check `is_mounted` flag before unmounting, return early if not mounted

### File Copying Errors

- **Source file not found**: Skip file (log warning) - file may have been deleted after monitoring stopped
- **Destination directory creation fails**: Wrap in GLib.IOError.FAILED with message including path
- **File write fails**: Wrap in GLib.IOError.FAILED with message including source and destination paths
- **Permission denied**: Wrap in GLib.IOError.FAILED with descriptive message

### Permission Copying Errors

- **Overlay file not found**: Skip file (log warning) - file may have been deleted
- **Real file not found**: Skip file (log warning) - file may have been deleted
- **Permission query fails**: Skip file (log warning) - file may not support permission queries
- **Permission set fails**: Wrap in GLib.IOError.FAILED with descriptive message

### Cleanup Errors

- **Unmount fails during cleanup**: Log warning but continue with directory removal
- **Directory removal fails**: Wrap in GLib.IOError.FAILED with message including path
- **Partial cleanup**: If cleanup fails partway through, overlay directory may remain - log warning

## Edge Cases

### Multiple Project Roots

- **Overlay subdirectories**: Each project root gets its own subdirectory in upper directory
- **Path mapping**: Overlay map correctly maps each subdirectory to its project root
- **File copying**: Files from different project roots are copied to correct destinations

### Nested Directories

- **Directory creation**: Parent directories are created recursively when copying files
- **Deep nesting**: Handles deeply nested directory structures (e.g., `src/sub1/sub2/sub3/file.c`)

### Empty Files

- **Zero-length files**: Handled correctly by `GLib.FileUtils.get_contents()` and `set_contents()`
- **Empty directories**: Directories are created even if empty (for new directory structures)

### Symlinks

- **Symlink handling**: Symlinks in overlay are copied as regular files (not as symlinks)
- **Symlink targets**: Symlink targets are resolved during path conversion

### Concurrent Access

- **File modifications during copying**: Files may be modified during copying - no locking mechanism
- **Race conditions**: Monitor may detect changes after command execution completes - handled by async stop()

### Large Files

- **Memory usage**: Large files are read entirely into memory (may cause issues with very large files)
- **Performance**: File copying is synchronous and may be slow for large files

### Special Files

- **Device files**: Not handled (only regular files are copied)
- **Named pipes**: Not handled (only regular files are copied)
- **Sockets**: Not handled (only regular files are copied)

## Implementation Summary

### Class Structure

- **Overlay class**: Manages overlay filesystem lifecycle (create, mount, unmount, cleanup)
- **Properties**: Store overlay paths, mount state, and overlay map
- **Methods**: Create directory structure, mount/unmount filesystem, get paths, cleanup

### Integration Points

- **Request.execute_tool_async()**: Creates Overlay, starts Monitor, executes command, copies files, cleans up
- **Monitor class**: Monitors overlay upper directory for filesystem changes (from Phase 2, already supports overlay_map)
- **Bubble class**: Not modified in Phase 3 (overlay integration happens in Phase 4)
  - **Design target**: This code is designed for Phase 4/5 where Bubble will use overlay mount point
  - **Current state**: Bubble still uses direct project directory binds, but Overlay class is ready for integration

### File Operations

- **File copying**: Simple string-based copying (read content, write content)
- **Directory creation**: Recursive directory creation for new files
- **Permission copying**: Compare and copy file permissions from overlay to live system
- **File deletion**: Remove deleted files from live system

### Workflow

1. Create overlay directory structure
2. Mount overlay filesystem
3. Start Monitor on overlay upper directory
4. Execute command in Bubble (still uses direct project directory binds in Phase 3)
5. Stop Monitor
6. Copy files from overlay to live system (modified, added, deleted)
7. Copy permissions from overlay to live system
8. Cleanup overlay (unmount and remove directory)

## Notes

- This phase uses simple string/file copying - no backup support yet
- Backup support will be added in Phase 5
- Overlay will be integrated with Bwrap in Phase 4 (overlay mount point will be bind-mounted into Bubble)
- Overlay is created and mounted but not yet used by Bubble in Phase 3
- Monitor tracks changes in overlay upper directory
- Files are copied from overlay to live system after command execution
- Permissions are copied silently (no approval required)

