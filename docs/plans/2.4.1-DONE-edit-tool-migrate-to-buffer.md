# 2.4.1. DONE - Edit Tool Migrate to Use Project Manager and Buffer

## Overview

Migrate `libollmchat/Tools/RequestEditMode` to use `ProjectManager` and buffer-based file operations instead of direct file I/O. This ensures consistent file handling, proper backup management, and eliminates race conditions when counting file lines after writes.

## Status

âœ… **DONE** - Completed

## Problem

The current `libollmchat/Tools/RequestEditMode` implementation:
- Uses direct file I/O (`DataInputStream`/`DataOutputStream`) instead of buffers
- Reads files directly from disk after writing, causing race conditions
- Does not use `ProjectManager` for file access
- Does not benefit from automatic backup management
- Line counting fails due to file system caching/timing issues

The `liboctools/RequestEditMode` already uses the correct approach with buffers and `ProjectManager`.

## Goals

1. Migrate `libollmchat/Tools/RequestEditMode` to use `ProjectManager` and buffers
2. Remove all direct file I/O operations
3. Use `file.buffer.read_async()` for reading
4. Use `file.buffer.write()` for writing (automatic backups)
5. Use `file.buffer.get_line_count()` for line counting (no disk reads)
6. Ensure `EditMode` tool class has `project_manager` property

## Implementation Plan

### Phase 1: Add ProjectManager Support to EditMode Tool

- [x] Add `project_manager` property to `libollmchat/Tools/EditMode` class
- [x] Update `EditMode` constructor to accept optional `ProjectManager` parameter
- [x] Ensure `project_manager` is passed from `Window.vala` when creating the tool

### Phase 2: Migrate File Access to Use ProjectManager

- [x] Update `RequestEditMode.apply_all_changes()` to:
  - Get or create `File` object using `project_manager.get_file_from_active_project()`
  - Create fake file if not in project: `File.new_fake(project_manager, path)`
  - Ensure buffer exists: `file.manager.buffer_provider.create_buffer(file)`
- [x] Update `build_perm_question()` to check if file is in active project (skip permission for project files)
- [x] Update `count_file_lines()` to use ProjectManager and buffer-based line counting
- [x] Make `apply_all_changes()`, `apply_edits()`, and `create_new_file_with_changes()` async and accept File parameter

### Phase 3: Migrate File Reading to Buffer

- [x] For edit mode (non-complete_file):
  - Replace `apply_edits()` streaming approach with buffer-based approach
  - Use `file.buffer.read_async()` to load file if needed
  - Use `file.buffer.get_text()` or `file.buffer.apply_edits()` for applying changes
  - Remove `process_edits()` method that uses `DataInputStream`
- [x] Remove temporary file creation and file move operations

### Phase 4: Migrate File Writing to Buffer

- [x] For complete_file mode:
  - Replace `create_new_file_with_changes()` direct file writing
  - Use `file.buffer.write(replacement_content)` instead
  - Remove `DataOutputStream` usage
- [x] For edit mode:
  - Use `file.buffer.apply_edits(changes)` if available
  - Or use `file.buffer.write(final_content)` after reconstructing in memory
- [x] Ensure all writes go through buffer (automatic backups for project files)

### Phase 4.5: Handle Newly Created Files in Project

When creating a new file (complete_file mode) within the active project, convert the fake file to a proper File object (id = 0) after the file is written to disk:

**Step 1: Create directory and write file (already done)**
- `create_new_file_with_changes()` already:
  - Creates parent directory if needed: `dir.make_directory_with_parents()`
  - Writes file using fake file: `file.buffer.write()` (file has id = -1 at this point)

**Step 2: After write completes, convert to real file if within project**
- [x] Create new method `deal_with_new_file(File file)`:
  - Early return if file is outside active project:
    - Check if `active_project == null` or `!normalized_path.has_prefix(active_project.path)`
    - If outside project, return early (keep as fake file, id = -1)
  - File is within project and has id = -1 (fake file):
    - Get parent directory path: `GLib.Path.get_dirname(normalized_path)`
    - Find or create parent folder objects in project tree (walk from `active_project` down the path, creating Folder objects as needed)
    - Query file info from disk: `GLib.File.query_info()` to get FileInfo
    - Convert fake file to real File object:
      - Create new File: `new File(project_manager)` (not `new_fake()`)
      - Set `file.path = normalized_path`
      - Set `file.parent = parent_folder` and `file.parent_id = parent_folder.id`
      - Set `file.id = 0` (new file, will be inserted on save)
      - Set properties from FileInfo: `is_text`, `last_modified`, `language`, etc.
    - Add file to parent folder's children: `parent_folder.children.append(file)`
    - Add file to `project_manager.file_cache`: `project_manager.file_cache.set(file.path, file)`
    - Replace buffer's file reference (or recreate buffer with new file object)
    - Save file to DB: `file.saveToDB(project_manager.db, null, false)` (gets id > 0)
    - Update ProjectFiles list: `active_project.project_files.update_from(active_project)`
    - Manually emit `new_file_added` signal: `active_project.project_files.new_file_added(file)`
    - This notifies UI components that a new file was created (not just discovered during scan)
- [x] Add `new_file_added` signal to ProjectFiles:
  - Add signal declaration: `public signal void new_file_added(File file)`
  - Do NOT emit in `append()` or `insert()` (those are called during scans)
  - Only emit when explicitly adding a new file (e.g., in `deal_with_new_file()` after converting fake to real)
  - This allows UI components to react only when new files are created, not during directory scans
- [x] In `create_new_file_with_changes()`, after `yield file.buffer.write()`:
  - Only call `yield this.deal_with_new_file(file)` if `file.id == -1` (fake file)

### Phase 5: Fix Line Counting to Use Buffer

- [x] Replace `count_file_lines()` disk reading with buffer-based counting
- [x] For complete_file mode: After writing to buffer, use `file.buffer.get_line_count()`
- [x] For edit mode: After applying edits, use `file.buffer.get_line_count()`
- [x] Remove all `DataInputStream` usage for line counting
- [x] Remove all character-by-character loops for line counting
- [x] Use buffer's built-in `get_line_count()` method (no manual counting needed)

### Phase 6: Update Permission Handling

- [x] Check if file is in active project before permission prompts
- [x] Skip permission checks for files in active project (auto-approved)
- [x] Only prompt for files outside active project

### Phase 7: Testing and Validation

Follow the same testing pattern as readfile tests (`tests/test-file-ops.sh`):
- Use `oc-test-files` as the action part by adding command-line options
- Create a shell script to run the 'actions' and test the results

#### 7.1: Add Command-Line Options to oc-test-files

Add the following options to `examples/oc-test-files.vala`:

- [ ] `--edit=PATH` - Primary option: file path to edit (required for all edit operations)
  - When combined with `--edit-complete-file` flag: complete file mode (create new file or overwrite existing)
  - When used without `--edit-complete-file` flag: edit mode (apply edits to existing file)

- [ ] `--edit-complete-file` - Flag: enable complete file mode (overwrite entire file)
  - Requires `--edit=PATH` to specify the file
  - Requires `--edit-content=FILE` or `--edit-content-text=TEXT` to specify content
  - Optional `--overwrite` flag to allow overwriting existing files
  - Output: `FILE: path`, `FILE_ID: id`, `LINE_COUNT: count`, `BACKUP: path` (if applicable), `MODE: complete_file`

- [ ] Edit mode (when `--edit-complete-file` is NOT set):
  - Reads JSON from stdin (array of FileChange objects)
  - Each change has: `start` (1-based, inclusive), `end` (1-based, exclusive), `replacement` (text string)
  - Output: `FILE: path`, `FILE_ID: id`, `LINE_COUNT: count`, `CHANGES_APPLIED: count`, `MODE: edit`

- [ ] JSON format (read from stdin):
  ```json
  [
    {"start": 2, "end": 4, "replacement": "new content\nline 2"},
    {"start": 10, "end": 10, "replacement": "inserted line\n"}
  ]
  ```
  - If stdin is empty, error

- [ ] `--edit-content=FILE` - File containing complete content for `--edit-complete-file`
- [ ] `--edit-content-text=TEXT` - Inline text content for `--edit-complete-file` (no newlines)
- [ ] `--overwrite` - Allow overwriting existing files in complete_file mode

#### 7.2: Create Test Script

Create `tests/test-edit-ops.sh` following the same pattern as `tests/test-file-ops.sh`:

- [ ] **Test 1: Complete file mode (new file creation)**
  - Create test file with `--edit=PATH --edit-complete-file` pointing to non-existent file
  - Verify file is created with correct content
  - Verify line count is accurate
  - Verify no backup created (new file, not in project initially)
  - Use sourceview backend (critical test)

- [ ] **Test 2: Complete file mode (overwrite existing file in project)**
  - Create project with test file
  - Read file first to ensure it's loaded
  - Save original content for backup comparison
  - Overwrite with `--edit=PATH --edit-complete-file --overwrite`
  - Verify backup is created for project file
  - Verify backup contains original content
  - Verify file contains new content
  - Verify line count is accurate
  - Use sourceview backend (critical test)

- [ ] **Test 3: Edit mode (single edit)**
  - Create test file with known content
  - Create project and add file
  - Apply single edit (e.g., replace lines 2-4)
  - Verify backup is created
  - Verify file content matches expected result
  - Verify line count is accurate
  - Use sourceview backend (critical test)

- [ ] **Test 4: Edit mode (multiple edits)**
  - Create test file with known content
  - Create project and add file
  - Apply multiple edits by piping JSON to stdin: `echo '[...]' | oc-test-files --edit=PATH`
  - Verify backup is created
  - Verify file content matches expected result after all edits
  - Verify line count is accurate
  - Use sourceview backend (critical test)

- [ ] **Test 5: Edit mode (insertion at end of file)**
  - Create test file with known content
  - Create project and add file
  - Apply edit with start=end=last_line+1 (insertion at end)
  - Verify backup is created
  - Verify file content has new lines appended
  - Verify line count is accurate
  - Use sourceview backend (critical test)

- [ ] **Test 6: Line counting accuracy**
  - Test with files of various sizes (1 line, 10 lines, 100 lines)
  - Test with files with/without trailing newline
  - Verify `LINE_COUNT` in output matches actual line count
  - Verify no race conditions (count immediately after write)

- [ ] **Test 7: Backup verification for project files**
  - Verify backups are created for files in project (id > 0)
  - Verify backups are NOT created for fake files (id = -1)
  - Verify backup path format: `{id}-{date YY-MM-DD}-{basename}`
  - Verify backup content matches original file content

- [ ] **Test 8: No race conditions in line counting**
  - Write file and immediately check line count
  - Apply edits and immediately check line count
  - Verify counts are accurate (no timing issues)
  - Use sourceview backend (critical test)

#### 7.3: Test Script Structure

The test script should:
- Follow same pattern as `tests/test-file-ops.sh`
- Use `~/.cache/ollmchat/testing/` as test directory
- Use `--test-db` option for isolated testing
- Use `--backend sourceview` for critical tests
- Create expected output files and compare with `diff`
- Extract values from output using `extract_value()` helper
- Clean up on success, leave files on failure
- Print colored pass/fail messages
- Track test statistics

## Files to Modify

- `libollmchat/Tools/EditMode.vala` - Add `project_manager` property
- `libollmchat/Tools/RequestEditMode.vala` - Migrate to buffer-based operations
- `ollmchat/Window.vala` - Pass `project_manager` to `EditMode` constructor

## Reference Implementation

See `liboctools/RequestEditMode.vala` for the correct implementation pattern:
- Uses `project_manager.get_file_from_active_project()`
- Uses `file.buffer.read_async()` for reading
- Uses `file.buffer.write()` for writing
- Uses `file.buffer.get_line_count()` for counting
- Handles fake files for files outside project

## Notes

- The `liboctools` version is the reference implementation
- This migration should make `libollmchat` version match `liboctools` approach
- All file operations must go through buffers - no direct I/O
- Buffer operations handle backups automatically for project files
- Buffer operations are async and thread-safe

