# 2.4.1. DONE - Edit Tool Migrate to Use Project Manager and Buffer

## Overview

Migrate `libollmchat/Tools/RequestEditMode` to use `ProjectManager` and buffer-based file operations instead of direct file I/O. This ensures consistent file handling, proper backup management, and eliminates race conditions when counting file lines after writes.

## Status

âœ… **DONE** - Completed

## Problem

The current `libollmchat/Tools/RequestEditMode` implementation:
- Uses direct file I/O (`DataInputStream`/`DataOutputStream`) instead of buffers
- Reads files directly from disk after writing, causing race conditions
- Does not use `ProjectManager` for file access
- Does not benefit from automatic backup management
- Line counting fails due to file system caching/timing issues

The `liboctools/RequestEditMode` already uses the correct approach with buffers and `ProjectManager`.

## Goals

1. Migrate `libollmchat/Tools/RequestEditMode` to use `ProjectManager` and buffers
2. Remove all direct file I/O operations
3. Use `file.buffer.read_async()` for reading
4. Use `file.buffer.write()` for writing (automatic backups)
5. Use `file.buffer.get_line_count()` for line counting (no disk reads)
6. Ensure `EditMode` tool class has `project_manager` property

## Implementation Plan

### Phase 1: Add ProjectManager Support to EditMode Tool

- [x] Add `project_manager` property to `libollmchat/Tools/EditMode` class
- [x] Update `EditMode` constructor to accept optional `ProjectManager` parameter
- [x] Ensure `project_manager` is passed from `Window.vala` when creating the tool

### Phase 2: Migrate File Access to Use ProjectManager

- [x] Update `RequestEditMode.apply_all_changes()` to:
  - Get or create `File` object using `project_manager.get_file_from_active_project()`
  - Create fake file if not in project: `File.new_fake(project_manager, path)`
  - Ensure buffer exists: `file.manager.buffer_provider.create_buffer(file)`
- [x] Update `build_perm_question()` to check if file is in active project (skip permission for project files)
- [x] Update `count_file_lines()` to use ProjectManager and buffer-based line counting
- [x] Make `apply_all_changes()`, `apply_edits()`, and `create_new_file_with_changes()` async and accept File parameter

### Phase 3: Migrate File Reading to Buffer

- [x] For edit mode (non-complete_file):
  - Replace `apply_edits()` streaming approach with buffer-based approach
  - Use `file.buffer.read_async()` to load file if needed
  - Use `file.buffer.get_text()` or `file.buffer.apply_edits()` for applying changes
  - Remove `process_edits()` method that uses `DataInputStream`
- [x] Remove temporary file creation and file move operations

### Phase 4: Migrate File Writing to Buffer

- [x] For complete_file mode:
  - Replace `create_new_file_with_changes()` direct file writing
  - Use `file.buffer.write(replacement_content)` instead
  - Remove `DataOutputStream` usage
- [x] For edit mode:
  - Use `file.buffer.apply_edits(changes)` if available
  - Or use `file.buffer.write(final_content)` after reconstructing in memory
- [x] Ensure all writes go through buffer (automatic backups for project files)

### Phase 4.5: Handle Newly Created Files in Project

When creating a new file (complete_file mode) within the active project, convert the fake file to a proper File object (id = 0) after the file is written to disk:

**Step 1: Create directory and write file (already done)**
- `create_new_file_with_changes()` already:
  - Creates parent directory if needed: `dir.make_directory_with_parents()`
  - Writes file using fake file: `file.buffer.write()` (file has id = -1 at this point)

**Step 2: After write completes, convert to real file if within project**
- [x] Create new method `deal_with_new_file(File file)`:
  - Early return if file is outside active project:
    - Check if `active_project == null` or `!normalized_path.has_prefix(active_project.path)`
    - If outside project, return early (keep as fake file, id = -1)
  - File is within project and has id = -1 (fake file):
    - Get parent directory path: `GLib.Path.get_dirname(normalized_path)`
    - Find or create parent folder objects in project tree (walk from `active_project` down the path, creating Folder objects as needed)
    - Query file info from disk: `GLib.File.query_info()` to get FileInfo
    - Convert fake file to real File object:
      - Create new File: `new File(project_manager)` (not `new_fake()`)
      - Set `file.path = normalized_path`
      - Set `file.parent = parent_folder` and `file.parent_id = parent_folder.id`
      - Set `file.id = 0` (new file, will be inserted on save)
      - Set properties from FileInfo: `is_text`, `last_modified`, `language`, etc.
    - Add file to parent folder's children: `parent_folder.children.append(file)`
    - Add file to `project_manager.file_cache`: `project_manager.file_cache.set(file.path, file)`
    - Replace buffer's file reference (or recreate buffer with new file object)
    - Save file to DB: `file.saveToDB(project_manager.db, null, false)` (gets id > 0)
    - Update ProjectFiles list: `active_project.project_files.update_from(active_project)`
    - Manually emit `new_file_added` signal: `active_project.project_files.new_file_added(file)`
    - This notifies UI components that a new file was created (not just discovered during scan)
- [x] Add `new_file_added` signal to ProjectFiles:
  - Add signal declaration: `public signal void new_file_added(File file)`
  - Do NOT emit in `append()` or `insert()` (those are called during scans)
  - Only emit when explicitly adding a new file (e.g., in `deal_with_new_file()` after converting fake to real)
  - This allows UI components to react only when new files are created, not during directory scans
- [x] In `create_new_file_with_changes()`, after `yield file.buffer.write()`:
  - Only call `yield this.deal_with_new_file(file)` if `file.id == -1` (fake file)

### Phase 5: Fix Line Counting to Use Buffer

- [x] Replace `count_file_lines()` disk reading with buffer-based counting
- [x] For complete_file mode: After writing to buffer, use `file.buffer.get_line_count()`
- [x] For edit mode: After applying edits, use `file.buffer.get_line_count()`
- [x] Remove all `DataInputStream` usage for line counting
- [x] Remove all character-by-character loops for line counting
- [x] Use buffer's built-in `get_line_count()` method (no manual counting needed)

### Phase 6: Update Permission Handling

- [x] Check if file is in active project before permission prompts
- [x] Skip permission checks for files in active project (auto-approved)
- [x] Only prompt for files outside active project

### Phase 7: Testing and Validation

Follow the same testing pattern as readfile tests (`tests/test-file-ops.sh`):
- Use `oc-test-files` as the action part by adding command-line options
- Create a shell script to run the 'actions' and test the results

#### 7.1: Add Command-Line Options to oc-test-files

Add the following options to `examples/oc-test-files.vala`:

- [x] `--edit=PATH` - Primary option: file path to edit (required for all edit operations)
  - All edits/changes are read from stdin (format depends on mode)
  - When combined with `--edit-complete-file` flag: complete file mode (create new file or overwrite existing)
  - When used without `--edit-complete-file` flag: edit mode (apply edits to existing file)

- [x] `--edit-complete-file` - Flag: enable complete file mode (overwrite entire file)
  - Requires `--edit=PATH` to specify the file
  - Reads complete file content from stdin as raw text (not JSON)
  - Optional `--overwrite` flag to allow overwriting existing files
  - Output: `FILE: path`, `FILE_ID: id`, `LINE_COUNT: count`, `BACKUP: path` (if applicable), `MODE: complete_file`

- [x] Edit mode (when `--edit-complete-file` is NOT set):
  - Reads JSON array of FileChange objects from stdin
  - Each change has: `start` (1-based, inclusive), `end` (1-based, exclusive), `replacement` (text string)
  - Output: `FILE: path`, `FILE_ID: id`, `LINE_COUNT: count`, `CHANGES_APPLIED: count`, `MODE: edit`

- [x] Stdin format (all edits come from stdin):
  - **Complete file mode** (`--edit=PATH --edit-complete-file`): Raw file content (plain text)
  - **Edit mode** (`--edit=PATH`): JSON array of FileChange objects:
  ```json
  [
    {"start": 2, "end": 4, "replacement": "new content\nline 2"},
    {"start": 10, "end": 10, "replacement": "inserted line\n"}
  ]
  ```
  - If stdin is empty, error

- [x] `--overwrite` - Allow overwriting existing files in complete_file mode

#### 7.2: Create Test Data Files

- [x] Create `tests/data/` directory with test data files:
- Number test files: `1.read-test-*` for readfile tests, `2.edit-test-*` for editfile tests
- These files contain original file content and JSON for stdin (instead of cluttering test script with echo commands)
- Example files:
  - `2.edit-test-1-original.txt` - Original file content for test 1
  - `2.edit-test-1-complete.txt` - Complete file content for stdin (complete_file mode)
  - `2.edit-test-1-expected.txt` - Expected result after operation
  - `2.edit-test-3-original.txt` - Original file content for test 3
  - `2.edit-test-3-changes.json` - JSON array of FileChange objects for stdin (edit mode)
  - `2.edit-test-3-expected.txt` - Expected result after edits

#### 7.3: Create Test Script

Create `tests/test-edit-ops.sh` following the same pattern as `tests/test-file-ops.sh`:

**Test file location**: All test files, directories, and databases should be created in `~/.cache/ollmchat/testing/`
**Test database**: **Always use `--test-db=~/.cache/ollmchat/testing/test.db`** for all `oc-test-files` commands in test scripts
**Database safety**: Test scripts must always pass `--test-db` to ensure they never touch live/main database files
**Test data files**: Read from `tests/data/2.edit-test-*.txt` and `tests/data/2.edit-test-*.json` files

- [ ] **Test 1: Complete file mode (new file creation)**
  - Uses data file: `tests/data/2.edit-test-1-complete.txt` (content for stdin)
  - Creates test file with `--edit=~/.cache/ollmchat/testing/test_new.txt --edit-complete-file` pointing to non-existent file
  - Pipes content from data file: `cat tests/data/2.edit-test-1-complete.txt | oc-test-files --edit=~/.cache/ollmchat/testing/test_new.txt --edit-complete-file --backend sourceview --test-db ~/.cache/ollmchat/testing/test.db`
  - Compares result with expected: `tests/data/2.edit-test-1-expected.txt`
  - Verify file is created with correct content
  - Verify line count is accurate
  - Verify no backup created (new file, not in project initially)
  - Uses GTK source buffer backend (critical test)
  - Cleans up on success, leaves files on failure

- [ ] **Test 2: Complete file mode (overwrite existing file in project)**
  - Uses data files: `tests/data/2.edit-test-2-original.txt` (original content), `tests/data/2.edit-test-2-complete.txt` (new content for stdin)
  - Creates test file in `~/.cache/ollmchat/testing/testproj2/test.txt` from `2.edit-test-2-original.txt`
  - Creates project with `oc-test-files --create-project ~/.cache/ollmchat/testing/testproj2 --test-db ~/.cache/ollmchat/testing/test.db`
  - Reads file first to ensure it's loaded: `oc-test-files --read ~/.cache/ollmchat/testing/testproj2/test.txt --backend sourceview --test-db ~/.cache/ollmchat/testing/test.db`
  - Saves original content for backup comparison
  - Overwrites with: `cat tests/data/2.edit-test-2-complete.txt | oc-test-files --edit=~/.cache/ollmchat/testing/testproj2/test.txt --edit-complete-file --overwrite --backend sourceview --test-db ~/.cache/ollmchat/testing/test.db`
  - Compares result with expected: `tests/data/2.edit-test-2-expected.txt`
  - Verify backup is created for project file
  - Verify backup contains original content (from `2.edit-test-2-original.txt`)
  - Verify file contains new content
  - Verify line count is accurate
  - Uses GTK source buffer backend (critical test)
  - Cleans up on success, leaves files on failure

- [ ] **Test 3: Edit mode (single edit)**
  - Uses data files: `tests/data/2.edit-test-3-original.txt` (original content), `tests/data/2.edit-test-3-changes.json` (JSON changes for stdin), `tests/data/2.edit-test-3-expected.txt` (expected result)
  - Creates test file in `~/.cache/ollmchat/testing/testproj3/test.txt` from `2.edit-test-3-original.txt`
  - Creates project: `oc-test-files --create-project ~/.cache/ollmchat/testing/testproj3 --test-db ~/.cache/ollmchat/testing/test.db`
  - Applies single edit by piping JSON from data file: `cat tests/data/2.edit-test-3-changes.json | oc-test-files --edit=~/.cache/ollmchat/testing/testproj3/test.txt --backend sourceview --test-db ~/.cache/ollmchat/testing/test.db`
  - Compares result with expected: `tests/data/2.edit-test-3-expected.txt`
  - Verify backup is created
  - Verify file content matches expected result
  - Verify line count is accurate
  - Uses GTK source buffer backend (critical test)
  - Cleans up on success, leaves files on failure

- [ ] **Test 4: Edit mode (multiple edits)**
  - Uses data files: `tests/data/2.edit-test-4-original.txt` (original content), `tests/data/2.edit-test-4-changes.json` (JSON array of multiple changes for stdin), `tests/data/2.edit-test-4-expected.txt` (expected result)
  - Creates test file in `~/.cache/ollmchat/testing/testproj4/test.txt` from `2.edit-test-4-original.txt`
  - Creates project: `oc-test-files --create-project ~/.cache/ollmchat/testing/testproj4 --test-db ~/.cache/ollmchat/testing/test.db`
  - Applies multiple edits by piping JSON from data file: `cat tests/data/2.edit-test-4-changes.json | oc-test-files --edit=~/.cache/ollmchat/testing/testproj4/test.txt --backend sourceview --test-db ~/.cache/ollmchat/testing/test.db`
  - Compares result with expected: `tests/data/2.edit-test-4-expected.txt`
  - Verify backup is created
  - Verify file content matches expected result after all edits
  - Verify line count is accurate
  - Uses GTK source buffer backend (critical test)
  - Cleans up on success, leaves files on failure

- [ ] **Test 5: Edit mode (insertion at end of file)**
  - Uses data files: `tests/data/2.edit-test-5-original.txt` (original content), `tests/data/2.edit-test-5-changes.json` (JSON with start=end=last_line+1 for insertion at end), `tests/data/2.edit-test-5-expected.txt` (expected result)
  - Creates test file in `~/.cache/ollmchat/testing/testproj5/test.txt` from `2.edit-test-5-original.txt`
  - Creates project: `oc-test-files --create-project ~/.cache/ollmchat/testing/testproj5 --test-db ~/.cache/ollmchat/testing/test.db`
  - Reads file to get line count, then applies edit with start=end=last_line+1 (insertion at end)
  - Pipes JSON from data file: `cat tests/data/2.edit-test-5-changes.json | oc-test-files --edit=~/.cache/ollmchat/testing/testproj5/test.txt --backend sourceview --test-db ~/.cache/ollmchat/testing/test.db`
  - Compares result with expected: `tests/data/2.edit-test-5-expected.txt`
  - Verify backup is created
  - Verify file content has new lines appended
  - Verify line count is accurate
  - Uses GTK source buffer backend (critical test)
  - Cleans up on success, leaves files on failure

- [ ] **Test 6: Line counting accuracy**
  - Tests with files of various sizes (1 line, 10 lines, 100 lines) in `~/.cache/ollmchat/testing/`
  - Tests with files with/without trailing newline
  - Creates projects and files, then applies edits
  - Verifies `LINE_COUNT` in output matches actual line count
  - Verifies no race conditions (count immediately after write)
  - Uses `--test-db ~/.cache/ollmchat/testing/test.db` for all commands
  - Cleans up on success, leaves files on failure

- [ ] **Test 7: Backup verification for project files**
  - Creates test files in project (id > 0) in `~/.cache/ollmchat/testing/testproj7/`
  - Creates project: `oc-test-files --create-project ~/.cache/ollmchat/testing/testproj7 --test-db ~/.cache/ollmchat/testing/test.db`
  - Verifies backups are created for files in project (id > 0)
  - Creates fake files (id = -1) in `~/.cache/ollmchat/testing/` outside project
  - Verifies backups are NOT created for fake files (id = -1)
  - Verifies backup path format: `{id}-{date YY-MM-DD}-{basename}` in `~/.cache/ollmchat/edited/`
  - Verifies backup content matches original file content
  - Uses `--test-db ~/.cache/ollmchat/testing/test.db` for all commands
  - Cleans up on success, leaves files on failure

- [ ] **Test 8: No race conditions in line counting**
  - Creates test files in `~/.cache/ollmchat/testing/testproj8/`
  - Creates project: `oc-test-files --create-project ~/.cache/ollmchat/testing/testproj8 --test-db ~/.cache/ollmchat/testing/test.db`
  - Writes file and immediately checks line count
  - Applies edits and immediately checks line count
  - Verifies counts are accurate (no timing issues)
  - Uses GTK source buffer backend (critical test)
  - Uses `--test-db ~/.cache/ollmchat/testing/test.db` for all commands
  - Cleans up on success, leaves files on failure

#### 7.4: Test Script Structure

The test script should:
- Follow same pattern as `tests/test-file-ops.sh`
- **Test data files**: Read from `tests/data/2.edit-test-*.txt` and `tests/data/2.edit-test-*.json` files
  - Use `cat tests/data/2.edit-test-N-*.txt` or `cat tests/data/2.edit-test-N-*.json` to pipe to stdin
  - Use `diff` to compare results with `tests/data/2.edit-test-N-expected.txt` files
- **Test file location**: All test files, directories, and databases in `~/.cache/ollmchat/testing/`
- **Test database**: Always use `--test-db=~/.cache/ollmchat/testing/test.db` for all `oc-test-files` commands
- **Database safety**: Always pass `--test-db` to ensure never touching live/main database files
- Use `--backend sourceview` for critical tests
- Extract values from output using `extract_value()` helper
- **Cleanup rules**:
  - If test succeeds: Delete all files in `~/.cache/ollmchat/testing/*` (complete cleanup)
  - If test fails: Leave all files in `~/.cache/ollmchat/testing/*` for debugging (no cleanup)
- Print colored pass/fail messages
- Track test statistics

## Files to Modify

- `libollmchat/Tools/EditMode.vala` - Add `project_manager` property
- `libollmchat/Tools/RequestEditMode.vala` - Migrate to buffer-based operations
- `ollmchat/Window.vala` - Pass `project_manager` to `EditMode` constructor

## Reference Implementation

See `liboctools/RequestEditMode.vala` for the correct implementation pattern:
- Uses `project_manager.get_file_from_active_project()`
- Uses `file.buffer.read_async()` for reading
- Uses `file.buffer.write()` for writing
- Uses `file.buffer.get_line_count()` for counting
- Handles fake files for files outside project

## Notes

- The `liboctools` version is the reference implementation
- This migration should make `libollmchat` version match `liboctools` approach
- All file operations must go through buffers - no direct I/O
- Buffer operations handle backups automatically for project files
- Buffer operations are async and thread-safe

