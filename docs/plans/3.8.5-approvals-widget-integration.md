# 3.8.5. Approvals Widget Integration

## Overview

Modify the Approvals widget to be a horizontal box containing the existing next/popover button, approve button, and reject button. This consolidates all approval-related functionality into a single widget that can monitor list changes and update all buttons accordingly.

## Status

‚è≥ **TODO** - To be implemented.

## Prerequisites

- Phase 3.8.3 must be completed (Approvals widget with popover)

## Goals

1. Convert Approvals widget from Gtk.Button to Gtk.Box (horizontal)
2. Keep existing popover button functionality (task-due icon, popover on mouseover)
3. Add approve button to the box
4. Add reject button to the box
5. Consolidate visibility management in one place
6. Monitor ReviewFiles changes and update all buttons accordingly

## Implementation Details

### Files to Modify

- `liboccoder/Approvals.vala` - Convert to horizontal box with integrated buttons
- `libocfiles/File.vala` - Add `approve()` and `revert()` methods
- `libocfiles/Folder.vala` - Add `refresh_review()` wrapper method

### Widget Structure

**Current Structure** (3.8.3):
- `Approvals` extends `Gtk.Button`
- Contains internal popover with file list
- Shows task-due icon

**New Structure** (3.8.5):
- `Approvals` extends `Gtk.Box` (horizontal orientation)
- Contains three buttons (in order):
  1. **Approve Button** - Approve selected file
  2. **Reject Button** - Revert selected file
  3. **Next/Popover Button** - Existing functionality (task-due icon, popover on mouseover)

### Button Details

1. **Approve Button**:
   - Location: First button in the box
   - CSS Classes: `oc-approve` and `suggested-action`
   - Icon: None (text-only button)
   - Visibility: Only visible when a file in ReviewFiles is selected
   - Action: Approve selected file and all FileHistory items
   - Behavior: Disappears when file is approved or no file selected

2. **Reject Button**:
   - Location: Second button in the box
   - CSS Class: `oc-reject`
   - Icon: None (text-only button)
   - Tooltip: "Revert file to previous version"
   - Visibility: Only visible when a file in ReviewFiles is selected AND has FileHistory records with backup_path
   - Action: Restore file from FileHistory backup and update database
   - Behavior: Disappears when no file selected or file has no backup to restore from

3. **Next/Popover Button**:
   - Location: Third button in the box
   - Icon: "task-due" (only button with icon)
   - Functionality: Existing popover on mouseover, file selection
   - Visibility: Handled by Approvals widget (shows/hides based on `review_files.get_n_items()`)
   - Tooltip: Can show "X more files to approve" (optional)

### Class Structure

```vala
namespace OLLMcoder
{
    /**
     * Horizontal box widget containing buttons for file approval workflow.
     * 
     * Contains:
     * - Next/popover button (existing functionality)
     * - Approve button
     * - Reject button
     * 
     * Monitors ReviewFiles and updates button visibility accordingly.
     */
    public class Approvals : Gtk.Box
    {
        private OLLMfiles.ProjectManager project_manager;
        
        // Buttons (in order: approve, reject, next)
        private Gtk.Button approve_button;
        private Gtk.Button reject_button;
        private Gtk.Button next_button;  // Existing popover button functionality
        
        // Existing popover functionality (moved from button to next_button)
        private Gtk.Popover popover;
        private Gtk.ListView list_view;
        private Gtk.SingleSelection selection;
        private List.SortedList<OLLMfiles.File> sorted_model;
        private Gtk.EventControllerMotion button_motion;
        private Gtk.EventControllerMotion popover_motion;
        private bool blocking_selection_handler = false;
        private uint hide_timeout_id = 0;
        private uint cooldown_timeout_id = 0;
        private bool in_cooldown = false;
        private ulong? review_files_handler_id = null;
        
        /**
         * Currently selected file (or null).
         */
        private OLLMfiles.File? selected_file { get; set; default = null; }
        
        /**
         * Emitted when a file is selected/clicked.
         */
        public signal void file_selected(OLLMfiles.File file);
        
        // ... methods ...
    }
}
```

### Implementation Steps

1. **Convert Class Structure**:
   - Change `Approvals` from `extends Gtk.Button` to `extends Gtk.Box`
   - Set orientation to `Gtk.Orientation.HORIZONTAL`
   - Move existing button functionality to `next_button` (internal button)

2. **Create Approve Button**:
   - Create `approve_button` as `Gtk.Button.with_label("Approve")` (text-only, no icon)
   - Add CSS classes: `oc-approve` and `suggested-action`
   - Connect click handler to approve workflow
   - Append to box (first button)

3. **Create Reject Button**:
   - Create `reject_button` as `Gtk.Button.with_label("Reject")` (text-only, no icon)
   - Add CSS class: `oc-reject`
   - Connect click handler to revert workflow
   - Append to box (second button)

4. **Create Next/Popover Button**:
   - Create `next_button` as `Gtk.Button` with "task-due" icon
   - Move all existing popover functionality from `this` (the button) to `next_button`
   - Set popover parent to `next_button` using `popover.set_parent(next_button)`
   - Move motion controllers to `next_button`
   - Append `next_button` to the box (third button)

5. **Consolidate Visibility Management**:
   - Single method to update all button visibility
   - Monitor `review_files.items_changed` signal
   - Update button visibility based on:
     - ReviewFiles count (for next_button visibility)
     - Selected file (for approve_button visibility)
     - Selected file + FileHistory backup (for reject_button visibility)

### Approval Workflow

1. **Approve Button Clicked**:
   ```vala
   void on_approve_clicked() {
       var file = this.selected_file;
       if (file == null) {
           return;
       }
       
       // Approve file (handles FileHistory approval and database updates)
       file.approve();
       
       // Refresh ReviewFiles (file will be removed)
       this.project_manager.active_project.refresh_review();
       
       // Update button visibility
       this.update_button_visibility();
   }
   ```

2. **Reject Button Clicked**:
   ```vala
   void on_reject_clicked() {
       var file = this.selected_file;
       if (file == null) {
           return;
       }
       
       // Revert the file (handles FileHistory revert and database updates)
       try {
           yield file.revert();
           
           // Refresh ReviewFiles (file may be removed or updated)
           this.project_manager.active_project.refresh_review();
           
           // Update button visibility
           this.update_button_visibility();
       } catch (GLib.Error e) {
           GLib.warning("Failed to revert file: %s", e.message);
       }
   }
   ```

3. **File Selected Signal Handler**:
   ```vala
   private void update_selected_file() {
       if (this.selection.selected == Gtk.INVALID_LIST_POSITION) {
           this.selected_file = null;
           this.update_button_visibility();
           return;
       }
       
       var file = this.sorted_model.get_item_typed(this.selection.selected);
       this.selected_file = file;
       this.file_selected(file);  // Emit signal
       this.update_button_visibility();
   }
   ```

### Button Visibility Management

```vala
private async void update_button_visibility() {
    var project = this.project_manager.active_project;
    if (project == null) {
        this.visible = false;
        return;
    }
    
    var count = project.review_files.get_n_items();
    
    // Next button visibility: based on ReviewFiles count
    this.next_button.visible = (count > 0);
    
    // Approve button visibility: based on selected file
    this.approve_button.visible = (this.selected_file != null);
    
    // Reject button visibility: based on selected file + FileHistory backup
    this.reject_button.visible = false;
    if (this.selected_file != null) {
        // Check if file has FileHistory records with backup_path
        var db = this.project_manager.db;
        var history_records = new Gee.ArrayList<OLLMfiles.FileHistory>();
        try {
            yield OLLMfiles.FileHistory.query(db).select_async(
                "WHERE filebase_id = %lld AND backup_path != '' LIMIT 1".printf(this.selected_file.id),
                history_records
            );
            this.reject_button.visible = (history_records.size > 0);
        } catch (GLib.Error e) {
            GLib.warning("Failed to check FileHistory for reject button: %s", e.message);
        }
    }
    
    // Overall widget visibility: show if any button should be visible
    this.visible = (this.next_button.visible || this.approve_button.visible || this.reject_button.visible);
}
```

### File.approve() Method

Add approve method to File class:

**File**: `libocfiles/File.vala`

```vala
/**
 * Approve this file and all its FileHistory items.
 * 
 * Sets is_need_approval = false and updates all FileHistory records
 * for this file to status = 1 (approved).
 */
public void approve()
{
    // Approve file
    this.is_need_approval = false;
    this.saveToDB(this.manager.db, null, false);
    
    // Approve all FileHistory items for this file using query wrapper
    var db = this.manager.db;
    var history_records = new Gee.ArrayList<OLLMfiles.FileHistory>();
    try {
        OLLMfiles.FileHistory.query(db).select(
            "WHERE filebase_id = %lld".printf(this.id),
            history_records
        );
    } catch (GLib.Error e) {
        GLib.warning("Failed to query FileHistory for approval: %s", e.message);
        return;
    }
    
    // Update each FileHistory record to approved status
    foreach (var history in history_records) {
        history.status = 1;
        try {
            OLLMfiles.FileHistory.query(db).updateById(history);
        } catch (GLib.Error e) {
            GLib.warning("Failed to update FileHistory status: %s", e.message);
        }
    }
}
```

### Project.refresh_review() Method

Add refresh_review wrapper to Folder class (for projects):

**File**: `libocfiles/Folder.vala`

```vala
/**
 * Refresh review_files list.
 * 
 * Wrapper method that calls review_files.refresh().
 * Only works for projects (folders with is_project = true).
 */
public void refresh_review()
{
    if (!this.is_project) {
        return;
    }
    this.review_files.refresh();
}
```

### FileHistory.commit() Update

Update `commit()` method to handle "revert" change_type:

**File**: `libocfiles/FileHistory.vala`

```vala
// In commit() method, update the backup creation condition:
// Create backup if needed (for modified/deleted/revert files, but not for symlinks)
if ((this.change_type == "modified" || this.change_type == "deleted" || this.change_type == "revert")) {
    yield this.create_backup();
    // Update database record with backup_path
    yield this.save_to_db();
}
```

**Note**: The `create_backup()` method already handles copying the file from its current path, so it works for "revert" change_type as well.

### File.revert() Method

Add revert method to File class:

**File**: `libocfiles/File.vala`

```vala
/**
 * Revert this file to previous version from FileHistory backup.
 * 
 * Finds the most recent FileHistory record with a backup for this file
 * and restores the file from that backup. Before restoring, creates a new
 * FileHistory record with change_type="revert" to backup the rejected content
 * (flagged as approved). Updates the original FileHistory status to rejected (-1)
 * and sets is_need_approval = true.
 * 
 * @throws Error if backup file doesn't exist or restore fails
 */
public async void revert() throws Error
{
    // Get FileHistory records for this file
    var db = this.manager.db;
    var history_records = new Gee.ArrayList<OLLMfiles.FileHistory>();
    try {
        yield OLLMfiles.FileHistory.query(db).select_async(
            "WHERE filebase_id = %lld AND backup_path != '' ORDER BY timestamp DESC LIMIT 1".printf(this.id),
            history_records
        );
    } catch (GLib.Error e) {
        throw new Error.FILE_NOT_FOUND("Failed to query FileHistory for revert: %s".printf(e.message));
    }
    
    if (history_records.size == 0) {
        throw new Error.FILE_NOT_FOUND("No backup found for file: %s".printf(this.path));
    }
    
    // Get the most recent FileHistory record with backup
    var history = history_records[0];
    
    // Check if backup exists
    if (history.backup_path == "" || !GLib.FileUtils.test(history.backup_path, GLib.FileTest.EXISTS)) {
        throw new Error.FILE_NOT_FOUND("Backup file does not exist: %s".printf(history.backup_path));
    }
    
    // Check change type - cannot revert "added" files (no backup)
    if (history.change_type == "added") {
        throw new Error.INVALID_ARGUMENT("Cannot revert added files (no backup exists)");
    }
    
    // Before restoring, backup the current content (the rejected content)
    // Create a new FileHistory record with change_type="revert" to backup the rejected content
    var now = new GLib.DateTime.now_local();
    var revert_history = new OLLMfiles.FileHistory(
        db,
        this,
        "revert",
        now
    );
    
    // Set status to approved (1) for the revert record
    revert_history.status = 1;
    
    // Commit the revert history record (creates backup of current content)
    yield revert_history.commit();
    
    // Copy backup file back to original path
    var backup_file = GLib.File.new_for_path(history.backup_path);
    var target_file = GLib.File.new_for_path(history.path);
    
    // Create parent directory if it doesn't exist (for deleted files)
    var parent_dir = target_file.get_parent();
    if (parent_dir != null && !parent_dir.query_exists()) {
        parent_dir.make_directory_with_parents(null);
    }
    
    // Copy backup to original location (overwrites existing file)
    backup_file.copy(
        target_file,
        GLib.FileCopyFlags.OVERWRITE,
        null,
        null
    );
    
    // Update File object metadata
    this.last_modified = now.to_unix();
    
    // Save File object to database
    this.saveToDB(db, null, false);
    
    // Reload buffer if it exists (file content changed on disk)
    if (this.buffer != null) {
        try {
            yield this.buffer.read_async();
        } catch (GLib.Error e) {
            GLib.warning("Failed to reload buffer after revert for %s: %s", this.path, e.message);
        }
    }
    
    // Update FileHistory status to rejected (-1) using query wrapper
    history.status = -1;
    try {
        OLLMfiles.FileHistory.query(db).updateById(history);
    } catch (GLib.Error e) {
        GLib.warning("Failed to update FileHistory status: %s", e.message);
    }
    
    // Update file's is_need_approval flag (file may need re-approval after revert)
    this.is_need_approval = true;
    this.saveToDB(db, null, false);
}
```

### CSS Styling

Add CSS classes to buttons:

1. **Approve Button**:
   ```vala
   this.approve_button = new Gtk.Button.with_label("Approve") {
       css_classes = {"oc-approve", "suggested-action"}
   };
   ```

2. **Reject Button**:
   ```vala
   this.reject_button = new Gtk.Button.with_label("Reject") {
       css_classes = {"oc-reject"}
   };
   ```

**CSS Classes** (add to `resources/style.css`):

```css
/* Approve button - uses suggested-action for primary styling */
.oc-approve {
  /* No styling currently, class exists for potential future use */
}

/* Reject button - no styling currently */
.oc-reject {
  /* No styling currently, class exists for potential future use */
}
```

## Implementation Tasks

### Approvals Widget Refactoring
- [ ] Change `Approvals` from `extends Gtk.Button` to `extends Gtk.Box`
- [ ] Set orientation to `Gtk.Orientation.HORIZONTAL`
- [ ] Create `next_button` as internal `Gtk.Button` with "task-due" icon
- [ ] Move all existing popover functionality from `this` to `next_button`
- [ ] Move motion controllers from `this` to `next_button`
- [ ] Set popover parent to `next_button`
- [ ] Create `approve_button` as `Gtk.Button`
- [ ] Create `reject_button` as `Gtk.Button` with "edit-undo" icon
- [ ] Append all three buttons to the box
- [ ] Add CSS classes to approve and reject buttons

### Functionality
- [ ] Connect approve button click handler
- [ ] Connect reject button click handler
- [ ] Implement `update_button_visibility()` method
- [ ] Update `update_selected_file()` to call `update_button_visibility()`
- [ ] Connect to `review_files.items_changed` signal to update button visibility
- [ ] Update overall widget visibility based on button visibility

### File.approve() Method
- [ ] Add `approve()` method to File class
- [ ] Set `is_need_approval = false` and save to database
- [ ] Query FileHistory records for this file using query wrapper
- [ ] Update each FileHistory record to status = 1 using `updateById()`
- [ ] Add error handling

### FileHistory.commit() Update
- [ ] Update `commit()` method to handle "revert" change_type
- [ ] Add "revert" to backup creation condition (along with "modified" and "deleted")

### File.revert() Method
- [ ] Add `revert()` async method to File class
- [ ] Query FileHistory records with backup_path for this file
- [ ] Find most recent FileHistory record with backup
- [ ] Check if backup file exists
- [ ] Handle "added" change type (throw error, cannot revert)
- [ ] Create new FileHistory record with change_type="revert" before restoring
- [ ] Set revert history status to 1 (approved)
- [ ] Call `revert_history.commit()` to backup current content (rejected content)
- [ ] Copy backup file back to original path
- [ ] Create parent directory if needed (for deleted files)
- [ ] Update File object metadata after restore
- [ ] Reload buffer if it exists (call `buffer.read_async()` to refresh editor content)
- [ ] Update original FileHistory status to -1 (rejected) using `updateById()`
- [ ] Set `is_need_approval = true` after revert
- [ ] Add error handling for missing backup files
- [ ] Add error handling for buffer reload failures

### Project.refresh_review() Method
- [ ] Add `refresh_review()` method to Folder class
- [ ] Check if folder is a project (is_project = true)
- [ ] Call `review_files.refresh()` wrapper

### CSS Styling
- [ ] Add `.oc-approve` CSS class to `resources/style.css` (no styling currently)
- [ ] Add `.oc-reject` CSS class to `resources/style.css` (no styling currently)

### UI Integration
- [ ] Add Approvals widget to main UI (toolbar/header area)
- [ ] Test all workflows

## Testing

- Test Approvals widget appears as horizontal box with three buttons
- Test next button shows task-due icon and popover on mouseover
- Test approve button only visible when file selected
- Test approve button disappears when file approved
- Test reject button only visible when file selected and has backup
- Test reject button disappears when no file selected or no backup
- Test widget visibility updates based on ReviewFiles count
- Test approve button approves file and FileHistory
- Test reject button restores file from backup
- Test clicking files in popover selects them and updates button visibility
- Test ReviewFiles.items_changed signal updates button visibility
- Test all buttons update correctly when selection changes
- Test FileHistory.revert() method works correctly
- Test revert updates FileHistory status to rejected
- Test revert sets file.is_need_approval = true
- Test revert creates new FileHistory record with change_type="revert"
- Test revert FileHistory record has status = 1 (approved)
- Test revert FileHistory record backs up the rejected content
- Test FileHistory.commit() handles "revert" change_type correctly
- Test revert reloads buffer if file is open in editor
- Test revert updates editor content to show reverted version
- Test revert handles buffer reload errors gracefully