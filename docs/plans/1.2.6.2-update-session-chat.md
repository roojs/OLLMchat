# 1.2.6.2. Update Session to Use Agent Instead of Direct Chat Access

## Overview

Refactor message flow to go through Manager: UI creates Message objects and calls `manager.send(fid, message)`, which routes to `session.send(message)`. Session adds the Message to session history, and if message.role == "user", delegates to AgentHandler. AgentHandler builds the full message history from session data and sends it to Chat. Remove `this.chat` from SessionBase (it was a temporary solution). Session should only manage message history, and Chat should be created per request by AgentHandler. Also update Chat's `send()` method to take messages array as argument and reset everything when called.

**Parent Plan**: [1.2.6. Update Legacy Methods](./1.2.6-update-legacy-methods.md)

**Prerequisite**: [1.2.6.1. Update Client Method Signatures](./1.2.6.1-update-client-method-signatures.md) must be complete

## Status

⏳ **TODO** - Needs implementation.

## Architectural Changes

### 1. Remove `this.chat` from SessionBase

**Current State**:
- `SessionBase` has `public Call.Chat? chat { get; set; }` (line 32 in `SessionBase.vala`)
- `SessionBase` constructor creates `this.chat` (line 157)
- Session uses `this.chat` for various operations (fid, reply, cancellation, etc.)

**New State**:
- Remove `this.chat` property from `SessionBase`
- Session should only have access to AgentHandler (via `session.agent` property)
- Users can get chat from AgentHandler: `agent_handler.get_chat()` or similar method (if needed)
- **Note**: AgentHandler creates Chat objects per request, so there may not be a persistent Chat on Session. Need to determine how UI accesses Chat for display.

**Impact**:
- `Session.fid` currently returns `this.chat.fid` (line 54) - **Change**: `fid` should be owned by Session, not Chat
- `Session.send()` uses `this.chat` for reply() and cancellation - needs refactoring
- UI accesses `session.chat` - needs alternative access pattern
- `SessionPlaceholder` and `EmptySession` create/use `this.chat` - needs refactoring

### 1.1. Move `fid` Ownership from Chat to Session

**Current State**:
- `Chat` has `public string fid = ""` field (line 100 in `Chat.vala`)
- `Chat` constructor generates `fid` from timestamp (line 113)
- `Session.fid` is computed property that returns `this.chat.fid` (line 54 in `Session.vala`)
- `Session.on_message_created()` copies `fid` from new chat: `this.chat.fid = new_chat.fid` (line 115)

**Rationale**:
- `fid` (file ID) is a session identifier, not a chat identifier
- Session is the persistent entity that owns the conversation history
- Chat is a transient request object that should not own session-level data
- This aligns with the principle that Chat should be stateless and reusable

**New State**:
- `fid` should be a property on `SessionBase` with `public get, protected set` (no backing storage needed)
- `Session` constructor should generate `fid` from timestamp
- `Chat.fid` should be **removed completely** - users can access via `chat.agent.session.fid` (where `chat.agent` is AgentHandler)
- Remove `fid` field from `Chat` constructor
- Remove `this.chat.fid = new_chat.fid` assignment in `Session.on_message_created()`

**Implementation**:
```vala
// SessionBase.vala
// File ID: Format Y-m-d-H-i-s (e.g., "2025-01-15-14-30-45")
// Owned by Session, not Chat
public abstract string fid { get; protected set; }

// Session.vala
public Session(Manager manager, Call.Chat chat)
{
    // ... existing code ...
    // Generate fid from current timestamp (format: YYYY-MM-DD-HH-MM-SS)
    var now = new DateTime.now_local();
    this.fid = now.format("%Y-%m-%d-%H-%M-%S");
    // ... rest of constructor ...
}

// Chat.vala
// Note: fid is removed completely from Chat
// Users can access via: chat.agent.session.fid

public Chat(Settings.Connection connection, string model, Call.Options? options = null)
{
    // ... existing code ...
    // Note: fid is no longer generated here - it's owned by Session
    // ... rest of constructor ...
}
```

### 2. Update Chat's `send()` Method

**Current State**:
- `Chat.exec_chat()` uses `this.messages` array (line 447)
- Messages array must be prepared before calling `exec_chat()`

**New State**:
- `send()` should take messages array as argument: `public async Response.Chat send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null)`
- `send()` should reset all state when called:
  - Clear/reset `streaming_response`
  - Clear/reset any internal state
  - Use the provided messages array instead of `this.messages`

**Benefits**:
- Makes Chat more stateless and reusable
- Each call is independent
- No need to clear messages array before calling
- Clearer API - messages are passed explicitly

## Flow Context

**Proposed New Flow**:
```
UI → Manager.send(fid, message) 
  → Session.send(message)
    → Session adds Message to session history
    → If message.role == "user": Session passes to AgentHandler
      → AgentHandler builds full message history from Session.messages
      → AgentHandler creates Chat and calls chat.send(messages, cancellable)
```

**Manager.send() Signature**:
```vala
public async void send(string fid, Message message, GLib.Cancellable? cancellable = null) throws Error
```

**Session.send() Signature**:
```vala
public async void send(Message message, GLib.Cancellable? cancellable = null) throws Error
```

**Flow Details**:
1. **UI calls `manager.send(fid, message, cancellable)`**
   ```vala
   var user_msg = new Message(null, "user", "Hello!");
   yield manager.send("2025-01-15-14-30-45", user_msg, cancellable);
   ```
   - `fid` (string): Session identifier, e.g., "2025-01-15-14-30-45"
   - `message` (Message): Message object with type and content, e.g., `new Message(null, "user", "Hello!")`
   - `cancellable` (GLib.Cancellable?): Optional cancellation token
   - Manager finds session by `fid` and calls `session.send(message, cancellable)`

2. **Session.send(message, cancellable) adds Message to history**
   ```vala
   public async void send(Message message, GLib.Cancellable? cancellable = null) throws Error
   {
       // Add to session history
       this.messages.add(message);  // Add to session.messages array
       this.manager.message_added(message, this);  // Emit signal to notify UI
   }
   ```
   - Receives `Message` object (already created by UI)
   - Adds `message` to `session.messages` array
   - Emits `manager.message_added(message, this)` signal to notify UI
   - UI receives signal immediately and can display the user message

3. **If message.role == "user", Session passes to AgentHandler**
   ```vala
   if (message.role == "user") {
       // Session has reference to agent (AgentHandler)
       if (this.agent != null) {
           yield this.agent.send_async(this, message, cancellable);
       } else {
           throw new OllamaError.INVALID_ARGUMENT("No agent available for session");
       }
   }
   ```
   - Session has `agent` property (AgentHandler) - set when session is created or when AgentHandler is changed
   - If user changes AgentHandler, need to copy chat/messages from old AgentHandler to new AgentHandler
   - Calls `this.agent.send_async(message, cancellable)`:
     - `message` (Message): The user message that was just added to session
     - `cancellable` (GLib.Cancellable?): Cancellation token
     - AgentHandler uses `this.session` (set in constructor) to access session.messages

4. **AgentHandler.send_async(message, cancellable) builds full message history**
   ```vala
   // AgentHandler.vala
   public async void send_async(Message message, GLib.Cancellable? cancellable = null) throws Error
   {
       var messages = new Gee.ArrayList<Message>();
       
       // Build system prompt at this point in time
       // CodeAssistant does this, BasicAgent does nothing
       string system_content = this.agent.generate_system_prompt();
       if (system_content != "") {
           messages.add(new Message(null, "system", system_content));
       }
       
       // Filter and add messages from this.session.messages (full conversation history)
       // Note: The user message was already added to session.messages in step 2
       // AgentHandler filters messages to get API-compatible messages (system, user, assistant, tool)
       // Filters out: "user-sent", "ui", and other non-API message types
       foreach (var msg in this.session.messages) {
           // Filter: only include API-compatible message roles
           if (msg.role == "system" || msg.role == "user" || msg.role == "assistant" || msg.role == "tool") {
               messages.add(msg);
           }
           // Skip: "user-sent", "ui", etc. (these are for UI/persistence only)
       }
       
       // Create Chat for this request
	   // add fixme that this should not be using client and needs to be fixed
       var chat = new Call.Chat(this.session.client.connection, this.session.model) {
           cancellable = cancellable,
           stream = true,
           think = true,
           options = this.get_options_for_model(this.session.model)
       };
       
       // Send full message array
       var response = yield chat.send(messages, cancellable);
   }
   ```
   - Receives `message` (the user message that was just added to session)
   - Uses `this.session` (set in AgentHandler constructor) to access session.messages
   - **System prompt generation**: AgentHandler builds system prompt at this point in time
     - **BaseAgentHandler**: Simple implementation - calls `agent.generate_system_prompt()`
     - **CodeAssistantHandler**: Overrides to build complex system prompt with current context (regenerated each call)
   - **Message filtering**: AgentHandler filters `session.messages` to get API-compatible messages
     - **Includes**: "system", "user", "assistant", "tool" roles
     - **Excludes**: "user-sent", "ui", and other non-API message types (these are for UI/persistence only)
   - Prepares complete message array: system messages + filtered `session.messages`
   - Creates new `Call.Chat` object for this request (not stored on session)
   - Calls `chat.send(messages, cancellable)` with full message array
   
   **Note**: This logic is already in AgentHandler (see `libollmchat/Prompt/AgentHandler.vala`), but needs to be updated to:
   - Filter messages from `session.messages` instead of building messages differently
   - Build system prompt at this point (simple implementation in base, CodeAssistantHandler overrides)
   - Use the new `chat.send(messages, cancellable)` signature

5. **Chat.send(messages, cancellable) executes the request**
   ```vala
   public async Response.Chat send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null) throws Error
   {
       // Reset state
       this.streaming_response = null;
       this.cancellable = cancellable;
       
       // Send request with provided messages array
       // Streams response back via callbacks/streaming handlers
   }
   ```
   - Sends full message array to API
   - Streams response back to AgentHandler via streaming callbacks/handlers
   - AgentHandler receives chunks via streaming handlers (not shown in signature, but handled internally)

6. **AgentHandler processes streaming response and adds assistant message**
   ```vala
   // Inside AgentHandler.send_async(), after chat.send() returns or during streaming:
   // AgentHandler receives streaming chunks and builds assistant message
   var assistant_msg = new Message(null, "assistant", response_content);
   yield session.send(assistant_msg);
   ```
   - AgentHandler receives streaming response from Chat (via callbacks/handlers)
   - AgentHandler creates assistant `Message` object from response content
   - AgentHandler calls `session.send(assistant_message)`:
     - `assistant_message` (Message): The assistant's response message
   - `session.send()`:
     - Adds `assistant_message` to `session.messages` array
     - Emits `manager.message_added(assistant_message, session)` signal
   - UI receives signal and displays the assistant message

**Current Architecture (Temporary)**:
- `SessionBase` has `this.chat` created in constructor
- Session uses `this.chat` for operations
- UI accesses `session.chat` for display

**New Architecture (Target)**:
- `SessionBase` does NOT have `this.chat`
- Session manages message history (`session.messages`)
- Manager routes messages via `manager.send(fid, message)` where message is a Message object
- Session adds messages to history
- AgentHandler builds full history and sends to Chat
- Chat is created per request by AgentHandler, not stored on Session

**How Messages Flow Through the System**:
1. **UI → Manager**: UI creates `Message` object, calls `manager.send(fid, message)`
2. **Manager → Session**: Finds session by `fid`, calls `session.send(message)`
3. **Session adds Message**: Calls `session.send(message)` which adds to `session.messages` and emits `message_added` signal
4. **Session → AgentHandler**: If `message.role == "user"`, calls `agent_handler.send_async(message, cancellable)`
5. **AgentHandler builds history**: Reads `session.messages`, prepares full message array
6. **AgentHandler → Chat**: Creates `Call.Chat`, calls `chat.send(messages, cancellable)`
7. **Chat → API**: Sends request, streams response back to AgentHandler
8. **AgentHandler processes response**: Receives streaming response, creates assistant Message objects
9. **AgentHandler → Session**: Sees it's an assistant message, calls `session.send(assistant_message)`
10. **Session → Manager**: `send()` emits `manager.message_added(message, session)` signal
11. **Manager → UI**: UI receives signal and displays message

**Session.send()** (line 299):
- Method that adds message to `session.messages` array
- Emits `manager.message_added(message, this)` signal to notify UI
- UI receives `SessionBase` so it can access `session.client` and session properties

**Manager.message_added()** signal (line 93 in `Manager.vala`):
- Signal emitted when a message is added to a session
- Emitted with `(Message, SessionBase?)` parameters
- UI connects to this signal to display messages
- Messages carry all necessary information for display
- Session can be accessed via `session.fid` to identify which session the message belongs to

## Goal

1. Add `Manager.send(fid, message)` as the entry point for UI to send messages (message is a Message object)
2. Add `Session.agent` property (AgentHandler?) - Session has reference to AgentHandler, not retrieved from manager
3. Update `Session.send(message)` to add Message to history and delegate to `this.agent.send_async()` if `message.role == "user"`
4. Update `AgentHandler.send_async(message, cancellable)` method to:
   - Build system prompt at this point in time (simple implementation in base, CodeAssistantHandler overrides)
   - Filter messages from `session.messages` to get API-compatible messages (system, user, assistant, tool)
   - Exclude non-API message types (user-sent, ui, etc.) - these are for UI/persistence only
   - Build full message array and send to Chat using `chat.send(messages, cancellable)`
5. Handle AgentHandler changes - when user changes AgentHandler, copy chat/messages from old AgentHandler to new AgentHandler
6. Update Chat's `send()` method to take messages array as argument and reset state
7. Remove `this.chat` from `SessionBase` - Session should only manage message history
8. Refactor all code that uses `session.chat` - Chat is created per request by AgentHandler, not stored on Session

## Current Implementation

### SessionBase.chat Property

**File**: `libollmchat/History/SessionBase.vala` (line 32)

```vala
public Call.Chat? chat { get; set; }
```

**Created in constructor** (line 157):
```vala
this.chat = new Call.Chat(this.client.connection, model) {
    stream = true,
    think = false
};
```

**Used in**:
- `Session.fid` getter (line 54): `return this.chat.fid;` - **Will change**: `fid` owned by Session, not Chat
- `Session.send()` (line 425, 429, 434, 469): Uses `this.chat` for stream, reply, cancellation
- `Session.on_message_created()` (line 108-115): Updates `this.chat` properties from new chat (including `this.chat.fid = new_chat.fid` which will be removed)
- `Session.on_stream_chunk()` (line 172, 184, 203, 208): Creates Messages with `this.chat`
- `SessionPlaceholder.load()` (line 69, 79, 106, 120, 129): Uses `this.chat`
- `EmptySession.send()` (line 36, 76): Uses `this.chat`
- `SessionBase.permission_provider` setter (line 50): Sets on `this.chat`

### Chat.send() Method

**File**: `libollmchat/Call/Chat.vala` (line 444)

**Current**:
```vala
public async Response.Chat exec_chat() throws Error
{
    // Agent/handler must prepare the messages array before calling exec_chat()
    if (this.messages.size == 0) {
        throw new OllamaError.INVALID_ARGUMENT("Chat messages array is empty...");
    }
    // ... uses this.messages
}
```

**Problem**: Uses `this.messages` array, requires preparation before calling.

## Proposed Changes

### 1. Add Manager.send() Method

**New Method**:
```vala
// Manager.vala
// HashMap for fast fid lookup (fid -> SessionBase)
private Gee.HashMap<string, SessionBase> sessions_by_fid = new Gee.HashMap<string, SessionBase>();

public async void send(string fid, Message message, GLib.Cancellable? cancellable = null) throws Error
{
    // Find session by fid using HashMap lookup
    var session = this.sessions_by_fid.get(fid);
    if (session == null) {
        throw new OllamaError.INVALID_ARGUMENT("Session with fid '%s' not found", fid);
    }
    
    // Delegate to session
    yield session.send(message, cancellable);
}
```

**Note**: Manager should maintain `sessions_by_fid` HashMap:
- Add to HashMap when session is created: `sessions_by_fid.set(session.fid, session)`
- Remove from HashMap when session is removed: `sessions_by_fid.unset(session.fid)`
- Update HashMap when session.fid changes (if that's allowed)

### 2. Update Session.send() Method

**New Signature**:
```vala
// SessionBase.vala
public abstract async void send(Message message, GLib.Cancellable? cancellable = null) throws Error;
```

**Session.send() Implementation**:
```vala
// Session.vala
public async void send(Message message, GLib.Cancellable? cancellable = null) throws Error
{
    // Add to session history
    this.messages.add(message);
    
    // Emit signal to notify UI
    this.manager.message_added(message, this);
    
    // If user message, pass to AgentHandler
    if (message.role == "user") {
        // Session has reference to AgentHandler
        if (this.agent != null) {
            yield this.agent.send_async(message, cancellable);
        } else {
            throw new OllamaError.INVALID_ARGUMENT("No agent available for session");
        }
    }
}
```

**Session.agent Property**:
```vala
// SessionBase.vala
public AgentHandler? agent { get; set; }
```

**AgentHandler Change Handling**:
- When user changes AgentHandler, need to copy chat/messages from old AgentHandler to new AgentHandler
- Session maintains reference to current AgentHandler
- AgentHandler is set when session is created or when user changes AgentHandler
- AgentHandler is created from BaseAgent (via `BaseAgent.create_handler(client, session)`)

### 3. Update AgentHandler.send_async() to Build History from Session

**AgentHandler.send_async() Signature**:
```vala
// AgentHandler.vala
public async void send_async(Message message, GLib.Cancellable? cancellable = null) throws Error
{
    // Build full message history from this.session
    var messages = new Gee.ArrayList<Message>();
    
    // Build system prompt at this point in time
    // BaseAgentHandler: Simple implementation - just calls agent.generate_system_prompt()
    // CodeAssistantHandler: Overrides to build complex system prompt with current context
    string system_content = this.agent.generate_system_prompt();
    if (system_content != "") {
        messages.add(new Message(null, "system", system_content));
    }
    
    // Filter and add messages from this.session.messages (full conversation history)
    // Filter to get API-compatible messages (system, user, assistant, tool)
    // Exclude non-API message types (user-sent, ui, etc.)
    foreach (var msg in this.session.messages) {
        if (msg.role == "system" || msg.role == "user" || msg.role == "assistant" || msg.role == "tool") {
            messages.add(msg);
        }
    }
    
    // Create Chat for this request
    var chat = new Call.Chat(this.session.client.connection, this.session.model) {
        cancellable = cancellable,
        stream = true,
        think = true,
        options = this.get_options_for_model(this.session.model)
    };
    
    // Send full message array
    var response = yield chat.send(messages, cancellable);
    
    // Process response and add assistant messages to session via session.send()
    // ...
}
```

### 4. Remove `this.chat` from SessionBase

**Steps**:
1. **Move `fid` ownership from Chat to Session**:
   - Add `fid` property to `SessionBase` with `public get, protected set` (no backing storage)
   - Generate `fid` in `Session` constructor from timestamp
   - Remove `fid` field completely from `Chat` class
   - Remove `fid` generation from `Chat` constructor
   - Remove `this.chat.fid = new_chat.fid` assignment in `Session.on_message_created()`
2. Remove `public Call.Chat? chat { get; set; }` from `SessionBase`
3. Remove Chat creation from `SessionBase` constructor
4. Update `Session.on_message_created()` to not update `this.chat` (chat doesn't exist)
5. Update `Session.on_stream_chunk()` to get Chat from message or agent
6. Update `SessionPlaceholder` and `EmptySession` to not use `this.chat`
7. Update `SessionBase.permission_provider` setter to not set on `this.chat`
8. Update UI code to call `manager.send(fid, type, message)` instead of `session.send()`

**Alternative Access Patterns**:
- **For fid**: Store `fid` directly on SessionBase as a property with `public get, protected set`. `Chat.fid` is removed - users access via `chat.agent.session.fid` (where `chat.agent` is AgentHandler)
- **For reply()**: Create new Chat or get from AgentHandler
- **For cancellation**: Track cancellable separately or via AgentHandler
- **For Messages**: Messages have `message_interface` which can be Chat
- **For UI**: Access Chat via `message.message_interface` or via AgentHandler

### 2. Update Chat.send() Method

**New Signature**:
```vala
public async Response.Chat send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null) throws Error
```

**Behavior**:
- Takes messages array as argument (instead of using `this.messages`)
- Resets all state when called:
  - `this.streaming_response = null`
  - Clear any internal state
  - Use provided messages array (don't modify `this.messages`)
- Returns Response.Chat

**Implementation**:
```vala
public async Response.Chat send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null) throws Error
{
    if (messages.size == 0) {
        throw new OllamaError.INVALID_ARGUMENT("Chat messages array is empty. Provide messages to send.");
    }
    
    // Reset state
    this.streaming_response = null;
    this.cancellable = cancellable;
    
    // Use provided messages (create temporary array for API call)
    var api_messages = new Gee.ArrayList<Message>();
    foreach (var msg in messages) {
        api_messages.add(msg);
    }
    
    // Store messages in this.messages for serialization/access (but don't require it for send)
    this.messages = api_messages;
    
    if (this.stream) {
        return yield this.execute_streaming();
    }
    
    return yield this.execute_non_streaming();
}
```

**Update call sites**:
- `AgentHandler.send_async()`: Change `call.exec_chat()` to `call.send(call.messages, cancellable)`
- `CodeAssistantHandler.send_async()`: Same change
- `Session.send()`: Create Chat, prepare messages, call `chat.send(messages, cancellable)`
- `Client.chat()`: Prepare messages, call `call.send(messages, cancellable)`

## Implementation Steps

### Phase 1: Update Chat.send() Method
1. Update `send()` signature to take messages array: `send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null)`
2. Add state reset logic
3. Update all call sites to pass messages array

### Phase 2: Move `fid` Ownership from Chat to Session
1. Add `fid` property to `SessionBase` with `public get, protected set` (no backing storage)
2. Generate `fid` in `Session` constructor from timestamp
3. Remove `fid` field completely from `Chat` class
4. Remove `fid` generation from `Chat` constructor
5. Remove `this.chat.fid = new_chat.fid` assignment in `Session.on_message_created()`
6. Update any code that accesses `chat.fid` to use `chat.agent.session.fid` instead

### Phase 3: Add Manager.send() and Update Session.send()
1. Add `Manager.send(fid, message)` method (message is a Message object)
2. Add `Session.agent` property (AgentHandler?) - set when session is created or AgentHandler is changed
3. Update `Session.send(message)` signature and implementation
4. Update `Session.send()` to add Message to session history
5. Update `Session.send()` to delegate to `this.agent.send_async()` if `message.role == "user"`
6. Update `AgentHandler.send_async(message, cancellable)` method to:
   - Build system prompt at this point in time (simple implementation in base, CodeAssistantHandler overrides)
   - Filter messages from `session.messages` to get API-compatible messages (system, user, assistant, tool)
   - Exclude non-API message types (user-sent, ui, etc.)
   - Use `chat.send(messages, cancellable)` with filtered message array
7. Handle agent changes - when user changes agent, copy chat/messages from old AgentHandler to new AgentHandler
8. Update UI code to create Message objects and call `manager.send(fid, message)` instead of direct session access

### Phase 4: Remove `this.chat` from SessionBase
1. Update `Session.on_message_created()` to not update `this.chat` (chat doesn't exist)
2. Update `Session.on_stream_chunk()` to get Chat from message or AgentHandler
3. Update `SessionPlaceholder` and `EmptySession`
4. Update `SessionBase.permission_provider` setter
5. Remove `this.chat` property from `SessionBase`
6. Remove Chat creation from `SessionBase` constructor

### Phase 5: Update UI Access Pattern
1. Update UI code to create Message objects and call `manager.send(fid, message)` instead of `session.send()`
2. Remove UI code that accesses `session.chat` (no longer needed)
3. Test UI still works for displaying messages

## Test

1. Verify Session still works for first message
2. Verify reply() still works for subsequent messages
3. Verify UI can still access Chat for display
4. Verify cancellation still works
5. Verify fid is still accessible

## Result

- `fid` is owned by Session (via SessionBase property with `public get, protected set`) - `Chat.fid` is removed completely
- UI creates Message objects and calls `manager.send(fid, message)` to send messages
- `Session.send(message)` adds Message to history, delegates to AgentHandler if `message.role == "user"`
- `AgentHandler.send_async()` builds full message history from `this.session.messages` and sends to Chatw
- Chat's `send()` method takes messages array and resets state
- Session no longer has `this.chat` - only manages message history (`session.messages`)
- Chat is created per request by AgentHandler, not stored on Session

## Files to Modify

- `libollmchat/Call/Chat.vala` - Update `send()` signature to take messages array; Remove `fid` field completely
- `libollmchat/History/Manager.vala` - Add `send(fid, message)` method (message is Message object); Add `sessions_by_fid` HashMap for fast fid lookup; Maintain HashMap when sessions are created/removed
- `libollmchat/History/SessionBase.vala` - Add `fid` property with `public get, protected set`; Add `agent` property (AgentHandler?); Add abstract `send(message)` method; Remove `this.chat` property and creation
- `libollmchat/History/Session.vala` - Generate `fid` in constructor; Set `agent` property (AgentHandler) when session is created or AgentHandler is changed; Update `send(message)` to add Message to history, delegate to `this.agent.send_async()` if `message.role == "user"`; Handle AgentHandler changes (copy chat/messages from old AgentHandler to new); Update to not use `this.chat`
- `libollmchat/Prompt/AgentHandler.vala` - Update `send_async(message, cancellable)` method to build system prompt, filter messages from `this.session.messages`, and use `chat.send(messages, cancellable)`
- `libollmchat/History/SessionPlaceholder.vala` - Update `send()` implementation; Update to not use `this.chat`
- `libollmchat/History/EmptySession.vala` - Update `send()` implementation; Update to not use `this.chat`
- `liboccoder/Prompt/CodeAssistantHandler.vala` - Update `send_async()` similarly
- `libollmchat/Client.vala` - Update to use `chat.send(messages, cancellable)`
- UI files (e.g., `ChatWidget.vala`) - Update to create Message objects and call `manager.send(fid, message)` instead of `session.send()`

## Related Plans

- [1.2.6.1. Update Client Method Signatures](./1.2.6.1-update-client-method-signatures.md) - Prerequisite
- [1.2.7. Move Signals to Chat](./1.2.7-move-signals-to-chat.md) - Related plan for signal architecture
- [1.10. Refactor Agents as Interface](./1.10-refactor-agents-interface.md) - Documents the planned UI → Manager → Agent → Chat flow
