# 1.23.15 Task refinements

**FORBIDDEN:** Never write long paragraphs in this plan. They are unreadable. **ALWAYS** use short bullet points and nested bullet points only.

**Scope:** Task classes only (liboccoder/Task/: List, Step, Details, ResultParser, **Tool**). Runner/PromptTemplate → 1.23.14.

**Coding standards:** Follow `.cursor/rules/CODING_STANDARDS.md`. When implementing:
- Nullable avoided; null checks only where design requires; no `@"..."`
- No one-use temporaries (inline); braces inline for control flow; **this.**; **GLib.** prefix
- Default init on properties; **string[]** and **joinv**; **continue** in loops; no character loops
- Try/catch only around minimal throwing code; no leading underscore; no get_* accessors
- Use **continue** in loops; avoid **else** and nested **if** inside loops

---

## Overview

- Follow-on to **1.23.13** (DONE)
- Task classes implemented; this plan = remaining bugs/alignment **within** Task namespace only
- **Dependencies:** 1.23.13 (task-related code, DONE)

**Status:** DONE (items deferred to 1.23.16 are out of scope here).

**Deferred to 1.23.16 (ignore for this plan):**
- Markdown.Document headings keyed by anchor (`heading_text_to_anchor`); ResultParser/consumers switch to anchor keys (e.g. `tool-calls`, `refined-task`).
- Adding Tool.vala to meson (1.23.15 §4 explicitly excludes this; 1.23.16 §5 delivers it).

---

## Details (`liboccoder/Task/Details.vala`)

### tool_calls never populated (refine stage — solved by Tool class)

- **Reference:** [Ollama tool calling](https://docs.ollama.com/capabilities/tool-calling) — use as reference for JSON structure and tool-call semantics.
- **Problem:** code_blocks from refinement are never turned into executable tool calls; run_tools() has nothing to run.
- **Refinement section:** **## Tool Calls** (exact heading). After "Refined task"; one fenced code block per call.
- **JSON format per call** (one code block per call; standardized):
  - Block body = single JSON object: **uid** (unique id), **name** (tool name), **arguments** (object, e.g. `{"city": "London"}`).
  - Example: `{ "uid": "{unique_id}", "name": "{toolname}", "arguments": {"city": "London"} }`
  - Parser: parse block as JSON; read uid, name, arguments; build ToolCall (id = uid, function.name = name, function.arguments = arguments).
- **How to use a tool (prompt instructions only):** When we tell the LLM how to use a tool, output only this (simplified; no full Ollama wrapper):
  - **name**, **description**, **parameters** (type, required, properties) — e.g. `{ "name": "get_temperature", "description": "Get the current temperature for a city", "parameters": { "type": "object", "required": ["city"], "properties": { "city": {"type": "string", "description": "The name of the city"} } } }`
  - Slightly different from standard tool/API payload; enough for the LLM to know name, description, and argument schema.
- **Tools spec (runtime):** ToolCall has id (= uid), function (name + arguments Json.Object). Key by function.name; Message.tool_reply(id, name, result).
- **Solution (Tool class)**
  - **Tool** (see ## Tool below): **Tool(task)** then **parse(block)**; validate then execute. Ctor takes task only; parse(block) takes the block.
  - **ResultParser:** "## Tool Calls" walk (key **"Tool Calls"** — heading text; 1.23.16 will add heading_text_to_anchor and switch to anchor key "tool-calls"): for each fenced block, **new Tool(task)**, **tool.parse(block)**, task.tools.add(tool). Validation in refine stage; run_tools() does not validate.
  - **Details:** Holds list of **Tool** instances. run_tools(): yield tool.execute() only (no validate — done in refine).
- **Document:** Refinement format (## Tool Calls, JSON per block) in 1.23.12 and task_refinement.md; "how to use" format = name + description + parameters only.

---

### validate_references() — solution and URL / header rules

- **Accepted reference types**
  - **#anchor** — Section anchor in document/plan. Validate format (see below). Resolve via Runner.
  - **output:task_name** — Prior task output. Validate task_name non-empty; optionally match existing task. Resolve via Runner.
  - **Absolute file path** — Must exist on disk. Keep current behaviour.
  - **URL (http/https)** — Reference only; content via web fetch when building reference block. No tool in task code. validate_references(): accept http/https; no existence check; optional URL syntax (GLib.Uri.parse). Document: URLs supported; content fetched when building task reference block.
  - **#project-description** — Section anchor for project description. All code and references use **#project-description** only. Runner can register that section for resolution when building the task reference block. No literal "project_description" href; task list / prompts should use #project-description.
- **Section anchor standard**
  - Document in **document headers** code (Markdown / heading handling). Use anchors for section links, not title-based lookups.
  - **Rules (GFM/CommonMark):** Lowercase heading text; spaces → single hyphen (-); remove punctuation (keep hyphens).
  - **Examples:** # Section One → #section-one; ## Hello World → #hello-world; ### Project description → #project-description
  - Use when generating or resolving section links.
- **validate_references() changes**
  - Accept: `#*` (including #project-description), `output:*`, `http://*`, `https://*`, absolute path (file exists).
  - Reject else with clear message (list accepted types). URLs: no existence check; optional syntax check.

```vala
// Details.vala — validate_references() body (replace existing foreach)
foreach (var link in this.reference_targets) {
	var href = link.href;
	if (href.has_prefix("#")) {
		// FIXME: validate #anchor format and existence; defer for now
		continue;
	}
	if (href.has_prefix("output:")) {
		continue;
	}
	if (href.has_prefix("http://") || href.has_prefix("https://")) {
		continue;
	}
	if (GLib.Path.is_absolute(href)) {
		if (!GLib.File.new_for_path(href).query_exists()) {
			this.issues += "\n" + "Invalid reference target \"" + href + "\": file does not exist.";
		}
		continue;
	}
	this.issues += "\n" + "Invalid reference target \"" + href + "\". "
		+ "Use only: #anchor (e.g. #project-description), output:task_name, http(s) URL, or absolute file path (must exist).";
}
```

---

### validate_references() not called in parse path

- **Change:** In ResultParser.parse_step(), after constructing each Details, call **task.validate_references()** before checking task.issues.
- **Flow:** new Details → validate_references() → if issues then continue else add to step.

```vala
// ResultParser.parse_step() — inside foreach (var list_child in list_block.children)
var list_item = (Markdown.Document.ListItem) list_child;
var task_data = list_item.to_key_map();
var task = new Details(this.runner, this.runner.factory, this.runner.session, task_data);
task.validate_references();
if (task.issues != "") {
	this.issues += "\n" + "Section \"" + section_heading.to_markdown() +
		"\", a task in this section (References): " + task.issues;
	continue;
}
step.children.add(task);
last_task = task;
```

---

### Error handling

- **Task-class:** Errors from refine() / post_evaluate() must **include context** (task identifier, phase "refinement" or "executor", underlying message). Use GLib.IOError.INVAL or similar with task info in message. Do not swallow; rethrow with context.
- **refine():** In catch block set refine_error with message prefixed by task context (e.g. "Task refinement: " + e.message). When throwing after max attempts include result_parser.issues and task context.
- **post_evaluate():** When throwing after max attempts include task context in message.
- **Caller:** Runner catches and reports to user (1.23.14). Replace FIXME with comment: "Caller (Runner) must catch and report to user; see 1.23.14."

---

### Executor precursor format — tool name for outputs

- Output keyed by **tool name** (not ordinals). executor_precursor() already uses e.key (tool name) for "Tool call {name}" and "Tool call {name} Output".
- **Spec:** "Tool output {name}" where name = tool name. All tool calls must define a name (see Tool calls section); add to tool call instructions ("kludge into our tool call instructions").
- No code change in Details if already keying by name; align plan and prompt docs only.

---

## Tool (`liboccoder/Task/Tool.vala`)

- **Purpose:** One class per tool call. Wraps a single tool call; owns **parse**, **validate**, **to_instructions** (refine precursor), and **execute**.
- **Namespace:** OLLMcoder.Task (class **Tool**; file Tool.vala).
- **Constructor**
  - **Tool(Details task)** only. Block is passed to **parse(block)**; ctor does not take block.
- **Parse vs validate (split)**
  - **parse(Markdown.Document.Block block):** Read block body; parse as JSON; set this.uid, this.name, this.arguments. Build ToolCall; set this.tool_call. Do not strip uid/name/arguments.
  - **validate():** Clear this.issues. Check **this.name == ""** first (before tool_call), append to this.issues and return false. Then this.tool_call == null; then tool registered; then **argument validation** (original tool’s required parameters). Append to this.issues on failure. Empty-name check only in validate(), not in parse().
- **to_instructions (refine precursor)**
  - **Purpose:** Produce "how to use a tool" text/JSON for the **refine** stage so the LLM knows name, description, parameters (and optionally an example call).
  - **Content:** name, description, parameters only (simplified schema; see Details section). Optionally include **example call** JSON (one example { uid, name, arguments }) so the LLM can mimic format.
  - **Source:** Resolve **original tool** from task.runner / session (e.g. session.manager.tools.get(tool_name)). Original tool = OLLMchat.Tool.BaseTool (or equivalent) with name, description, parameter_description / Function.parameters. Extract name, description, parameters (e.g. from tool.function or tool.description + ParamParser).
  - **Example call:** Add optional property on **original tool** (e.g. OLLMchat.Tool.BaseTool): **example_call** — string (JSON) or Json.Object — one example call in our format { uid, name, arguments }. Refine prompt can include this so the LLM sees a concrete example. If not set, omit or try to **auto-generate** one example from parameters (e.g. one placeholder per required param).
  - **Derived / wrapped tools:** Tools that wrap another (e.g. RunCommand wrapping a .tool file) may have different parameters. Options: (1) Original tool (wrapper) exposes description/parameters and optional example_call; (2) Wrapped tool’s schema could be merged or chosen by skill. Document: derived tools should override or set **example_call** if they want a custom example; otherwise we use base tool’s schema and optionally auto-generate example from parameters.
- **execute():** If not parsed, call parse(); then validate(); if !valid return. Build list of one ToolCall; yield task.execute_tools(list); set task.tool_outputs and task.tool_calls from reply.
- **Lifecycle**
  - ResultParser: **new Tool(task)**, **tool.parse(block)**, task.tools.add(tool). Validation happens in the refine stage (ResultParser); run_tools() does **not** validate — it only executes. run_tools(): for each tool, **yield tool.execute()**.
- **Details integration**
  - Details holds list of Tool. ResultParser adds Tool(task, block) per ## Tool Calls block; parse and validate there. run_tools() iterates Tools; for each: **yield tool.execute()** (no validate in run_tools — already done in refine).
  - When building refine retry (e.g. current_skill_call_issues): aggregate **tool.issues** from all tools (or from tools that failed validate()) so the LLM receives per-call feedback and can fix the Tool Calls in the next refinement.

---

## ResultParser (`liboccoder/Task/ResultParser.vala`)

### Integration with Details.validate_references()

- In parse_step(), after `var task = new Details(...);` insert **task.validate_references();** then keep existing issues check and step.children.add(task).
- Every Details gets validate_references() before being added. Parser.issues then includes task_data and reference validation issues.
- **Code:** See code block under "validate_references() not called in parse path" above (ResultParser.parse_step() fragment).

---

## List and Step

- No outstanding issues recorded for List or Step (behaviour matches 1.23.13).

---

---

## Concrete code changes (codeblocks / Tool Calls)

- All changes for ## Tool Calls parsing, Tool class, Details.tools, and ResultParser. For review/approval.

### 1. New file: `liboccoder/Task/Tool.vala`

- Namespace **OLLMcoder.Task**. One class **Tool**.
- **Properties (set in parse):** **this.uid** (string, default ""), **this.name** (string, default ""), **this.arguments** (Json.Object?; default null; set only when JSON has arguments object). get_string_member returns empty string on failure, not null.
- **issues:** **this.issues** (string, default ""). Same pattern as Details: append with this.issues += "\n" + msg on validation failure. Clear at start of validate() (this.issues = "") so only current-round issues are reported. Caller aggregates tool.issues into refine prompt (e.g. current_skill_call_issues) so the LLM can fix the call.
- **Split parse / validate**
  - **parse():** Body only. Clear this.issues at start. Parse JSON; extract uid, name, arguments. Set this.uid, this.name, this.arguments. On invalid JSON or root not object, append to this.issues and return false. Build ToolCall (even if name empty); return true. Empty name is checked in validate() only.
  - **validate():** Clear this.issues. Check this.name == "" first (before tool_call), append to this.issues and return false. Then tool_call == null; then tool registered; then argument validation (required params). Append to this.issues on failure.
- **to_instructions (refine precursor)**
  - **Signature:** `public string to_instructions()` — no argument; uses **this.name**. Caller creates **new Tool(task) { name = tool_name }** then calls to_instructions().
  - **Build string/JSON:** Resolve original from task.runner.session.manager.tools.get(this.name). Build simplified schema: name, description, parameters (from base_tool.function); serialize to JSON string (Json.Object + Json.Generator). If original has **example_call** property, append to return. See concrete code in plan.
  - **Refine prompt fill:** For each tool name in the skill’s tools list: **new Tool(task) { name = tool_name }**, then to_instructions(); concatenate into "how to run tools" section.
  - **execute():** Caller must have called **parse(block)** and **validate()** before execute(). execute() only runs the tool call (build list, yield execute_tools, set tool_outputs and tool_calls).

```vala
// liboccoder/Task/Tool.vala — parse/validate split (review/approve)
namespace OLLMcoder.Task {
public class Tool : Object
{
	public weak Details task { get; construct; }
	public string uid { get; private set; default = ""; }
	public string name { get; set; default = ""; }
	public Json.Object? arguments { get; private set; default = null; }
	public string issues { get; set; default = ""; }
	public OLLMchat.Response.ToolCall? tool_call { get; private set; default = null; }

	public Tool(Details task)
	{
		Object(task: task);
	}

	/** Parse block: JSON → uid, name, arguments; set properties and tool_call. Set this.issues on parse failures. */
	public bool parse(Markdown.Document.Block block)
	{
		this.issues = "";
		var body = block.to_markdown().strip();
		Json.Parser p = new Json.Parser();
		try {
			p.load_from_data(body);
		} catch (GLib.Error e) {
			this.issues += "\n" + "Tool Calls: invalid JSON in block: " + e.message;
			return false;
		}
		var root = p.get_root();
		if (root == null || root.get_node_type() != Json.NodeType.OBJECT) {
			this.issues += "\n" + "Tool Calls: each block must be a JSON object with uid, name, arguments.";
			return false;
		}
		var obj = root.get_object();
		this.uid = obj.has_member("uid") ? obj.get_string_member("uid") : "";
		this.name = obj.has_member("name") ? obj.get_string_member("name") : "";
		if (obj.has_member("arguments") && obj.get_member("arguments").get_node_type() == Json.NodeType.OBJECT) {
			this.arguments = obj.get_object_member("arguments");
		}
		var args = this.arguments ?? new Json.Object();
		var func = new OLLMchat.Response.CallFunction.with_values(this.name, args);
		this.tool_call = new OLLMchat.Response.ToolCall.with_values(
			this.uid != "" ? this.uid : "call_" + this.name, func);
		return true;
	}

	/** Validate: empty name (first), then tool_call set, tool registered, required arguments. Append to this.issues for refine feedback. */
	public bool validate()
	{
		this.issues = "";
		if (this.name == "") {
			this.issues += "\n" + "Tool Calls: each block must have non-empty \"name\".";
			return false;
		}
		if (this.tool_call == null) {
			return false;
		}
		if (!this.task.runner.session.manager.tools.has_key(this.name)) {
			this.issues += "\n" + "Tool Calls: unknown tool \"" + this.name + "\".";
			return false;
		}
		var original = this.task.runner.session.manager.tools.get(this.name);
		if (!(original is OLLMchat.Tool.BaseTool)) {
			return true;
		}
		var base_tool = (OLLMchat.Tool.BaseTool) original;
		var params = base_tool.function.parameters;
		if (params == null) {
			return true;
		}
		foreach (var param in params.properties) {
			if (!param.required) {
				continue;
			}
			if (this.arguments != null && this.arguments.has_member(param.name)) {
				continue;
			}
			this.issues += "\n" + "Tool Calls: tool \"" + this.name + "\" requires argument \"" + param.name + "\".";
			return false;
		}
		return true;
	}

	/** Instructions for refine stage: name, description, parameters (uses this.name). Call after new Tool(task) { name = tool_name }. */
	public string to_instructions()
	{
		var original = this.task.runner.session.manager.tools.get(this.name);
		var base_tool = (OLLMchat.Tool.BaseTool) original;
		var schema = new Json.Object();
			schema.set_string_member("name", base_tool.function.name);
			schema.set_string_member("description", base_tool.function.description);
		var param_node = Json.gobject_serialize(base_tool.function.parameters);
			param_node.get_object().set_string_member("type", base_tool.function.parameters.x_type);
		schema.set_object_member("parameters", param_node.get_object());
		var root = new Json.Node(Json.NodeType.OBJECT);
		root.set_object(schema);
		var gen = new Json.Generator();
		gen.set_root(root);
		var ret = gen.to_data(null);
		if (base_tool.example_call != "") {
			ret += "\nExample: " + base_tool.example_call;
		}
		return ret;
	}

	/** Execute: caller must have called parse(block) and validate() before. */
	public async void execute() throws GLib.Error
	{
		var list = new Gee.ArrayList<OLLMchat.Response.ToolCall>();
		list.add(this.tool_call);
		var replies = yield this.task.execute_tools(list);
		foreach (var msg in replies) {
			if (msg.role == "tool" && msg.name != null && msg.content != null) {
				this.task.tool_outputs.set(msg.name, msg.content);
			}
		}
		this.task.tool_calls.set(this.tool_call.function.name, this.tool_call);
	}
}
}
```

### 1b. Original tool — example_call property (OLLMchat.Tool / Runner)

- **Add optional property** on the original tool type (e.g. OLLMchat.Tool.BaseTool or interface used by manager.tools): **example_call** — e.g. `string? example_call { get; set; default = null; }` — JSON string for one example call in our format: `{ "uid": "call_example_1", "name": "tool_name", "arguments": { ... } }`.
- **Use in to_instructions():** When building refine instructions, if original.example_call != null, append to the instructions (e.g. "Example call:\n" + example_call) so the LLM sees a concrete example.
- **Derived / wrapped tools:** Subclasses or wrappers can override or set example_call to a custom example (e.g. wrapper’s parameters). If not set, Task.Tool can try to auto-generate one example from parameters (e.g. one placeholder value per required param) or omit.
- **Where to add:** Plan in 1.23.14 or here: BaseTool (or the type in session.manager.tools) gets optional example_call; Task.Tool.to_instructions() reads it when building precursor for refine.

```vala
// OLLMchat.Tool.BaseTool (or type in session.manager.tools) — add property (empty string = not set)
public string example_call { get; set; default = ""; }
```

### 2. Details.vala — add tools list and run_tools() via Tool

- **Add property** (after code_blocks):
  - `public Gee.ArrayList<Tool> tools { get; set; default = new Gee.ArrayList<Tool>(); }`
- **run_tools():** Does **not** validate — validation is already done in the refine stage (ResultParser parses ## Tool Calls and validates each tool; issues aggregated for refine retry). Replace body: foreach tool in this.tools, **yield tool.execute()**. Note: in theory tool execution could be concurrent; we will update to concurrent execution later.

```vala
// Details.vala — add after code_blocks property
public Gee.ArrayList<Tool> tools { get; set; default = new Gee.ArrayList<Tool>(); }

// run_tools() — replace existing body (sequential for now; concurrent execution to be added later)
public async void run_tools() throws GLib.Error
{
	foreach (var tool in this.tools) {
		yield tool.execute();
	}
}
```

- **Tool.execute()** (in Tool.vala) after setting tool_outputs: add `this.task.tool_calls.set(this.tool_call.function.name, this.tool_call)` so Details.tool_calls is populated for executor_precursor.

### 3. ResultParser.extract_refinement() — add ## Tool Calls walk

- After the existing "Refined task" logic, add:
  - Look up section by heading text key **"Tool Calls"** (current Document behaviour; 1.23.16 will implement heading_text_to_anchor and then key becomes "tool-calls").
  - If document has heading for Tool Calls: get section contents; foreach node, if Block and FENCED_CODE: **var tool = new Tool(task); tool.parse((Markdown.Document.Block) node); task.tools.add(tool)**.
  - If Tool Calls section missing: do not append to issues (optional section for backward compat) or optionally append "Refinement should include ## Tool Calls with one JSON block per call (uid, name, arguments)."

```vala
// ResultParser.extract_refinement() — append before final closing brace of method
if (this.document.headings.has_key("tool-calls")) {
	foreach (var node in this.document.headings.get("tool-calls").contents()) {
		if (!(node is Markdown.Document.Block)) {
			continue;
		}
		var block = (Markdown.Document.Block) node;
		if (block.kind != Markdown.FormatType.FENCED_CODE_QUOTE
			&& block.kind != Markdown.FormatType.FENCED_CODE_TILD) {
			continue;
		}
		var tool = new Tool(task);
		tool.parse(block);
		if (!tool.validate()) {
			task.issues += tool.issues;
		}
		task.tools.add(tool);
	}
}
```

### 4. Build / meson

- **Do not add Tool.vala to meson anywhere until we are ready.** This plan is not ready for that. Add Tool.vala to liboccoder Task sources only when we explicitly decide we are ready (outside this plan).
- **WARNING: Do not modify this §4** to add Tool.vala to meson or to "when ready" wording that implies meson changes in this plan. We are explicitly NOT updating meson in this plan.

### 5. Prerequisites — what needs to exist or change before Tool can be wired in

- **OLLMchat.Tool.BaseTool.example_call** — Property exists (check != "" in to_instructions()). If not yet added, add per §1b.
- **Markdown.Document headings keyed by anchor** — In 1.23.16 (not this plan). This plan uses heading text key "Tool Calls"; 1.23.16 will implement heading_text_to_anchor() and update consumers to anchor keys.
- **Details.tools** — Property `Gee.ArrayList<Tool> tools` and run_tools() iterating and `yield tool.execute()` per §2.
- **ResultParser.extract_refinement()** — Tool Calls walk per §3; uses key "Tool Calls" (heading text); 1.23.16 will switch to "tool-calls".
- **Task.Tool class (Tool.vala)** — Uses: task.runner.session.manager.tools, BaseTool.function, BaseTool.example_call, task.execute_tools(), task.tool_outputs, task.tool_calls. Not in meson yet; do not add to meson in this plan (see §4).

### 6. Refined task code_blocks vs Tool Calls

- **Decision:** Keep **code_blocks** for blocks under "Refined task" (existing behaviour). **Tool Calls** section is separate; only its blocks become **Tool** instances. No change to existing code_blocks parsing under "Refined task"; add Tool Calls walk as above.

---

## References

- [Ollama tool calling](https://docs.ollama.com/capabilities/tool-calling) — reference for JSON tool-call format and semantics.
- 1.23.13 (task-related code, DONE); 1.23.14 (existing skill code updates); 1.23.12 (prompt refinements — ## Tool Calls section, JSON format, "how to use" = name+description+parameters); 1.23.16 (heading_text_to_anchor — headings keyed by anchor).
