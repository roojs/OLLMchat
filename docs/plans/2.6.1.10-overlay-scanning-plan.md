# 2.6.1.10. Overlay Scanning After Completion

## Overview

Replace the Monitor-based filesystem monitoring with a post-completion scanning approach. After command execution completes, scan the overlay directory structure to detect all changes (additions, modifications, deletions) and synchronize them with the live filesystem and ProjectFiles database.

## Status

⏳ **PLANNING** - Design phase.

## Prerequisites

- Phase 1 (2.6.1.1) must be completed
- Phase 2 (2.6.1.2) must be completed
- Phase 3 (2.6.1.3) must be completed
- Phase 4 (2.6.1.4) must be completed
- See main plan: `2.6.1-code-exec-improvements.md` for overlay details

## Goals

1. Remove Monitor class and all inotify-based monitoring
2. Create new Scan class (constructor takes Overlay instance)
3. Implement post-completion overlay scanning using scan_dir() pattern
4. Create handler methods for files, folders, and file aliases (add/remove)
5. Move is_wipeout and path conversion logic to Layout class
6. Synchronize overlay changes with ProjectFiles and live filesystem
7. Handle type changes (file ↔ directory ↔ symlink)

## Implementation Details

### Architecture Change

**Current Approach:**
- Monitor class uses inotify (via GLib.FileMonitor) to track changes in real-time
- Tracks added/removed/updated HashMaps during command execution
- Processes changes after command completion

**New Approach:**
- Remove Monitor class entirely
- Create Scan class (constructor takes Overlay instance)
- Scan instance created at start (like Monitor currently is)
- After command completion, call Scan.run() to recursively scan overlay upper directory
- Compare overlay state with ProjectFiles state
- Apply changes (create/modify/delete) based on comparison

### New Scanning Pattern

Follow similar pattern to `Folder.read_dir()`:

```vala
scan_dir(overlay_path, real_path)
  * handle_file(overlay_path, real_path)
  * handle_file_remove(overlay_path, real_path)  // is_wipeout
  * handle_folder(overlay_path, real_path)
  * handle_folder_remove(overlay_path, real_path)  // is_wipeout
  * handle_filealias(overlay_path, real_path)
  * handle_filealias_remove(overlay_path, real_path)  // is_wipeout
```

### Handler Logic

Each handler follows this pattern:

1. **Check ProjectFiles:**
   - If not exist → create_file/folder/alias
   - If exist but not same type → delete_file/folder/alias, then create_file/folder/alias
   - For folders → do nothing (folders are containers, not modified directly)
   - For files/alias → modify_file/modify_alias

2. **Type Detection:**
   - File: regular file (not symlink, not directory)
   - Folder: directory
   - FileAlias: symlink

3. **Wipeout Detection:**
   - `is_wipeout()` moved to Layout class
   - Check for whiteout files (character device with 0/0 device number)
   - Check if file doesn't exist in overlay but exists in ProjectFiles

### Scan Class

Create new `Scan` class in `liboctools/RunCommand/Scan.vala`:

- Constructor takes same parameters as Monitor:
  - `project_folder` (OLLMfiles.Folder) - provides access to project_files
  - `base_path` (string) - base path of overlay upper directory
  - `overlay_map` (HashMap<string, string>) - maps overlay subdirectory names to real project paths
- Created at start (like Monitor currently is)
- Creates Layout instance internally (using base_path and overlay_map)
- Contains `added`, `removed`, `updated` HashMaps (moved from Monitor)
- Implements `scan_dir()` method
- Implements all handler methods (handle_file, handle_file_remove, handle_folder, handle_folder_remove, handle_filealias, handle_filealias_remove)
- Implements `create_filebase_from_path()` method (moved from Monitor)
- Implements `run()` method to execute the scan after command completion
- Uses Layout instance for path conversion and wipeout detection

**What moves from Monitor to Scan:**
- `added`, `removed`, `updated` HashMaps
- `create_filebase_from_path()` method
- `handle_directory_created()`, `handle_file_created()`, `handle_file_modified()`, `handle_file_deleted()` logic (refactored into new handler methods)
- Logic for checking is_ignored based on parent folder (in handlers)
- All scanning and change detection logic
- Constructor parameters (project_folder, base_path, overlay_map)

### Layout Class

Create new `Layout` class in `liboctools/RunCommand/Layout.vala`:

- Move `is_whiteout()` method from Monitor to Layout
- Move `to_real_path()` method from Monitor to Layout
- Constructor takes base_path and overlay_map (same as Monitor currently takes)
- Provide utility methods for overlay path conversion
- Handle overlay filesystem-specific logic (whiteout detection, path mapping)

**What moves from Monitor to Layout:**
- `is_whiteout()` method
- `to_real_path()` method
- `base_path` and `overlay_map` fields (constructor parameters)

### Scanning Flow

1. **At start (in Overlay constructor):**
   - Create Scan instance (takes project_folder, base_path, overlay_map - same as Monitor)
   - Scan creates Layout instance internally (using base_path and overlay_map)

2. **After command completion:**
   - Call `scan.run()` to execute the scan
   - Scan recursively processes overlay upper directory
   - For each overlay subdirectory (overlay1, overlay2, etc.), call `scan_dir()` recursively

3. **scan_dir() implementation (in Scan class):**
   - Enumerate directory contents in overlay
   - For each item:
     - Convert overlay path to real path (using Layout.to_real_path())
     - Determine type (file/folder/symlink)
     - Check if exists in ProjectFiles
     - Call appropriate handler (handle_file/handle_folder/handle_filealias)
   - Check for removed items (in ProjectFiles but not in overlay)
   - Call appropriate remove handler (handle_file_remove/handle_folder_remove/handle_filealias_remove)

4. **Handler execution (in Scan class):**
   - Each handler checks ProjectFiles state
   - Populates added/removed/updated HashMaps
   - Does NOT copy files (that's done by Overlay.copy_files() after scan completes)

5. **After scan completes:**
   - Overlay.copy_files() processes Scan's added/removed/updated HashMaps
   - Copies files from overlay to live filesystem
   - Updates ProjectFiles database

### Files to Modify

- `liboctools/RunCommand/Overlay.vala`
  - Remove Monitor instance
  - Add Scan instance (created in constructor, like Monitor currently is)
  - Add Layout instance (created in constructor)
  - Remove `start_monitor()` method
  - Modify `copy_files()` to call `scan.run()` then process scan's added/removed/updated HashMaps
  - Keep file copying methods (file_added, file_updated, file_removed, folder_added, folder_removed)
  - Keep `command_timestamp` property
  - Keep `copy_permissions()` method
  - Keep `recursive_delete()` method

- `liboctools/RunCommand/Scan.vala`
  - **CREATE** - New class for overlay scanning
  - Constructor takes `Overlay` instance
  - Contains `added`, `removed`, `updated` HashMaps (moved from Monitor)
  - Implements `run()` method to execute scan
  - Implements `scan_dir()` method
  - Implements all handler methods (handle_file, handle_file_remove, handle_folder, handle_folder_remove, handle_filealias, handle_filealias_remove)
  - Implements `create_filebase_from_path()` method (moved from Monitor)
  - Uses Layout instance for path conversion and wipeout detection

- `liboctools/RunCommand/Layout.vala`
  - **CREATE** - New class for overlay layout utilities
  - Constructor takes `base_path` and `overlay_map` (same as Monitor currently takes)
  - Add `is_whiteout()` method (moved from Monitor)
  - Add `to_real_path()` method (moved from Monitor)
  - Add other overlay path conversion utilities

- `liboctools/RunCommand/Monitor.vala`
  - **DELETE** - Remove entire file

- `liboctools/RunCommand/Bubble.vala`
  - Remove `overlay.start_monitor()` call (no longer needed)
  - Scanning happens automatically in `overlay.copy_files()`

### Scan Class Method Signatures

```vala
// In Scan class
public Scan(OLLMfiles.Folder project_folder, string base_path, Gee.HashMap<string, string> overlay_map)  // Constructor (same as Monitor)
public async void run()  // Main entry point - executes the scan
private void scan_dir(string overlay_path, string real_path)  // Recursive scanning
private void handle_file(string overlay_path, string real_path)  // File handler
private void handle_file_remove(string overlay_path, string real_path)  // File removal handler
private void handle_folder(string overlay_path, string real_path)  // Folder handler
private void handle_folder_remove(string overlay_path, string real_path)  // Folder removal handler
private void handle_filealias(string overlay_path, string real_path)  // Symlink handler
private void handle_filealias_remove(string overlay_path, string real_path)  // Symlink removal handler
private OLLMfiles.FileBase create_filebase_from_path(string overlay_path, string real_path)  // Create FileBase from path

// Public properties (accessed by Overlay.copy_files())
public Gee.HashMap<string, OLLMfiles.FileBase> added { get; private set; }
public Gee.HashMap<string, OLLMfiles.FileBase> removed { get; private set; }
public Gee.HashMap<string, OLLMfiles.FileBase> updated { get; private set; }
```

### Layout Class Method Signatures

```vala
// In Layout class
public Layout(string base_path, Gee.HashMap<string, string> overlay_map)  // Constructor
public bool is_whiteout(string overlay_path)  // Check if path is whiteout file
public string to_real_path(string overlay_path)  // Convert overlay path to real path
```

### Type Change Handling

When a file exists in ProjectFiles but overlay has a different type:

1. Delete existing file/folder/alias from ProjectFiles
2. Create new file/folder/alias from overlay
3. Update database accordingly

### Folder Handling

- Folders are containers - they don't get "modified" directly
- If folder exists in ProjectFiles and overlay, do nothing (no modification needed)
- If folder exists in overlay but not ProjectFiles, create it
- If folder exists in ProjectFiles but not overlay, remove it (recursively)

### File/Alias Handling

- If file/alias exists in overlay but not ProjectFiles, create it
- If file/alias exists in ProjectFiles but not overlay, remove it
- If file/alias exists in both, check if modified (compare timestamps or content)
  - If modified, update it (copy from overlay to live filesystem)

## Implementation Tasks

- [ ] Create `liboctools/RunCommand/Layout.vala` with `is_whiteout()` and `to_real_path()` methods
- [ ] Create `liboctools/RunCommand/Scan.vala` class
  - [ ] Add constructor taking same parameters as Monitor (project_folder, base_path, overlay_map)
  - [ ] Create Layout instance internally in constructor
  - [ ] Add `added`, `removed`, `updated` HashMaps
  - [ ] Move `create_filebase_from_path()` from Monitor
  - [ ] Implement `run()` method
  - [ ] Implement `scan_dir()` method
  - [ ] Implement `handle_file()` method
  - [ ] Implement `handle_file_remove()` method
  - [ ] Implement `handle_folder()` method
  - [ ] Implement `handle_folder_remove()` method
  - [ ] Implement `handle_filealias()` method
  - [ ] Implement `handle_filealias_remove()` method
- [ ] Update `Overlay.vala`:
  - [ ] Remove Monitor instance
  - [ ] Add Scan instance (created in constructor with same parameters as Monitor: project_folder, base_path, overlay_map)
  - [ ] Remove `start_monitor()` method
  - [ ] Modify `copy_files()` to call `scan.run()` then process scan's HashMaps
- [ ] Remove Monitor class from `liboctools/RunCommand/Monitor.vala` (DELETE file)
- [ ] Remove `start_monitor()` call from `Bubble.vala`
- [ ] Update tests to work with new scanning approach
- [ ] Verify all file operations work correctly
- [ ] Verify type changes are handled correctly
- [ ] Verify wipeout detection works correctly

## Testing

### Test Scenarios

1. **Basic file operations:**
   - Create new file in overlay
   - Modify existing file in overlay
   - Delete file from overlay

2. **Folder operations:**
   - Create new folder in overlay
   - Delete folder from overlay
   - Create nested folder structure

3. **Symlink operations:**
   - Create new symlink in overlay
   - Modify symlink target in overlay
   - Delete symlink from overlay

4. **Type changes:**
   - File → Directory
   - Directory → File
   - File → Symlink
   - Symlink → File

5. **Wipeout detection:**
   - Delete file (should create whiteout)
   - Verify wipeout is detected correctly
   - Verify file is removed from ProjectFiles

### Test Execution

1. Build project: `meson compile -C build`
2. Run existing tests: `./tests/test-bubble.sh`
3. Verify all tests pass with new scanning approach
4. Add new tests for edge cases if needed

## Notes

- Scanning approach is simpler and more reliable than inotify monitoring
- No race conditions with inotify events
- No need to handle complex event ordering
- Post-completion scanning ensures all changes are captured
- May be slightly slower than real-time monitoring, but more accurate
- Handles edge cases better (type changes, wipeouts, etc.)
- Easier to test and debug

## Migration Notes

- Monitor class will be completely removed
- Scan class replaces Monitor (same constructor signature: project_folder, base_path, overlay_map)
- Scan creates Layout instance internally (no need to create separately in Overlay)
- Layout class provides utility methods (path conversion, wipeout detection)
- Overlay.copy_files() now calls scan.run() instead of monitor.stop()
- Scan handlers populate HashMaps (added/removed/updated) instead of Monitor event handlers
- Overlay.copy_files() processes Scan's HashMaps (same as it currently processes Monitor's HashMaps)
- Tests may need updates to work with new approach
- No database schema changes needed
- No API changes to Bubble class (internal implementation change only)
