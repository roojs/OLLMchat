# 2.6.1.1. Simple Bubble Support (No Overlay)

## Overview

Implement basic bubble (bubblewrap) sandboxing for code execution without overlay filesystem support. This phase establishes the foundation for secure command execution.

## Status

‚è≥ **PLANNING** - Design phase.

## Prerequisites

- See main plan: `2.6.1-code-exec-improvements.md` for general architecture and design decisions
- bubblewrap must be installed on system

## Goals

1. Implement `build_roots()` method in Folder class
2. Create `Bubble` class for bubblewrap command execution
3. Configure read-only root filesystem access
4. Block network access by default
5. Replace `GLib.Subprocess` with bubblewrap execution

## Implementation Details

### Files to Create

- `liboctools/RunCommand/Bubble.vala` - bubblewrap wrapper class

### Files to Modify

- `liboctools/RunCommand/Request.vala` - Integrate Bubble class for command execution
- `libocfiles/Folder.vala` - Add `build_roots()` method to return paths that need write access (following symlinks)

### Bubble Class Design

#### Class Structure

```vala
namespace OLLMtools.RunCommand {
    public class Bubble {
        // Properties
        private OLLMfiles.Folder project;           // Project folder (is_project = true)
        private Gee.HashMap<string, OLLMfiles.Folder> roots;  // Map of path -> Folder objects to share (read-write access)
        private bool allow_network;                 // Network access flag (default: false)
        
        // Constructor
        public Bubble(OLLMfiles.Folder project, bool allow_network = false) throws Error
        
        // Public methods
        public async string exec(string command) throws Error
        
        // Private helper methods
        private string[] build_bubble_args(string command) throws Error
        private async string read_subprocess_output(Subprocess subprocess) throws Error
    }
}
```

**Note**: A new Bubble instance is created for each command execution. The instance is used once and then goes out of scope, so no cleanup logic is needed for old instances.

#### Method Details

**Constructor: `Bubble(OLLMfiles.Folder project, bool allow_network = false) throws Error`**
- **Purpose**: Initialize Bubble instance with configuration
- **Parameters**:
  - `project`: Project folder object (is_project = true) - the main project directory
  - `allow_network`: Whether to allow network access (default: false, Phase 7 feature)
- **Implementation**:
  - Store parameters as instance variables
  - Initialize `roots` as empty HashMap
  - Call `project.build_roots()` to get array of paths that need write access
  - For each path returned:
    - Validate path exists and is absolute
    - Add to HashMap: `roots.set(path, project)` (use project as the Folder reference)
  - Note: Environment variables are inherited from user's environment (no explicit handling needed)

**Method: `async string exec(string command) throws Error`**
- **Purpose**: Execute command string in bubblewrap sandbox and return output as string
- **Parameters**:
  - `command`: Command string to execute (e.g., `"ls -la"` or `"cd /path && make"`)
- **Returns**: String containing command output (stdout + stderr, with exit code if non-zero)
- **Implementation**:
  1. Build bubblewrap command arguments using `build_bubble_args(command)`
  2. Create `GLib.Subprocess` with bubblewrap as executable
  3. Configure subprocess flags: `STDOUT_PIPE | STDERR_PIPE | STDIN_INHERIT`
  4. Read output using `read_subprocess_output()`
  5. Wait for process to complete and get exit status
  6. Format output: stdout + stderr + exit code (if non-zero)
  7. Return formatted string
- **How it works**:
  - Constructs bubblewrap command: `bwrap [args] -- /bin/sh -c "command"`
  - Uses `GLib.Subprocess.newv()` to create process
  - Handles all I/O internally and returns simple string result
  - LLM only sees command string in, string out - everything else is internal

**Method: `private string[] build_bubble_args(string command) throws Error`**
- **Purpose**: Build complete bubblewrap command line arguments
- **Parameters**:
  - `command`: Command string to execute
- **Returns**: Array of arguments for bubblewrap command (including `/bin/sh -c "command"`)
- **Implementation**:
  1. Start with array: `["bwrap"]`
  2. Add read-only bind: `"--ro-bind"`, `"/"`, `"/"`
  3. Add root folder binds: Iterate over `roots` HashMap, for each path add `"--bind"`, `path`, `path`
  4. Add network args: If `allow_network == false`, add `"--unshare-net"`
  5. Add separator: `"--"`
  6. Add shell command: `"/bin/sh"`, `"-c"`, `command`
  7. Return final array
- **How it works**:
  - Builds complete bubblewrap command: `bwrap [flags] -- /bin/sh -c "command"`
  - Uses simple string array concatenation
  - Environment variables are inherited automatically (no explicit flags needed)
  - Working directory will be added in later phases when overlay support is added
  - Final array: `["bwrap", "--ro-bind", "/", "/", "--bind", folder1_path, folder1_path, ..., "--", "/bin/sh", "-c", "command"]`

**Method: `private async string read_subprocess_output(Subprocess subprocess) throws Error`**
- **Purpose**: Read stdout and stderr from subprocess and return combined output
- **Parameters**:
  - `subprocess`: The Subprocess instance to read from
- **Returns**: Combined stdout + stderr output as string
- **Implementation**:
  1. Get stdout and stderr streams from subprocess
  2. Read from both streams concurrently (async)
  3. Combine outputs (stdout first, then stderr if present)
  4. Wait for process to complete
  5. Get exit status
  6. Append exit code to output if non-zero
  7. Return formatted string
- **How it works**:
  - Uses async I/O to read both streams
  - Formats output similar to existing RunCommand behavior
  - Handles truncation if needed (similar to existing code)

**Note**: Working directory support will be added in later phases when overlay support is implemented. For Phase 1, commands execute from the project root directory.

**Note**: Environment variables are automatically inherited from the user's environment when using `GLib.Subprocess`. No explicit `--setenv` flags are needed. bubblewrap will inherit the environment from the parent process by default.

#### Integration with Request.vala

**Replace in `execute_tool_async()`:**
- Current: Creates `GLib.Subprocess` directly with `/bin/sh -c`, reads streams, formats output
- New: Check if bubblewrap can be used using `Bubble.can_wrap()` static method
  - If `Bubble.can_wrap()` returns false (Flatpak or bwrap not available): Use old permission system and existing `GLib.Subprocess` code (skip bubblewrap entirely)
  - If `Bubble.can_wrap()` returns true: Create `Bubble` instance, call `exec(command)`, get string back
- All stream reading and formatting is handled internally by Bubble (when used)

**Example usage:**
```vala
// Check if bubblewrap can be used (checks for Flatpak and bwrap availability)
if (!Bubble.can_wrap()) {
    // Running in Flatpak or bwrap not available - use old permission system and existing Subprocess code
    // Skip bubblewrap entirely, use existing execute_tool_async() implementation
    return yield this.execute_with_subprocess(this.command);
}

// Not in Flatpak and bwrap available - use bubblewrap
// Get project folder from ProjectManager via tool
var run_command_tool = (Tool) this.tool;
var project_manager = run_command_tool.project_manager;
if (project_manager == null || project_manager.active_project == null) {
    throw new GLib.IOError.FAILED("No active project available for bubblewrap execution");
}
var project = project_manager.active_project;  // OLLMfiles.Folder

// Create Bubble instance
var bubble = new Bubble(
    project: project,
    allow_network: false
);

// Execute command - simple string in, string out
var output = yield bubble.exec(this.command);

// Return output to LLM (already formatted with stdout + stderr + exit code)
return output;
```

## Implementation Phases

### Phase 1: Implement build_roots() in Folder

- [x] Add `build_roots()` method to `Folder` class
- [x] Method should return array of paths that need write access
- [x] Must follow symlinks within the project to find all directories that need to be writable
- [x] For Phase 1: Returns realpaths (actual filesystem paths with symlinks resolved)
- [x] In later phases: Will return overlay mount points instead of realpaths
- [x] Test `build_roots()` method in isolation

### Phase 2: Build Bubble Class

- [x] Create `Bubble` class structure
- [x] Implement constructor with Folder object (calls `project.build_roots()`)
- [x] Build `roots` HashMap from `project.build_roots()` array
- [x] Implement `build_bubble_args()` method (builds all args inline)
- [x] Implement `read_subprocess_output()` method
- [x] Implement `exec(string command)` method (main public API)
- [x] Test Bubble class in isolation

### Phase 3: Integration

- [x] Modify `RunCommand/Request.vala` to check for Flatpak at start of `execute_tool_async()`
- [x] If running in Flatpak: Use old permission system and existing `GLib.Subprocess` code (early return)
- [x] If not in Flatpak: Create `Bubble` instance and use `Bubble.exec()`
- [x] Replace `GLib.Subprocess` code with `Bubble.exec()` call (when not in Flatpak)
- [x] Simplify `execute_tool_async()` method
- [ ] Test integration with RunCommand tool
- [ ] Test basic command execution
- [ ] Test that bubblewrap is disabled when running inside Flatpak (falls back to regular Subprocess)
- [ ] Test network blocking (verify commands cannot access network by default)
- [ ] Test write restrictions (writes to project directory only)

## Testing

- Test commands that should work (read-only, project writes)
- Test commands that should be blocked (system writes)
- Test network blocking (commands cannot access network)
- Test that bubblewrap is disabled when running inside Flatpak (falls back to regular Subprocess)

## Notes

- bubblewrap may not be available on all systems - need fallback or requirement check
- **bubblewrap is disabled when running inside Flatpak**: Use `Bubble.can_wrap()` static method in `Request.vala` before creating Bubble, use old permission system and existing `GLib.Subprocess` code instead
- Network access will be added in Phase 7 (last phase)
- Overlay filesystem support will be added in Phase 3
- **Folder.build_roots() method**: Needs to be implemented in Folder class
  - Should return array of paths that need write access
  - Must follow symlinks within the project to find all directories that need to be writable
  - For Phase 1: Returns realpaths (actual filesystem paths with symlinks resolved)
  - In later phases: Will return overlay mount points instead of realpaths
