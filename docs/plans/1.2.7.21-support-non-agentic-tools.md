# 1.2.7.21. Support Non-Agentic Tools

## Overview

Create an interface for tools to work without an agent handler. Currently, all tools assume `request.agent` is always set and access `agent.chat`, `agent.session.manager.permission_provider`, etc. For non-agentic usage (external code using Chat directly), tools need an alternative way to access these resources.

**Parent Plan**: [1.2.7. Move Remaining Signals from Client to Chat](./1.2.7-move-signals-to-chat.md)

## Status

⏳ **TODO** - Create interface for non-agentic tool support.

## Goal

Create an interface that provides the resources tools need (chat, permission_provider, etc.) without requiring an agent handler. Tools can use either `agent` (for agentic usage) or the interface (for non-agentic usage).

## Current State

- `RequestBase.agent` is nullable (`Prompt.AgentHandler? agent`)
- Tools access resources via `agent.chat`, `agent.session.manager.permission_provider`
- Tools call `agent.session.add_message()` for UI messages
- For non-agentic usage, `chat_call.agent` is null, so `request.agent` would be null
- Tools would fail when trying to access `this.agent.chat` or `this.agent.session`

## Implementation Steps

### Step 1: Create ToolContext Interface

**Goal**: Create an interface that provides the resources tools need.

**Changes**:
1. Add to `libollmchat/Tool/ToolContext.vala` (new file):
   ```vala
   namespace OLLMchat.Tool
   {
       /**
        * Interface providing resources needed by tools for execution.
        * 
        * Used for non-agentic tool execution where agent handler is not available.
        * Agent handler implements this interface, and Chat can also provide a simple
        * implementation for non-agentic usage.
        * 
        * @since 1.2.7.21
        */
       public interface ToolContext : Object
       {
           /**
            * Chat instance for this tool execution.
            * Tools use this to access connection, model, etc.
            */
           public abstract Call.Chat chat { get; }
           
           /**
            * Permission provider for tool execution.
            * Tools use this to request permissions for file access, command execution, etc.
            */
           public abstract ChatPermission.Provider permission_provider { get; }
           
           /**
            * Add a UI message to the conversation.
            * 
            * For agentic usage: Adds message to session.
            * For non-agentic usage: Adds message to chat.messages or emits signal.
            * 
            * @param message The message to add
            */
           public abstract void add_message(Message message);
       }
   }
   ```

**Result**: Interface defined for tool context.

### Step 2: Make AgentHandler Implement ToolContext

**Goal**: AgentHandler implements ToolContext so tools can use it via the interface.

**Changes**:
1. Update `libollmchat/Prompt/AgentHandler.vala`:
   ```vala
   public class AgentHandler : Object, Tool.ToolContext
   {
       // Implement ToolContext interface
       public Call.Chat chat {
           get { return this.chat; }
       }
       
       public ChatPermission.Provider permission_provider {
           get { return this.session.manager.permission_provider; }
       }
       
       public void add_message(Message message)
       {
           this.session.add_message(message);
       }
   }
   ```

**Result**: AgentHandler implements ToolContext interface.

### Step 3: Add ToolContext Property to RequestBase

**Goal**: RequestBase has ToolContext property (can be agent or Chat-provided context).

**Changes**:
1. Update `libollmchat/Tool/RequestBase.vala`:
   ```vala
   /**
    * Reference to the tool context for this tool request.
    * 
    * For agentic usage: This is the agent handler (implements ToolContext).
    * For non-agentic usage: This is a Chat-provided ToolContext implementation.
    * 
    * Tools access resources via this.context instead of this.agent.
    */
   public ToolContext? context { get; set; }
   
   /**
    * Reference to the agent handler for this tool request (deprecated, use context instead).
    * 
    * @deprecated Use context instead. This property is kept for backward compatibility
    * and will be removed in a future version.
    */
   public Prompt.AgentHandler? agent { 
       get { return this.context as Prompt.AgentHandler; }
       set { this.context = value; }
   }
   ```

**Result**: RequestBase has ToolContext property, agent property becomes a convenience accessor.

### Step 4: Update Tools to Use ToolContext

**Goal**: Update tools to use `context` instead of `agent` directly.

**Changes**:
1. Update `libollmchat/Tool/RequestBase.vala`:
   - Change `this.agent.chat` → `this.context.chat`
   - Change `this.agent.session.manager.permission_provider` → `this.context.permission_provider`
   - Change `this.agent.session.add_message()` → `this.context.add_message()`

2. Update tool implementations:
   - `libollmchat/Tools/RequestEditMode.vala` - Update any direct `agent` access
   - `libollmchat/Tools/RequestRunCommand.vala` - Update any direct `agent` access
   - Any other tools that access `agent` directly

**Result**: Tools use ToolContext interface instead of accessing agent directly.

### Step 5: Create ChatToolContext Implementation

**Goal**: Create a simple ToolContext implementation for non-agentic Chat usage.

**Changes**:
1. Add to `libollmchat/Call/Chat.vala`:
   ```vala
   /**
    * Simple ToolContext implementation for non-agentic tool execution.
    */
   private class ChatToolContext : Object, Tool.ToolContext
   {
       private Chat chat;
       private ChatPermission.Provider permission_provider;
       
       public ChatToolContext(Chat chat, ChatPermission.Provider permission_provider)
       {
           this.chat = chat;
           this.permission_provider = permission_provider;
       }
       
       public Call.Chat chat {
           get { return this.chat; }
       }
       
       public ChatPermission.Provider permission_provider {
           get { return this.permission_provider; }
       }
       
       public void add_message(Message message)
       {
           // For non-agentic usage, add message to chat.messages
           this.chat.messages.add(message);
           // Also emit tool_message signal for UI updates
           this.chat.tool_message(message);
       }
   }
   ```

2. Update `BaseTool.execute()` to create ChatToolContext when agent is null:
   ```vala
   // Set context (agent or Chat-provided)
   if (chat_call.agent != null) {
       request.context = chat_call.agent;
   } else {
       // Non-agentic usage: create simple context
       // For non-agentic usage, permission_provider should be provided by caller
       // Default to Dummy provider if not available
       var permission_provider = new ChatPermission.Dummy();
       // TODO: Get permission_provider from Chat or caller-provided source
       request.context = new ChatToolContext(chat_call, permission_provider);
   }
   ```
   
   **Note**: For non-agentic usage, permission_provider needs to be provided somehow. Options:
   - Add `permission_provider` property to Chat (for non-agentic usage)
   - Pass permission_provider when creating Chat
   - Use Dummy provider as default (tools handle permissions themselves)

**Result**: Non-agentic tools can execute using Chat-provided ToolContext.

## Files to Modify

- `libollmchat/Tool/ToolContext.vala` - Create new interface file
- `libollmchat/Prompt/AgentHandler.vala` - Implement ToolContext interface
- `libollmchat/Tool/RequestBase.vala` - Add ToolContext property, update to use context instead of agent
- `libollmchat/Call/Chat.vala` - Add ChatToolContext class, update BaseTool.execute() to create context
- `libollmchat/Tool/Tool.vala` - Update execute() to set context instead of agent
- `libollmchat/Tools/RequestEditMode.vala` - Update to use context
- `libollmchat/Tools/RequestRunCommand.vala` - Update to use context

## Testing Checklist

- [ ] ToolContext interface is defined
- [ ] AgentHandler implements ToolContext
- [ ] RequestBase has ToolContext property
- [ ] RequestBase.agent property works as convenience accessor
- [ ] Tools use context instead of agent directly
- [ ] ChatToolContext implementation exists
- [ ] BaseTool.execute() creates ChatToolContext when agent is null
- [ ] Non-agentic tools can execute successfully
- [ ] Permission provider works for non-agentic tools
- [ ] UI messages work for non-agentic tools

## Related Plans

- [1.2.7. Move Remaining Signals from Client to Chat](./1.2.7-move-signals-to-chat.md) - Parent plan
- [1.2.7.10. Move Tool Execution to Agent](./1.2.7.10-move-tool-execution-to-agent.md) - Related (agent handles tool execution)

