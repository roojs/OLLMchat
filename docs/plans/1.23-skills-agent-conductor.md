# 1.23 Skills Agent & Conductor

## Overview

Introduce a **skills agent** system: skill definitions live under `resources/skills`, and a new agent **SkillRunner** (in the occoder directory) runs skills by loading their prompts. The first skill is the **Conductor**—a process enforcer and router that orchestrates a phased workflow (research → planning → implementation → review → finalize) and emits directives to invoke other skills rather than executing work itself.

No coding or new files beyond this plan until the plan is approved.

## Status

**PLAN** – Implementation not started.

## Conventions

### Skills location and path

- Skill files live under **`resources/skills`**.
- For development and round-robin testing use the explicit path: **`{HOME}/gitlive/OLLMchat/resources/skills`** (no reliance on runtime resource resolution for this folder initially).
- Later, external skills may be imported by extracting a `SKILLS.md` (or equivalent) into the skills folder; skill-specific code can live in a subfolder.

### Skill file format

- Follow the **SKILL.md-style format** (e.g. from create-skill): YAML frontmatter (`name`, `description`) plus markdown body.
- Initially **do not** require the file to be named `SKILL.md`; a single `.md` file per skill in the skills folder is enough (e.g. `conductor.md` for the Conductor).
- Future: if we import external skills, we may extract a `SKILLS.md` into the skills folder and allow a `code/` (or similar) directory alongside it.

### SKILL.md format (standardised sections — reference for extension)

- **Frontmatter (YAML, required)**  
  - `name`: unique id, max 64 chars, lowercase letters/numbers/hyphens only.  
  - `description`: non-empty, max 1024 chars; used for discovery / “when to use”; should state WHAT and WHEN (third person).

- **Directory layout (Cursor standard)**  
  - One directory per skill: `skill-name/`.  
  - `SKILL.md` (required) — main instructions.  
  - `reference.md` (optional) — detailed docs.  
  - `examples.md` (optional) — usage examples.  
  - `scripts/` (optional) — utility scripts.  
  - Progressive disclosure: SKILL.md links to reference/examples; agent reads those only when needed.

- **SKILL.md body sections (create-skill convention)**  
  - No single rigid schema; common patterns:  
    - **Instructions** — step-by-step guidance.  
    - **Examples** — concrete usage.  
    - **Quick start** + **Additional resources** (links to reference.md, examples.md).  
    - Optional patterns: Template, Workflow, Conditional workflow, Feedback loop, Utility scripts.

- **What is *not* standard (we may extend)**  
  - No standard **Input / Output** section in the SKILL.md body. We do **not** put Input/Output inside skill files; the task manager carries that (see “How to utilize skills”).

### How to utilize skills (our wrapper)

- **Picking a skill**  
  - Primarily choose a skill from the **descriptions** given (frontmatter `description`). The Conductor (and Skills Reader) use these to decide which skill to invoke.

- **Task manager — bullet-pointed task format**  
  - Skill files do **not** contain Input/Output sections.  
  - The **task manager** (who defines a skill-usage task) produces a **bullet-pointed list** in this form:  
    - **Skill:** &lt;which skill&gt;  
    - **Input:** A short description of what you want the skill to do, then **sub-bullets** for each piece of information that must be passed in (same style: clear, concise).  
    - **Output:** What you expect from the skill, in the same style — e.g. that the skill should produce **a document** (a research doc, a plan, a review, etc.) and where or in what form it should be delivered.  
  - This list is the task briefing the Conductor (or executor) uses to invoke the skill with the right inputs and to judge the output.

- **Skill output format (when the skill runs)**  
  - The **output from the skill** must include an **output section**: the skill produces the expected document and then adds a **short summary at the end** describing what it has done. That summary is the “output section” the task manager and Conductor can use to confirm completion and what was delivered without re-reading the whole document.

## Components

### 1. New agent: SkillRunner (occoder)

- Add a new agent in the **occoder** directory, analogous to “Just Ask” in libollmchat.
- **Name:** SkillRunner (factory: e.g. `SkillRunnerFactory`, agent: `SkillRunner`).
- **Role:** Load a skill’s markdown from `resources/skills` and use it as the system prompt (or equivalent) for the chat. First supported skill: Conductor.
- **Registration:** Register the SkillRunner agent alongside the existing Code Assistant in the app (e.g. in the same place where Code Assistant is registered), so it appears in the agent selector.
- **Implementation notes (for later):**
  - Factory sets agent `name` (e.g. `"skill-runner"`) and UI `title` (e.g. `"Conductor"` or `"Skill Runner"`).
  - System prompt is generated by loading the skill file from the skills path (e.g. `conductor.md` for the first skill). Path for now: `{HOME}/gitlive/OLLMchat/resources/skills`.
  - Agent instance can mirror JustAsk/Base behavior (no per-request context like Code Assistant) except for using the loaded skill prompt.

### 2. First skill: Conductor

- **File:** One markdown file in `resources/skills` (e.g. `conductor.md`), SKILL-style format (frontmatter + body).
- **Role:** Workflow Conductor Agent – process enforcer and router. It does **not** write code or deep technical plans; it manages the sequence of specialized skills.
- **Core rules (to be embedded in the skill prompt):**
  - **Phase-based execution:** Five phases – Research (`/research/`), Planning (`/plans/`), Implementation (`/code/`), Review/Debug (`/reviews/`), Finalize. Never skip a phase.
  - **Artifact check (Gatekeeper):** Before any action, require the presence of required input artifacts in the project’s document folder. If missing or invalid, state what is missing and which prior phase must be completed; do not proceed.
  - **Skill invocation, not execution:** Output is a **directive**: which skill to invoke, the exact task, input artifacts, and expected output artifact/location – not the final code/plan/fix.
  - **State awareness:** Responses start with a **State Assessment** (phase, key artifacts, blockers).
- **Process (Conductor algorithm):** For each user request: (1) Analyze request and classify intent, (2) Scan state (document folder / artifacts), (3) Apply rules and Gatekeeper, (4) Either output a **Skill Directive** (format A) or a **Blocking Message** (format B) or a **State Update** (format C) as defined in the skill.
- **First test (later):** With an empty document folder, a request like “We need to add a user notification system” should yield a Blocking Message proposing to invoke the Research skill. After adding a dummy `research_notifications.md` in `/research/`, “Plan the notification system” should yield a Skill Directive to invoke the Planning skill.

### 3. Placeholder skills (for Conductor to “pretend to utilize”)

- For the initial plan the Conductor must have **named skills** it can reference in directives (e.g. “Invoke Research Skill”, “Invoke Planning Skill”). Those skills are not fully implemented yet.
- Create **placeholder skill files** in `resources/skills` that contain **only the top YAML frontmatter** (`name`, `description`), so the Conductor has something to list and refer to. Skill files do not contain Input/Output; that lives in the task manager’s bullet list.
- Suggested placeholders (one `.md` per phase): e.g. `research.md`, `planning.md`, `implementation.md`, `review.md`, `finalize.md`.
- The **Skills Reader tool** (below) lists these files and returns frontmatter (name, description) so the Conductor can pick a skill; the **task manager** supplies the actual Input/Output for each invocation.

### 4. Skills Reader tool

- A **tool** available to the Conductor (SkillRunner) agent: it reads skill definitions from the skills directory so the Conductor can discover and choose skills.
- **Design principle (align with “progressive” / dynamic context discovery):** The tool does **not** return the full skill file. It returns only what the Conductor needs to decide **which skill to invoke** — i.e. **frontmatter** (name, description). Expected input and output for a given run come from the **task manager** bullet list, not from the skill file.
- **Implementation approach:** Parse the skill `.md` (e.g. with libocmarkdown or simple YAML/markdown split) and extract **frontmatter** (name, description) only.
- **Tool behaviour:** Given a skill name or path (or “list all”), the tool returns a short summary: `name`, `description`. No full instruction body.
- **Reference:** The idea that a “skills reader” does not read the whole skill is consistent with Cursor’s dynamic context discovery and progressive loading.

### 5. Document folder (later)

- The Conductor reasons about a “document folder” (e.g. `/research/`, `/plans/`, etc.). Plan only: no implementation of this folder or “state file” in 1.23; the first implementation step is the SkillRunner agent and the Conductor skill file. Teaching the Conductor to “read” the folder (e.g. by providing a file list in context) and adding a `_project_state.json` (or similar) can be a later iteration.

## Implementation order (when approved)

1. Add **SkillRunner** and **SkillRunnerFactory** in liboccoder (mirror JustAsk pattern; system prompt from skill file under `{HOME}/gitlive/OLLMchat/resources/skills`). **→ Full concrete code: [1.23.1-skill-runner-occoder.md](1.23.1-skill-runner-occoder.md)**
2. Create **placeholder skill files** in `resources/skills`: e.g. `research.md`, `planning.md`, `implementation.md`, `review.md`, `finalize.md`, each with YAML frontmatter only (name, description) so the Conductor has named skills to reference.
3. Create **`resources/skills/conductor.md`** with the full Conductor prompt (YAML frontmatter + body: role, rules, process, output formats A/B/C, and “Begin your response with `[CONDUCTOR AGENT INITIALIZED]`”).
4. Implement **Skills Reader tool**: parses skill `.md` files to extract frontmatter (name, description) only; returns that summary to the Conductor (no full body). Register the tool for the SkillRunner (Conductor) agent via `configure_tools()`.
5. Register the SkillRunner agent in the app (e.g. Window) and in the build (meson) so the Conductor appears in the agent list.
6. Manual test: select Conductor, send “We need to add a user notification system” and confirm a Blocking Message; add dummy research artifact and re-test for a Skill Directive. Optionally verify Conductor can call the Skills Reader tool to list/describe placeholder skills.

## Out of scope for 1.23

- Full implementation of Research, Planning, Implementation, Review, or Finalize skills (only placeholders with frontmatter).
- Document folder scanning, state file, or “reading” the folder in the Conductor.
- Import of external skills or `SKILLS.md` extraction (noted for future).

## References

- Conductor prompt template and output formats (A/B/C) as provided in the original 1.23 discussion.
- SKILL.md structure: `~/.cursor/skills-cursor/create-skill/SKILL.md` (name, description, markdown body).
- Existing agents: `libollmchat/Agent/JustAsk.vala`, `JustAskFactory.vala`; `liboccoder/Agent.vala`, `AgentFactory.vala`; registration in `ollmapp/Window.vala` and `libollmchat/History/Manager.vala`.
- Skills Reader design: tool does not read the whole skill; returns frontmatter (name, description) only so the Conductor can pick a skill. Expected input and output for a run come from the task manager bullet list (see “How to utilize skills”).
- Agent tools: `Factory.configure_tools(Call.Chat)` adds tools to the Conductor’s chat; libocmarkdown Parser/BlockMap/document model for section extraction by heading.
