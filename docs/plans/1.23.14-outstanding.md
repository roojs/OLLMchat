# 1.23.14 Outstanding — existing skill code

**Parent:** 1.23.14. **Dependencies:** 1.23.11, 1.23.13, 1.23.15, 1.23.17.

**Coding standards:** `.cursor/rules/CODING_STANDARDS.md`. Before implementing any section, verify the checklist (nullable types, null checks, string interpolation, temporaries, braces, `this.`, GLib prefix, property init, line length, StringBuilder/string-in-loops, string arrays, continue-in-loops, no underscore prefix, get_* vs properties, etc.).

---

## 1. Definition fetching — DONE

- **Manager methods:** **fetch(Task)** — skill name from `task.task_data.get("Skill").to_markdown().strip()`, return `by_name.get(skill_name)` (Definition; always present after validate). **validate(Task)** — return **bool** (true if skill exists, false otherwise); **caller** generates the error message.
- **Invariant:** Any call to fetch(Task) happens after validate; no null checks needed at call sites.
- **Caller:** Task (Details) uses **this.skill_manager.fetch(this)** and **this.skill_manager.validate(this)**. **Details** has **skill_manager** as a public alias to **runner.sr_factory.skill_manager**. Runner: **sr_factory** is public.
- **Definition API used:** `definition.skill_input_requirements()` (refine), `definition.header`, `definition.full_content`. **skill_input_requirements()** on Definition — **DONE**.

---

## 2. Task naming and output references (critical)

- **When:** On initial task list creation and whenever the task list is later updated.
- **Assign a name to each task.** Normal format: **skill_name + " " + number** (e.g. `MySkill 1`, `MySkill 2`). Store on task (e.g. Details) so it is stable and referrable.
- **Output reference format:** To refer to a task's output we use **`#{slug}-{number}-results`** where:
  - **slug** = skill name with non-ascii replaced by `-` and lowercased (e.g. "My Skill" → `my-skill`).
  - **number** = task index/number (same as in task name).
  - Example: `#my-skill-1-results`, `#my-skill-2-results`.
- This is the **'output'** reference we use: when References say `output:…` or a ref points at another task's results, the target is this anchor. **reference_content** (or the resolver) must resolve `#slug-number-results` to that task's result content (e.g. from user_request or stored task outputs).

---

## 3. Resolving references

- **Reference in:** Task list "References" → Details **reference_targets** (Gee.ArrayList<Format>, from `task_data.get("References").links()`). Href forms: `#anchor`, `output:task` (or `#slug-number-results`), http(s), absolute path.
- **Who resolves:** Details **reference_contents()** (private) loops reference_targets; for each href: if not absolute path → **runner.reference_content(href)**; if absolute → project_manager.get_file_from_active_project / File.new_fake + buffer_provider.create_buffer + get_contents(0).
- **Runner.reference_content(href):** Not implemented. Non-file refs: `#project-description`, `#current-file`, and **`#slug-number-results`** (task output; see §2). Use **this.user_request.headings.get(anchor)** (anchor = href without "#") and block.**to_markdown_with_content()**. Return "" if null. File refs stay in Details (project manager).
- **validate_reference_targets()** (Details): Validates href forms (#, output:, http, absolute path exists); does not fetch content. FIXME: validate #anchor format and existence.

---

## 4. Current file issues — DONE

- **Where used:** Runner **task_creation()** fills placeholder "current_file" — currently empty string. Details **refine()** fill passes current file content (stubbed `""`).
- **Public property forbidden:** Use a method that returns **File or null** instead of a string property.
- **Do not check if project_manager exists** — it will always exist (see "We must fix" at end of plan).
- **project_manager on sr_factory, not Runner:** Move **project_manager** to **Skill.Factory** (sr_factory). Runner and Details get it via `this.runner.sr_factory` (or factory). We must fix all project_manager references to use the factory.

**Design:**

- **Skill.Factory** holds **project_manager** (required). **Factory** has a method **`current_file()`** returning **`OLLMfiles.File?`** (null when no active file). The method ensures the buffer is there: call **`this.project_manager.buffer_provider.create_buffer(file)`** before returning the file (so callers can safely call `file.get_contents(200)`).
- **Call site (Runner.task_creation and Details.refine):** Get file from factory, then format with header:
  - `var file = this.sr_factory.current_file();`
  - `"current_file", file == null ? "" : tpl.header("Current File - " + file.path, file.get_contents(200))`

**Concrete code:**

**1. Skill.Factory (liboccoder/Skill/Factory.vala)** — add project_manager and current_file():

```vala
public class Factory : OLLMchat.Agent.Factory
{
	public OLLMfiles.ProjectManager project_manager { get; private set; }
	public Manager skill_manager { get; private set; }
	public string skill_name { get; private set; }

	public Factory(OLLMfiles.ProjectManager project_manager, Gee.ArrayList<string> skills_directories, string skill_name = "")
	{
		this.name = "skill-runner";
		this.title = "Skills Agent";
		this.project_manager = project_manager;
		this.skill_manager = new Manager(skills_directories);
		this.skill_name = skill_name != "" ? skill_name : "task_creator";
	}

	/** Returns active file; ensures buffer exists so caller can call get_contents(). */
	public OLLMfiles.File? current_file()
	{
		var file = this.project_manager.active_file;
		if (file == null) {
			return null;
		}
		this.project_manager.buffer_provider.create_buffer(file);
		return file;
	}

	public override OLLMchat.Agent.Base create_agent(OLLMchat.History.SessionBase session)
	{
		return new Runner(this, session);
	}
}
```

Call site that creates Factory (e.g. Window.vala) must pass project_manager: `new OLLMcoder.Skill.Factory(this.project_manager, skills_dirs, "")`.

**2. Runner (liboccoder/Skill/Runner.vala)** — remove project_manager property; use sr_factory:

- Delete: `public OLLMfiles.ProjectManager? project_manager { get; set; default = null; }`
- In **env()**: replace `this.project_manager` with `this.sr_factory.project_manager` (e.g. `this.sr_factory.project_manager.active_project`).
- In **task_creation()**:

```vala
var file = this.sr_factory.current_file();
var open_files_list = "";
tpl.fill(
	"user_prompt", tpl.header("User Prompt", user_prompt),
	"environment", tpl.header("Environment", this.env(), false),
	"project_description", "",
	"current_file", file == null ? "" : tpl.header("Current File - " + file.path, file.get_contents(200)),
	"open_files", open_files_list,
	"previous_proposal", previous_proposal == "" ? "" : tpl.header("Previous Proposal", previous_proposal),
	"previous_proposal_issues", previous_proposal_issues == "" ? "" : tpl.header("Previous Proposal Issues", previous_proposal_issues),
	"skill_catalog", this.sr_factory.skill_manager.to_markdown());
```

**3. Details (liboccoder/Task/Details.vala)** — use runner.sr_factory:

- In **refine()** fill:

```vala
var file = this.runner.sr_factory.current_file();
"current_file", file == null ? "" : tpl.header("Current File - " + file.path, file.get_contents(200)),
```

- In **reference_contents()**: replace `this.runner.project_manager` with `this.runner.sr_factory.project_manager`:

```vala
var found = this.runner.sr_factory.project_manager.get_file_from_active_project(link.href);
if (found == null) {
	found = new OLLMfiles.File.new_fake(this.runner.sr_factory.project_manager, link.href);
}
this.runner.sr_factory.project_manager.buffer_provider.create_buffer(found);
ret += this.reference_block(link.href, found.get_contents(0));
```

**Completion (implemented):** Skill.Factory now has `project_manager` and `current_file()`; constructor takes `(OLLMfiles.ProjectManager, Gee.ArrayList<string>, string)`. Runner no longer has `project_manager`; `env()` and `task_creation()` use `sr_factory.project_manager` and `sr_factory.current_file()`. Details.refine() and reference_contents() use `runner.sr_factory.current_file()` and `runner.sr_factory.project_manager`. Window.vala creates Factory with `new OLLMcoder.Skill.Factory(this.project_manager, skills_dirs, "")`. Build verified.

---

## 5. Validate tasks — DONE

- **Manager.validate(Task):** Returns **bool** (true = valid). Caller builds the error message when false. **DONE.**
- **List.validate_skills():** **DONE.** Implemented in List.vala; called from Runner.send_async after parse (flow uncommented).
- **5.1 flow:** Uncommented. **sr_factory.current_file()** and project_manager on Factory are **DONE** (§4). Only **Runner.reference_content(href)** remains stubbed at its call site; it does **not** hold up 5.1.

---

## 5.1 Call sites for Manager.validate — DONE

- **Current state:** **Manager.validate(Task)** and **List.validate_skills()** are implemented. **Runner.send_async** task-list flow (parse → validate_skills → task_list → handle_task_list) is **uncommented**. **Runner.task_list** property added; **request_writer_approval** and **run_post_completion** stubbed on Runner so the flow compiles.
- **Stubbed at call site only (do not hold up 5.1):** **Runner.reference_content(href)** — not implemented; only the lines that pass/use it are stubbed. See §3 / FIXME list. (§4 current_file/project_manager on Factory is DONE.)

**List (`liboccoder/Task/List.vala`)** — implemented (per CODING_STANDARDS: `continue` in loop). For reference:

```vala
/**
 * For each task (steps → children), call task.skill_manager.validate(task).
 * When false, add issue line: skill must be one of the available skills.
 * Returns combined issues string; "" when all tasks' skills exist.
 */
public string validate_skills()
{
	var issues = "";
	foreach (var step in this.steps) {
		foreach (var t in step.children) {
			if (t.skill_manager.validate(t)) {
				continue;
			}
			 
			var skill_name = t.task_data.get("Skill").to_markdown().strip();
			issues += "Task references skill \"" + skill_name + "\", which is not in the available skills list.\n";
		}
	}
	return issues;
}
```

**Runner.send_async** — (uncommented.) After `parser.parse_task_list()` and when `parser.issues == ""`:

- Call **var skill_issues = parser.task_list.validate_skills();**
- If **skill_issues != ""**, set **parser.issues = skill_issues** (or append), then continue the retry loop (previous_proposal / previous_proposal_issues).
- If **skill_issues == ""**, then assign **this.task_list = parser.task_list**, yield **handle_task_list()**, and return.

*(So validate_skills runs only when parse succeeded; when it fails, the existing retry path with previous_proposal_issues is used.)*

---

## 6. Skill catalog — DONE

- **Manager.to_markdown()** — Implemented. Not “catalog string”. Returns a string: one line per skill, format **`**Skillname** - description`**. Name and description from each Definition’s header. That’s all it returns.

- **Caller:** Runner `task_creation()` fills `"skill_catalog"` with `this.sr_factory.skill_manager.to_markdown()` (no header wrapper; template has "Available Skills" heading and intro paragraph before `{skill_catalog}`).
- **Template:** task_creation_initial.md has the heading, intro text, and placeholder; skills without descriptions never load (Definition validates).

---

## FIXME list (code commented out until implemented)

**What is skill input requirements?** It is the **piece of the skill file** that describes how to invoke that skill: parameter schema, call format, required/optional arguments (the skill’s execution spec). It is **input to the refine stage**, not the output. At refine we already have the skill name (from the coarse task). We **inject** that skill’s input-requirements block into the refinement prompt via `{skill_input_requirements}` so the refiner knows exactly what arguments and syntax to produce. The refiner **outputs** the refined task including the **Skill call** (concrete arguments). So: skill input requirements = “how to call this skill” (from the skill file); used only at **refine** (Details.refine() → template placeholder `{skill_input_requirements}`). See 1.23.4.

- **Definition.skill_input_requirements()** — **DONE.** Implemented on Definition; used in Details.refine() for `{skill_input_requirements}`.
- **sr_factory.current_file()** — **DONE.** Method on Skill.Factory returning File?; project_manager on Factory. §4 implemented; Runner.task_creation() and Details.refine() now fill `{current_file}` from factory.current_file().
- **Runner.reference_content(href)** — *Specific item; does not hold up 5.1.* Not yet on Runner. Details.reference_contents() passes `""` for non-absolute hrefs at call site only. See §3 Resolving references.
- **ListItem.key_value(Block)** and **List.to_key_map()** — **DONE.** Implemented in libocmarkdown (ListItem.vala, List.vala). ResultParser uses **list_block.to_key_map()** in parse_task_list and extract_refinement.
- **Factory access:** ResultParser builds Details with the runner’s factory. `OLLMchat.Agent.Base.factory` is protected, so `this.runner.factory` was denied. **Fix:** use **this.runner.sr_factory** (public on Runner, returns `Skill.Factory` which is an `Agent.Factory`). Details constructor accepts `OLLMchat.Agent.Factory`, so passing `runner.sr_factory` is correct. *(Already fixed in code; nothing to uncomment.)*

**Can we uncomment yet?** 5.1 flow is uncommented. Only **reference_content** remains stubbed at its call site (does not block 5.1).

**Remaining to be added (stub at call site only until implemented):**

| Item | Where to add | Call site (currently stubbed) |
|------|----------------|-------------------------------|
| ~~`current_file()` (method on Factory) + project_manager on Factory~~ | ~~Factory.vala~~ | **DONE** §4 |
| `reference_content(href)` | `liboccoder/Skill/Runner.vala` | Details.vala reference_contents() |

---

## to_key_map — one approved format (List + ListItem) — DONE

**Document model:** A ListItem does not have a paragraph wrapper. Its **children** are the content directly — typically **Format**/inline nodes (BOLD, TEXT, LINK, etc.). A **List**'s children are **ListItems**. One list item = one row (e.g. **What is needed** — text, or **Skill** — text).

- **ListItem.key_value(Block value)** — instance method on **this** ListItem. Caller creates the value block and passes it in; we append the rest of this.children (tail) to value.children. **Return value is the key** (string). Only checks first child; only **BOLD_ASTERISK**. If first child is not BOLD_ASTERISK → return "". No copy, no adopt — just append to value's child array.
- **List.to_key_map()** — run on a **List** block. The List's children are ListItems. It just iterates this.children and for each ListItem calls key_value(value), then result.set(key, value). Caller creates a new Block for each item and passes it to key_value.

**Implementation (for review).** No copy, no adopt — just append each tail node to value's child array.

```vala
/**
 * Get key from this list item and fill value with the rest (operates on this).
 * Caller creates value and passes it in. Only checks first child; only BOLD_ASTERISK.
 * If first child is not BOLD_ASTERISK → return "". Else return first child's text and append tail to value.children.
 */
public string key_value(Block value)
{
	if (this.children.size == 0) {
		return "";
	}
	var first = this.children.get(0);
	if (!(first is Format) || ((Format) first).kind != FormatType.BOLD_ASTERISK) {
		return "";
	}
	var key = ((Format) first).text_content().strip();
	for (var i = 1; i < this.children.size; i++) {
		value.children.add(this.children.get(i));
	}
	return key;
}

}
```

**Add to `libocmarkdown/document/List.vala`:**

```vala
/**
 * Build a map from this list: children are ListItems. Iterate and call key_value on each; key = return value, value = caller-created block.
 */
public Gee.Map<string, Block> to_key_map()
{
	var result = new Gee.HashMap<string, Block>();
	foreach (var node in this.children) {
		var item = node as ListItem;
		if (item == null) {
			continue;
		}
		var v = new Block(FormatType.PARAGRAPH);
		var k = item.key_value(v);
		if (k == "") {
			continue;
		}
		result.set(k, v);
	}
	return result;
}
```

---

## Later (1.23.18 — low priority)

- **validate_task_list_reference_lengths(TaskList):** Runner method. Per-task resolved reference content length (same as Details); if any over max return issues string. send_async would append to parser.issues and retry. Deferred from main 1.23.14 flow.

---

## Naming / other


- List: **run_until_user_approval** (line 105) → align with plan **run_until_writer**; add **has_writer_tasks**.
- PromptTemplate, Factory, Manager, Definition, prompt format: per 1.23.14 main plan and 1.23.17.

---

## We must fix: project_manager references — DONE

- **project_manager** now lives on **sr_factory** (Skill.Factory), not on Runner. Factory is constructed with project_manager (required). Implemented §4; Window.vala passes `this.project_manager` to Factory.
- Call sites (Runner, Details) get it via **this.sr_factory.project_manager** or **this.runner.sr_factory.project_manager**, and use **sr_factory.current_file()** for current file. All references updated.
