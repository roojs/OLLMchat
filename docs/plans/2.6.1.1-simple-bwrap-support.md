# 2.6.1.1. Simple bwrap Support (No Overlay)

## Overview

Implement basic bwrap (bubblewrap) sandboxing for code execution without overlay filesystem support. This phase establishes the foundation for secure command execution.

## Status

‚è≥ **PLANNING** - Design phase.

## Prerequisites

- See main plan: `2.6.1-code-exec-improvements.md` for general architecture and design decisions
- bwrap (bubblewrap) must be installed on system

## Goals

1. Create `Bwrap` class for bwrap command execution
2. Configure read-only root filesystem access
3. Block network access by default
4. Disable bwrap if running inside Flatpak (nested bwrap too difficult to support)
5. Replace `GLib.Subprocess` with bwrap execution

## Implementation Details

### Files to Create

- `liboctools/RunCommand/Bwrap.vala` - bwrap wrapper class

### Files to Modify

- `liboctools/RunCommand/Request.vala` - Integrate Bwrap class for command execution
- `libocfiles/Folder.vala` - Add `root_folders()` method to return paths that need write access (following symlinks)

### Bwrap Class Design

#### Class Structure

```vala
namespace OLLMtools.RunCommand {
    public class Bwrap {
        // Properties
        private OLLMfiles.Folder project;           // Project folder (is_project = true)
        private Gee.ArrayList<OLLMfiles.Folder> additional_folders;  // Additional folders to share (optional)
        private Gee.HashMap<string, OLLMfiles.Folder> shared_folders;  // Map of path -> Folder objects to share (read-write access)
        private bool allow_network;                 // Network access flag (default: false)
        
        // Constructor
        public Bwrap(OLLMfiles.Folder project, Gee.ArrayList<OLLMfiles.Folder>? additional_folders = null, bool allow_network = false)
        
        // Public methods
        public async string exec(string command) throws Error
        
        // Private helper methods
        private bool check_if_in_flatpak()
        private void build_shared_folders() throws Error
        private string[] build_bwrap_args(string command) throws Error
        private async string read_subprocess_output(Subprocess subprocess) throws Error
    }
}
```

**Note**: Implementation should be split into two parts:
1. **Part 1**: Create the Bwrap class with basic functionality
2. **Part 2**: Integrate Bwrap into RunCommand/Request.vala to replace GLib.Subprocess

**Note**: A new Bwrap instance is created for each command execution. The instance is used once and then goes out of scope, so no cleanup logic is needed for old instances.

#### Method Details

**Constructor: `Bwrap(OLLMfiles.Folder project, Gee.ArrayList<OLLMfiles.Folder>? additional_folders = null, bool allow_network = false) throws Error`**
- **Purpose**: Initialize Bwrap instance with configuration
- **Parameters**:
  - `project`: Project folder object (is_project = true) - the main project directory
  - `additional_folders`: Optional array of additional Folder objects to share (default: null)
  - `allow_network`: Whether to allow network access (default: false, Phase 7 feature)
- **Implementation**:
  - Call `check_if_in_flatpak()` to check if running inside Flatpak
  - If `is_in_flatpak == true`: Throw error (bwrap disabled when running inside Flatpak)
  - Store parameters as instance variables
  - Initialize `shared_folders` as empty HashMap
  - Call `build_shared_folders()` to build the HashMap from Folder objects
  - Note: Environment variables are inherited from user's environment (no explicit handling needed)

**Method: `async string exec(string command) throws Error`**
- **Purpose**: Execute command string in bwrap sandbox and return output as string
- **Parameters**:
  - `command`: Command string to execute (e.g., `"ls -la"` or `"cd /path && make"`)
- **Returns**: String containing command output (stdout + stderr, with exit code if non-zero)
- **Implementation**:
  1. Build bwrap command arguments using `build_bwrap_args(command)`
  2. Create `GLib.Subprocess` with bwrap as executable
  3. Configure subprocess flags: `STDOUT_PIPE | STDERR_PIPE | STDIN_INHERIT`
  4. Read output using `read_subprocess_output()`
  5. Wait for process to complete and get exit status
  6. Format output: stdout + stderr + exit code (if non-zero)
  7. Return formatted string
- **How it works**:
  - Constructs bwrap command: `bwrap [args] -- /bin/sh -c "command"`
  - Uses `GLib.Subprocess.newv()` to create process
  - Handles all I/O internally and returns simple string result
  - LLM only sees command string in, string out - everything else is internal

**Method: `private void build_shared_folders() throws Error`**
- **Purpose**: Build the shared_folders HashMap from project and additional_folders using Folder methods
- **Implementation**:
  1. Clear existing `shared_folders` HashMap
  2. Get writable paths from project:
     - Call `project.root_folders()` to get array of paths that need to be writable
     - This method follows symlinks within the project and returns all paths that need write access
     - For each path returned:
       - Validate path exists and is absolute
       - Add to HashMap: `shared_folders.set(path, project)` (use project as the Folder reference)
  3. Add additional folders (if provided):
     - For each folder in `additional_folders`:
       - Call `folder.root_folders()` to get array of paths that need to be writable
       - For each path returned:
         - Validate path exists and is absolute
         - Add to HashMap: `shared_folders.set(path, folder)`
- **How it works**:
  - Uses `folder.root_folders()` method to get paths (following symlinks)
  - For Phase 1: Returns realpaths (actual filesystem paths, with symlinks resolved)
  - In later phases: `root_folders()` will return overlay mount points instead of realpaths
  - The HashMap key (path) is what's used for bwrap bind mounting
  - The HashMap value (Folder object) is kept for reference and future use
  - Multiple paths can be returned from a single Folder if it contains symlinks to other directories

**Method: `private bool check_if_in_flatpak()`**
- **Purpose**: Check if application is running inside Flatpak
- **Returns**: `true` if running in Flatpak, `false` otherwise
- **Implementation**:
  - Check for `FLATPAK_ID` environment variable using `GLib.Environment.get_variable("FLATPAK_ID")`
  - Return `true` if variable exists and is not empty, `false` otherwise
- **How it works**:
  - Flatpak sets the `FLATPAK_ID` environment variable when running inside a Flatpak sandbox
  - Simple and reliable detection method
  - Used in constructor to throw error and disable bwrap if running in Flatpak

**Method: `private string[] build_bwrap_args(string command) throws Error`**
- **Purpose**: Build complete bwrap command line arguments
- **Parameters**:
  - `command`: Command string to execute
- **Returns**: Array of arguments for bwrap command (including `/bin/sh -c "command"`)
- **Implementation**:
  1. Start with array: `["bwrap"]`
  2. Add read-only bind: `"--ro-bind"`, `"/"`, `"/"`
  3. Add shared folder binds: Iterate over `shared_folders` HashMap, for each path add `"--bind"`, `path`, `path`
  4. Add network args: If `allow_network == false`, add `"--unshare-net"`
  5. Add separator: `"--"`
  6. Add shell command: `"/bin/sh"`, `"-c"`, `command`
  7. Return final array
- **How it works**:
  - Builds complete bwrap command: `bwrap [flags] -- /bin/sh -c "command"`
  - Uses simple string array concatenation
  - Environment variables are inherited automatically (no explicit flags needed)
  - Working directory will be added in later phases when overlay support is added
  - Final array: `["bwrap", "--ro-bind", "/", "/", "--bind", folder1_path, folder1_path, ..., "--", "/bin/sh", "-c", "command"]`

**Method: `private async string read_subprocess_output(Subprocess subprocess) throws Error`**
- **Purpose**: Read stdout and stderr from subprocess and return combined output
- **Parameters**:
  - `subprocess`: The Subprocess instance to read from
- **Returns**: Combined stdout + stderr output as string
- **Implementation**:
  1. Get stdout and stderr streams from subprocess
  2. Read from both streams concurrently (async)
  3. Combine outputs (stdout first, then stderr if present)
  4. Wait for process to complete
  5. Get exit status
  6. Append exit code to output if non-zero
  7. Return formatted string
- **How it works**:
  - Uses async I/O to read both streams
  - Formats output similar to existing RunCommand behavior
  - Handles truncation if needed (similar to existing code)

**Note**: Working directory support will be added in later phases when overlay support is implemented. For Phase 1, commands execute from the project root directory.

**Note**: Environment variables are automatically inherited from the user's environment when using `GLib.Subprocess`. No explicit `--setenv` flags are needed. bwrap will inherit the environment from the parent process by default.

#### Integration with Request.vala

**Replace in `execute_tool_async()`:**
- Current: Creates `GLib.Subprocess` directly with `/bin/sh -c`, reads streams, formats output
- New: Check if running in Flatpak first
  - If in Flatpak: Use old permission system and existing `GLib.Subprocess` code (skip bwrap entirely)
  - If not in Flatpak: Create `Bwrap` instance, call `exec(command)`, get string back
- All stream reading and formatting is handled internally by Bwrap (when used)

**Example usage:**
```vala
// Check if running in Flatpak first
if (GLib.Environment.get_variable("FLATPAK_ID") != null) {
    // Running in Flatpak - use old permission system and existing Subprocess code
    // Skip bwrap entirely, use existing execute_tool_async() implementation
    return yield this.execute_with_subprocess(this.command);
}

// Not in Flatpak - use bwrap
// Get project folder from ProjectManager
var project_manager = this.agent.project_manager;
var project = project_manager.active_project;  // OLLMfiles.Folder

// Optionally create list of additional folders to share
var additional_folders = new Gee.ArrayList<OLLMfiles.Folder>();
// Can add more folders here if needed:
// additional_folders.add(some_other_folder);

// Create Bwrap instance (will not be in Flatpak at this point)
var bwrap = new Bwrap(
    project: project,
    additional_folders: additional_folders,  // Can be null if no additional folders
    allow_network: false
);

// Execute command - simple string in, string out
var output = yield bwrap.exec(this.command);

// Return output to LLM (already formatted with stdout + stderr + exit code)
return output;
```

### Flatpak Support

- Detect if application is running inside Flatpak (check `FLATPAK_ID` environment variable)
- **Disable bwrap if running inside Flatpak**: Check in `Request.vala` before creating Bwrap instance
- **Use old permission system in Flatpak**: When running in Flatpak, skip bwrap entirely and use existing `GLib.Subprocess` code with old permission system
- Nested bwrap support is too difficult to implement reliably, so bwrap is disabled in Flatpak environments
- When disabled, RunCommand uses existing permission system and `GLib.Subprocess` execution

### Integration

**Part 2: Integrate into RunCommand**
- Check for `FLATPAK_ID` environment variable at start of `execute_tool_async()`
- If running in Flatpak: Use old permission system and existing `GLib.Subprocess` code (skip bwrap entirely)
- If not in Flatpak: Create `Bwrap` instance and use `Bwrap.exec()`
- All I/O handling is internal to Bwrap class (when used)
- LLM interface remains simple: command string in, output string out

## Implementation Tasks

**Part 1: Create Bwrap Class**
- [ ] Add `root_folders()` method to `Folder` class (returns paths that need write access, following symlinks)
- [ ] Create `Bwrap` class structure
- [ ] Implement constructor with Folder objects
- [ ] Implement `build_shared_folders()` method (calls `folder.root_folders()`)
- [ ] Implement `check_if_in_flatpak()` method
- [ ] Implement `build_bwrap_args()` method (builds all args inline, no helper methods needed)
- [ ] Implement `read_subprocess_output()` method
- [ ] Implement `exec(string command)` method (main public API)
- [ ] Test Bwrap class in isolation

**Part 2: Integrate into RunCommand**
- [ ] Modify `RunCommand/Request.vala` to check for Flatpak at start of `execute_tool_async()`
- [ ] If running in Flatpak: Use old permission system and existing `GLib.Subprocess` code (early return)
- [ ] If not in Flatpak: Create `Bwrap` instance and use `Bwrap.exec()`
- [ ] Replace `GLib.Subprocess` code with `Bwrap.exec()` call (when not in Flatpak)
- [ ] Simplify `execute_tool_async()` method
- [ ] Test integration with RunCommand tool
- [ ] Test basic command execution
- [ ] Test that bwrap is disabled when running inside Flatpak (constructor throws error)
- [ ] Test network blocking (verify commands cannot access network by default)
- [ ] Test write restrictions (writes to project directory only)

## Testing

- Test commands that should work (read-only, project writes)
- Test commands that should be blocked (system writes)
- Test network blocking (commands cannot access network)
- Test that bwrap is disabled when running inside Flatpak (falls back to regular Subprocess)

## Notes

- bwrap may not be available on all systems - need fallback or requirement check
- **bwrap is disabled when running inside Flatpak**: Check `FLATPAK_ID` in `Request.vala` before creating Bwrap, use old permission system and existing `GLib.Subprocess` code instead
- Network access will be added in Phase 7 (last phase)
- Overlay filesystem support will be added in Phase 3
- **Folder.root_folders() method**: Needs to be implemented in Folder class
  - Should return array of paths that need write access
  - Must follow symlinks within the project to find all directories that need to be writable
  - For Phase 1: Returns realpaths (actual filesystem paths with symlinks resolved)
  - In later phases: Will return overlay mount points instead of realpaths

