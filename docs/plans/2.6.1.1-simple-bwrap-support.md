# 2.6.1.1. Simple bwrap Support (No Overlay)

## Overview

Implement basic bwrap (bubblewrap) sandboxing for code execution without overlay filesystem support. This phase establishes the foundation for secure command execution.

## Status

‚è≥ **PLANNING** - Design phase.

## Prerequisites

- See main plan: `2.6.1-code-exec-improvements.md` for general architecture and design decisions
- bwrap (bubblewrap) must be installed on system

## Goals

1. Create `Bwrap` class for bwrap command execution
2. Configure read-only root filesystem access
3. Block network access by default
4. Disable bwrap if running inside Flatpak (nested bwrap too difficult to support)
5. Replace `GLib.Subprocess` with bwrap execution

## Implementation Details

### Files to Create

- `liboctools/RunCommand/Bwrap.vala` - bwrap wrapper class

### Files to Modify

- `liboctools/RunCommand/Request.vala` - Integrate Bwrap class for command execution
- `libocfiles/Folder.vala` - Add `root_folders()` method to return paths that need write access (following symlinks)

### Bwrap Class Design

#### Class Structure

```vala
namespace OLLMtools.RunCommand {
    public class Bwrap {
        // Properties
        private OLLMfiles.Folder project;           // Project folder (is_project = true)
        private Gee.ArrayList<OLLMfiles.Folder> additional_folders;  // Additional folders to share (optional)
        private Gee.HashMap<string, OLLMfiles.Folder> shared_folders;  // Map of path -> Folder objects to share (read-write access)
        private bool allow_network;                 // Network access flag (default: false)
        private bool is_in_flatpak;                   // Whether we're running inside Flatpak
        
        // Constructor
        public Bwrap(OLLMfiles.Folder project, Gee.ArrayList<OLLMfiles.Folder>? additional_folders = null, bool allow_network = false)
        
        // Public methods
        public async string exec(string command) throws Error
        
        // Private helper methods
        private bool check_if_in_flatpak()
        private void build_shared_folders() throws Error
        private string[] build_bwrap_args(string command) throws Error
        private async string read_subprocess_output(Subprocess subprocess) throws Error
    }
}
```

**Note**: Implementation should be split into two parts:
1. **Part 1**: Create the Bwrap class with basic functionality
2. **Part 2**: Integrate Bwrap into RunCommand/Request.vala to replace GLib.Subprocess

**Note**: A new Bwrap instance is created for each command execution. The instance is used once and then goes out of scope, so no cleanup logic is needed for old instances.

#### Method Details

**Constructor: `Bwrap(OLLMfiles.Folder project, Gee.ArrayList<OLLMfiles.Folder>? additional_folders = null, bool allow_network = false)`**
- **Purpose**: Initialize Bwrap instance with configuration
- **Parameters**:
  - `project`: Project folder object (is_project = true) - the main project directory
  - `additional_folders`: Optional array of additional Folder objects to share (default: null)
  - `allow_network`: Whether to allow network access (default: false, Phase 7 feature)
- **Implementation**:
  - Store parameters as instance variables
  - Initialize `shared_folders` as empty HashMap
  - Call `check_if_in_flatpak()` to check if running inside Flatpak
  - Call `build_shared_folders()` to build the HashMap from Folder objects
  - Note: Environment variables are inherited from user's environment (no explicit handling needed)

**Method: `async string exec(string command) throws Error`**
- **Purpose**: Execute command string in bwrap sandbox and return output as string
- **Parameters**:
  - `command`: Command string to execute (e.g., `"ls -la"` or `"cd /path && make"`)
- **Returns**: String containing command output (stdout + stderr, with exit code if non-zero)
- **Implementation**:
  1. Build bwrap command arguments using `build_bwrap_args(command)`
  2. Create `GLib.Subprocess` with bwrap as executable
  3. Configure subprocess flags: `STDOUT_PIPE | STDERR_PIPE | STDIN_INHERIT`
  4. Read output using `read_subprocess_output()`
  5. Wait for process to complete and get exit status
  6. Format output: stdout + stderr + exit code (if non-zero)
  7. Return formatted string
- **How it works**:
  - Constructs bwrap command: `bwrap [args] -- /bin/sh -c "command"`
  - Uses `GLib.Subprocess.newv()` to create process
  - Handles all I/O internally and returns simple string result
  - LLM only sees command string in, string out - everything else is internal

**Method: `private void build_shared_folders() throws Error`**
- **Purpose**: Build the shared_folders HashMap from project and additional_folders using Folder methods
- **Implementation**:
  1. Clear existing `shared_folders` HashMap
  2. Get writable paths from project:
     - Call `project.root_folders()` to get array of paths that need to be writable
     - This method follows symlinks within the project and returns all paths that need write access
     - For each path returned:
       - Validate path exists and is absolute
       - Add to HashMap: `shared_folders.set(path, project)` (use project as the Folder reference)
  3. Add additional folders (if provided):
     - For each folder in `additional_folders`:
       - Call `folder.root_folders()` to get array of paths that need to be writable
       - For each path returned:
         - Validate path exists and is absolute
         - Add to HashMap: `shared_folders.set(path, folder)`
- **How it works**:
  - Uses `folder.root_folders()` method to get paths (following symlinks)
  - For Phase 1: Returns realpaths (actual filesystem paths, with symlinks resolved)
  - In later phases: `root_folders()` will return overlay mount points instead of realpaths
  - The HashMap key (path) is what's used for bwrap bind mounting
  - The HashMap value (Folder object) is kept for reference and future use
  - Multiple paths can be returned from a single Folder if it contains symlinks to other directories

**Method: `private bool check_if_in_flatpak()`**
- **Purpose**: Check if application is running inside Flatpak
- **Returns**: `true` if running in Flatpak, `false` otherwise
- **Implementation**:
  - Check for `FLATPAK_ID` environment variable using `GLib.Environment.get_variable("FLATPAK_ID")`
  - Return `true` if variable exists and is not empty, `false` otherwise
- **How it works**:
  - Flatpak sets the `FLATPAK_ID` environment variable when running inside a Flatpak sandbox
  - Simple and reliable detection method
  - Cached result stored in `is_in_flatpak` property

**Method: `private string[] build_bwrap_args(string command) throws Error`**
- **Purpose**: Build complete bwrap command line arguments
- **Parameters**:
  - `command`: Command string to execute
- **Returns**: Array of arguments for bwrap command (including `/bin/sh -c "command"`)
- **Implementation**:
  1. Start with array: `["bwrap"]`
  2. Add read-only bind: `"--ro-bind"`, `"/"`, `"/"`
  3. Add shared folder binds: Iterate over `shared_folders` HashMap, for each path add `"--bind"`, `path`, `path`
  4. Add network args: If `allow_network == false`, add `"--unshare-net"`
  5. Add Flatpak-specific args: If `is_in_flatpak == true`, may add `"--share-net"` (if needed)
  6. Add separator: `"--"`
  7. Add shell command: `"/bin/sh"`, `"-c"`, `command`
  8. Return final array
- **How it works**:
  - Builds complete bwrap command: `bwrap [flags] -- /bin/sh -c "command"`
  - Uses simple string array concatenation
  - Environment variables are inherited automatically (no explicit flags needed)
  - Working directory will be added in later phases when overlay support is added
  - Final array: `["bwrap", "--ro-bind", "/", "/", "--bind", folder1_path, folder1_path, ..., "--", "/bin/sh", "-c", "command"]`

**Method: `private async string read_subprocess_output(Subprocess subprocess) throws Error`**
- **Purpose**: Read stdout and stderr from subprocess and return combined output
- **Parameters**:
  - `subprocess`: The Subprocess instance to read from
- **Returns**: Combined stdout + stderr output as string
- **Implementation**:
  1. Get stdout and stderr streams from subprocess
  2. Read from both streams concurrently (async)
  3. Combine outputs (stdout first, then stderr if present)
  4. Wait for process to complete
  5. Get exit status
  6. Append exit code to output if non-zero
  7. Return formatted string
- **How it works**:
  - Uses async I/O to read both streams
  - Formats output similar to existing RunCommand behavior
  - Handles truncation if needed (similar to existing code)

**Note**: Working directory support will be added in later phases when overlay support is implemented. For Phase 1, commands execute from the project root directory.

**Note**: Environment variables are automatically inherited from the user's environment when using `GLib.Subprocess`. No explicit `--setenv` flags are needed. bwrap will inherit the environment from the parent process by default.

#### Integration with Request.vala

**Replace in `execute_tool_async()`:**
- Current: Creates `GLib.Subprocess` directly with `/bin/sh -c`, reads streams, formats output
- New: Create `Bwrap` instance, call `exec(command)`, get string back
- All stream reading and formatting is handled internally by Bwrap

**Example usage:**
```vala
// Get project folder from ProjectManager
var project_manager = this.agent.project_manager;
var project = project_manager.active_project;  // OLLMfiles.Folder

// Optionally create list of additional folders to share
var additional_folders = new Gee.ArrayList<OLLMfiles.Folder>();
// Can add more folders here if needed:
// additional_folders.add(some_other_folder);

// Create Bwrap instance (it will build shared_folders HashMap internally)
var bwrap = new Bwrap(
    project: project,
    additional_folders: additional_folders,  // Can be null if no additional folders
    allow_network: false
);

// Execute command - simple string in, string out
var output = yield bwrap.exec(this.command);

// Return output to LLM (already formatted with stdout + stderr + exit code)
return output;
```

### Flatpak Support

- Detect if application is running inside Flatpak (`check_if_in_flatpak()`)
- Check for `FLATPAK_ID` environment variable
- Use appropriate bwrap nesting flags/methods when running inside Flatpak
- Ensure nested bwrap still provides proper sandboxing when inside Flatpak

### Integration

**Part 2: Integrate into RunCommand**
- Replace `GLib.Subprocess` calls in `RunCommand/Request.vala` with `Bwrap.exec()`
- Simplify `execute_tool_async()` to just call `bwrap.exec(command)` and return string
- All I/O handling is internal to Bwrap class
- LLM interface remains simple: command string in, output string out

## Implementation Tasks

**Part 1: Create Bwrap Class**
- [ ] Add `root_folders()` method to `Folder` class (returns paths that need write access, following symlinks)
- [ ] Create `Bwrap` class structure
- [ ] Implement constructor with Folder objects
- [ ] Implement `build_shared_folders()` method (calls `folder.root_folders()`)
- [ ] Implement `check_if_in_flatpak()` method
- [ ] Implement `build_bwrap_args()` method (builds all args inline, no helper methods needed)
- [ ] Implement `read_subprocess_output()` method
- [ ] Implement `exec(string command)` method (main public API)
- [ ] Test Bwrap class in isolation

**Part 2: Integrate into RunCommand**
- [ ] Modify `RunCommand/Request.vala` to use Bwrap
- [ ] Replace `GLib.Subprocess` code with `Bwrap.exec()` call
- [ ] Simplify `execute_tool_async()` method
- [ ] Test integration with RunCommand tool
- [ ] Test basic command execution (both inside and outside Flatpak)
- [ ] Test network blocking (verify commands cannot access network by default)
- [ ] Test write restrictions (writes to project directory only)

## Testing

- Test commands that should work (read-only, project writes)
- Test commands that should be blocked (system writes)
- Test network blocking (commands cannot access network)
- Test Flatpak scenarios (application running inside Flatpak and not in Flatpak)

## Notes

- bwrap may not be available on all systems - need fallback or requirement check
- Network access will be added in Phase 7 (last phase)
- Overlay filesystem support will be added in Phase 3
- **Folder.root_folders() method**: Needs to be implemented in Folder class
  - Should return array of paths that need write access
  - Must follow symlinks within the project to find all directories that need to be writable
  - For Phase 1: Returns realpaths (actual filesystem paths with symlinks resolved)
  - In later phases: Will return overlay mount points instead of realpaths

