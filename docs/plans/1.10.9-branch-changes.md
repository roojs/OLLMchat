# 1.10.9 branch changes (code only)

## handle_line_break — state_stack clear (Parser.vala)

```vala
			// Reset inline formatting so next block starts clean (CommonMark: inline scoped per block)
			this.state_stack.clear();
			if (str != "") {
```
Clear state_stack on newline before flushing text.

---

## process_inline (Parser.vala) — ON HOLD (not thought to be the issue)

```vala
		public void process_inline(string text)
		{
			var pos = 0;
			var str = "";
			while (pos < text.length) {
				if (text.get_char(pos) == '\\' && pos + 1 < text.length) {
					this.renderer.on_text(str);
					str = "";
					this.renderer.on_text(text.get_char(pos + 1).to_string());
					pos += 1 + text.get_char(pos + 1).to_string().length;
					continue;
				}
				var matched_format = FormatType.NONE;
				var byte_length = 0;
				var match_len = this.formatmap.eat(text, pos, true, out matched_format, out byte_length);
				if (this.state_stack.size > 0) {
					var top = this.state_stack.get(this.state_stack.size - 1);
					if ((top == FormatType.LITERAL || top == FormatType.CODE) && matched_format != top) {
						match_len = 0;
					}
				}
				if (match_len == -1) {
					this.renderer.on_text(str);
					str = "";
					var c = text.get_char(pos);
					this.renderer.on_text(c.to_string());
					pos += c.to_string().length;
					continue;
				}
				if (match_len == 0) {
					var c = text.get_char(pos);
					str += c.to_string();
					pos += c.to_string().length;
					continue;
				}
				this.renderer.on_text(str);
				str = "";
				if (matched_format == FormatType.LINK) {
					var seq_pos = pos + byte_length;
					var link_result = this.formatmap.eat_link(text, pos, seq_pos, true);
					if (link_result == -1) {
						var c = text.get_char(pos);
						this.renderer.on_text(c.to_string());
						pos += c.to_string().length;
						continue;
					}
					if (link_result == 0) {
						this.renderer.on_text(text.substring(pos, byte_length));
						pos += byte_length;
						continue;
					}
					this.formatmap.handle_link(text, pos, seq_pos, link_result);
					pos = link_result;
					continue;
				}
				if (matched_format != FormatType.HTML) {
					this.got_format(matched_format);
					pos += byte_length;
					continue;
				}
				var sub = text.substring(pos + byte_length);
				var rest = this.add_html(sub);
				pos += byte_length + (sub.length - rest.length);
			}
			for (var i = this.state_stack.size - 1; i >= 0; i--) {
				this.do_format(false, this.state_stack.get(i));
			}
			this.state_stack.clear();
			if (str != "") {
				this.renderer.on_text(str);
			}
		}
```
Parse inline-only string (escape, code-span literal, LINK branch); used for link text and table cells.

---

## MarkerMap.eat() — single-char at end of chunk (MarkerMap.vala)

```vala
			if (next_pos >= chunk.length) {
				// only hit at end of chunk
				matched_type = map.get(single_char);
				if (matched_type == FormatType.INVALID) {
					// INVALID at end of chunk: need more input to resolve (e.g. [ → [?, [??; ~ → ~~)
					if (!is_end_of_chunks) {
						return -1;
					}
					return 0;
				}
				if (!is_end_of_chunks) {
					return -1; // Might be longer match
				}
				byte_length = next_pos - chunk_pos;
				return 1; // Definitive single char match
			}
```
At end of chunk, INVALID (e.g. `[`) returns -1 if more chunks may follow, else 0.

---

## MarkerMap.eat() — loop: wildcard_sequence and two lookups (MarkerMap.vala)

**main branch (before):**

```vala
			var sequence = "";

			for (var cp = chunk_pos; cp < chunk.length; ) {
				var char_at_cp = chunk.get_char(cp);
				sequence += char_at_cp.isdigit() ? "1" : char_at_cp.to_string();
				cp += char_at_cp.to_string().length;
				char_count++;

				var last_char = char_at_cp;
				if (last_char.isalpha() && last_char.tolower() != 'x') {
					return max_match_length;
				}

				if (!map.has_key(sequence)) {
					return max_match_length;
				}

				matched_type = map.get(sequence);

				if (matched_type != FormatType.INVALID) {
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
				}
			}
```

**branch (after):**

```vala
			string sequence = "";
			string wildcard_sequence = "";

			for (var cp = chunk_pos; cp < chunk.length; ) {
				var char_at_cp = chunk.get_char(cp);
				var wc_char = char_at_cp.to_string();
				// NOTE done this way as vala frees a?b:c assignemnts whcich borks this loop
				if (char_at_cp.isdigit()) {
					wc_char = "1";
				}
				sequence += wc_char;
				if (char_at_cp.isalpha()) {
					wc_char = "?";
				}
				wildcard_sequence += wc_char;

				cp += char_at_cp.to_string().length;
				char_count++;

				var last_char = char_at_cp;
				

				if (map.has_key(sequence)) {
					matched_type = map.get(sequence);
					if (matched_type == FormatType.INVALID) {
						continue; // e.g. "[" alone: keep building to try "[a", "[ ]", etc.
					}
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
					continue; // try next char for longer match (e.g. * → ** → ***)
				}
				if (map.has_key(wildcard_sequence)) {
					matched_type = map.get(wildcard_sequence);
					if (matched_type == FormatType.INVALID) {
						continue; // let the loop eat another character
					}
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
					break; // exit loop; end-of-loop returns max_match_length
				}
				if (matched_type != FormatType.NONE) {
					break;
				}
				if (last_char.isalpha() && last_char.tolower() != 'x') {
					return max_match_length;
				}
				return max_match_length;
			}
```
Build wildcard key (alpha → `?`); exact lookup first, then wildcard; INVALID continues loop; alpha early-return moved after lookups.

---

## MarkerMap.eat() — end of chunk, wildcard INVALID (MarkerMap.vala)

```vala
			// Reached end of chunk (no more characters to eat)
			if (!is_end_of_chunks) {
				// Wildcard INVALID (e.g. "[?") means need more characters to decide
				if (map.has_key(wildcard_sequence) && map.get(wildcard_sequence) == FormatType.INVALID) {
					return -1;
				}
				// ...
			}
```
When chunk ends on wildcard INVALID (e.g. `[?`), return -1 so parser defers.
