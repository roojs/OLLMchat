# 1.10.9 branch changes (code only)

## process_inline (Parser.vala) — ON HOLD (not thought to be the issue)

Parse inline-only string (escape, code-span literal, LINK branch); used for link text and table cells.

---

## MarkerMap.eat() — single-char at end of chunk (MarkerMap.vala)

```vala
			if (next_pos >= chunk.length) {
				// only hit at end of chunk
				matched_type = map.get(single_char);
				if (matched_type == FormatType.INVALID) {
					// INVALID at end of chunk: need more input to resolve (e.g. [ → [?, [??; ~ → ~~)
					if (!is_end_of_chunks) {
						return -1;
					}
					return 0;
				}
				if (!is_end_of_chunks) {
					return -1; // Might be longer match
				}
				byte_length = next_pos - chunk_pos;
				return 1; // Definitive single char match
			}
```
At end of chunk, INVALID (e.g. `[`) returns -1 if more chunks may follow, else 0.

---

## MarkerMap.eat() — loop: wildcard_sequence and two lookups (MarkerMap.vala)

**main branch (before):**

```vala
			var sequence = "";

			for (var cp = chunk_pos; cp < chunk.length; ) {
				var char_at_cp = chunk.get_char(cp);
				sequence += char_at_cp.isdigit() ? "1" : char_at_cp.to_string();
				cp += char_at_cp.to_string().length;
				char_count++;

				var last_char = char_at_cp;
				if (last_char.isalpha() && last_char.tolower() != 'x') {
					return max_match_length;
				}

				if (!map.has_key(sequence)) {
					return max_match_length;
				}

				matched_type = map.get(sequence);

				if (matched_type != FormatType.INVALID) {
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
				}
			}
```

**branch (after):**

```vala
			string sequence = "";
			string wildcard_sequence = "";

			for (var cp = chunk_pos; cp < chunk.length; ) {
				var char_at_cp = chunk.get_char(cp);
				var wc_char = char_at_cp.to_string();
				// NOTE done this way as vala frees a?b:c assignemnts whcich borks this loop
				if (char_at_cp.isdigit()) {
					wc_char = "1";
				}
				sequence += wc_char;
				if (char_at_cp.isalpha()) {
					wc_char = "?";
				}
				wildcard_sequence += wc_char;

				cp += char_at_cp.to_string().length;
				char_count++;

				var last_char = char_at_cp;
				

				if (map.has_key(sequence)) {
					matched_type = map.get(sequence);
					if (matched_type == FormatType.INVALID) {
						continue; // e.g. "[" alone: keep building to try "[a", "[ ]", etc.
					}
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
					continue; // try next char for longer match (e.g. * → ** → ***)
				}
				if (map.has_key(wildcard_sequence)) {
					matched_type = map.get(wildcard_sequence);
					if (matched_type == FormatType.INVALID) {
						continue; // let the loop eat another character
					}
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
					break; // exit loop; end-of-loop returns max_match_length
				}
			}
```

**Held back (might be added to the code):**

```vala
				if (matched_type != FormatType.NONE) {
					break;
				}
				if (last_char.isalpha() && last_char.tolower() != 'x') {
					return max_match_length;
				}
				return max_match_length;
```

Note: This block may be added to the loop but is currently held back.

Build wildcard key (alpha → `?`); exact lookup first, then wildcard; INVALID continues loop; alpha early-return moved after lookups.
