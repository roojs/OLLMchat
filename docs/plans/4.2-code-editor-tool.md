# 4.2. Code Editor Interface

## Overview

Code editor tool for viewing and approving changes to files. Allows users to review and approve file changes before they are applied.

## Status

üü° **IN PROGRESS** - Core data layer and dropdown widgets complete. Source view and integration pending.

**Progress:** 4 of 10 phases complete (40%), 1 partially complete (10%)

## Features
- View and ??? edit files.....
- View file changes in code editor
- Project and file selection with searchable dropdowns
- Approve changes to files (see Phase 6)
- Track approved file versions (see Phase 6)
- Handle partial file approvals (see Phase 6)

## Phase Summary

| Phase | Status | Description |
|-------|--------|-------------|
| Phase 1: Pane View Component | ‚úÖ DONE | WindowPane component with visibility toggle and resizing behavior |
| Phase 1.5: Project Migration | ‚úÖ DONE | ProjectMigrate class for importing from Cursor, roobuilder, VS Code |
| Phase 2A: Data Layer (liboccoder) | ‚úÖ DONE | FileBase, File, Folder, Project, and ProjectManager classes |
| Phase 2B: Database Schema and Sync | üü° PARTIAL | Database methods implemented, missing background sync/watcher |
| Phase 2C: Searchable Dropdown Widgets | üü° PARTIAL | SearchableDropdown, ProjectDropdown, FileDropdown implemented. Sections/separators for recent items pending |
| Phase 3: Source View Component | ‚è≥ TODO | SourceView component with header bar and code editor (in liboccoder, not libollmchatgtk) |
| Phase 4: Configuration Persistence | ‚è≥ FUTURE | Save/restore UI state preferences |
| Phase 5: CodeAssistant Integration | ‚è≥ TODO | Integrate CodeAssistant with ProjectManager and editor |
| Phase 6: File Approval and Version Tracking | ‚è≥ FUTURE | Approval workflow and version tracking system |
| Phase 7: Code Editor Manager Tool | ‚è≥ TODO | Tool for LLM to manage code editor interface |

**Legend:**
- ‚úÖ DONE - Fully implemented
- üü° PARTIAL - Partially implemented
- ‚è≥ TODO - Not yet started
- ‚è≥ FUTURE - Planned for future implementation

## Phased Implementation Plan

### Phase 1: Pane View Component

‚úÖ **DONE** - WindowPane component created and moved to ollmchat directory.

Create a window pane component to contain the chat widget and a GTK Editor inside a tabbed window.

#### Component: Window Pane
- **Purpose**: Handle adjustment of the pane and manage visibility/resizing behavior
- **Contains**: Right tabbed view only (not responsible for adding widgets to tabs)
- **Exposes**: Tab view reference so main window (controller) can add widgets

#### Pane Behavior Rules
1. **Initial State**:
   - When program starts, right pane (source view) is **hidden/collapsed**
   - Chat widget occupies full available space

2. **Visibility Toggle (Opening Code View)**:
   - Pane becomes visible when user switches from "ask me" to "code assist" mode
   - **Window Resizing Strategy**:
     1. Capture current chat view width
     2. Set minimum width of chat view to its current width (prevents chat from shrinking)
     3. Unhide source view with minimum width (initially fixed 400px, later restored from configuration - see Phase 4)
     4. Window automatically resizes to accommodate both panes with their minimum widths
     5. In idle callback, remove the minimum width constraints
     6. Window has now been resized, and panes can be adjusted normally
   - This ensures chat view width stays the same when code view opens
   - Window grows to accommodate the new pane rather than shrinking the chat area

3. **Hide Right Pane Method**:
   - Method to hide the right pane
   - When hidden, adjust window size such that:
     - Chat widget remains the same size (does not expand)
     - Window shrinks to accommodate the hidden pane

#### Implementation Details
- Use GTK4 `Gtk.Paned` (horizontal orientation) for the split view
- Left pane: Chat widget
- Right pane: Tabbed container (initially empty/hidden)
- Pane adjustment handles minimum size constraints for both panes
- Main window will add widgets to the tabbed container

#### Files to Create
- `ollmchat/WindowPane.vala` - Main pane component class (namespace: OLLMchat)

---

### Phase 2A: Data Layer (liboccoder)

‚úÖ **DONE** - Basic data layer library created with FileBase, File, Folder, Project, and ProjectManager classes.

**Note**: File class has `is_open` and `is_active` properties. The `text_buffer` property (GtkSource.Buffer) will be added in Phase 3 when SourceView is implemented. The `sourceview` property is not needed - SourceView component manages the single view widget and switches buffers.

#### Component: liboccoder Library
- **Namespace**: `OLLMcoder`
- **Library Name**: `liboccoder`
- **Classes**:
  - `OLLMcoder.Files.File` - Represents a file (extends `FileBase`)
  - `OLLMcoder.Files.Folder` - Represents a folder/directory (extends `FileBase`)
  - `OLLMcoder.Files.Project` - Represents a project (extends `OLLMcoder.Files.Folder`)
  - `OLLMcoder.ProjectManager` - Manages projects and files (basic structure, database sync added in Phase 2B)

#### Class Properties

##### OLLMcoder.Files.FileBase (Base Class)
- `id` (int64) - Database ID
- `path` (string) - File/folder path
- `parent` (OLLMcoder.Files.Folder?) - Reference to parent folder (nullable for root folders/projects)
- `icon_name` (string) - Icon name for binding in lists
- `display_name` (string) - Display name for binding in lists
- `tooltip` (string) - Tooltip text for binding in lists
- **Methods**:
  - `mtime_on_disk()` - Get modification time on disk (Unix timestamp)

**Note**: FileBase provides common properties and methods shared by both File and Folder.

##### OLLMcoder.Files.File (extends FileBase)
- Inherits all properties from `OLLMcoder.Files.FileBase`
- `language` (string?) - Programming language (optional, for files)
- `manager` (OLLMcoder.ProjectManager) - Reference to ProjectManager
- `text_buffer` (GtkSource.Buffer?) - Pointer to text buffer (GTK-specific, nullable, created when file is first opened)
- `is_active` (bool) - Whether this is the currently active/viewed file (stored in database)
- `is_open` (bool) - **Computed property**: Whether file was viewed within last week (based on `last_viewed` timestamp)
- `last_viewed` (int64) - Unix timestamp of last view (stored in database, default: 0)
- `cursor_line` (int) - Last cursor line number (stored in database, default: 0)
- `cursor_offset` (int) - Last cursor character offset (stored in database, default: 0)
- `scroll_position` (double) - Last scroll position (stored in database, optional, default: 0.0)
- `last_approved_copy_path` (string) - Filename of last approved copy (default: empty string)

**Note**: 
- `sourceview` property removed from design. SourceView component manages a single view widget and switches buffers.
- Each File object stores its buffer reference for reuse when switching between files.
- `is_open` is now computed from `last_viewed` timestamp (within last week = open).
- Buffer state (cursor, scroll) is persisted to database for session restoration.
- **Methods**: 
  - `read()` - Read file contents
  - `write(string)` - Write file contents
- **Signals**: `changed` - Emitted when file content changes

**Note**: Files can be in multiple projects (due to softlinks/symlinks). All alias references are tracked in ProjectManager's alias_map.

##### OLLMcoder.Files.Folder (extends FileBase)
- Inherits all properties from `OLLMcoder.Files.FileBase`
- `children` (Gee.ListStore<OLLMcoder.Files.FileBase>) - ListStore of children (files and subfolders)
- `child_map` (Gee.HashMap<string, OLLMcoder.Files.FileBase>) - Hashmap of [name in dir] => file object
- **Methods**:
  - `async read_dir()` - Load children from filesystem
- **Signals**: 
  - `child_added` - Emitted when a child is added
  - `child_removed` - Emitted when a child is removed

**Note**: Folder maintains a list of its children and a hashmap for quick lookup by filename. Emits signals when children are added/removed.

##### OLLMcoder.Files.Project
- Inherits all properties from `OLLMcoder.Files.Folder`
- `all_files` (GLib.ListStore<OLLMcoder.Files.File>) - ListStore of all files in project (used by dropdowns)
- `is_active` (bool) - Whether this is the currently active project (stored in database)
- `last_viewed` (int64) - Unix timestamp of last view (stored in database, default: 0)

**Note**: Projects are folders with special project management capabilities. Maintains a flat list of all files for efficient dropdown population. Tracks active state and last viewed timestamp for showing recent projects in dropdowns.

#### Design Decisions
- **File SourceView lifecycle**: Decision pending on whether to keep SourceView open when file is not active, or close/recreate it
- **Multi-project files**: Files can belong to multiple projects (via softlinks), managed through separate relationship tracking
- **GTK-specific properties**: `text_buffer` and `sourceview` are nullable and only set when file is open in GTK UI

#### ProjectManager Basic Responsibilities
- Manage project discovery and indexing
- Keep file/directory objects in memory
- **Static stores**:
  - `path_map` (Gee.HashMap<string, OLLMcoder.Files.FileBase>) - Hashmap of path => FileBase for quick lookup
  - `alias_map` (Gee.HashMap<OLLMcoder.Files.File, Gee.ArrayList<string>>) - Hashmap of File => list of all paths (aliases) that reference it
- Basic methods for accessing projects, files, and folders
- Methods to handle file changes (rename, move) and update all alias references
- Import initial data from ProjectMigrate (Phase 1.5)
- Note: Database persistence and sync will be added in Phase 2B

**Note**: The `alias_map` tracks all paths that reference the same file object, making it easy to find all references when a file changes (e.g., rename). This is more efficient than iterating through all folders.

#### Files to Create
- `liboccoder/` - New library directory
- `liboccoder/meson.build` - Meson build configuration
- `liboccoder/files/` - Subdirectory for file/folder/project classes
- `liboccoder/files/FileBase.vala` - Base class (namespace: OLLMcoder.Files) - shared properties and methods
- `liboccoder/files/File.vala` - File class (namespace: OLLMcoder.Files, extends FileBase)
- `liboccoder/files/Folder.vala` - Folder class (namespace: OLLMcoder.Files, extends FileBase)
- `liboccoder/files/Project.vala` - Project class (namespace: OLLMcoder.Files, extends OLLMcoder.Files.Folder)
- `liboccoder/ProjectManager.vala` - Project and file management (namespace: OLLMcoder, basic structure)

#### Meson Build Configuration
- **Library Name**: `occoder`
- **VAPI Name**: `occoder.vapi`
- **Header Name**: `occoder.h`
- **Dependencies**: 
  - `gee-0.8`
  - `gio-2.0`
  - `glib-2.0`
  - `gobject-2.0`
  - `sqlite3` (via libocsqlite)
  - `ocsqlite` (link with libocsqlite)
- **GObject Introspection**:
  - Namespace: `OLLMcoder`
  - NSVersion: `1.0`
  - Identifier prefix: `OLLMcoder`
  - Symbol prefix: `ollmcoder`
- **Build Order**: Add `subdir('liboccoder')` to main `meson.build` after `libocsqlite` (depends on it)
- **RPath**: Add liboccoder to build rpath in dependent libraries
- **Main meson.build Update**: 
  - Add `subdir('liboccoder')` in dependency order (after libocsqlite, before libraries that depend on it)
  - Add liboccoder path to library paths for LD_LIBRARY_PATH in wrapper scripts
- **Dependency Updates**:
  - `libollmchatgtk` will need to depend on `liboccoder` (for dropdown widgets)

---

### Phase 1.5: Project Migration

‚úÖ **DONE** - ProjectMigrate class fully implemented with migration from Cursor, roobuilder, and VS Code.

Create a Project Migrate class to read and import project data from existing sources.

#### Component: Project Migrate
- **Namespace**: `OLLMcoder`
- **Class**: `OLLMcoder.ProjectMigrate`
- **Purpose**: Read project and file data from bootstrap sources and prepare for import into liboccoder

#### Data Sources to Read
1. **Cursor SQLite Database**
   - Path: `~/.config/Cursor/User/globalStorage/state.vscdb`
   - Query: `SELECT value FROM ItemTable WHERE key = 'history.recentlyOpenedPathsList';`
   - Extracts recently opened file paths from Cursor

2. **roobuilder Projects List**
   - Path: `~/.config/roobuilder/Projects.list`
   - Contains project information from roobuilder

3. **VS Code Storage**
   - Path: `~/.config/Code/storage.json`
   - Contains VS Code workspace and file history

#### Implementation Details
- Read data from each source
- Parse and normalize project/file paths
- Extract project roots and file associations
- Prepare data structure for import into ProjectManager (Phase 2A)
- Handle missing or inaccessible sources gracefully

#### Files to Create
- `liboccoder/ProjectMigrate.vala` - Migration class (namespace: OLLMcoder)
  - Methods to read from each data source
  - Data normalization and parsing
  - Output format for ProjectManager import

#### Dependencies
- Uses libocsqlite for reading Cursor SQLite database
- JSON parsing for VS Code storage
- File I/O for roobuilder Projects.list

---

### Phase 2B: Database Schema and Sync

üü° **PARTIALLY DONE** - Database integration implemented: ProjectManager has `db` property, FileBase has `initDB()` and `saveToDB()` methods with sync parameter. Still missing: background sync process and file system watcher for real-time updates.

Add database persistence and background sync functionality to ProjectManager.

#### Database Schema
- SQLite table to store file information and directories
- Fields to track:
  - File paths
  - Directory structure
  - Project associations
  - Metadata (timestamps, etc.)
  - **Active state**: `is_active` (INTEGER) for files and projects
  - **Buffer state**: `cursor_line`, `cursor_offset`, `scroll_position`, `last_viewed` (INTEGER/REAL) for files
  - **Project state**: `is_active` (INTEGER), `last_viewed` (INTEGER) for projects

#### ProjectManager Database Integration
- Uses libocsqlite (SQ library) for database operations
- Background process to update database
- Methods to:
  - Update representation of files as objects
  - Sync objects to database (via libocsqlite)
  - Sync to UI if necessary (when UI is active)
- File system watcher for real-time updates

#### Files to Modify
- `liboccoder/ProjectManager.vala` - Add database persistence and sync methods

---

### Phase 2C: Searchable Dropdown Widgets

üü° **PARTIALLY DONE** - SearchableDropdown base class, ProjectDropdown, and FileDropdown widgets implemented. Still need: sections/separators for "recent" vs "rest" items.

Create searchable dropdown widgets for Project and File selection.

#### Component: Searchable Dropdowns
- **Location**: Header bar above source view
- **Layout**:
  - **Project dropdown**: Left side, searchable
  - **File dropdown**: Right side, searchable
- **Functionality**:
  - Both support search/filter interface
  - Can open files or switch projects
  - Query data via ProjectManager (from in-memory objects, backed by database from Phase 2B)

#### Implementation Details
- **Wrapper Pattern**: GTK4 dropdowns are sealed classes, so we wrap them rather than extend
- **Naming Convention**: Use `this.ell` pattern for internal widget references (not overly explicit like `this.dropdown`)
- Create wrapper widgets that contain the dropdown and add search/filter functionality
- Integrate with ProjectManager for data access
- Populate dropdowns from ProjectManager's in-memory objects

#### Files Created
- `liboccoder/SearchableDropdown.vala` - Base class for searchable dropdown widgets
- `liboccoder/ProjectDropdown.vala` - Searchable project dropdown widget (extends SearchableDropdown)
- `liboccoder/FileDropdown.vala` - Searchable file dropdown widget (extends SearchableDropdown)

**Note**: Files are in liboccoder (data layer) rather than libollmchatgtk, which is appropriate as they integrate with ProjectManager.

#### Sections/Separators in Dropdowns (TODO)

**Requirement**: Add visual separators between "recent" and "rest" of projects/files in dropdowns.

**Implementation Approach**:
- **Option 1: Wrapper objects with separators**
  - Create a wrapper class (e.g., `DropdownSection`) that can represent either an item or a separator
  - Factory checks if item is a separator and creates `Gtk.Separator` widget
  - Populate store with: [recent items...], [separator], [rest of items...]
  
- **Option 2: Custom factory with position detection**
  - Factory detects position in list (e.g., after last recent item)
  - Inserts separator widget at appropriate position
  - Requires tracking which items are "recent" vs "rest"

- **Option 3: Two separate stores with separator between**
  - Use `Gtk.FlattenListModel` to combine: recent_store, separator_item, rest_store
  - Simpler but requires managing two stores

**Recommended**: Option 1 (wrapper objects) - most flexible and clean.

**Implementation Details**:
```vala
// Wrapper class for dropdown items
internal class DropdownItem : Object {
  public Files.FileBase? item { get; set; }
  public bool is_separator { get; set; default = false; }
  public string? separator_label { get; set; } // e.g., "Recent", "All Projects"
}

// In factory setup:
factory.setup.connect((list_item) => {
  var item = list_item.item as DropdownItem;
  if (item.is_separator) {
    var separator = new Gtk.Separator(Gtk.Orientation.HORIZONTAL);
    var label = new Gtk.Label(item.separator_label) {
      halign = Gtk.Align.START,
      margin_start = 5
    };
    var box = new Gtk.Box(Gtk.Orientation.VERTICAL, 0);
    box.append(label);
    box.append(separator);
    list_item.child = box;
  } else {
    // Normal item setup
  }
});
```

**Sorting Logic**:
- **ProjectDropdown**: Sort by `is_active` first (active project at top), then by `last_viewed` (recent first), then alphabetically
- **FileDropdown**: Sort by `is_active` first (active file at top), then by `is_open` (recently viewed within last week), then alphabetically
- Insert separator after active/recent items, before rest

**Recent Definition**:
- **Projects**: `is_active = true` OR `last_viewed` within last week
- **Files**: `is_active = true` OR `is_open = true` (which is computed from `last_viewed` within last week)

---

### Phase 3: Source View Component

‚è≥ **TODO** - SourceView component not yet implemented.

Add the source view component to the tabbed container inside the window pane.

#### Component: Source View
- **Location**: Added to tabbed container in window pane (right side)
- **Layout**:
  - **Header Bar**: Contains Project and File dropdowns (from Phase 2C)
  - **Code Editor**: GTK SourceView or similar code editor component
- **Sizing**:
  - Minimum width: 400px
  - No responsibility for pane sizing (handled by WindowPane)

#### Design Decision: Buffer Switching Strategy

**Research Findings:**
- ‚úÖ **Buffer switching is feasible**: `GtkSource.View.set_buffer()` (inherited from `Gtk.TextView`) allows switching buffers at runtime
- ‚úÖ **API supports it**: The GTK4 API explicitly supports this pattern - one view can display different buffers
- ‚úÖ **One buffer can be shared**: A single buffer can be displayed in multiple views (though we won't need this)
- ‚ö†Ô∏è **View state is separate**: Cursor position, scroll position, selection are view-specific, not buffer-specific

**Chosen Approach: Single SourceView with Buffer Switching**

**Rationale:**
1. **Memory efficiency**: One view widget instead of one per file
2. **Simpler management**: Single view to maintain, configure, and style
3. **State management**: View state (cursor, scroll) is maintained per-view, so switching buffers will reset these (acceptable behavior)
4. **Proven pattern**: Used in existing codebase (RenderSourceView, RequestRunCommand)

**Alternative Considered:**
- Multiple SourceViews (one per file) with visibility switching
- **Rejected because**: More complex state management, higher memory usage, no clear benefit

#### Implementation Details

##### Buffer Management
- **Single SourceView widget**: One `GtkSource.View` instance in the SourceView component
- **Buffer per file**: Each `OLLMcoder.Files.File` object can have an associated `GtkSource.Buffer`
- **Buffer lifecycle**:
  - Create buffer when file is first opened
  - Store buffer reference in File object (via `text_buffer` property - see Phase 2A note)
  - Reuse existing buffer when switching back to a previously opened file
  - Switch view to file's buffer using `source_view.set_buffer(file.text_buffer)`
- **Buffer creation**:
  - Detect language from file extension/path
  - Create `GtkSource.Buffer.with_language()` if language detected
  - Fall back to `GtkSource.Buffer(null)` if no language match
  - Load file content into buffer: `buffer.text = file.read()`

##### File Switching Workflow
1. **User selects file from FileDropdown**
2. **SourceView receives file selection signal**
3. **Save current file state** (if switching away):
   - Save cursor position to `file.cursor_line` and `file.cursor_offset`
   - Save scroll position (if tracking)
   - Update `file.last_viewed` timestamp
   - Call `manager.notify_file_changed(file)` to update database
4. **Notify manager**: Call `manager.activate_file(file)` to:
   - Deactivate previous active file (`is_active = false`)
   - Activate new file (`is_active = true`)
   - Update database
5. **Check if file has existing buffer**:
   - If `file.text_buffer != null`: Reuse existing buffer
   - If `file.text_buffer == null`: Create new buffer, load content, store reference
6. **Switch view to file's buffer**: `source_view.set_buffer(file.text_buffer)`
7. **Restore buffer state**:
   - Restore cursor position from `file.cursor_line` and `file.cursor_offset`
   - Restore scroll position (if saved)
   - Update `file.last_viewed` timestamp
8. **Update UI**: Refresh dropdowns, update header display

##### Language Detection
- Use `GtkSource.LanguageManager.get_default()` to detect language from file path
- Map common file extensions to GtkSource language IDs
- Set buffer language when creating buffer (affects syntax highlighting)
- Language is buffer property, persists when switching buffers

##### Buffer State Persistence
- **State to store**: Cursor position, scroll position, selection (if any)
- **Storage location**: File object properties and database
- **Database fields** (add to FileBase table):
  - `cursor_line` (int) - Last cursor line number
  - `cursor_offset` (int) - Last cursor character offset
  - `scroll_position` (double) - Last scroll position (optional)
  - `last_viewed` (int64) - Unix timestamp of last view
- **Restore on open**: When switching to a file, restore cursor and scroll position from stored state
- **Save on switch**: When switching away from a file, save current buffer state to File object and database

##### Cursor Position and Navigation
- **Cursor position**: Restore from File object when switching to file, save when switching away
- **Navigate to line**: When opening/switching to file, can navigate to specific line (overrides saved position):
  ```vala
  Gtk.TextIter iter;
  buffer.get_iter_at_line(out iter, line_number);
  buffer.place_cursor(iter);
  source_view.scroll_to_iter(iter, 0.0, false, 0.0, 0.5);
  ```
- **Selection**: Save selection range when switching away, restore if still valid

##### File Content Synchronization
- **Initial load**: Read file from disk when creating buffer
- **File changes**: Monitor file system for changes (future: Phase 2B file watcher)
- **Unsaved changes**: Track via buffer's `modified` property
- **Reload prompt**: If file changed on disk and buffer has unsaved changes, prompt user

##### ProjectManager Integration
- **SourceView requires ProjectManager**: SourceView must have a `manager` property (OLLMcoder.ProjectManager)
- **Manager responsibilities**:
  - Track active project and active file
  - Handle activation/deactivation of files and projects
  - Update database when files/projects change
  - Provide methods for SourceView to call
- **Manager methods to add**:
  ```vala
  // Activate a file (deactivates previous active file)
  public void activate_file(OLLMcoder.Files.File file)
  
  // Activate a project (deactivates previous active project)
  public void activate_project(OLLMcoder.Files.Project project)
  
  // Notify that a file's state has changed (save to database)
  public void notify_file_changed(OLLMcoder.Files.File file)
  
  // Notify that a project's state has changed (save to database)
  public void notify_project_changed(OLLMcoder.Files.Project project)
  
  // Get active project
  public OLLMcoder.Files.Project? get_active_project()
  
  // Get active file
  public OLLMcoder.Files.File? get_active_file()
  ```
- **Signals on Manager** (optional, for UI updates):
  ```vala
  public signal void active_file_changed(OLLMcoder.Files.File? file)
  public signal void active_project_changed(OLLMcoder.Files.Project? project)
  ```

##### Integration Points
- **ProjectDropdown**: When project changes, call `manager.activate_project(project)`, update FileDropdown's project
- **FileDropdown**: When file selected, trigger file switching workflow (which calls `manager.activate_file()`)
- **ProjectManager**: Query files from active project's `all_files` ListStore
- **File objects**: Store buffer references, track active state, store buffer state (cursor, scroll)

##### Component Structure
```
SourceView (Gtk.Box, vertical)
‚îú‚îÄ‚îÄ HeaderBar (Gtk.Box, horizontal)
‚îÇ   ‚îú‚îÄ‚îÄ ProjectDropdown (left-aligned)
‚îÇ   ‚îú‚îÄ‚îÄ [Spacer - space for future widgets]
‚îÇ   ‚îî‚îÄ‚îÄ FileDropdown (right-aligned)
‚îî‚îÄ‚îÄ ScrolledWindow
    ‚îî‚îÄ‚îÄ GtkSource.View
        ‚îî‚îÄ‚îÄ (buffer switched dynamically)
```

**Header Layout:**
- Project dropdown: Left side, left-aligned
- File dropdown: Right side, right-aligned  
- Middle space: Reserved for future widgets (not yet decided)

##### Signals and Events
- **File selection**: Connect to FileDropdown's `file_selected` signal
- **Project selection**: Connect to ProjectDropdown's `project_selected` signal
- **Buffer modified**: Connect to buffer's `modified-changed` signal to track unsaved changes
- **File changed**: Future: Connect to file system watcher (Phase 2B)

##### Methods to Expose
- `open_file(OLLMcoder.Files.File file, int? line_number = null)` - Open/switch to file, optionally navigate to line (calls manager.activate_file())
- `open_project(OLLMcoder.Files.Project project)` - Switch to project (calls manager.activate_project())
- `get_current_file()` - Return currently active File object (from manager)
- `get_current_project()` - Return currently active Project object (from manager)
- `get_current_buffer()` - Return current GtkSource.Buffer
- `navigate_to_line(int line_number)` - Navigate to line in current file
- `refresh_file()` - Reload current file from disk (if no unsaved changes)
- `restore_session()` - Restore active project and file from database (called on startup)

#### Files to Create
- `liboccoder/SourceView.vala` - Source view component with header bar and editor (in liboccoder, not libollmchatgtk)

#### File.is_open Semantics Change
- **Current**: `is_open` is a simple boolean property
- **New requirement**: Since there's only one editor and no close button, `is_open` should represent "recently viewed"
- **Implementation**: Make `is_open` a computed property that checks if `last_viewed` is within the last week
- **Database**: Store `last_viewed` timestamp (int64, Unix timestamp)
- **Logic**:
  ```vala
  public bool is_open {
    get {
      if (this.last_viewed == 0) {
        return false;
      }
      var now = new DateTime.now_local();
      var one_week_ago = now.add_days(-7);
      var viewed_time = new DateTime.from_unix_local(this.last_viewed);
      return viewed_time.compare(one_week_ago) > 0;
    }
  }
  ```
- **Update**: Set `last_viewed` timestamp whenever file is viewed/opened

#### Session Restoration
- **On startup**: SourceView should restore the last active project and file from database
- **Database query**: Query for project/file where `is_active = 1`
- **Workflow**:
  1. On SourceView initialization, call `restore_session()`
  2. Query database for active project and active file
  3. If found, call `manager.activate_project()` and `manager.activate_file()` (without saving, just setting state)
  4. Open the file in the editor
  5. Restore buffer state (cursor, scroll position)

#### Dependencies
- SourceView is part of `liboccoder` (not libollmchatgtk) - it's a data layer component
- Requires `gtksourceview-5` (for GtkSource.View and GtkSource.Buffer)
- GTK4 widgets (Gtk.Box, Gtk.ScrolledWindow)
- SourceView must have `manager` property (OLLMcoder.ProjectManager) - set in constructor
- liboccoder will need GTK4 dependency (already added in meson.build)

#### Additional Features to Consider (from roobuilder Editor.vala)

##### Error Markers and Diagnostics
- **GtkSource.Mark for line markers**: Use `GtkSource.Mark` to show error/warning/deprecation markers in the left gutter
- **GtkSource.MarkAttributes**: Configure icons and tooltips for different mark categories:
  - ERR: `dialog-error` icon, pink background highlight
  - WARN: `dialog-warning` icon, light blue background highlight  
  - DEPR: `dialog-information` icon, purple background highlight
- **Text tags for highlighting**: Use `Gtk.TextTag` to highlight error ranges with background colors
- **Tooltip integration**: Show diagnostic messages when hovering over marks or error-highlighted text
- **Mark management**: Track marks per file, remove old marks when diagnostics update
- **Implementation pattern**:
  ```vala
  // Create mark attributes
  var attrs = new GtkSource.MarkAttributes();
  attrs.set_icon_name("dialog-error");
  attrs.query_tooltip_text.connect((mark) => { return mark.name; });
  source_view.set_mark_attributes("ERR", attrs, 1);
  
  // Create marks and tags
  var mark = buffer.create_source_mark(message, category, iter);
  var tag = buffer.create_tag("ERR" + counter, "background", "pink");
  buffer.apply_tag(tag, start_iter, end_iter);
  ```

##### Editor Settings
- **Line marks**: `source_view.show_line_marks = true` - Enables gutter for error markers
- **Current line highlight**: `source_view.highlight_current_line = true`
- **Line numbers**: `source_view.show_line_numbers = true`
- **Space drawer**: Show whitespace characters (optional, for debugging)
- **Font size control**: Scale widget to adjust editor font size (optional)

##### Search Functionality

**Reference Implementation**: See `/home/alan/gitlive/roobuilder/src/Builder4/Editor.vala` for complete search implementation.

**Feature**: In-buffer search with highlighting and navigation - simple to add using existing code pattern.

**Implementation**:
- **GtkSource.SearchContext**: Use `GtkSource.SearchContext` with `GtkSource.SearchSettings`
- **Search options**: Case sensitive, regex, multiline support (via SearchSettings)
- **Navigation**: Forward/backward search with keyboard shortcuts (Ctrl+G, Ctrl+Shift+G)
- **Search UI**: Add search entry widget to footer bar below the code editor
- **Result display**: Show match count (e.g., "3 matches")
- **Highlighting**: Use `searchcontext.set_highlight(true)` to highlight all matches

**Implementation Pattern** (from roobuilder Editor.vala):
```vala
// Create search settings
var search_settings = new GtkSource.SearchSettings();
search_settings.case_sensitive = case_sensitive_checkbox.active;
search_settings.regex_enabled = regex_checkbox.active;
search_settings.wrap_around = false;

// Create search context
var searchcontext = new GtkSource.SearchContext(buffer, search_settings);
searchcontext.set_highlight(true);
search_settings.set_search_text(search_text);

// Forward search
Gtk.TextIter beg, st, en;
bool has_wrapped_around;
buffer.get_iter_at_offset(out beg, last_search_end);
if (searchcontext.forward(beg, out st, out en, out has_wrapped_around)) {
    buffer.place_cursor(st);
    source_view.scroll_to_iter(st, 0.1f, true, 0.0f, 0.5f);
    last_search_end = en.get_offset();
}

// Get match count
var count = searchcontext.get_occurrences_count();
```

**UI Location**: Footer bar below the SourceView editor (simple addition, not complex).

**Note**: Error markers are the most important feature to consider for Phase 3, as they provide immediate visual feedback about code issues. Search functionality is also straightforward to add using the existing roobuilder pattern.

#### Testing Considerations
- Test buffer switching with files of different languages
- Test switching between files rapidly
- Test opening same file multiple times (should reuse buffer)
- Test language detection for various file extensions
- Test cursor position after buffer switch (should reset)
- Test file content reloading
- Test error markers display and removal
- Test error marker tooltips
- Test error highlighting with text tags

---

### Phase 4: Configuration Persistence (Future)

Save and restore UI state preferences.

#### Configuration to Persist
- **Source View Width**: Save the user's preferred source view pane width
- Restore this width when opening code view (used in Phase 1 visibility toggle)
- Store in application settings/preferences

#### Implementation Details
- Use GSettings or similar configuration system
- Save width when user adjusts pane
- Restore on application startup and when switching to code assist mode

#### Files to Create/Modify
- Configuration management module
- Update WindowPane to use saved width when available

---

### Phase 5: CodeAssistant Integration

‚è≥ **TODO** - CodeAssistantProvider still uses OpenFile tracking, not integrated with ProjectManager yet.

Integrate CodeAssistant prompt system with ProjectManager and the code editor.

#### CodeAssistant Integration
- **Current Location**: `libollmchat/Prompt/CodeAssistant.vala`
- **Integration**: CodeAssistant prompt system will use ProjectManager to:
  - Get workspace path from active project
  - Access file contents via ProjectManager
  - Track open files and active file state from SourceView
- **Provider**: `CodeAssistantProvider` (in `libollmchatgtk/Prompt/CodeAssistantProvider.vala`) will integrate with:
  - ProjectManager for project/file access
  - SourceView for active file and cursor position tracking
- **Note**: CodeAssistant remains in `libollmchat` but will depend on `liboccoder` for data access

#### Implementation Details
- Update CodeAssistantProvider to use ProjectManager instead of OpenFile tracking
- Connect SourceView to CodeAssistantProvider for active file updates
- Integrate cursor position and selection tracking from code editor
- Update CodeAssistant to use ProjectManager for workspace and file access

#### Files to Modify
- `libollmchatgtk/Prompt/CodeAssistantProvider.vala` - Integrate with ProjectManager and SourceView
- `libollmchat/Prompt/CodeAssistant.vala` - Update to use ProjectManager for workspace/file access (if needed)

#### Dependency Updates
- `libollmchat` will need to depend on `liboccoder` (for CodeAssistant integration)

---

### Phase 6: File Approval and Version Tracking (Future)

Implement file approval workflow and version tracking system.

#### Auto-commit Assumption
- All changes are assumed to be auto-committed
- **Important**: Git committing automatically should NOT be done on main/master branch
- Use work-in-progress branch for automatic commits
- Need to track which version of file has been approved

#### Approval States
1. **Full file approval**: Jumps to the approved state of the file
2. **Partial file approval**: More complicated
   - Need temporary approved copy of the file
   - Diff against temporary approved copy
   - When further changes occur, compare to temporary approved copy rather than committed copy
   - Handle sliding window between approval process

#### Version Tracking
- Track approved file version
- Maintain temporary approved copy for partial approvals
- Diff management between approved and current state

#### Implementation Details
- Design approval workflow UI
- Handle edge cases in partial approval
- Manage temporary approved file copies
- Diff algorithm for comparing against approved state
- UI for showing changes and approval status

#### Files to Create/Modify
- Code editor component with diff view
- Approval UI components
- File version tracking system
- Temporary file management for partial approvals

---

### Phase 7: Code Editor Manager Tool

‚è≥ **TODO** - CodeEditorManager tool not yet implemented.

Create a tool that allows the LLM to manage the code editor interface.

#### Component: Code Editor Manager Tool
- **Namespace**: `OLLMchat.Tools`
- **Class**: `OLLMchat.Tools.CodeEditorManager` (implements `OLLMchat.Tool.Interface`)
- **Request Handler**: `OLLMchat.Tools.RequestCodeEditorManager` (extends `OLLMchat.Tool.RequestBase`)
- **Purpose**: Allow LLM to control file navigation and cursor positioning in the code editor UI

#### Tool Capabilities
Single unified tool that handles:
- **Open/Switch to file**: Open a file in the SourceView code editor, or switch to an already open file/tab
- **Navigate to line**: Jump to a specific line number in the current or target file
- Parameters: `file_path` (required), `line_number` (optional)

**Note**: Query operations (get cursor position, get selected text, get file contents) are already provided by `CodeAssistantProvider` (Phase 5) and do not need to be duplicated in this tool.

#### Implementation Details
- Tool follows the same pattern as `ReadFile`, `EditMode`, `RunCommand`
- Single tool handles both file opening/switching and line navigation
- If file is not open, opens it; if already open, switches to it
- If line_number is provided, navigates to that line after opening/switching
- Integrates with SourceView component from Phase 3
- May need to integrate with WindowPane to ensure code view is visible
- Request handler will need access to SourceView instance
- GTK-specific implementation in `libollmchatgtk/Tools/RequestCodeEditorManager.vala`

#### EditMode Integration
- **Component**: `OLLMchat.Tools.EditModeWrapper`
- **Purpose**: Intercept EditMode changes and update SourceView editor UI
- **Implementation**: 
  - Wraps the existing `EditMode` tool
  - Connects to `EditMode.change_done` signal to intercept file changes
  - Updates SourceView when files are edited via EditMode tool
  - If file is open in editor, refreshes content and highlights changes
  - If file is not open, optionally opens it in editor to show changes

#### Files to Create
- `libollmchat/Tools/CodeEditorManager.vala` - Tool interface definition
- `libollmchat/Tools/RequestCodeEditorManager.vala` - Base request handler
- `libollmchatgtk/Tools/RequestCodeEditorManager.vala` - GTK-specific implementation with SourceView integration (SourceView is in liboccoder, accessed via manager)
- `libollmchatgtk/Tools/EditModeWrapper.vala` - Wrapper to intercept EditMode changes and update SourceView

#### Files to Modify
- `ollmchat/Window.vala` - Add CodeEditorManager tool to client, use EditModeWrapper instead of direct EditMode
- `liboccoder/SourceView.vala` - Expose methods for tool to control editor (open file, navigate, refresh content, highlight changes)
- `ollmchat/WindowPane.vala` - May need to expose method to show/ensure code view is visible

---

## Future Considerations (Not in Current Scope)

These are features and issues that will need to be addressed in the future but are not part of the current implementation plan.

### Forward/Back Navigation

**Issue**: Users may want to navigate forward/back through their file viewing history (like browser history).

**Considerations**:
- Maintain a history stack of viewed files
- Track navigation order (not just active file)
- Support forward/back buttons or keyboard shortcuts
- Handle history when switching projects
- Decide if history is per-window or global
- Store history in database for persistence across sessions

**Implementation Notes**:
- Could use a simple stack: `Gee.ArrayList<OLLMcoder.Files.File>` for history
- Need to track current position in history (not just top of stack)
- History should update when user manually selects file (adds to history)
- History should update when navigating forward/back (moves position)

### Aliasing Issues (Files in Multiple Projects)

**Issue**: Files can belong to multiple projects via symlinks/softlinks. Current design tracks this in `ProjectManager.alias_map`, but there are unresolved questions.

**Considerations**:
- **Active file in multiple projects**: If a file is active and exists in multiple projects, which project is considered active?
- **File state per project**: Should buffer state (cursor, scroll) be per-project or global per file?
- **Dropdown display**: When showing files in a project dropdown, should symlinked files show which projects they're also in?
- **File operations**: When renaming/moving a file, need to update all alias references
- **Project switching**: When switching projects, if current file exists in new project, should it remain active?

**Current Design**:
- `alias_map` tracks all paths that reference the same file object
- File object is shared across projects (single buffer per file)
- Buffer state is global per file (not per-project)

**Open Questions**:
- Should we track "active project context" separately from "active file"?
- If file is active in Project A, and user switches to Project B (which also contains the file), should file remain active?
- Should we maintain separate cursor positions per project for the same file?

### Active File and Active Project Handling

**Issue**: Current design assumes single active file and single active project, but this may not scale to multiple windows.

**Considerations**:
- **Single window assumption**: Current design tracks one active file/project globally
- **Multiple windows**: If application supports multiple windows, each window may have its own active file/project
- **Database storage**: `is_active` flag in database can only represent one active item - how to handle multiple windows?
- **Manager responsibility**: Should ProjectManager track active state per-window, or should each window have its own manager instance?

**Possible Solutions**:
1. **Per-window ProjectManager**: Each window has its own ProjectManager instance
   - Pros: Clean separation, no conflicts
   - Cons: Duplicate data, harder to share state
   
2. **Window-aware ProjectManager**: Manager tracks active state per-window
   - Pros: Shared data, single source of truth
   - Cons: More complex, need window identifiers
   
3. **Hybrid**: Shared ProjectManager for data, per-window state for active items
   - Pros: Best of both worlds
   - Cons: Most complex to implement

**Database Considerations**:
- Current schema has `is_active` as boolean - insufficient for multiple windows
- May need `active_window_id` or similar to track which window has item active
- Or: Don't store active state in database, only track in memory per-window

### Multiple Windows Support

**Issue**: If the application supports multiple windows, how does the code editor work across windows?

**Considerations**:
- **SourceView per window**: Each window would have its own SourceView instance
- **Shared ProjectManager**: Should projects/files be shared across windows, or per-window?
- **Active state**: Each window can have different active file/project
- **Buffer sharing**: Should file buffers be shared across windows (same file in multiple windows), or separate?
- **Session restoration**: Which window should restore the "active" project/file from database?

**Design Questions**:
- Should ProjectManager be a singleton or per-window?
- Should file buffers be shared (one buffer, multiple views) or separate (one buffer per window)?
- How to handle file changes when same file is open in multiple windows?
- Should there be a "global" active file/project, or only per-window?

**Recommendation** (for future):
- ProjectManager as singleton (shared data)
- Active state tracked per-window (not in database, or with window_id)
- File buffers shared across windows (single buffer, multiple views - GTK supports this)
- Each window has its own SourceView and tracks its own active file/project in memory


### Code Completion

**Feature**: Code completion support with language-specific providers.

**Implementation**:
- **GtkSource.Completion**: Use GTK's built-in completion system
- **Completion providers**: Custom providers for language-specific completions
- **Trigger**: Ctrl+Space to show completion popup
- **Integration**: May require LSP or language server integration for advanced completions

### Hover Help

**Feature**: Show help/hover information when hovering over symbols.

**Implementation**:
- **LSP integration**: Connect to language server for hover information
- **Tooltip display**: Show documentation in helper label or tooltip
- **Cursor tracking**: Detect when cursor is over a symbol
- **Async loading**: Load hover information asynchronously to avoid blocking UI

---

**Note**: These considerations are documented for future reference but are explicitly out of scope for the current implementation phases. The current design assumes a single-window application with one active file and one active project.
