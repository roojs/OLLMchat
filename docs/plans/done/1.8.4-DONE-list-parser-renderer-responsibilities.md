# List handling: parser vs renderer responsibilities

**Scope:** Fix the division of responsibility between the parser and renderers for list handling. The parser must not emit per-nesting-level list signals (no on_ul/on_ol at each level). It must emit: **list block start** / **list block end** (one pair per list, so renderers can handle line breaks correctly), and **list item** events (li number 1. 2. 3. or 0 for unordered, space_skip, start/end). All renderers (GTK, HTML, document, Pango, etc.) are responsible for their own list state, nesting, line numbers, and when to open/close list containers.

---

## Problem

During document-creation work, list handling was changed so that the parser:

- Tracks **list state** (`current_block == ORDERED_LIST | UNORDERED_LIST`) and keeps list “open” across newlines.
- Decides when to **open/close** a list (emits `on_ul`/`on_ol` / `on_node_int(UNORDERED_LIST|ORDERED_LIST)` via `do_block`).
- Emits **LIST_ITEM** start/end and **on_li** with indent and task_checked.

That puts list semantics in the parser. The parser should **not** emit signals on different nesting levels (no on_ul/on_ol per level). It should emit **list block start** and **list block end** (so document and GTK renderers can handle line breaks correctly), and **per-item facts**: list number (0 = unordered, 1/2/3… = ordered), indent (e.g. space_skip), and start/end of that item. Renderers own all logic for nesting, opening/closing &lt;ul&gt;/&lt;ol&gt;, List/ListItem structure, and line numbers.

---

## Current behaviour (this branch)

**Parser / BlockMap**

- `BlockMap.handle_block_result()`:
  - Uses `parser.current_block` to detect “same list” vs “new list”.
  - On same list: emits `on_li(false)`, `on_node_int(LIST_ITEM, false, 0)`, `on_node_int(LIST_ITEM, true, space_skip)`, `on_li(true, space_skip, task_checked)`.
  - On new list: calls `do_block(false, current_block)` then `do_block(true, list_type, list_marker, "", space_skip)` and `on_node_int(LIST_ITEM, true, space_skip)`, `on_li(true, space_skip, task_checked)`.
- `Parser.handle_line_break()`: does **not** call `do_block(false, ...)` when `current_block` is ORDERED_LIST or UNORDERED_LIST, so “list state” is kept across newlines.
- `Parser.do_block()`: for UNORDERED_LIST/ORDERED_LIST emits `on_li(false)`, `on_node_int(LIST_ITEM, false, 0)` on end, and `on_node_int(UNORDERED_LIST|ORDERED_LIST, is_start, list_indent)`.

So the parser both **tracks** list state and **emits** ol/ul and LIST_ITEM. Renderers receive a mix of list-container and list-item events.

**Renderers**

- **Document** (`libocmarkdown/document/Render.vala`): Uses `on_node_int(UNORDERED_LIST|ORDERED_LIST)` to push/pop `List` and `list_stack`; uses `on_node_int(LIST_ITEM, ...)` and `on_li` to create `ListItem` and manage nesting (including “nested list” by opening a new List under the previous item). Works with space_skip because it never uses indent as “level − 1” for array indexing.
- **GTK / Pango / HTML**: Implement `on_ul`/`on_ol` and `on_li`. They **rely on the parser** to tell them when to open/close ul/ol.

---

## Main branch (comparison)

- **Parser**: No `on_li` or `LIST_ITEM` at all. Only `on_ul(is_start, level)` and `on_ol(is_start, level)` via `do_block(true, list_type, list_marker)`. Level is derived in `do_block` as `(lang.length - sl + 1) / 2` (from marker string length).
- **BlockMap**: Every list-marker line does `current_block = matched_block` and `do_block(true, matched_block, list_marker)`. There is **no “same list” vs “new list”** check: every line triggers `do_block(true, ...)`, so **every list line** would emit `on_ul(true, level)` or `on_ol(true, level)` — i.e. open a new list each time. So main is **broken** for multiple consecutive list items (no notion of “item” vs “list”).
- **handle_line_break**: On newline, if `current_block != NONE`, it calls `do_block(false, this.current_block)` and clears `current_block`. So on main, each newline **closes** the current block (including list), which is also wrong for “list over multiple lines”.

So main is a bit broken: no list items, and list container semantics are inconsistent with multi-item lists.

---

## Desired model

**Parser**

- Emits **list block** via **on_block** (e.g. `do_block(true, LIST_BLOCK)` / `do_block(false, LIST_BLOCK)`). This is **not** per nesting level — no signals for “level 1 list”, “level 2 list”, etc. One start/end pair per list block so renderers (document, GTK) can handle line breaks correctly. RenderBase (only) maps that block to `on_list(is_start)`.
- For each line that is a list marker (ordered or unordered, including task lists):
  - Emit **start of list item**: **list number** (0 = unordered; 1, 2, 3… = ordered, i.e. the “1.” “2.” “3.”), indent (e.g. space_skip), and optional task_checked.
  - Then the rest of the line (and any continuation) is content (inline events).
  - When that item ends (next list line, or non-list line, or end of input), emit **end of list item**.
- Parser does **not**:
  - Emit signals on different nesting levels (no on_ul/on_ol per level).
  - Decide nesting; it only reports **this line’s** list number, indent, and start/end of item.

**Renderers**

- Receive: **on_list(is_start)** (from RenderBase, driven by parser’s on_block), and **li start** (list_number, space_skip, task_checked), **content**, **li end**.
- Are **responsible for**:
  - Using `on_list(is_start)` to handle line breaks (e.g. after list block in document/GTK output).
  - Tracking line numbers if needed.
  - Deciding when to open/close list **containers** (e.g. &lt;ul&gt;/&lt;ol&gt;, or `List` in the document model) from the stream of li start/end and indent/list_number.
  - Nesting (e.g. when indent increases after an item, open a nested list; when indent decreases, close lists).
  - For ordered lists, the parser supplies the number (1, 2, 3…); renderers use it (or may ignore and number by position).

So: **parser = “on_block list start, then for each item: li start (number, indent), content, li end; then on_block list end”**; **RenderBase = “dispatch that block to on_list(is_start)”**; **renderers = “I’ll turn on_list + li stream into ul/ol/li, or List/ListItem, and manage nesting and line breaks.”**

---

## Proposed API (parser → renderer)

- **Remove** from parser output:
  - `on_ul` / `on_ol` (and `on_node_int(UNORDERED_LIST|ORDERED_LIST, ...)`) **on different nesting levels**. We do **not** fire signals per level.

- **Add** list block boundaries (so document and GTK can handle line breaks correctly), following the same pattern as the current design:
  - **List block**: `on_list(bool is_start)` — one callback, `on_list(true)` when a list block starts, `on_list(false)` when it ends. One pair per list, not per nesting level. This is **only on the base renderer** (RenderBase); the **parser uses on_block** (i.e. parser calls `do_block(is_start, LIST_BLOCK)` or equivalent; RenderBase dispatches that block type to `on_list(is_start)`).

- **List item callback**: pass **int list_number** (the “1.” “2.” “3.”), not bool ordered.
  - `on_li(bool is_start, int list_number, uint space_skip, int task_checked = -1)` where **list_number** is 0 for unordered, and 1, 2, 3… for ordered list items; **space_skip** is the raw number of spaces before the list marker. Renderers get the actual number for ordered lists; they infer nesting and when to open/close ul/ol from space_skip and list_number.

Recommendation: **Option A** — list block via `on_list(is_start)` (parser uses on_block; RenderBase dispatches to `on_list`), plus `on_li(is_start, list_number, space_skip, task_checked)`. No LIST_ITEM in `on_node_int` for lists; no `on_ul`/`on_ol` per level. RenderBase implements `on_list`; all renderers implement `on_li` for list structure.

---

## Implementation plan

### 1. Parser / BlockMap

- **BlockMap.handle_block_result()** (ORDERED_LIST / UNORDERED_LIST / TASK_LIST / TASK_LIST_DONE):
  - Stop emitting per-level list container events (no `on_ul`/`on_ol` at each nesting level).
  - When the **first** list item of a list block is seen: emit **list block start** via `do_block(true, LIST_BLOCK)` (or equivalent block type). When the list block ends (next non-list line or end of input): emit **list block end** via `do_block(false, LIST_BLOCK)`. The parser uses **on_block** only; RenderBase maps that block type to `on_list(is_start)`. One pair per list; the parser does **not** fire signals on different nesting levels.
  - For **every** list-marker line (first or subsequent, same or different type/indent):
    - Compute **list_number**: 0 for unordered; for ordered, the number from the source (1, 2, 3…). Parser passes this through so renderers get “1.” “2.” “3.” directly.
    - Emit **list item start**: `on_li(true, list_number, space_skip, task_checked)`.
    - Consume the rest of the line and feed as content (inline).
  - When to emit **list item end**:
    - When the **next** line is a list line: before emitting the next `on_li(true, ...)`, emit `on_li(false)` (and optionally end any “continuation” block).
    - When the next line is **not** a list line (or blank): when handling that next line start, emit `on_li(false)`, then list block end via `do_block(false, LIST_BLOCK)`, then proceed with the new block.
    - On end of input / flush: if we’re “inside” a list item, emit `on_li(false)`; if we’re inside a list block, emit list block end via `do_block(false, LIST_BLOCK)`.

- **Parser.handle_line_break()**:
  - Continuation of list item content across newlines (e.g. lazy continuation, or blank line inside item) is a parsing rule: when to call `on_li(false)` vs when to keep the same item open. CommonMark-style: list item end is when we see the next list marker at same or shallower indent, or a non-blank non-indented line, or end of input. The parser is responsible only for emitting list block start/end and li start/end; it is **not** the parser’s responsibility to “remove” or “keep” special-cases for list state in handle_line_break beyond what’s needed to emit those events correctly.

- **Parser.do_block()**:
  - Remove the UNORDERED_LIST and ORDERED_LIST cases (no more `on_ul`/`on_ol` or `on_node_int(..., LIST_ITEM, ...)` from here). Add a **LIST_BLOCK** case: when BlockMap calls `do_block(is_start, LIST_BLOCK)`, do_block invokes the renderer (e.g. `on_node_int(FormatType.LIST_BLOCK, is_start, 0)` or equivalent so RenderBase can dispatch to `on_list(is_start)`). List-item emission stays only in BlockMap.

- **List block**: Parser emits list block start/end via `do_block(is_start, LIST_BLOCK)`; RenderBase (only) dispatches that to `on_list(is_start)` so renderers get an explicit list boundary for line breaks. Renderers still infer nesting from space_skip/list_number.

- **Parser.handle_line_break()**: No change. Keep the existing behaviour: when `current_block` is ORDERED_LIST or UNORDERED_LIST, do **not** call `do_block(false, ...)` on newline (so the list stays open across newlines). The block is ended only when we see a non-list line (BlockMap "End list" condition) or at end of input (Phase 2.4).

### 2. RenderBase

- Remove dispatch to `on_ul` / `on_ol` from `on_node_int` (and remove UNORDERED_LIST/ORDERED_LIST from that switch).
- In `on_node_int`, add a **LIST_BLOCK** case that calls **`on_list(is_start)`**. So list block follows the same pattern as current design: **`on_list(bool is_start)`** — only on the base renderer. Parser uses on_block (`do_block(is_start, LIST_BLOCK)`); RenderBase maps LIST_BLOCK to `on_list(is_start)`. No signals per nesting level.
- Extend `on_li(bool is_start, uint indent = 0, int task_checked = -1)` to `on_li(bool is_start, int list_number, uint space_skip = 0, int task_checked = -1)` where **list_number** is 0 for unordered, 1/2/3… for ordered (the “1.” “2.” “3.”). Default `list_number = 0` for backward compatibility during migration if needed.
- Document that list **containers** are not sent per level; only list block (on_list start/end) and list-item start/end with list_number and space_skip.

### 3. Document renderer (`libocmarkdown/document/Render.vala`)

- **Stop** handling `on_node_int(UNORDERED_LIST|ORDERED_LIST, ...)` and `on_node_int(LIST_ITEM, ...)` for building List/ListItem.
- Use **on_list(is_start)** (from RenderBase dispatch) to know when a list block begins/ends (for line-break handling in output).
- Use **only** `on_li(is_start, list_number, space_skip, task_checked)` for items:
  - On `on_li(true, list_number, space_skip, task_checked)`: maintain a stack of (space_skip, ordered) where ordered = (list_number != 0). Compare `space_skip` with stack to pop until stack top &lt;= current space_skip; if current space_skip &gt; stack top, open a new List (ordered/unordered) under the last ListItem of the current list; push (space_skip, ordered). Create ListItem, set task_checked/is_task_item, attach to current List. For ordered lists, store or use `list_number` (1, 2, 3…) if needed for round-trip.
  - On `on_li(false)`: pop current ListItem from block stack; if the next line (or later) has a lower space_skip, pop List(s) as needed (can be done on next `on_li(true)` by the “pop until” logic).
- Line numbers: if the document model needs line numbers, the document renderer can track “current line” from the stream of events (e.g. count newlines in on_text or from parser if we ever pass line info).

### 4. GTK renderer (`libocmarkdowngtk/Render.vala`)

**Concrete code: see Phase 4.1 below** (REMOVE/ADD and full `on_list` / `on_li` code blocks).

- Remove `on_ul` / `on_ol` overrides (or make them no-ops).
- Use **on_list(is_start)** for line-break handling (e.g. newline after list block).
- Implement list state in `on_li(is_start, list_number, space_skip, task_checked)`:
  - Maintain `list_stack` (or equivalent) keyed by space_skip/depth. On `on_li(true, list_number, space_skip, task_checked)`: close lists to current depth (pop while stack depth &gt; space_skip); open &lt;ul&gt;/&lt;ol&gt; as needed when going deeper or when type changes (list_number == 0 vs list_number &gt; 0); push depth and type; output &lt;li&gt; and bullet or number (use `list_number` for ordered: 1, 2, 3…).
  - On `on_li(false)`: close &lt;/li&gt;; do not close ul/ol here — do that when next `on_li(true)` has smaller space_skip or on `on_list(false)`.
- The renderer will use its own stack and space_skip for indexing.

### 5. Pango renderer (`libocmarkdown/PangoRender.vala`)

**Concrete code: see Phase 4.2 below** (REMOVE/ADD and full `on_list` / `on_li` code blocks).

- Same as GTK: remove reliance on `on_ul`/`on_ol`; use `on_list(is_start)` for line breaks; drive all list state from `on_li(is_start, list_number, space_skip, task_checked)`. Use space_skip for nesting and stack depth; use `list_number` (0 = bullet, 1+ = number) for bullet vs number.

### 6. HTML renderer (`libocmarkdown/HtmlRender.vala`)

**Concrete code: see Phase 4.3 below** (REMOVE/ADD and full `on_list` / `on_li` code blocks).

- Same: remove `on_ul`/`on_ol` handling (or make no-ops); use list block start/end and only `on_li(is_start, list_number, space_skip, task_checked)` to open/close &lt;ul&gt;/&lt;ol&gt;/&lt;li&gt; and manage `list_stack` from space_skip and list_number.

### 7. DummyRenderer / tests

**Concrete code: see Phase 5 below** (REMOVE `on_ul`/`on_ol`, ADD `on_list` and new `on_li` code blocks).

- Update to the new `on_list(is_start)` and `on_li(is_start, list_number, space_skip, task_checked)` signatures and ensure tests (e.g. `tests/test-markdown-doc.sh`, list round-trips) still pass.

---

## Summary

| Component   | Current (this branch) | Main | Target |
|------------|------------------------|------|--------|
| Parser     | Tracks list state; emits on_ul/on_ol and LIST_ITEM | Emits on_ul/on_ol per line (broken); no on_li | Emits list block via **on_block** (do_block LIST_BLOCK) and **on_li(is_start, list_number, space_skip, task_checked)**; no per-level list signals |
| Document   | Uses on_ul/on_ol + LIST_ITEM to build List/ListItem | N/A | Uses **on_list(is_start)** + on_li(list_number, space_skip, …) to build List/ListItem, nesting, and line breaks |
| GTK/Pango/HTML | Rely on on_ul/on_ol for list containers | Expect 1-based level | Use **on_list(is_start)** + on_li(list_number, space_skip, …); manage ul/ol and line state themselves |

**Coding standards:** Any code changes must follow `.cursor/rules/CODING_STANDARDS.md`.

**Process:** Agree this plan and the chosen API (list block via **on_block** → `on_list(is_start)` on RenderBase only, plus `on_li(is_start, list_number, space_skip, task_checked)`). Then implement in the phases below; run tests after each phase.

**Code must not be changed until this plan is reviewed and approved.** The concrete code in the phases below is the specification; implement only after approval.

---

## Concrete code changes (phased)

**IMPORTANT:** Do **not** change any implementation code until this plan has been **reviewed and approved**. The code below is the agreed specification; implement only after approval.

---

### Phase 1: Add LIST_BLOCK and RenderBase wiring

**1.1** `libocmarkdown/Parser.vala` — add enum value and list block case in `do_block`:

```vala
// In enum FormatType (after LIST_ITEM or TABLE_CELL), add:
LIST_BLOCK,
```

In `do_block()`, **REMOVE** the following two case blocks entirely:

```vala
case FormatType.UNORDERED_LIST:
	if (!is_start) {
		this.renderer.on_li(false);
		this.renderer.on_node_int(FormatType.LIST_ITEM, false, 0);
	}
	this.renderer.on_node_int(FormatType.UNORDERED_LIST, is_start, list_indent);
	break;
case FormatType.ORDERED_LIST:
	if (!is_start) {
		this.renderer.on_li(false);
		this.renderer.on_node_int(FormatType.LIST_ITEM, false, 0);
	}
	this.renderer.on_node_int(FormatType.ORDERED_LIST, is_start, list_indent);
	break;
```

**ADD** in their place:

```vala
case FormatType.LIST_BLOCK:
	this.renderer.on_node_int(FormatType.LIST_BLOCK, is_start, 0);
	break;
```

**1.2** `libocmarkdown/RenderBase.vala` — add `on_list`, change `on_li` signature, wire LIST_BLOCK and remove UNORDERED_LIST/ORDERED_LIST from `on_node_int`:

```vala
// In on_node_int(), REMOVE:
case FormatType.UNORDERED_LIST:
	this.on_ul(is_start, (uint)v1);
	return;
case FormatType.ORDERED_LIST:
	this.on_ol(is_start, (uint)v1);
	return;

// ADD:
case FormatType.LIST_BLOCK:
	this.on_list(is_start);
	return;
```

```vala
// Add new virtual method (e.g. after on_li):
/** List block start/end (one pair per list; parser uses do_block(LIST_BLOCK). No per-level signals. */
protected virtual void on_list(bool is_start) {}

// Change on_li signature from:
public virtual void on_li(bool is_start, uint indent = 0, int task_checked = -1) {}
// To:
public virtual void on_li(bool is_start, int list_number = 0, uint space_skip = 0, int task_checked = -1) {}
// list_number: 0 = unordered, 1/2/3… = ordered (the "1." "2." "3." from source).
// space_skip: raw number of spaces before the list marker (parser passes this through; renderers use for nesting/comparison).
```

Keep `on_ul` and `on_ol` as no-ops for now (or remove if nothing calls them after Phase 2). Subclasses will stop overriding them in later phases.

---

### Phase 2: BlockMap — emit LIST_BLOCK and on_li with list_number

**2.1** `libocmarkdown/BlockMap.vala` — in `handle_block_result()`, replace the ORDERED_LIST/UNORDERED_LIST/TASK_LIST/TASK_LIST_DONE case with logic that:

- Uses a single “list block” type for tracking (e.g. keep `current_block == ORDERED_LIST|UNORDERED_LIST` only to know “we’re in a list” for when to emit list block end).
- On **first** list item of a list block: call `do_block(true, FormatType.LIST_BLOCK)` (not `do_block(true, list_type, ...)`).
- On **every** list line: compute `list_number` (0 for unordered/task, or parsed number for ordered); emit `on_li(true, list_number, space_skip, task_checked)`; **do not** emit `on_node_int(LIST_ITEM, ...)` or `on_node_int(UNORDERED_LIST|ORDERED_LIST, ...)`.
- On **same list, new item**: emit `on_li(false)` then `on_li(true, list_number, space_skip, task_checked)`.
- On **new list** (different list type or not in list): if currently in list, emit `on_li(false)` then `do_block(false, FormatType.LIST_BLOCK)` and clear current_block; then set `current_block = list_type`; emit `do_block(true, FormatType.LIST_BLOCK)`; then `on_li(true, list_number, space_skip, task_checked)`.
- When **leaving list** (existing block_match condition that ends list): before `do_block(false, this.parser.current_block)` change to emit `on_li(false)` then `do_block(false, FormatType.LIST_BLOCK)` (and keep clearing `current_block`).

Concrete replacement for the list case (adjust to your exact variable names if needed):

```vala
case FormatType.ORDERED_LIST:
case FormatType.UNORDERED_LIST:
case FormatType.TASK_LIST:
case FormatType.TASK_LIST_DONE:
	var list_marker = chunk.substring(chunk_pos, byte_length);
	var is_task = (matched_block == FormatType.TASK_LIST || matched_block == FormatType.TASK_LIST_DONE);
	var task_checked = is_task ? (matched_block == FormatType.TASK_LIST_DONE ? 1 : 0) : -1;
	var list_type = (matched_block == FormatType.ORDERED_LIST) ? FormatType.ORDERED_LIST : FormatType.UNORDERED_LIST;
	// 0 = unordered/task; for ordered, parse the marker (e.g. "1. " → 1). Block regex ensures digits for ORDERED_LIST.
	int list_number = (matched_block == FormatType.ORDERED_LIST)
		? int.parse(list_marker.replace(".", "").strip()) : 0;

	bool same_list = (this.parser.current_block == FormatType.ORDERED_LIST || this.parser.current_block == FormatType.UNORDERED_LIST);
	if (same_list) {
		this.parser.renderer.on_li(false);
		this.parser.renderer.on_li(true, list_number, space_skip, task_checked);
		this.parser.at_line_start = false;
		chunk_pos = seq_pos;
		return false;
	}
	// Not same list: end previous list block if any, then start new list block
	if (this.parser.current_block == FormatType.ORDERED_LIST || this.parser.current_block == FormatType.UNORDERED_LIST) {
		this.parser.renderer.on_li(false);
		this.parser.do_block(false, FormatType.LIST_BLOCK);
		this.parser.last_line_block = this.parser.current_block;
		this.parser.current_block = FormatType.NONE;
	}
	this.parser.current_block = list_type;
	this.parser.do_block(true, FormatType.LIST_BLOCK);
	this.parser.renderer.on_li(true, list_number, space_skip, task_checked);
	this.parser.at_line_start = false;
	chunk_pos = seq_pos;
	return false;
```

**2.2** In the same file, at the top of `handle_block_result()` (immediately after the `if (block_match == -1) { ... return true; }` block), replace the entire “End list when we see a non-list line” block so that: (1) we only end the list when the next line is not any list type (treat TASK_LIST and TASK_LIST_DONE as list); (2) the body emits `on_li(false)` then `do_block(false, LIST_BLOCK)`.

**REMOVE** the existing block (exact code in `BlockMap.vala`):

```vala
// End list when we see a non-list line (or no block)
if (
		(this.parser.current_block == FormatType.ORDERED_LIST 
		|| this.parser.current_block == FormatType.UNORDERED_LIST)
	&& (
		block_match == 0 || 
		(block_match > 0 &&
			 matched_block != FormatType.ORDERED_LIST &&
			 matched_block != FormatType.UNORDERED_LIST))) {
	this.parser.do_block(false, this.parser.current_block);
	this.parser.last_line_block = this.parser.current_block;
	this.parser.current_block = FormatType.NONE;
}
```

**REPLACE WITH**:

```vala
// End list when we see a non-list line (or no block). Do not end when next line is a list item (including task).
bool in_list = (this.parser.current_block == FormatType.ORDERED_LIST
		|| this.parser.current_block == FormatType.UNORDERED_LIST);
bool next_line_is_list = (matched_block == FormatType.ORDERED_LIST
		|| matched_block == FormatType.UNORDERED_LIST
		|| matched_block == FormatType.TASK_LIST
		|| matched_block == FormatType.TASK_LIST_DONE);
if (in_list && (block_match == 0 || (block_match > 0 && !next_line_is_list))) {
	this.parser.renderer.on_li(false);
	this.parser.do_block(false, FormatType.LIST_BLOCK);
	this.parser.last_line_block = this.parser.current_block;
	this.parser.current_block = FormatType.NONE;
}
```

**2.3** Parser end of input: in `Parser.add()`, locate the final flush block (the code that runs after “Flush any remaining text” / `this.renderer.on_node(FormatType.TEXT, false, str);` and before `if (is_end_of_chunks && this.leftover_chunk != "")`). There you have an `if (this.current_block != FormatType.NONE) { ... }` that closes the current block. Replace that entire `if` block with the following so that when we are inside a list we emit `on_li(false)` then list block end, instead of `do_block(false, this.current_block)`:

```vala
if (this.current_block != FormatType.NONE) {
	if (this.current_block == FormatType.ORDERED_LIST || this.current_block == FormatType.UNORDERED_LIST) {
		this.renderer.on_li(false);
		this.do_block(false, FormatType.LIST_BLOCK);
	} else {
		this.do_block(false, this.current_block);
	}
	this.last_line_block = this.current_block;
	this.current_block = FormatType.NONE;
}
```

---

### Phase 3: Document renderer

**3.1** `libocmarkdown/document/Render.vala` — in `on_node_int()`, **remove** the three cases `UNORDERED_LIST`, `ORDERED_LIST`, and `LIST_ITEM` entirely. Do **not** add a `LIST_BLOCK` case (RenderBase dispatches that to `on_list()`). The switch should no longer contain any list-related cases.

**3.2** Add a private flag and override `on_list(bool is_start)` for list-block boundary (e.g. for line-break handling in serialization):

```vala
private bool in_list_block = false;

public override void on_list(bool is_start)
{
	this.in_list_block = is_start;
}
```

**3.3** Replace the current `on_li` override and list handling so that List/ListItem are built **only** from `on_li(is_start, list_number, space_skip, task_checked)`:

```vala
public override void on_li(bool is_start, int list_number = 0, uint space_skip = 0, int task_checked = -1)
{
	if (!is_start) {
		this.block_stack.remove_at(this.block_stack.size - 1);
		this.current_block_with_inlines = this.inline_target_stack.size > 0
			? this.inline_target_stack.remove_at(this.inline_target_stack.size - 1)
			: null;
		this.current_list_item = null;
		return;
	}

	bool ordered = (list_number != 0);

	// Pop list_stack until stack top <= current space_skip
	while (this.list_stack.size > 0 && space_skip < this.list_stack.get(this.list_stack.size - 1)) {
		this.list_stack.remove_at(this.list_stack.size - 1);
		this.pop_list();
	}

	// First item at this depth: ensure we have a List (from on_list we are in list block)
	if (this.list_stack.size == 0) {
		this.list_stack.add(space_skip);
		this.push_list(new List() { ordered = ordered, indentation = space_skip });
	} else if (this.list_stack.size > 0 && space_skip > this.list_stack.get(this.list_stack.size - 1)) {
		// Deeper: open a new List under the last ListItem
		var current_list = this.block_stack.get(this.block_stack.size - 1) as List;
		if (current_list != null && current_list.children.size > 0) {
			var last_item = current_list.children.get(current_list.children.size - 1) as ListItem;
			if (last_item != null) {
				var nested = new List() {
					ordered = ordered,
					indentation = space_skip
				};
				last_item.adopt(nested);
				this.block_stack.add(nested);
				this.list_stack.add(space_skip);
			}
		}
	}

	var item = new ListItem() {
		task_checked = (task_checked == 1),
		is_task_item = (task_checked >= 0)
	};
	item.uid = this.document.uid_count++;
	var parent = this.block_stack.get(this.block_stack.size - 1) as List;
	parent.adopt(item);
	this.block_stack.add(item);
	if (this.current_block_with_inlines != null) {
		this.inline_target_stack.add(this.current_block_with_inlines);
	}
	this.current_block_with_inlines = item;
	this.current_list_item = item;
}
```

If round-trip requires storing the source number for ordered items, add a property (e.g. `list_item_number`) to `ListItem` and set it from `list_number` when `list_number > 0`; otherwise omit.

---

### Phase 4: GTK, Pango, HTML renderers

**4.1** `libocmarkdowngtk/Render.vala`:

- **REMOVE** the entire override methods `on_ul` and `on_ol` (delete the two methods so the base no-ops are used). Do not call `reset_lists_above_level` from the new `on_li` (list state is fully driven by `on_li`; the existing `reset_lists_above_level` is a no-op).
- **KEEP** the existing helpers `close_lists_to_level(uint level)` and `ensure_indent_level(int indentation)` unchanged: they already key by indent/level; pass `space_skip` as the argument from `on_li`. `list_stack` at `depth_index` should hold the display number (0 = unordered, 1/2/3… = ordered); set it with `list_stack.set(depth_index, list_number == 0 ? 0 : list_number)` — do not advance a counter.
- **ADD** `on_list` override and replace `on_li` with the new signature and implementation:

```vala
public override void on_list(bool is_start)
{
	if (!is_start) {
		this.current_state.close_state();
		this.current_state.add_text("\n");
	}
}

public override void on_li(bool is_start, int list_number = 0, uint space_skip = 0, int task_checked = -1)
{
	if (!is_start) {
		this.current_state.close_state();
		this.current_state.add_text("\n");
		return;
	}

	this.close_lists_to_level(space_skip);
	int depth_index = this.ensure_indent_level((int)space_skip);
	this.list_stack.set(depth_index, list_number == 0 ? 0 : list_number);
	this.current_list_indentation = space_skip;

	this.current_state.add_text(string.nfill(depth_index + 1, '\t'));
	if (list_number == 0) {
		this.current_state.add_text("●");
	} else {
		string number_marker = list_number.to_string() + ".";
		var bold_state = this.current_state.add_state();
		bold_state.style.weight = Pango.Weight.BOLD;
		bold_state.add_text(number_marker);
		bold_state.close_state();
	}
	this.current_state.add_text("\t");
	this.current_state.add_state();
}
```

**4.2** `libocmarkdown/PangoRender.vala`:

- **REMOVE** the entire override methods `on_ul` and `on_ol` (delete them so the base no-ops are used).
- **HELPER BEHAVIOUR:** Use the same pattern as GTK: depth is keyed by `space_skip`. If the class does not already have an `indent_levels` (or equivalent) list, add one: `Gee.ArrayList<int> indent_levels` that stores the `space_skip` values seen at each depth. Then `ensure_indent_level(int space_skip)` finds or inserts that value and returns the depth index; `close_lists_to_level(uint space_skip)` pops while the top indent level is greater than `space_skip`. `list_stack` at that depth index holds the display number (0 = ul, 1/2/3… = ol). If the current Pango renderer uses a different scheme (e.g. list_stack size as depth), adapt so that depth index is derived from `space_skip` (so 0, 2, 4 spaces map to depths 0, 1, 2).
- **ADD** `on_list` and replace `on_li` with the new signature and implementation:

```vala
public override void on_list(bool is_start)
{
	if (!is_start) {
		this.pango_markup.append("\n");
	}
}

public override void on_li(bool is_start, int list_number = 0, uint space_skip = 0, int task_checked = -1)
{
	if (!is_start) {
		this.pango_markup.append("\n");
		return;
	}
	this.close_lists_to_level(space_skip);
	int depth_index = this.ensure_indent_level((int)space_skip);
	// Store list_number at this depth (0 = ul, 1/2/3… = ol number)
	this.list_stack.set(depth_index, list_number);
	uint indent_tabs = 1 + (uint)depth_index;
	for (uint i = 0; i < indent_tabs; i++) {
		this.pango_markup.append("\t");
	}
	if (list_number == 0) {
		this.pango_markup.append("•");
	} else {
		this.pango_markup.append(list_number.to_string() + ".");
	}
	this.pango_markup.append("\t");
}
```

**4.3** `libocmarkdown/HtmlRender.vala`:

- **REMOVE** the entire override methods `on_ul` and `on_ol` (delete them so the base no-ops are used). List structure is now driven only by `on_li(is_start, list_number, space_skip, task_checked)`; do not call `on_li(true)` or `handle_list_start` from inside the removed `on_ul`/`on_ol`.
- **KEEP** `close_li_if_needed(uint new_indentation)`, `handle_list_start(int list_type, uint indentation)`, and `close_lists_to_level(uint level)`; call them from the new `on_li` with `space_skip` and `list_type = (list_number == 0) ? 0 : 1`.
- **ADD** `on_list` and replace `on_li` with the new signature and implementation:

```vala
public override void on_list(bool is_start)
{
	if (!is_start) {
		// Optional: ensure all list tags closed, or add newline for output
	}
}

public override void on_li(bool is_start, int list_number = 0, uint space_skip = 0, int task_checked = -1)
{
	if (!is_start) {
		this.close_tag("li");
		return;
	}
	this.close_li_if_needed(space_skip);
	this.current_list_indent = space_skip;
	int list_type = (list_number == 0) ? 0 : 1;
	this.handle_list_start(list_type, space_skip);
	this.append_indent(true);
	this.html_output.append("<li>");
	this.open_tags.add("li");
}
```

Keep `handle_list_start`, `close_lists_to_level`, `close_li_if_needed`, and list_stack keyed by `space_skip`; they now receive type from `list_number` (0 = ul, 1 = ol) and depth from `space_skip`.

---

### Phase 5: DummyRenderer and tests

**5.1** `libocmarkdown/DummyRenderer.vala`:

- **REMOVE** the entire override methods `on_ul` and `on_ol` (delete them so the base no-ops are used).
- **ADD** `on_list` override and replace `on_li` with the new signature and implementation:

```vala
protected override void on_list(bool is_start)
{
	if (!is_start) {
		indent_level--;
		print_indent();
		stdout.printf("END: <list block>\n");
		return;
	}
	print_indent();
	stdout.printf("START: <list block>\n");
	indent_level++;
}

public override void on_li(bool is_start, int list_number = 0, uint space_skip = 0, int task_checked = -1)
{
	if (!is_start) {
		indent_level--;
		print_indent();
		stdout.printf("END: <li>\n");
		return;
	}
	print_indent();
	stdout.printf("START: <li> (list_number=%d, space_skip=%u)\n", list_number, space_skip);
	indent_level++;
}
```

**5.2** Run `tests/test-markdown-doc.sh` and any list-related tests; fix regressions (e.g. document round-trip list structure, GTK/Pango/HTML output).
