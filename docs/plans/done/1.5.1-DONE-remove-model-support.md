# 1.5.1. Remove Model Support

## Overview

Add the ability to remove models from the server via the Ollama API. When a model row is expanded in the ModelsPage, users will see an additional option to remove the model. This requires a confirmation dialog warning about model size and download time, since models are large and re-downloading them takes significant time.

**Parent Plan**: [1.5. Model List Management](../1.5-DONE-model-list-management.md)

## Status

✅ **COMPLETE** - Implemented.

## Goal

1. Add remove model API support in `Call.Base` (create `Call.Delete` class)
2. Add remove button/row to expanded model options in `ModelRow`
3. Implement confirmation dialog with warning about model size and download time
4. Handle model removal and refresh the model list after successful deletion

## Related Plans

- **1.5** - Model List Management (parent plan)
- **1.4** - Client Configuration Setup (uses client connections)

## Implementation Details

### API Support

#### Create `Call.Delete` Class

Create a new API call class for deleting models, following the pattern of `Call.Pull`:

**File**: `libollmchat/Call/Delete.vala`

```vala
namespace OLLMchat.Call
{
    /**
     * API call to delete a model from the Ollama server.
     *
     * Deletes a model by name using the Ollama delete API endpoint.
     * This permanently removes the model from the server.
     */
    public class Delete : Base
    {
        public string name { get; set; default = ""; }

        public Delete(Settings.Connection connection, string model_name)
        {
            base(connection);
            if (model_name == "") {
                throw new OllmError.INVALID_ARGUMENT("Model name cannot be empty");
            }
            this.name = model_name;
            this.url_endpoint = "delete";
            this.http_method = "DELETE";
        }

        /**
         * Executes the delete API call.
         *
         * @throws Error if the request fails or response is invalid
         */
        public async void exec_delete() throws Error
        {
            yield this.send_request(true);
        }
    }
}
```

**Error handling**: Other Call classes (e.g. Version, Models) do not duplicate status handling; they call `send_request()` and let Base throw on non-200. Delete should do the same — pass on the error from Base rather than wrapping it in a duplicate switch.

**Request body for DELETE**: `Call.Base.send_request()` currently sets the request body only when `http_method == "POST"`. So we extend Base once and keep Delete thin.

**File**: `libollmchat/Call/Base.vala` — in `send_request()`, change the body condition so DELETE requests get the JSON body:

Use a switch on `http_method`; inside the POST/DELETE case, bail if `!needs_body` then set the body:

**File**: `libollmchat/Call/Base.vala` — in `send_request()`, replace the body block (lines 85–87) with:

```vala
switch (this.http_method) {
    case "POST":
    case "DELETE":
        if (!needs_body) {
            break;
        }
        this.set_request_body(message);
        break;
    default:
        break;
}
```

**File**: `libollmchat/meson.build` — add to `ollmchat_ollama_src` (e.g. after `'Call/Create.vala'`):

```meson
'Call/Delete.vala',
```

### UI Changes

#### Add Remove Button to ModelRow

**File**: `ollmapp/SettingsDialog/ModelRow.vala`

In `expand()`, after adding the options_widget rows and before `load_defaults()`, add the remove row and connect it. Use a private field to hold the remove button so it can be disabled if needed (optional; alternatively disable the whole row).

**Code to add in `expand()` after the `foreach (var row in this.options_widget.rows)` block and before `load_defaults()`:**

```vala
// Remove model row (destructive action)
var remove_btn = new Gtk.Button.from_icon_name("user-trash-symbolic") {
    tooltip_text = "Remove this model from the server",
    css_classes = { "destructive-action" }
};
var remove_row = new Adw.ActionRow() {
    title = "Remove model from server"
};
remove_row.add_suffix(remove_btn);
remove_row.set_activatable_widget(remove_btn);
this.add_row(remove_row);

remove_btn.clicked.connect(() => {
    this.confirm_and_delete.begin();
});
```

Add the following async methods to `ModelRow` (same file):

```vala
private async void confirm_and_delete()
{
    var message = "Are you sure you want to delete '%s'? This will permanently remove the model from the server. Models are large files and re-downloading them may take a significant amount of time. Only delete if you're certain or running low on disk space.".printf(this.model.name);
    var dialog = new Adw.AlertDialog("Delete Model?", message);
    dialog.add_response("cancel", "Cancel");
    dialog.add_response("delete", "Delete");
    dialog.set_response_appearance("delete", Adw.ResponseAppearance.DESTRUCTIVE);

    var response = yield dialog.choose(this.models_page.dialog, null);
    if (response != "delete") {
        return;
    }

    this.expanded = false;
    this.sensitive = false;
    try {
        var delete_call = new OLLMchat.Call.Delete(this.connection, this.model.name);
        yield delete_call.exec_delete();
        yield this.models_page.connection_models.refresh();
    } catch (GLib.Error e) {
        this.sensitive = true;
        var err_dialog = new Adw.AlertDialog("Delete failed", e.message);
        err_dialog.add_response("ok", "OK");
        yield err_dialog.choose(this.models_page.dialog, null);
    }
}
```

#### Confirmation dialog

Implemented in `confirm_and_delete()` above: title "Delete Model?", message with `model_name`, responses "Cancel" / "Delete" (destructive). On "delete": collapse row, set row not sensitive, run delete + refresh; on error re-enable and show "Delete failed" dialog.

### Model List Refresh (store + items_changed)

After delete or pull we refresh the store (`connection_models.refresh()`); the store emits `items_changed`. ModelsPage listens to `connection_models.items_changed` and calls `sync_ui_from_store.begin()` so the UI stays in sync. No custom `model_deleted` signal. Concrete code: see "Code: ModelsPage" and "sync_ui_from_store()" below.

(Optional: ConnectionModels could add `refresh_connection_url(connection_url)`; then in `confirm_and_delete()` call that instead of `refresh()`.)

**Code: ModelsPage — expose store and monitor its signal**

**File**: `ollmapp/SettingsDialog/ModelsPage.vala`

1. **Expose the store** — change the field declaration:

```vala
// Before:
private OLLMchat.Settings.ConnectionModels connection_models;

// After:
public OLLMchat.Settings.ConnectionModels connection_models { get; private set; }
```

**Hide from serialization**: A public property can be picked up by any serialization (e.g. `Json.Serializable`, or code that iterates GObject properties). Exclude `connection_models` so it is never serialized. If `ModelsPage` (or a base like `SettingsPage`) implements `Json.Serializable`, override `serialize_property` and return `null` for that property:

```vala
// In ModelsPage (only needed if the class implements Json.Serializable)
public override Json.Node? serialize_property(string property_name, Value value, ParamSpec pspec)
{
    if (property_name == "connection-models") {  // GObject property name uses hyphen
        return null;  // do not serialize
    }
    return base.serialize_property(property_name, value, pspec);
}
```

If serialization is done elsewhere (e.g. only specific properties are saved), ensure `connection_models` is never included in the saved set.

2. **In the constructor**, remove the existing `pull_manager.model_complete` connection and add these two (same place, after `this.append(this.group)` and before the closing of the constructor block):

```vala
this.connection_models.items_changed.connect((position, removed, added) => {
    this.sync_ui_from_store.begin();
});

this.dialog.pull_manager.model_complete.connect((model_name) => {
    this.connection_models.refresh.begin();
});
```

3. **Replace `render_models()` body** — substitute the entire method body with:

```vala
public async void render_models()
{
    if (this.is_rendering) {
        return;
    }
    this.is_rendering = true;

    this.show_loading(true);
    yield this.connection_models.refresh();
    yield this.sync_ui_from_store();
    this.show_loading(false);

    this.is_rendering = false;
}
```

4. **Add `sync_ui_from_store()`** — add the method below (same file); it must not call `refresh()` or show/hide loading.

**sync_ui_from_store()** — add this private async method (does not call `refresh()` or loading):

```vala
/**
 * Syncs the boxed_list (model rows, section headers) to the current store state.
 * Does not refetch; use when the store has already been updated (e.g. after items_changed).
 */
private async void sync_ui_from_store()
{
    foreach (var entry in this.connection_models.connection_map.entries) {
        var connection_url = entry.key;
        var connection = this.dialog.app.config.connections.get(connection_url);
        if (connection == null || !connection.is_working) {
            continue;
        }
        var models_list = new Gee.ArrayList<OLLMchat.Settings.ModelUsage>();
        models_list.add_all(entry.value.values);
        yield this.update_models_from_connection_models(connection, models_list);
    }
    this.cleanup_removed_models();
}
```

### Model list sort order and incremental updates

**Sorting — already by display name**

- **ModelsPage**: `update_models_from_connection_models` sorts by **display name** using `ModelUsageSort`, which compares `display_name_with_size()` (see `libollmchatgtk/List/ModelUsageSort.vala`). The in-code comment says "model name" but the sorter uses display name. No change needed for "sort by display name."
- **AddModelDialog**: Uses its own sorted list (search-aware + alphabetical). Already sorted.

**Incremental updates — order bug**

Currently we do **not** remove everything; we update in place: for each connection we iterate the sorted `models_list`, for existing rows we update and `continue`, for **new** rows we **append**. So new rows are always added at the **end** of that connection’s block. If a model is added that sorts in the middle (e.g. "foo" when we have "bar", "quux"), the UI order becomes bar, quux, foo instead of bar, foo, quux.

**Fix: reorder to match sorted list**

For each connection, after updating/creating rows, **reorder** the boxed_list so it matches the sorted `models_list`. Option A: unparent all rows for this connection from boxed_list, then in sorted order re-append each row. Option B: use `reorder_child_after()` to move each row to the correct place. Option A is simpler and keeps one code path.

**Code: in `update_models_from_connection_models`, after the "Remove models from this connection that no longer exist" block, reorder so boxed_list matches sorted `models_list` using `reorder_child_after` — only move rows that are out of place:**

```vala
// Desired order (already sorted by ModelUsageSort / display name)
var desired_rows = new Gee.ArrayList<ModelRow>();
foreach (var model_usage in models_list) {
    var composite_key = "%s#%s".printf(connection.url, model_usage.model);
    if (this.model_rows.has_key(composite_key)) {
        desired_rows.add(this.model_rows.get(composite_key));
    }
}
var header_row = this.section_headers.get(connection.url);
Gtk.Widget? prev = header_row;
foreach (var row in desired_rows) {
    // Only reorder if this row is not already immediately after prev
    if (row.get_prev_sibling() != prev) {
        this.boxed_list.reorder_child_after(row, prev);
    }
    prev = row;
}
```

This only moves rows that are in the wrong position (e.g. a newly added model that sorts in the middle); rows already in order are left alone. Uses GTK4 `Gtk.Box.reorder_child_after(child, sibling)`.

**Refresh flow summary**

1. User confirms delete in ModelRow → `Call.Delete.exec_delete()` runs.
2. On success → ModelRow calls `yield this.models_page.connection_models.refresh()` (refresh the store).
3. `connection_models.refresh()` runs → refetches from server → for the deleted model's connection, it's no longer in `connection.models` → store calls `this.remove(model_usage)` → **`items_changed` emitted**.
4. ModelsPage is connected to `connection_models.items_changed` → handler runs → `sync_ui_from_store.begin()` → UI rebuilds from current store; deleted row is gone.
5. Other UIs bound to ConnectionModels (e.g. chat model dropdown) already see the update via the same `items_changed`.

### Error Handling

- **Network / API errors**: `exec_delete()` throws (Base handles non-200). ModelRow handles it in `confirm_and_delete()`: `this.sensitive = true` then show `Adw.AlertDialog("Delete failed", e.message)` with response "OK" (see `confirm_and_delete()` catch block in "Add Remove Button to ModelRow").
- **Model in use**: Server 400 is handled in Base (`parse_error_from_json()`); the thrown message is shown in the same error dialog.
- **UI state**: In `confirm_and_delete()`, collapse + `sensitive = false` before the try; on catch, `sensitive = true`; on success the row is removed by store refresh so no re-enable.

## Files to Create

- `libollmchat/Call/Delete.vala` - Delete API call class for removing models (full code in "Create Call.Delete Class" and "Why not send_request" above)

## Files to Modify

### `libollmchat/Call/Base.vala`

In `send_request()`, replace the block that sets the request body (the `if (needs_body && this.http_method == "POST")` block) with:

```vala
switch (this.http_method) {
    case "POST":
    case "DELETE":
        if (!needs_body) {
            break;
        }
        this.set_request_body(message);
        break;
    default:
        break;
}
```

### `libollmchat/meson.build`

Add `Call/Delete.vala` to `ollmchat_ollama_src` (e.g. after `Call/Create.vala`):

```meson
'Call/Delete.vala',
```

### `docs/meson.build`

Add to the libollmchat valadoc file list, after `'../libollmchat/Call/Create.vala'`:

```meson
'../libollmchat/Call/Delete.vala',
```

### `ollmapp/SettingsDialog/ModelRow.vala`

- In `expand()`: add the remove row and button (see code block in "Add Remove Button to ModelRow").
- Add async method `confirm_and_delete()` (see code block in same section).

### `ollmapp/SettingsDialog/ModelsPage.vala`

1. **Expose store** — change field to public property (see "Expose the store" code block).
2. **Hide from serialization** — if the class implements `Json.Serializable`, add the `serialize_property` override (see "Hide from serialization" code block).
3. **Constructor** — replace `model_complete` connection and add `items_changed` connection (see "In the constructor" code block).
4. **render_models()** — replace body with `yield this.sync_ui_from_store()` flow (see "Replace render_models() body" code block).
5. **Add sync_ui_from_store()** — add the private async method (see "sync_ui_from_store()" code block).
6. **update_models_from_connection_models** — after removing keys_to_remove, add the reorder block (see "Model list sort order and incremental updates" reorder code block).

### `libollmchat/Settings/ConnectionModels.vala`

Optional: add `refresh_connection_url(connection_url)` for per-connection refresh after delete (no code block in this plan; implement if desired).

## Implementation Notes

- Follow the same pattern as `Call.Pull` for API call implementation (build message with body, send_and_read_async, check status)
- Use `Adw.AlertDialog` for confirmation (same pattern as `Window.vala`: `choose(parent, null)` to get response; use `Adw.ResponseAppearance.DESTRUCTIVE` for the Delete response)
- Ensure the delete button is clearly marked as a destructive action
- Consider showing model size in the confirmation dialog if available from model metadata
- The delete operation should be cancellable (use `Cancellable` from `Call.Base`)
- After deletion, the model should disappear from the list immediately without requiring a manual refresh

## API Reference

Ollama Delete API:
- **Endpoint**: `DELETE /api/delete`
- **Request Body**: `{"name": "model_name"}`
- **Response**: Empty or simple confirmation JSON

## Future Considerations

- **Bulk Delete**: Allow deleting multiple models at once
- **Model Size Display**: Show model size in the confirmation dialog
- **Usage Check**: Warn if model is currently in use by any chat
- **Undo Support**: Keep deleted models in a "recently deleted" list for quick restore (if server supports it)
