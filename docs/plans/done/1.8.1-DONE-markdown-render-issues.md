# 1.8.1 DONE — Markdown render issues (remaining)

- **Goal:** Fix remaining markdown test failures (formatting, indented fenced blocks).
- **Status:** done.
- **Coding standards:** Verify against `.cursor/rules/CODING_STANDARDS.md` (brace placement, `this.` prefix, no one-line if with body, no unnecessary temporaries, line breaking).

---

## 1. Formatting (HTML) — test 1

- Code span must not parse inline formatting inside backticks.
- `**bold**` / `*italic*` inside `` `code` `` → output literal, not `<strong>`/`<em>`.
- **Clarification:** Literals (inline backtick spans) are not code blocks. Emit their content as regular text (e.g. via `on_text` within the code-span wrapper), not as block code.

**Proposed change (string instead of bool):**
- `string is_literal = ""` — off (not in code span).
- is_literal = one backtick char — literal span (close on one `).
- is_literal = two backtick chars — code span (close on two ``).
- So we know which delimiter closes; no formatting inside either.

**formatmap.peek_literal(...):**
- Returns 0 (no match, treat char as literal), -1 (need more data), or N (match length in bytes; closing delimiter).
- Simple case first: when is_literal == one backtick: if c == '`' return 1; else return 0. Never -1.
- When is_literal == two backticks: if only one char in chunk and it's ` return -1; if two chars and `` return 2; else return 0.

```vala
// FormatMap: add method
// @return 0 no match, -1 need more, N match length (bytes to advance)
public int peek_literal(string chunk, int chunk_pos, bool is_end_of_chunks, string is_literal)
{
    if (is_literal == "" || chunk_pos >= chunk.length) {
        return 0;
    }
    var c0 = chunk.get_char(chunk_pos);
    if (c0 != '`') {
        return 0;
    }
    // Simple case: one backtick span — close on one `
    if (is_literal.length == 1) {
        return 1;
    }
    // Two backtick span — need `` to close (c0 is `, so 1 byte)
    if (chunk_pos + 1 >= chunk.length) {
        if (!is_end_of_chunks) {
            return -1;
        }
        return 0;
    }
    var c1 = chunk.get_char(chunk_pos + 1);
    if (c1 != '`') {
        return 0;
    }
    return 2;
}
```

**Parser block (after escape, before startmap/leftmap/rightmap/formatmap):**

```vala
if (this.is_literal != "") {
    var result = this.formatmap.peek_literal(chunk, chunk_pos, is_end_of_chunks, this.is_literal);
    if (result == -1) {
        this.leftover_chunk = str + chunk.substring(chunk_pos, chunk.length - chunk_pos);
        str = "";
        return;
    }
    if (result == 0) {
        str += c.to_string();
        chunk_pos += c.to_string().length;
        this.at_line_start = false;
        continue;
    }
    // result == N: closing delimiter matched, advance N
    this.renderer.on_text(str);
    str = "";
    this.state_stack.remove_at(this.state_stack.size - 1);
    this.do_format(false, this.is_literal.length == 1 ? FormatType.LITERAL : FormatType.CODE);
    this.is_literal = "";
    chunk_pos += result;
    this.at_line_start = false;
    continue;
}
```

**Implementation:**
- Add `string is_literal { get; set; default = ""; }` to Parser (replace bool in_literal when done; property with default per CODING_STANDARDS).
- In do_format: when opening LITERAL set is_literal = one backtick; when opening CODE set is_literal = two backticks; when closing set is_literal = "".
- Add FormatMap.peek_literal(chunk, chunk_pos, is_end_of_chunks, is_literal); implement as above.
- Insert parser block after escape, before startmap; on result N use stack top (or is_literal) to call do_format(false, LITERAL) or do_format(false, CODE).
- Apply same is_literal + peek_literal logic in process_inline.

**Issues with this fix:**
- None for single-backtick test.
- Double-backtick span: fixed by peek_literal (returns 2 when `` seen; -1 when only one ` and need more).

**Terminology:**
- **Code span (inline):** One or two backticks. Set is_literal to one or two backtick chars when opened; cleared on close. peek_literal decides close.
- **Code block:** Fenced or indented; block-level, does not set is_literal.

**Caveats (optional):**
- Set at_line_start = false in close branch.

**Options:**

- **A. Early flush (chosen)**
  - When `in_literal`: if not backtick → append, advance, continue; if backtick → close LITERAL here. No formatmap.eat.
- **B. Skip maps when in literal**
  - Add `if (in_literal) skip` before startmap, leftmap, rightmap
  - After formatmap.eat: zero match_len unless LITERAL/CODE and matches stack top
- **C. Zero after eat only**
  - Current: zero match_len when in_literal and not LITERAL
  - Fails: leftmap matches `**` before formatmap
  - Need A or B

---

## 2. Indented fenced blocks (trace) — test 5 — DONE

- CODE_TEXT includes leading list-item indent (e.g. `"   void main() {"`).
- Strip indent from code block lines before CODE_TEXT callback.
- Update expected trace to word-split TEXT (match blocks/links) when fixing CODE_TEXT.

**Original condition:** At start of line, if the fenced start is > 3 chars (indented open like `"   ```"`):
- Eat 3 spaces on content lines (shift `chunk_pos`) before emitting CODE_TEXT.
- Closing: watch for 6 chars (same as open) — already done via `fence_open`.

**Approach:** Detect and shift in **peekFencedEnd** (detect closing fence; when not closing and `fence_open.length > 3`, shift `chunk_pos` past up to 3 leading spaces). Remove all check_fenced_newline / handle_fence_result indent logic from the plan; flow is at-line-start only: peekFencedEnd then handle_fence_result.

---

**Caller in `Parser.add()` (fenced block, at line start)**

```vala
// If we're in a fenced code block, check for closing fence only at line start
if (this.current_block == FormatType.FENCED_CODE_QUOTE
	 || this.current_block == FormatType.FENCED_CODE_TILD) {
	if (!this.at_line_start) {
		if (this.blockmap.check_fenced_newline(ref chunk_pos, chunk)) {
			assert(str == "");
			return;
		}
		continue;
	}
	// At line start - check for closing fence
	var fence_result = this.blockmap.peekFencedEnd(chunk, ref chunk_pos, this.current_block, is_end_of_chunks);
	if (this.blockmap.handle_fence_result(fence_result, ref chunk_pos, chunk)) {
		assert(str == "");
		return;
	}
	continue;
}
```

Flow: newline → `handle_line_break`; at line start → `peekFencedEnd` then `handle_fence_result`. Indent handling: in `peekFencedEnd` (detect + shift `chunk_pos`), not in check_fenced_newline / handle_fence_result.

---

**`BlockMap.peekFencedEnd()` — detect and shift `chunk_pos`**

Current code (peekFencedEnd; no check_fenced_newline / handle_fence_result body in plan):

**Changes (one-line each):**
1. Remove early "need newline" check — at line start we're always called; later code checks length to match open tag.
2. Signature: add `ref` to `chunk_pos` so we can shift it for indent.
3. When `at_marker != this.fence_open`: if indented open and line starts with 3 spaces, advance `chunk_pos` by 3 then return 0.

```vala
public int peekFencedEnd(
	string chunk,
	ref int chunk_pos,  // CHANGE: ref so we can shift chunk_pos for indent
	FormatType fence_type,
	bool is_end_of_chunks)
{
	// CHANGE: removed — if (!chunk.contains("\n") && !is_end_of_chunks) return -1;
	if (chunk_pos >= chunk.length) {
		return 0;
	}
	if (chunk_pos + this.fence_open.length > chunk.length) {
		if (is_end_of_chunks) {
			return 0;
		}
		return -1;
	}
	var at_marker = chunk.substring(chunk_pos, this.fence_open.length);
	if (at_marker != this.fence_open) {
		// CHANGE: if indented open and line has prefix "   ", eat 3 spaces and return 0
		if (this.fence_open.length > 3 && at_marker.has_prefix("   ")) {
			chunk_pos += 3;
		}
		return 0;
	}
	var pos = chunk_pos + this.fence_open.length;
	if (pos >= chunk.length) {
		if (is_end_of_chunks) {
			return this.fence_open.length;
		}
		return -1;
	}
	var newline_pos = chunk.index_of_char('\n', pos);
	if (newline_pos == pos) {
		var nl_char = chunk.get_char(newline_pos);
		return this.fence_open.length + nl_char.to_string().length;
	}
	if (newline_pos != -1) {
		var between = chunk.substring(pos, newline_pos - pos);
		if (between.strip().length == 0) {
			var nl_char = chunk.get_char(newline_pos);
			return newline_pos - chunk_pos + nl_char.to_string().length;
		}
		return 0;
	}
	var remaining = chunk.substring(pos);
	if (remaining.strip().length == 0) {
		if (is_end_of_chunks) {
			return (int) chunk.length - chunk_pos;
		}
		return -1;
	}
	return 0;
}
```

- **Detect:** closing fence = `fence_open` at `chunk_pos` (e.g. 6 chars); return >0 = bytes to consume. Return 0 = not closing (content line).
- **When `at_marker != this.fence_open`:** if `this.fence_open.length > 3` and `at_marker.has_prefix("   ")` → advance `chunk_pos` by 3, return 0. Otherwise return 0. So `peekFencedEnd` takes `ref int chunk_pos`.

**Placeholders**

- CHANGE: Caller passes `ref chunk_pos` to `peekFencedEnd` (Parser.add() call site).
- `handle_fence_result(0)` unchanged: uses `chunk_pos` (already past indent when peekFencedEnd did the shift).
