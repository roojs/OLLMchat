# Table support Phase 5: Calling code and Types (1.10.5)

- Part of the phased implementation for markdown table support.
- See **1.8.2-table-support-current-design.md** for the overall design and phase order.
- Depends on **1.10.4-DONE-table-handling.md** (TableState, feed_line, process_cell).

**Status: 1.10.5 done.**

- **Done (this plan):**
  - **libocmarkdown/Parser.vala** – handle_block_result TABLE case; add() TABLE line handling at line start (feed row or end table, strip.has_prefix("|") early exit); handle_line_break TABLE branch; do_block TABLE case (end only; start handled by TableState).

---

## Goal

Wire table handling into the parser main loop:

- **handle_block_result** when `matched_block == TABLE`:
  - Set `current_block = TABLE`.
  - Create `table_state`.
  - Split the consumed 3-line block into 3 lines.
  - Call `table_state.feed_line(line)` three times.
  - Advance `chunk_pos`.
- **add()** at line start when `current_block == TABLE`:
  - Get the rest of the line.
  - If it looks like a table row:
    - Call `table_state.feed_line(line)`.
    - Advance.
  - Else: end the table and re-process the line.
- **handle_line_break** when `current_block == TABLE`:
  - End the table (do_block(false, TABLE), clear state).
  - Flush text.
  - Advance past the newline.
  - Set `at_line_start = true`.
- **do_block** for `is_start == false`:
  - Add case `FormatType.TABLE`.
  - Call `renderer.on_table(false)`.
  - Clear `table_state`.

- Add any **Types** (e.g. table alignment enum) if desired.
  - See 1.10.4 §1 (optional; renderer already uses `int`).

---

## Files

- **libocmarkdown/Parser.vala**:
  - All call-site changes.
  - All do_block changes.
- **libocmarkdown/TableState.vala**:
  - No changes in this phase.
  - Already has feed_line, split_row, process_cell, emit_row.

---

## 1. Types

- As in **1.10.4 §1**:
  - Stick to `int` for alignment: **-1** left, **0** center, **1** right.
  - No enum; renderer and TableState already use `int`.
  - No change required in this phase.

---

## 2. handle_block_result – TABLE case

- Add a **case** for `FormatType.TABLE` in the switch on `matched_block`.
  - Place before `default`.
  - Block consumed by BlockMap is the 3-line block (header, separator, first body row).
  - Extract it.
  - Split by newline.
  - Create TableState.
  - Feed the three lines.
  - Advance `chunk_pos`.
- **Location:**
  - In `Parser.vala`.
  - Inside `handle_block_result()`.
  - In the `switch (matched_block)` block.
  - Add before `default:`.

**Concrete code:**

```vala
case FormatType.TABLE:
	this.current_block = FormatType.TABLE;
	this.table_state = new TableState(this);
	var consumed_block = chunk.substring(chunk_pos, byte_length);
	var lines = consumed_block.split("\n");
	// BlockMap guarantees 3 lines; ensure we have at least 3
	this.table_state.feed_line(lines[0]);
	this.table_state.feed_line(lines[1]);
	this.table_state.feed_line(lines[2]);
	this.at_line_start = true;
	chunk_pos = seq_pos;
	return false;
```

- **Note:**
  - `seq_pos = chunk_pos + byte_length` is already computed above the switch.
  - After this case, the next character is the start of the line after the table.
  - Or more content.
  - `at_line_start` is true.
  - Next iteration will hit the “current_block == TABLE” branch in add().
  - If the next line is a table row.
  - Or block detection otherwise.

---

## 3. add() – TABLE line handling at line start

- When we are already in a table (`current_block == TABLE`) and at line start:
  - Read the **rest of the current line** (up to and not including the newline).
  - Either feed it as a table row or end the table.
- **Location:**
  - In `Parser.vala`.
  - Inside `add()`.
  - In the `while (chunk_pos < chunk.length)` loop.
  - **Before** the existing block “At line start – check for block markers”.
  - That block is the `if (this.at_line_start)` that calls `blockmap.peek` and `handle_block_result`.
  - Add a branch for `current_block == TABLE`.

**Logic:**

- If we don’t have a newline in the chunk from `chunk_pos` and `!is_end_of_chunks`:
  - We need more input.
  - Set `leftover_chunk` and return.
- Otherwise:
  - Form the line from `chunk_pos` to the next newline.
  - Or end of chunk.
- If the line looks like a table row (e.g. contains `|`):
  - Call `table_state.feed_line(line)`.
  - Advance `chunk_pos` past the line and past the newline (table reader eats the ending `\n`).
  - Set `at_line_start = true`.
  - Continue.
- Else (non-table line):
    - Call `do_block(false, FormatType.TABLE)` (clears `table_state`).
    - Set `current_block = FormatType.NONE`.
    - **Do not** advance `chunk_pos`.
    - So the same line is re-processed as normal content.

**Concrete code:**

```vala
// In table: at line start, consume one full line and either feed as row or end table
if (this.at_line_start && this.current_block == FormatType.TABLE) {
	var newline_pos = chunk.index_of_char('\n', chunk_pos);
	if (newline_pos == -1) {
		if (!is_end_of_chunks) {
			this.leftover_chunk = chunk.substring(chunk_pos, chunk.length - chunk_pos);
			return;
		}
		newline_pos = chunk.length;
	}
	var line_len = newline_pos - chunk_pos;
	var line = chunk.substring(chunk_pos, line_len);
	if (line.contains("|")) {
		this.table_state.feed_line(line);
		chunk_pos = newline_pos;
		if (chunk_pos < chunk.length) {
			chunk_pos += chunk.get_char(chunk_pos).to_string().length;
		}
		this.at_line_start = true;
		continue;
	}
	this.do_block(false, FormatType.TABLE);
	this.current_block = FormatType.NONE;
	this.in_literal = false;
	// do_block(TABLE, false) clears table_state; do not advance chunk_pos – re-process this line as non-table
	continue;
}
```

- Place this block immediately **before** the existing block (shown below):

```vala
if (this.at_line_start) {
	var saved_chunk_pos = chunk_pos;
	...
```

---

## 4. handle_line_break – TABLE branch

**Logic verification:**

- Our table reader (add() TABLE branch) **eats** the ending `\n` when we feed_line a row – that’s OK; we advance past the newline there.
- So we normally **don’t** see `handle_line_break` with `current_block == TABLE` (the `\n` is already consumed).
- When we **do** see `\n` and `current_block == TABLE` (e.g. blank line `\n\n`, or chunk boundary), we should **end** the table: kill table state, close it up.
  - Clear `str` (it’s always empty here; we never accumulated while in TABLE).
  - Call `do_block(false, FormatType.TABLE)` (clears `table_state`, calls `renderer.on_table(false)`).
  - Set `current_block = FormatType.NONE`.
  - Advance past the newline.
  - Set `at_line_start = true`.
  - Return.

- **Location:**
  - In `Parser.vala`.
  - At the start of `handle_line_break(ref int chunk_pos, ref string str)`.

**Concrete code:**

- Add after the fenced-code check.
- Add before the “flush str” / “do_block” logic:

**What is `str` in handle_line_break?**

- `str` is the parser’s **accumulated plain text** in `add()` (the buffer for the current line). The newline that triggered this call is in the **chunk** at `chunk_pos`, not in `str`.
- We’re just **consuming the line break** from the chunk (advance `chunk_pos`). We don’t need to clear or modify `str`. In the TABLE case we never accumulated into `str` anyway, so it’s always empty; no flush, no assign.

```vala
if (this.current_block == FormatType.TABLE) {
	this.do_block(false, FormatType.TABLE);
	this.current_block = FormatType.NONE;
	this.at_line_start = true;
	chunk_pos += 1;
	return;
}
```

- **Full order** in `handle_line_break`:
  1. Fenced code branch.
  2. **TABLE branch** (new).
  3. Flush str.
  4. If current_block != NONE: do_block(false).
  5. Then:
     - on_text("\n").
     - at_line_start = true.
     - chunk_pos += 1.

---

## 5. do_block – TABLE case (end of table)

- When ending a table:
  - Call `renderer.on_table(false)`.
  - Clear `table_state`.
- **Location:**
  - In `Parser.vala`.
  - Inside `do_block()`.
  - In the `switch (block_type)` block.
  - Add an explicit case for `FormatType.TABLE`.
  - So it is not handled by `default`.

**Concrete code:**

```vala
case FormatType.TABLE:
	if (!is_start) {
		this.renderer.on_table(false);
		this.table_state = null;
	}
	break;
```

- Place this before `case FormatType.NONE:`.
  - Or before `default:`.
- No action when `is_start == true`.
- TableState.feed_line() emits `on_table(true)` when emitting the first body row.
  - Row index 2.

---

## 6. Summary of edits (Parser.vala)

- **handle_block_result**
  - Add `case FormatType.TABLE:` before `default`.
  - Set current_block.
  - New TableState(this).
  - Split consumed block by "\n".
  - feed_line for lines[0..2].
  - at_line_start = true.
  - chunk_pos = seq_pos.
  - return false.
- **add()**
  - Before “At line start – check for block markers”.
  - If at_line_start && current_block == TABLE: read line to next newline.
  - If line.contains("|"): feed_line(line) and advance (past line and newline).
  - Else:
    - do_block(false,TABLE) (clears table_state).
    - current_block = NONE.
    - continue without advancing.
- **handle_line_break**
  - After fenced-code branch.
  - If current_block == TABLE:
    - Don’t touch str (just consume newline from chunk).
    - do_block(false, TABLE).
    - current_block = NONE.
    - at_line_start = true.
    - chunk_pos += 1.
    - return.
- **do_block**
  - Add case FormatType.TABLE.
  - If !is_start: renderer.on_table(false), table_state = null; break.

---

## 7. References to 1.10.4

- **TableState** and **feed_line(line)**:
  - Defined in 1.10.4.
  - Parser only creates and clears `table_state`.
  - Parser calls `feed_line` (1.10.5).
- **process_cell** and **emit_row**:
  - Live in TableState (1.10.4).
  - No Parser method named handle_table_line.
  - Delegation is `table_state.feed_line(line)`.
- **Alignment** and optional TableAlign enum: 1.10.4 §1.
- **Call-site snippets** in 1.10.4 §9:
  - Are for 1.10.5.
  - This document expands them.
  - With exact placement and surrounding context.
