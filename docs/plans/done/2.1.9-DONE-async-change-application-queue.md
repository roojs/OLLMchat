# 2.1.9. Async Change Application Queue

## Overview

Refactor the Stream class to remove blocking waits for change application. Implement asynchronous change application with a queue system that handles line-based and AST-based changes differently. Line-based changes are applied serially after message completion, while AST-based changes are applied asynchronously (but not concurrently) as they are received.

## Status

✅ **DONE** - Part of 2.1.4 AST Path Support for EditFile Integration

## Checklist (coding standards)

- [ ] **Nullable types**: No new APIs/properties use nullable types unless absolutely required; prefer default objects/flags.
- [ ] **Null checks**: Plan does not rely on generic null checks; only uses them where the design explicitly requires null.
- [ ] **String interpolation**: Any new/changed code avoids `@"..."` string interpolation except for multi-line usage/help text or docs.
- [ ] **Temporary variables**: New code avoids one-use temporaries and trivial aliases; only aliases long chains where needed.
- [ ] **Brace placement**: New/changed Vala code keeps brace style consistent with coding standards.
- [ ] **`this.` prefix**: New/changed Vala code uses `this.` for instance members.
- [ ] **GLib prefix & using statements**: New/changed code uses `GLib.*` prefixes and does not introduce `using` imports.
- [ ] **Property initialization**: New properties use defaults (`get; set; default =` or field defaults) instead of constructor init.
- [ ] **Line length & breaking**: Plan anticipates breaking long calls/concats over multiple lines for readability.

## Related Plans

- **2.1.4** - AST Path Support for EditFile Integration (main plan)
- **2.1.6** - Stream Class Refactoring (prerequisite)
- **2.1.7** - Line Number Mode (Legacy) and Mode Separation
- **2.1.8** - AST Path Mode (Incremental Application)

## Purpose

Refactor change application to be non-blocking and asynchronous. Line-based changes must be applied serially after message completion to ensure line numbers remain valid. AST-based changes can be applied asynchronously as they are received, but should not be applied concurrently (one at a time via a queue). When the AST end-of-message is received, the UI should not receive the "messages completed" signal until all queued changes have been applied.

**Key Requirements:**
- **Line-based changes**: Applied serially from start to end after message completion to preserve line number validity
- **AST-based changes**: Applied asynchronously (but not concurrently) via a queue as they are received
- **Queue processing**: When a change completes, process the next queue item, or if the end message has been received and queue is empty, send the response message
- **UI signal timing**: The "messages completed" signal should not be sent to the UI until all queued changes have been applied

## Implementation

### Phase 1: Add Change Queue to Stream Class

- [ ] **Add Queue State to Stream:**
  - [ ] Add `pending_changes` queue (Gee.Queue<OLLMfiles.FileChange>):
    ```vala
    private Gee.Queue<OLLMfiles.FileChange> pending_changes = new Gee.LinkedList<OLLMfiles.FileChange>();
    ```
  - [ ] Add `processing_change` flag (bool):
    ```vala
    private bool processing_change = false;
    ```
  - [ ] Add `message_completed` flag (bool):
    ```vala
    private bool message_completed = false;
    ```
  - [ ] Add `response` reference (OLLMchat.Response.Chat?):
    ```vala
    private OLLMchat.Response.Chat? pending_response = null;
    ```
  - [ ] Add `history_created` flag (bool):
    ```vala
    private bool history_created = false;
    ```

- [ ] **Modify Stream.add_linebreak() for AST Path Changes:**
  - [ ] When AST path code block closes (current_change.ast_path != ""):
    - [ ] Add change to `changes` array (for tracking)
    - [ ] Add change to `pending_changes` queue (for processing)
    - [ ] If `processing_change == false`, start processing queue
    - [ ] Do NOT wait for AST resolution or application
  - [ ] When line number code block closes (current_change.ast_path == ""):
    - [ ] Add change to `changes` array (as before)
    - [ ] Do NOT add to queue (line-based changes are handled after message completion)

- [ ] **Add Queue Processing Method:**
  - [ ] Add `process_next_change()` async method:
    ```vala
    private async void process_next_change()
    {
        if (this.processing_change) {
            return; // Already processing
        }
        
        if (this.pending_changes.size == 0) {
            // Queue is empty - sync buffer to file and update metadata for AST changes
            // then send response if message is completed
            if (this.message_completed) {
                yield this.sync_and_update_metadata();
                this.send_response();
            }
            return;
        }
        
        this.processing_change = true;
        var change = this.pending_changes.poll();
        
        // Ensure file history is created on first edit (before changes for modified files)
        yield this.create_file_history(
            this.file.manager,
            this.file,
            GLib.FileUtils.test(this.request.normalized_path, GLib.FileTest.IS_REGULAR) ? "modified" : "added"
        );
        
        // Wait for AST resolution if needed
        // Since resolve_ast_path() is async, we can yield on it directly
        // Changes in queue are not completed yet (they're added when code block closes)
        if (change.ast_path != "") {
            // Yield for resolution - no timeout loops needed
            yield change.resolve_ast_path();
        }
        
        // Apply change after resolution (change is already in changes array, don't add again)
        // apply_change() sets result and completed - does not throw errors
        yield change.apply_change(this.write_complete_file);
        // result and completed are already set by apply_change()
        // Note: apply_edit() only applies to buffer - does not sync to file
        // Buffer sync and metadata updates happen when queue is empty (before sending response)
        
        this.processing_change = false;
        
        // Process next item in queue, or send response if queue is empty and message completed
        // This is the key: when a change completes, either process next queue item
        // or if end message received and queue empty, sync metadata and send response
        this.process_next_change.begin();
    }
    ```
  - [ ] **Note:** The queue processing is self-perpetuating: when a change completes, it calls `process_next_change.begin()` again, which will either process the next queue item or send the response if the queue is empty and the message is completed.

- [ ] **Modify create_file_history() method:**
  - [ ] Modify existing `create_file_history()` method to include flag check and file existence check:
    ```vala
    private async void create_file_history(
        OLLMfiles.ProjectManager project_manager,
        OLLMfiles.File file,
        string change_type) throws Error
    {
        // Check if history already created
        if (this.history_created) {
            return; // Already created
        }
        
        // Check if file exists (for added files, this will be called again after file is created)
        if (!GLib.FileUtils.test(this.request.normalized_path, GLib.FileTest.IS_REGULAR)) {
            return; // File doesn't exist yet, will be called again later
        }
        
        // Create file history
        // For modified files: called before changes (to create backup)
        // For added files: called after file is created and converted to real (in sync_and_update_metadata)
        if (project_manager.db == null) {
            return;
        }
        
        var file_history = new OLLMfiles.FileHistory(
            project_manager.db,
            file,
            change_type,
            new GLib.DateTime.now_local()
        );
        try {
            yield file_history.commit();
            this.history_created = true;
        } catch (GLib.Error e) {
            GLib.warning("Cannot create FileHistory for edit (%s): %s", this.request.normalized_path, e.message);
        }
    }
    ```
  - [ ] **Note:** This method now ensures file history is created if not already created. It checks the `history_created` flag and file existence. For modified files, it's called before changes (to create backup). For added files, if the file doesn't exist yet, it will be called again later in `sync_and_update_metadata()` after the file is created and converted to real.

- [ ] **Add sync_and_update_metadata() method:**
  - [ ] Add `sync_and_update_metadata()` async method to Stream class:
    ```vala
    private async void sync_and_update_metadata() throws Error
    {
        var is_in_project = (this.file.id > 0);
        
        if (!is_in_project && this.file.manager.active_project != null) {
            if (this.file.manager.active_project.project_files.folder_map.has_key(
                GLib.Path.get_dirname(this.request.normalized_path)
            )) {
                is_in_project = true;
            }
        }
        
        var file_exists = GLib.FileUtils.test(this.request.normalized_path, GLib.FileTest.IS_REGULAR);
        var change_type = file_exists ? "modified" : "added";
        
        // Sync buffer to file (all changes have been applied to buffer)
        yield this.file.buffer.sync_to_file();
        
        // Update file metadata
        this.send_success_ui_message(is_in_project);
        
        // For added files: convert fake file to real
        if (change_type == "added" && this.file.id <= 0 && is_in_project) {
            var file = yield this.convert_new_file_to_real(this.file.manager, this.file);
            if (file != null) {
                is_in_project = true;
                this.file.manager.active_project.project_files.update_from(this.file.manager.active_project);
            }
        }
        
        // Create history if not already created (handles both modified and added)
        // For modified: should have been created before changes
        // For added: create here after file is created and converted to real
        // create_file_history() checks history_created flag and file existence internally
        yield this.create_file_history(this.file.manager, this.file, change_type);
        
        this.file.is_need_approval = true;
        this.file.last_change_type = change_type;
        this.file.last_modified = new GLib.DateTime.now_local().to_unix();
        
        if (is_in_project || this.file.id > 0) {
            this.file.saveToDB(this.file.manager.db, null, false);
        }
        
        if (is_in_project) {
            this.file.manager.active_project.project_files.review_files.refresh();
        }
        
        if (this.file.manager.db != null) {
            this.file.manager.db.backupDB();
        }
    }
    ```
  - [ ] **Note:** This method syncs the buffer to file and updates metadata after all changes have been applied. It also ensures file history is created if it wasn't created earlier (for added files). It's called by both line-based and AST-based change processing when all changes are done, before sending the response.

- [ ] **Add apply_edit() method to FileBuffer:**
  - [ ] Add public abstract `apply_edit()` async method to FileBuffer abstract class:
    ```vala
    /**
     * Apply a single edit to the buffer.
     * 
     * This performs the actual edit operation on the buffer.
     * Does NOT sync to file - that should be done by the caller.
     * 
     * @param change The FileChange to apply
     * @throws Error if edit cannot be applied (invalid line ranges, etc.)
     */
    public abstract async void apply_edit(FileChange change) throws Error;
    ```
  - [ ] Implement in GtkSourceFileBuffer:
    - [ ] Extract the edit logic from `apply_edits()` foreach loop into `apply_edit()`
    - [ ] Handle indentation normalization, iterators, delete/insert operations
    - [ ] Do NOT call `sync_to_file()` - that's done by `apply_edits()`
    - [ ] Throw Error on failure (invalid line ranges, etc.)
  - [ ] Implement in DummyFileBuffer:
    - [ ] Extract the edit logic from `apply_edits()` foreach loop into `apply_edit()`
    - [ ] Handle validation, array manipulation
    - [ ] Do NOT call `write_real()` - that's done by `apply_edits()`
    - [ ] Throw Error on failure (invalid line ranges, etc.)
  - [ ] Refactor `apply_edits()` in both implementations:
    - [ ] Ensure buffer is loaded
    - [ ] Sort changes descending by start line
    - [ ] Call `apply_edit()` for each change
    - [ ] Call `sync_to_file()` / `write_real()` once at the end

- [ ] **Add apply_change() method to FileChange:**
  - [ ] Add `apply_change()` async method to FileChange class:
    ```vala
    public async void apply_change(bool write_complete_file)
    {
        // File is already set as a property of FileChange
        // Project manager is available via file.manager
        this.file.manager.buffer_provider.create_buffer(this.file);
        
        // Ensure buffer is loaded
        if (!this.file.buffer.is_loaded) {
            try {
                yield this.file.buffer.read_async();
            } catch (Error e) {
                this.result = "Error loading buffer: " + e.message;
                this.completed = true;
                return;
            }
        }
        // TODO: When modes are added to the tool, in AST mode we should not reload the file
        // - The file is already in memory since we had to run the tree on it to start with
        // - AST path resolution requires the file to be parsed, so buffer should already be loaded
        // - This check can be optimized for AST mode to skip the reload
        
        // Handle complete file write
        if (write_complete_file) {
            try {
                yield this.file.buffer.write(this.replacement);
            } catch (Error e) {
                this.result = "Error writing file: " + e.message;
                this.completed = true;
                return;
            }
            this.result = "applied";
            this.completed = true;
            return;
        }
        
        // Apply single edit using apply_edit (singular)
        // apply_edit() throws errors - catch and set result/completed
        try {
            yield this.file.buffer.apply_edit(this);
        } catch (Error e) {
            this.result = "Error applying edit: " + e.message;
            this.completed = true;
            return;
        }
        this.result = "applied";
        this.completed = true;
    }
    ```
  - [ ] **Note:** `apply_change()` does NOT throw errors - it sets `this.result` and `this.completed` on success or failure. Both `apply_edit()` and `write()` errors are caught and handled internally.
  - [ ] **Remove `mark_completed()` helper from `FileChange`:**
    - [ ] Delete `mark_completed(string result_message)` from `libocfiles/FileChange.vala`
    - [ ] Update any remaining call sites (e.g. the old `Stream` AST resolution timeout path) to set `change.result` / `change.completed` directly
    - [ ] **Note:** With the `yield change.resolve_ast_path()` queue approach, we should not have a timeout-loop path at all, so `mark_completed()` becomes redundant.

### Phase 2: Modify Message Completion Handling

- [ ] **Modify Stream.finalize_and_handle_response():**
  - [ ] Finalize stream processing (add_linebreak)
  - [ ] Set `message_completed = true`
  - [ ] Store `response` in `pending_response`
  - [ ] Handle response:
    - [ ] If no changes captured, send no-changes message to LLM
    - [ ] Check queue status (not changes array - both line-based and AST changes go in changes array):
      - [ ] If queue is processing or has items, return (queue will handle response when done)
      - [ ] If queue is empty and not processing, send response immediately
  - [ ] Implementation:
    ```vala
    public async void finalize_and_handle_response(OLLMchat.Response.Chat response)
    {
        // Finalize stream processing
        this.add_linebreak();
        
        // Mark message as completed
        this.message_completed = true;
        this.pending_response = response;
        
        // Check if we have any changes
        if (this.changes.size == 0 && this.pending_changes.size == 0) {
            // No changes were captured - send message to LLM
            this.send_no_changes_response(response);
            return;
        }
        
        // Check queue status (not changes array - both line-based and AST changes go in changes array)
        // If queue is processing or has items, queue processing will handle response when done
        if (this.processing_change || this.pending_changes.size > 0) {
            return;
        }
        
        // Check if AST queue is empty - if so, send response immediately
        // Otherwise, queue processing will send response when done
        if (this.pending_changes.size == 0 && !this.processing_change) {
            this.send_response();
        }
    }
    ```
  - [ ] **Note:** Both line-based and AST-based changes go in the `changes` array. Line-based changes are processed separately (not in this method - handled by queue mechanism or elsewhere). This method only checks queue status and sends response when ready.

- [ ] **Add Line-Based Changes Application:**
  - [ ] Add `apply_line_based_changes()` async method:
    ```vala
    private async void apply_line_based_changes() throws Error
    {
        // Line-based changes must be applied serially from start to end
        // to ensure line numbers remain valid
        // File and project_manager are already set up (file is stored in Stream, project_manager via file.manager)
        
        var project_manager = this.file.manager;
        var normalized_path = this.request.normalized_path;
        var is_in_project = (this.file.id > 0);
        
        if (!is_in_project && project_manager.active_project != null) {
            var dir_path = GLib.Path.get_dirname(normalized_path);
            if (project_manager.active_project.project_files.folder_map.has_key(dir_path)) {
                is_in_project = true;
            }
        }
        
        this.file.manager.buffer_provider.create_buffer(this.file);
        
        // Ensure file history is created on first edit (before changes for modified files)
        var file_exists = GLib.FileUtils.test(normalized_path, GLib.FileTest.IS_REGULAR);
        var change_type = file_exists ? "modified" : "added";
        yield this.create_file_history(project_manager, this.file, change_type);
        
        this.validate_changes(file_exists);
        
        // Filter out completed changes - only process changes that are not yet completed
        var valid_changes = new Gee.ArrayList<OLLMfiles.FileChange>();
        foreach (var change in this.changes) {
            if (!change.completed) {
                valid_changes.add(change);
            }
        }
        
        // Apply line-based changes serially (from start to end)
        // Sort by start line (ascending) to apply in order
        valid_changes.sort((a, b) => {
            if (a.start < b.start) {
                return -1;
            }
            if (a.start > b.start) {
                return 1;
            }
            return 0;
        });
        
        if (valid_changes.size == 0) {
            return;
        }
        
        if (this.write_complete_file) {
            yield this.file.buffer.write(valid_changes.get(0).replacement);
        } else {
            // Apply in order (not reverse) for line-based changes
            // apply_edit() throws errors - catch and set result/completed
            foreach (var change in valid_changes) {
                try {
                    yield this.file.buffer.apply_edit(change);
                } catch (Error e) {
                    change.result = "Error applying edit: " + e.message;
                    change.completed = true;
                    continue;
                }
                change.result = "applied";
                change.completed = true;
            }
        }
        
        // Sync buffer to file and update metadata
        yield this.sync_and_update_metadata();
    }
    ```

- [ ] **Add No Changes Response Method:**
  - [ ] Add `send_no_changes_response()` method:
    ```vala
    private void send_no_changes_response(OLLMchat.Response.Chat response)
    {
        // Send message to LLM that edit mode was enabled but no changes were provided
        this.request.reply_with_errors(
            response,
            "You enabled edit mode for '" + this.request.normalized_path +
                "' but did not provide any code blocks with changes. " +
                "Please provide code blocks with the changes you want to make."
        );
    }
    ```

- [ ] **Add Response Sending Method:**
  - [ ] Add `send_response()` method:
    ```vala
    private void send_response()
    {
        if (!this.message_completed) {
            return; // Message not completed yet
        }
        
        if (this.processing_change || this.pending_changes.size > 0) {
            return; // Still processing changes
        }
        
        if (this.pending_response == null) {
            return; // No response to send
        }
        
        // Build summary and send response
        int applied_count = 0;
        int failed_count = 0;
        var summary_lines = new Gee.ArrayList<string>();
        
        foreach (var change in this.changes) {
            if (change.result != "applied") {
                failed_count++;
                summary_lines.add("  • " + change.get_description() + " was not applied: " +
                    (change.result != "" ? change.result : "unknown error"));
                this.error_messages.add(change.get_description() + " was not applied: " +
                    (change.result != "" ? change.result : "unknown error"));
                continue;
            }
            
            applied_count++;
            summary_lines.add("  • " + change.get_description() + " applied");
        }
        
        // Build summary message
        var summary = "All changes were applied.\n\n";
        if (failed_count > 0 && applied_count > 0) {
            summary = "Some changes were applied.\n\n";
        } else if (failed_count > 0) {
            summary = "No changes were applied.\n\n";
        }
        
        foreach (var line in summary_lines) {
            summary += line + "\n";
        }
        
        if (failed_count > 0) {
            this.error_messages.insert(0, summary);
        }
        
        // Calculate line count for success message
        int line_count = 0;
        try {
            line_count = this.count_file_lines();
        } catch (Error e) {
            GLib.warning("Error counting lines in %s: %s", this.request.normalized_path, e.message);
        }
        
        // Send tool reply to LLM
        // This will trigger the "messages completed" signal to UI after response is sent
        var response = this.pending_response;
        this.pending_response = null;
        this.request.reply_with_errors(
            response,
            (line_count > 0)
                ? "File '" + this.request.normalized_path +
                    "' has been updated. It now has " +
                    line_count.to_string() + " lines."
                : "File '" + this.request.normalized_path + "' has been updated."
        );
    }
    ```
  - [ ] **Note:** The `reply_with_errors()` method in Request will send the response to the LLM, which will eventually trigger UI signals. By delaying this call until all changes are applied, we ensure the UI doesn't receive "messages completed" until everything is done.

### Phase 3: Update Request Class

- [ ] **Modify Request.on_message_completed():**
  - [ ] Remove blocking wait logic (moved to Stream)
  - [ ] Simply call `stream_handler.finalize_and_handle_response()` and let Stream handle everything
  - [ ] Stream will call `reply_with_errors()` when ready
  - [ ] Implementation:
    ```vala
    public override void on_message_completed(OLLMchat.Response.Chat response)
    {
        if (!response.done) {
            return;
        }
        
        if (this.agent == null) {
            return;
        }
        
        this.agent.unregister_tool(this.request_id);
        
        // Process non-streaming content if needed
        if (!this.agent.chat().stream && response.message.content != "") {
            this.stream_handler.process_complete_content(response.message.content);
        }
        
        // Finalize stream processing - Stream handles queue and response sending
        this.stream_handler.finalize_and_handle_response.begin(response, (obj, res) => {
            this.stream_handler.finalize_and_handle_response.end(res);
            
            // Stream will handle response sending via send_response() or send_no_changes_response()
            // when queue is empty and message is completed
        });
    }
    ```

- [ ] **Remove apply_all_changes() call from Request:**
  - [ ] `apply_all_changes()` is now called internally by Stream for line-based changes
  - [ ] AST-based changes are applied via queue processing
  - [ ] Response is sent by Stream when ready

### Phase 4: Update FileChange AST Resolution

- [ ] **Ensure AST Resolution Starts Immediately:**
  - [ ] In `Stream.add_linebreak()`, when AST path code block closes:
    - [ ] Start AST resolution immediately: `current_change.resolve_ast_path.begin()`
    - [ ] Add to queue (resolution happens in parallel)
    - [ ] Queue processor will wait for resolution if needed

- [ ] **Note:** AST resolution already starts in `FileChange.add_linebreak(true)` when code block closes, so this should already work. Verify that resolution starts immediately and doesn't block.

## Files to Modify

- [ ] `liboctools/EditMode/Stream.vala` - Add queue system and async change application
  - [ ] Add queue state properties
  - [ ] Add `process_next_change()` method
  - [ ] Add `apply_line_based_changes()` method
  - [ ] Modify `create_file_history()` method (add flag check and file existence check)
  - [ ] Add `sync_and_update_metadata()` method
  - [ ] Add `send_response()` method
  - [ ] Add `send_no_changes_response()` method
  - [ ] Modify `add_linebreak()` to add AST changes to queue
  - [ ] Modify `finalize_and_handle_response()` to finalize stream and handle response sending
  - [ ] Remove blocking wait logic
  - [ ] Update queue processing to call `change.apply_change()` instead of `apply_single_change()`

- [ ] `libocfiles/FileBuffer.vala` - Add apply_edit() method
  - [ ] Add public abstract `apply_edit()` async method (takes single FileChange, does NOT throw)
  - [ ] Contains the actual edit logic (extracted from apply_edits())
  - [ ] Does NOT sync to file (that's done by apply_edits())
  - [ ] Handles errors internally - sets change.result and change.completed

- [ ] `liboccoder/GtkSourceFileBuffer.vala` - Implement apply_edit() and refactor apply_edits()
  - [ ] Implement `apply_edit()` with GTK buffer operations (extract from apply_edits() loop)
  - [ ] Wrap in try/catch - set change.result and change.completed on success/error
  - [ ] Refactor `apply_edits()` to call `apply_edit()` for each change, then sync once

- [ ] `libocfiles/DummyFileBuffer.vala` - Implement apply_edit() and refactor apply_edits()
  - [ ] Implement `apply_edit()` with array manipulation (extract from apply_edits() loop)
  - [ ] Wrap in try/catch - set change.result and change.completed on success/error
  - [ ] Refactor `apply_edits()` to call `apply_edit()` for each change, then write once

- [ ] `libocfiles/FileChange.vala` - Add apply_change() method
  - [ ] Add `apply_change()` async method that takes write_complete_file parameter
  - [ ] Does NOT throw errors - only sets `result` and `completed`
  - [ ] Uses `file.buffer.apply_edit(this)` for single edits (catches errors)
  - [ ] Handles all errors internally (read_async, write, apply_edit) with try/catch
  - [ ] Sets `result = "applied"` and `completed = true` on success
  - [ ] Sets `result = error message` and `completed = true` on failure
  - [ ] Remove `mark_completed()` and replace any remaining uses with direct `result/completed` assignments

- [ ] `liboctools/EditMode/Request.vala` - Simplify message completion handling
  - [ ] Simplify `on_message_completed()` to delegate to Stream
  - [ ] Remove `apply_all_changes()` call (handled by Stream)

## Benefits

- **Non-blocking**: Stream processing doesn't block waiting for change application
- **Async AST changes**: AST-based changes are applied asynchronously as they are received
- **Serial line-based changes**: Line-based changes are applied serially after message completion to preserve line numbers
- **Queue-based**: Simple queue ensures changes are applied one at a time (not concurrently)
- **Response timing**: Response is sent only after all changes are applied and queue is empty
- **UI feedback**: UI doesn't receive "messages completed" signal until all changes are applied
  - When AST end-of-message is received, `message_completed` flag is set but response is not sent
  - Response (and thus UI signals) are delayed until queue is empty and all changes are applied
  - This ensures UI shows accurate state: message appears complete only when all file changes are done
