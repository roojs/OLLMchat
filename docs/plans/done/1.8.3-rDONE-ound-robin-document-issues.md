# Round-trip: content between $$ lines lost (paragraph preservation)

**Scope:** We do **not** support `$$` as display-math and do not currently intend to. This plan is about round-trip **preserving lines as paragraphs**: after md→document→md, every line (including the line between two `$$` lines) should still be present. Other round-trip issues (blockquote, table) are done.

**Test:** `tests/test-markdown-doc.sh`. Input example: `tests/markdown/renderer-test-suite.md` (section 13). After md→document→md, the content **between** the two `$$` lines is missing.

**Observed**

- Input: first line `$$`, then (optional blank line), then line `\int_{-\infty}^{\infty} e^{-x^2} dx = \sqrt{\pi}`, then `$$`.
- Expected: that middle line (and any blank lines) preserved on round-trip (as paragraph(s)).
- Actual: output has `$$` then empty lines then `$$` — the LaTeX line (and any blank lines between) is gone.

**Do not add code yet.** The steps below are a **debugging plan** to find where the content is lost. Implement fixes only after the cause is identified and agreed.

---

## Process

When dealing with this issue, **do not jump in and start fixing code**. First complete the debugging steps below and document: (1) where the content is lost, and (2) why. Then propose a minimal fix in this plan and get it agreed. Only then implement.

**Coding standards:** Any code added later must follow `.cursor/rules/CODING_STANDARDS.md`.

---

## Debugging plan: why is content between $$ lines not added?

Goal: find the single place (or chain of places) where the middle line(s) between `$$` and `$$` are dropped. Possible loss points: **parser** (never attaches content to a block), **chunking/leftover** (content never parsed), **document model** (block exists but is not emitted), or **serialization** (block emitted but empty).

**How we debug:** We do **not** run the test suite. We use only the build binaries with the minimal file:
- **Parser trace:** `./build/oc-markdown-test tests/markdown/minimal-math.md` (from `examples/oc-markdown-test.vala`, DummyRenderer).
- **Document JSON:** `./build/oc-markdown-doc-test tests/markdown/minimal-math.md` (from `examples/oc-markdown-doc-test.vala`, md→JSON).

We add **GLib.debug** at specific points in the code (see each step). To see debug output we run with **--debug**:
```bash
./build/oc-markdown-test --debug tests/markdown/minimal-math.md
# or
./build/oc-markdown-doc-test --debug tests/markdown/minimal-math.md
```
Remove all DEBUG lines after the issue is found and fixed.

### Step 0: Capture baseline output

Run the pipeline and record what is actually produced. Add the relevant snippets to this report.

**Add this file** — minimal 3-line input for reproducible debugging:

```text
$$
\int_{-\infty}^{\infty} e^{-x^2} dx = \sqrt{\pi}
$$
```

Save as `tests/markdown/minimal-math.md` (use literal backslashes in the middle line).

**Run this test** — build, then parser callback trace for minimal input only:

```bash
meson compile -C build
./build/oc-markdown-test tests/markdown/minimal-math.md
```

**Captured output (minimal):**

- **DummyRenderer:** Parser emits `START: <p>` … `TEXT: "$$"` `END: <p>`, then `TEXT: "\n"`, then **loose** `TEXT: "int_{-infty}^{infty}"`, `TEXT: " e^{-x^2}"`, … then `START: <p>` … `TEXT: "$$"` `END: <p>`. The middle line **is** emitted as TEXT by the parser, but **not** inside a paragraph — it is loose TEXT between two paragraphs. The document renderer never attaches it to any block, so it does not appear in the document. Conclusion: **middle line is parsed and emitted as TEXT but not inside a block; document model only has blocks, so that content is dropped.**

### Step 1: What we already know

We already know from Step 0 that `$$` is not a block. The intended path for the middle line is a **new paragraph** at line start; the bug is that the parser does **not** open a new paragraph for that line, so its TEXT is emitted loose and the document renderer never attaches it to any block.

### Step 2: Rule out chunking / leftover

- **2.1** Reproduce with **one chunk**: minimal input string (e.g. `"$$\n\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}\n$$"`) and a single `add(chunk, true)`. If the middle line **appears** in the round-trip output, the loss is likely in **chunking/leftover** (e.g. middle line stuck in `leftover_chunk` and never passed again, or only passed when `is_end_of_chunks` is false and not flushed).
- **2.2** If the middle line is **still missing** with one chunk, chunking is ruled out; the bug is in the parsing path or the document/serialization path.
- **Output:** “Content lost only with multiple chunks” → focus on `leftover_chunk` and end-of-chunks flush. “Content lost even with one chunk” → focus on parser and document.

**Run (no test script)** — build, then md→JSON for minimal file only (one read = one chunk). If the middle line is missing from the JSON, chunking is ruled out.

```bash
meson compile -C build
./build/oc-markdown-doc-test tests/markdown/minimal-math.md
# Or redirect and inspect:
./build/oc-markdown-doc-test tests/markdown/minimal-math.md > build/tests/markdown-doc-out/minimal-math.json
```

### Step 3: Trace the middle line in the parser (add GLib.debug, run with --debug)

- **Debugging added:** GLib.debug in `Parser.vala` at (1) TEXT emission (log current_block), (2) paragraph open at line start when block_match==0. Run `oc-markdown-test --debug` to see where the middle line is lost.
- **3.1** Add targeted logging (or step in a debugger) for a minimal input (e.g. three lines: `$$`, `\int ...`, `$$`) with **one** `add(..., true)`:
  - When we are at line start and the line is the middle line (e.g. starts with `\` or is the second line), what is `block_match`? Do we open a paragraph?
  - Does the character loop (or `process_inline`) run for the entire middle line and emit TEXT (or equivalent) for it?
  - Is that TEXT (or the paragraph that contains it) attached to the current block (e.g. `current_block_with_inlines` or the document block stack)?
- **3.2** Check whether the first character of the middle line changes behaviour: e.g. `\` can set `escape_next` or trigger inline rules; confirm that the rest of the line is still processed and that we don’t early-return or skip the line.
- **Output:** “Middle line is parsed and attached to block X” or “Middle line is never emitted as TEXT” or “Middle line is emitted but not attached” (with exact location).

**Add these lines** — in `Parser.vala`, at the point where we emit TEXT (e.g. `this.renderer.on_node(FormatType.TEXT, false, str)` or equivalent), add a one-line debug log when the string contains backslash or "int" (remove after diagnosis):

```vala
if (str.contains("int") || str.contains("\\"))
	GLib.debug("DEBUG $$: TEXT emitted (current_block=%s) '%s'", this.current_block.to_string(), str);
```

**Add these lines** — in `Parser.vala`, in the block-handling path at line start when `block_match == 0` and we call `do_block(true, FormatType.PARAGRAPH)` (or set `current_block = FormatType.PARAGRAPH`), log once:

```vala
GLib.debug("DEBUG $$: at_line_start block_match=0 → do_block(true, PARAGRAPH) chunk_pos=%d", chunk_pos);
```

**Run with debug** — parser only, no test script; use **--debug** so GLib.debug output appears:

```bash
./build/oc-markdown-test --debug tests/markdown/minimal-math.md 2>&1 | grep -E "DEBUG \\$\\$|START: <p>|END: <p>|TEXT:"
```

### Step 4: Trace the document model and serialization (add GLib.debug in renderer, run with --debug)

- **Debugging added:** GLib.debug in `document/Render.vala` in `on_node()` for TEXT containing "int" or backslash; run `oc-markdown-doc-test --debug` to see whether the document renderer receives the middle line’s TEXT (if not, the parser never sends it because it’s loose).
- **4.1** After parsing the minimal input, inspect the document tree (e.g. in the test or via a small dump): is there a block (e.g. paragraph) that contains the middle line’s text? If yes, the loss is in **serialization** (e.g. `Block.to_markdown()` for that block type drops or mis-emits content). If no, the loss is in the **parser → document** path (renderer never creates or populates that block).
- **4.2** If the block exists but is empty (or has wrong content), trace how the document renderer handles the callbacks for that paragraph (e.g. `on_block(PARAGRAPH)`, `on_node(TEXT, ...)`): is the TEXT callback called for the middle line, and does it add the text to the current block?
- **Output:** “Document has a paragraph with the LaTeX line” → bug in serialization. “Document has no such block / block is empty” → bug in parser or document renderer.

**Run (no test script)** — md→JSON for minimal file; inspect whether any block contains the LaTeX line:

```bash
./build/oc-markdown-doc-test tests/markdown/minimal-math.md > build/tests/markdown-doc-out/minimal-math.json
cat build/tests/markdown-doc-out/minimal-math.json | jq .
# Or grep for "int" / paragraph blocks
```

**Add these lines** — in `document/Render.vala` in `on_node()` when `type == FormatType.TEXT`: add GLib.debug when the text contains "int" or backslash, to see whether the document renderer receives the middle line’s TEXT at all (remove after diagnosis):

```vala
if (content.contains("int") || content.contains("\\"))
	GLib.debug("DEBUG $$: Document renderer received TEXT '%s'", content);
```

**Run with debug** — use doc-test binary so the document renderer runs; **--debug** shows whether loose TEXT is passed to the renderer (no test script):

```bash
./build/oc-markdown-doc-test --debug tests/markdown/minimal-math.md
```

### Step 5: Summarize and propose fix

- **5.1** Write a short summary: “Content is lost at [component]: [reason].” (e.g. “Content is lost in Parser: middle line remains in `leftover_chunk` when input is chunked and the final chunk does not flush it.”)
- **5.2** Propose a minimal fix (in words or pseudocode) in this plan. Only after that is agreed, add or change code.

---

## After debugging (diagnosis)

- **Cause:** Content is lost in the **parser** because the middle line is never wrapped in a paragraph. The first character of the middle line is `\` (backslash). In `Parser.vala` the main loop handles **backslash before** it checks for block markers at line start: when `c == '\\'` we set `escape_next = true` and **`at_line_start = false`** and `continue` (lines 275–279). So we never reach the “At line start – check for block markers” block (lines 306–339) for that character. The block check is the only place that opens a new paragraph when `block_match == 0` (in `BlockMap.handle_block_result`). So we never open a paragraph for the middle line; all its TEXT is emitted with `current_block == NONE` (loose), and the document renderer only attaches content to blocks, so that TEXT never appears in the document or in the round-trip output.

  **Evidence from --debug run:** We see “at_line_start block_match=0 → do_block(true, PARAGRAPH)” at chunk_pos=0 (first line) and at chunk_pos=52 (third line), but **not** at the start of the middle line. We see “TEXT emitted (current_block=MARKDOWN_FORMAT_TYPE_NONE) 'int_{-infty}^{infty}'” — i.e. the middle line’s TEXT is emitted while current_block is NONE.

- **Proposed fix:** When we are at line start and we see `\`, open a paragraph first (if `current_block == FormatType.NONE`), then handle the backslash as usual. In `Parser.vala` in the `if (c == '\\')` branch: before setting `escape_next = true` and `at_line_start = false`, add: if `this.at_line_start && this.current_block == FormatType.NONE`, then `this.current_block = FormatType.PARAGRAPH` and `this.do_block(true, FormatType.PARAGRAPH)`. No reordering of the main loop; minimal change at the backslash branch only.

---

## Roundtrip diffs (`*-roundtrip-output.diff`)

- **Generate with `diff`**, not by hand. From `build/tests/markdown-doc-out` after a test run (so `*-roundtrip-output.md` and `*-original.md` exist and are normalized):
  - `diff -u BASE-roundtrip-output.md BASE-original.md`
  - Save as `tests/markdown/BASE-roundtrip-output.diff`. Optionally strip timestamps from the first two lines (e.g. `sed -i '1,2s/\t.*//'`).
- **Both headers must name the roundtrip file** so `patch` applies to the roundtrip output. If the diff has `--- roundtrip-output.md` and `+++ original.md`, change the `+++` line to `+++ BASE-roundtrip-output.md` so the patch modifies the roundtrip file and the test passes.
- See also `tests/markdown/README.md` for the comparison (roundtrip-output vs original).