# 1.2.7.10. Move Tool Execution to Agent Handler

## Overview

Move tool execution logic from `Chat.toolsReply()` to `AgentHandler`. The agent should handle all tool execution concerns. Chat should delegate tool execution to the agent when available, and emit a placeholder signal for non-agent usage.

**Parent Plan**: [1.2.7. Move Remaining Signals from Client to Chat](./1.2.7-DONE-move-signals-to-chat.md)

## Status

✅ **DONE** - Tool execution responsibility moved to agent handler.

## Goal

Agent handlers should own and manage all tool execution. Chat should delegate tool execution to the agent when an agent is present, and emit a signal for non-agent usage.

**Current Flow**:
- Chat detects tool calls → Chat executes tools directly → Chat continues conversation

**New Flow (Agent Usage)**:
- Chat detects tool calls → Chat calls agent method → Agent executes tools → Agent returns results → Chat continues conversation

**New Flow (Non-Agent Usage)**:
- Chat detects tool calls → Chat emits signal → External code handles tool execution → External code calls Chat method to continue

## Implementation Steps

### Step 1: Add Tool Execution Method to AgentHandler

**Goal**: Agent handler should have a method to execute all tool calls from a response.

**Changes**:
1. Add to `libollmchat/Prompt/AgentHandler.vala`:
   ```vala
   /**
    * Executes all tool calls and returns tool reply messages.
    * 
    * Called by Chat when tool calls are detected. Agent handler manages
    * tool execution flow including:
    * - Iterating through all tool calls
    * - Tool lookup and validation
    * - UI messages (execution start, errors)
    * - Tool execution
    * - Creating tool reply messages
    * - Error handling (creates tool_call_fail message on error, continues with next tool)
    * 
    * @param tool_calls The list of tool calls to execute
    * @return Array of tool reply messages (tool_reply or tool_call_fail messages)
    */
   public virtual async Gee.ArrayList<Message> execute_tools(Gee.ArrayList<Tool.Call> tool_calls)
   {
       var reply_messages = new Gee.ArrayList<Message>();
       
       foreach (var tool_call in tool_calls) {
           GLib.debug("AgentHandler.execute_tools: Executing tool '%s' (id='%s')",
               tool_call.function.name, tool_call.id);
           
           // Get tool from chat.tools (tools defaults to empty HashMap, never null)
           if (!this.chat.tools.has_key(tool_call.function.name)) {
               var available_tools_str = "";
               if (this.chat.tools.size > 0) {
                   available_tools_str = "'" + string.joinv("', '", this.chat.tools.keys.to_array()) + "'";
               }
               
               var err_message = "ERROR: You requested a tool called '" + tool_call.function.name + 
                   "', however we only have these tools: " + available_tools_str;
               
               var error_msg = new Message(this.chat, "ui", err_message);
               this.handle_tool_message(error_msg);
               reply_messages.add(new Message.tool_call_invalid(this.chat, tool_call, err_message));
               continue; // Continue to next tool call
           }
           
           var tool = this.chat.tools.get(tool_call.function.name);
           
           // Show message that tool is being executed
           var exec_msg = new Message(this.chat, "ui", "Executing tool: `" + tool_call.function.name + "`");
           this.handle_tool_message(exec_msg);
           
           try {
               // Execute the tool - tool.execute() will set request.agent = chat_call.agent
               var result = yield tool.execute(this.chat, tool_call.function.arguments);
               
               // Log result summary (truncate if too long)
               var result_summary = result.length > 100 ? result.substring(0, 100) + "..." : result;
               
               // Check if result is an error and display it in UI
               if (result.has_prefix("ERROR:")) {
                   GLib.debug("AgentHandler.execute_tools: Tool '%s' returned error result: %s",
                       tool_call.function.name, result);
                   var error_msg = new Message(this.chat, "ui", result);
                   this.handle_tool_message(error_msg);
               } else {
                   GLib.debug("AgentHandler.execute_tools: Tool '%s' executed successfully, result length: %zu, preview: %s",
                       tool_call.function.name, result.length, result_summary);
               }
               
               // Create tool reply message
               var tool_reply = new Message.tool_reply(
                   this.chat, tool_call.id, 
                   tool_call.function.name,
                   result
               );
               GLib.debug("AgentHandler.execute_tools: Created tool reply message: role='%s', tool_call_id='%s', name='%s', content length=%zu",
                   tool_reply.role, tool_reply.tool_call_id, tool_reply.name, tool_reply.content.length);
               reply_messages.add(tool_reply);
           } catch (Error e) {
               GLib.debug("AgentHandler.execute_tools: Error executing tool '%s' (id='%s'): %s", 
                   tool_call.function.name, tool_call.id, e.message);
               var error_msg = new Message(this.chat, "ui", "Error executing tool '" + tool_call.function.name + "': " + e.message);
               this.handle_tool_message(error_msg);
               reply_messages.add(new Message.tool_call_fail(this.chat, tool_call, e));
               continue; // Continue to next tool call
           }
       }
       
       return reply_messages;
   }
   ```

**Result**: Agent handler executes all tool calls and returns tool reply messages. Chat is responsible for adding them to messages and sending.

### Step 4: Add Tool Execution Signal to Chat

**Goal**: Add a signal for non-agent usage to handle tool execution.

**Changes**:
1. Add to `libollmchat/Call/Chat.vala` signal declarations:
   ```vala
   /**
    * Emitted when a tool call is detected and needs to be executed.
    * 
    * For non-agent usage: Connect to this signal to handle tool execution.
    * 
    * The handler is responsible for:
    * 1. Execute the tool: Get the tool from `chat.tools.get(tool_call.function.name)` and call `tool.execute(chat, tool_call.function.arguments)`
    * 2. Create tool reply message: `new Message.tool_reply(chat, tool_call.id, tool_call.function.name, result)`
    * 3. Append it to return_messages: `return_messages.add(tool_reply)`
    * 
    * Chat will collect all tool reply messages and send them automatically.
    * 
    * For agent usage: This signal is not used - agent.execute_tools() is called directly by Chat.toolsReply().
    * 
    * @param tool_call The tool call that needs to be executed
    * @param return_messages Array to append tool reply messages to
    */
   public signal void tool_call_requested(Tool.Call tool_call, Gee.ArrayList<Message> return_messages);
   ```

**Result**: Chat has a signal for non-agent tool execution. Caller is responsible for executing tools, creating tool reply messages, adding them to messages, and continuing the conversation using existing Chat methods (`send()`, `execute_streaming()`, etc.).

### Step 2: Add send_append() Method to Chat

**Goal**: Add a convenience method to append messages to existing messages and send.

**Changes**:
1. Add to `libollmchat/Call/Chat.vala`:
   ```vala
   /**
    * Appends new messages to existing messages and sends them.
    * 
    * Convenience method for continuing conversations after tool execution.
    * Appends the provided messages to this.messages and then calls send().
    * 
    * @param new_messages Messages to append to existing messages
    * @param cancellable Optional cancellation token
    * @return The Response from executing the chat call
    * @throws Error if send fails
    */
   public async Response.Chat send_append(Gee.ArrayList<Message> new_messages, GLib.Cancellable? cancellable = null) throws Error
   {
       // Append new messages to existing messages
       foreach (var msg in new_messages) {
           this.messages.add(msg);
       }
       
       // Send using existing send() method
       return yield this.send(this.messages, cancellable);
   }
   ```

**Result**: Chat has a convenience method to append and send messages.

### Step 3: Update Chat.toolsReply() to Delegate to Agent

**Goal**: Chat should delegate tool execution to agent, add messages, and send.

**Changes**:
1. Update `libollmchat/Call/Chat.vala` `toolsReply()` method:
   ```vala
   GLib.debug("Chat.toolsReply: Sending tool responses to LLM: %s", response.message.content);
   
   if (this.agent != null) {
       // Agent usage (normal flow): delegate to agent handler (agent executes tools and returns messages)
       var tool_reply_messages = yield this.agent.execute_tools(response.message.tool_calls);
       
       // Build messages array: assistant message with tool_calls + tool reply messages
       var messages_to_send = new Gee.ArrayList<Message>();
       messages_to_send.add(response.message); // Assistant message with tool_calls
       foreach (var reply_msg in tool_reply_messages) {
           messages_to_send.add(reply_msg); // Tool reply messages
       }
       
       // Append all messages and send
       return yield this.send_append(messages_to_send);
   }
   
   // Non-agent usage (external code using Chat directly): emit signal for each tool call
   // Signal handler is responsible for executing tools and appending tool reply messages
   // Our code always has agent set, so this path is only for external users
   
   // Build messages array: assistant message + tool replies (handler will append tool replies)
   var messages_to_send = new Gee.ArrayList<Message>();
   messages_to_send.add(response.message); // Assistant message with tool_calls
   
   // Emit signal for each tool call - handler executes tools and appends tool reply messages to messages_to_send
   // Signal handlers run synchronously, so they can modify messages_to_send
   foreach (var tool_call in response.message.tool_calls) {
       this.tool_call_requested(tool_call, messages_to_send);
   }
   
   // Append all messages and send (same logic as agent path)
   return yield this.send_append(messages_to_send);
   ```

**Result**: Chat delegates tool execution to agent, receives messages, appends them, and sends.

### Step 5: Remove Direct Tool Execution from Chat

**Goal**: Remove the direct tool execution code from Chat.toolsReply() - agent handles it all.

**Changes**:
1. Remove from `libollmchat/Call/Chat.toolsReply()`:
   - Remove direct `tools_map.get().execute()` call
   - Remove tool lookup and validation (moved to agent)
   - Remove tool execution UI messages (moved to agent)
   - Keep only the delegation logic and tool reply message creation

**Result**: Chat no longer directly executes tools - agent owns all tool execution.

### Step 6: Remove Client Property from Tool.BaseTool

**Goal**: Remove the `client` property from `Tool.BaseTool` since tools now access everything through the agent (via `request.agent` in RequestBase). Tools don't need direct client access.

**Changes**:
1. Remove from `libollmchat/Tool/Tool.vala`:
   - Remove `public Client? client { get; set; default = null; }` property (line 72-73, marked with FIXME)
   - Remove `Client? client = null` parameter from `BaseTool` constructor
   - Remove `this.client = client;` assignment in constructor

2. Update `register_all_tools()` method:
   - Remove `Client client` parameter from `BaseTool.register_all_tools()`
   - Remove `"client", client` from `Object.new()` call (line 618)
   - Update method signature: `public static Gee.HashMap<string, BaseTool> register_all_tools()`

3. Update `Manager.register_all_tools()`:
   - Remove `this.base_client` argument from `BaseTool.register_all_tools()` call
   - Update call: `var tools = OLLMchat.Tool.BaseTool.register_all_tools();`

4. Check for any remaining uses of `tool.client` or `this.client` in tool code:
   - `liboctools/RequestEditMode.vala` - Check if `this.tool.client` references need updating (lines 193, 199)
   - Any other tool implementations that might reference `this.client`

**Note**: Tools now get agent access through `RequestBase.agent` property (set in `BaseTool.execute()` at line 491). Tools access chat via `agent.chat` and connection via `agent.chat.connection`. The client property on BaseTool is no longer needed.

**Result**: `Tool.BaseTool` no longer has a `client` property - tools access everything through the agent.

### Step 7: Update Tools When Tool Config Changes

**Goal**: When tool configuration changes (user updates tool config in settings), the agent should rebuild tools for its Chat instance.

**Issue**: 
- Tools are stored on Manager and copied to Chat when AgentHandler is created (in constructor)
- If tool config changes after AgentHandler is created, Chat's tools are not updated
- Tool config changes affect tool.active state and tool configuration
- Need to rebuild tools on Chat when config changes

**Current State**:
- `AgentHandler` constructor copies tools from `session.manager.tools` to `chat.tools` (lines 116-120)
- Tools are stored on Manager and accessed via Session
- When tool config changes, Manager.tools are updated, but existing Chat instances don't get updated
- Config changes emit `config.changed()` signal

**Changes**:
1. Add to `libollmchat/Prompt/AgentHandler.vala`:
   ```vala
   /**
    * Rebuilds tools for this agent's Chat instance.
    * 
    * Called when tool configuration changes. Clears existing tools from Chat
    * and re-adds them from Manager, allowing agent to reconfigure/filter.
    * 
    * This ensures Chat always has the latest tool configuration.
    */
   public void rebuild_tools()
   {
       // Clear existing tools from Chat
       this.chat.tools.clear();
       
       // Re-add tools from Manager (they may have updated config/active state)
       foreach (var tool in this.session.manager.tools.values) {
           this.chat.add_tool(tool);
       }
       
       // Agent can reconfigure/filter tools if needed
       this.agent.configure_tools(this.chat);
   }
   ```

2. Add to `libollmchat/History/Session.vala`:
   - Connect to `manager.config.changed` signal in constructor or `load()` method
   - When config changes, call `agent.rebuild_tools()` if agent exists
   - This ensures all sessions update their tools when config changes

**Note**: Tool config changes are session-level (stored in Config2.tools), so we should tell the agent to rebuild tools for the session's Chat instance. This is different from model/options updates which are also session-level.

**Result**: When tool config changes, all active sessions' agents rebuild their tools, ensuring Chat always has the latest tool configuration.

## Files to Modify

- `libollmchat/Prompt/AgentHandler.vala` - Add `execute_tools()` method (returns messages), add `rebuild_tools()` method
- `libollmchat/Call/Chat.vala` - Add `send_append()` method, add `tool_call_requested` signal, update `toolsReply()` to delegate to agent and use send_append()
- `libollmchat/Tool/Tool.vala` - Remove `client` property and constructor parameter from `BaseTool`, update `register_all_tools()` to not take Client parameter
- `libollmchat/History/Manager.vala` - Update `register_all_tools()` to not pass `base_client` to `BaseTool.register_all_tools()`
- `libollmchat/History/Session.vala` - Connect to `config.changed` signal and call `agent.rebuild_tools()` when tool config changes
- `liboctools/RequestEditMode.vala` - Check and update any `this.tool.client` references (if still present)

## Testing Checklist

- [ ] AgentHandler has `execute_tools()` method (takes list of tool calls, returns array of messages)
- [ ] AgentHandler.execute_tools() iterates through all tool calls
- [ ] AgentHandler.execute_tools() handles tool lookup and validation for each tool
- [ ] AgentHandler.execute_tools() sends UI messages via handle_tool_message()
- [ ] AgentHandler.execute_tools() executes each tool
- [ ] AgentHandler.execute_tools() creates tool reply messages and returns them (doesn't add to chat.messages)
- [ ] AgentHandler.execute_tools() handles errors and creates tool_call_fail messages (continues to next tool)
- [ ] Chat has `send_append()` method that appends messages and sends
- [ ] Chat has `tool_call_requested` signal
- [ ] Chat.toolsReply() calls agent.execute_tools() once with all tool calls (no foreach loop in Chat)
- [ ] Chat.toolsReply() receives tool reply messages from agent and appends them using send_append()
- [ ] Chat.toolsReply() builds messages array with assistant message + tool replies before sending
- [ ] Tool execution still works correctly for agent usage
- [ ] Tool execution error handling still works correctly (handled by agent, continues to next tool)
- [ ] Tool reply messages are created by agent and returned, Chat adds them to messages
- [ ] Agent handles the foreach loop internally, Chat just delegates once and manages message flow
- [ ] Conversation continues automatically after tool execution
- [ ] `Tool.BaseTool` no longer has `client` property
- [ ] `Tool.BaseTool` constructor no longer takes `client` parameter
- [ ] `BaseTool.register_all_tools()` no longer takes `Client` parameter
- [ ] `Manager.register_all_tools()` no longer passes `base_client` to tool registration
- [ ] All tools access connection/chat via `agent.chat` (through RequestBase.agent)
- [ ] No remaining references to `tool.client` or `this.client` in tool code
- [ ] AgentHandler has `rebuild_tools()` method
- [ ] `rebuild_tools()` clears Chat tools and re-adds from Manager
- [ ] `rebuild_tools()` calls `agent.configure_tools()` after rebuilding
- [ ] Session connects to `config.changed` signal
- [ ] Session calls `agent.rebuild_tools()` when config changes
- [ ] Tool config changes update Chat tools correctly

## Related Plans

- [1.2.7. Move Remaining Signals from Client to Chat](./1.2.7-DONE-move-signals-to-chat.md) - Parent plan
- [1.2.7.4. Migrate Tool Signal Connections to Direct Method Calls](./1.2.7.4-DONE-migrate-non-agent-signals.md) - Previous phase (tools now use agent property)
- [1.2.7.9. Move Permission Provider to Agent](./1.2.7.9-move-permission-provider-to-agent.md) - Related (permission provider on agent)

