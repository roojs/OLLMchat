# 1.2.7.2. Add Signals to Chat

## Overview

Add the three asynchronous signals (`stream_chunk`, `stream_start`, `tool_message`) to `Call.Chat`. These signals will be used for non-agent usage (loosely coupled components), while agent usage will use direct method calls.

**Parent Plan**: [1.2.7. Move Remaining Signals from Client to Chat](./1.2.7-DONE-move-signals-to-chat.md)

## Status

âœ… **DONE** - Signals added to Chat. All three signals (stream_chunk, stream_start, tool_message) are declared and emitted from Call.Chat.

## Goal

Add signal declarations and emissions to Chat. Client will still have these signals for backward compatibility during the migration.

## Signals to Add

### 1. `stream_chunk(string, bool, Response.Chat)`

- **Current**: Emitted on `Client` when a streaming chunk is received
- **Move to**: `Call.Chat` - Chat orchestrates the conversation, emits streaming chunks
- **Usage**: For non-agent usage (loosely coupled components)

### 2. `stream_start()`

- **Current**: Emitted on `Client` when streaming starts (first chunk received)
- **Move to**: `Call.Chat` - Chat emits when streaming starts
- **Usage**: For non-agent usage (loosely coupled components)

### 3. `tool_message(Message)`

- **Current**: Emitted on `Client` when a tool sends a status message
- **Move to**: `Call.Chat` - Chat emits tool status messages
- **Usage**: For non-agent usage (loosely coupled components)

## Implementation Steps

### Step 1.1: Add Signal Declarations to Call.Chat

**Goal**: Add the three signal declarations to `Call.Chat`.

**Changes**:
1. Add to `libollmchat/Call/Chat.vala`:
   ```vala
   /**
    * Emitted when a streaming chunk is received from the chat API.
    *
    * @param new_text The new text chunk received
    * @param is_thinking Whether this chunk is thinking content (true) or regular content (false)
    * @param response The Response object containing the streaming state
    * @since 1.0
    */
   public signal void stream_chunk(string new_text, bool is_thinking, Response.Chat response);

   /**
    * Emitted when the streaming response starts (first chunk received).
    * This signal is emitted when the first chunk of the response is processed,
    * indicating that the server has started sending data back.
    *
    * @since 1.0
    */
   public signal void stream_start();

   /**
    * Emitted when a tool sends a status message during execution.
    *
    * @param message The Message object from the tool (typically "ui" role)
    * @since 1.0
    */
   public signal void tool_message(Message message);
   ```

**Result**: Chat has the signals, but Client still has them too (for backward compatibility)

### Step 1.2: Add Signal Emissions to Call.Chat

**Goal**: Emit signals from Chat in addition to (or instead of) Client.

**Changes**:
1. Find all places where `client.stream_chunk()` is emitted
2. Add `this.stream_chunk()` emission in the same place (or replace if Chat has access)
3. Repeat for `stream_start()` and `tool_message()`

**Files to check**:
- `libollmchat/Call/Chat.vala` - Add signal emissions
- `libollmchat/Call/Base.vala` - May need to emit via Chat reference

**Result**: Chat emits signals, Client still emits them too (for backward compatibility)

## Files to Modify

- `libollmchat/Call/Chat.vala` - Add signal declarations and emissions
- `libollmchat/Call/Base.vala` - May need to emit via Chat reference

## Testing Checklist

- [x] Chat has signal declarations (stream_chunk, stream_start, tool_message) for non-agent usage
- [x] Chat emits signals when appropriate
- [x] Client still emits signals (for backward compatibility during migration)
- [x] Signals are emitted at the correct times

## Related Plans

- [1.2.7. Move Remaining Signals from Client to Chat](./1.2.7-DONE-move-signals-to-chat.md) - Parent plan
- [1.2.7.3. Update Agent Usage to Direct Method Calls](./1.2.7.3-DONE-update-agent-usage-direct-calls.md) - Next phase
- [1.2. Refactor Client and Chat Relationship](./1.2-DONE-refactor-client-chat-relationship.md) - Grandparent plan

