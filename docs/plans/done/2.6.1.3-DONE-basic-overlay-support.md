# 2.6.1.3. Basic Overlay Support (String Copying)

## Overview

Implement overlay filesystem support to isolate writes during command execution. Files are copied from overlay to live system using simple string/file copying based on Monitor information.

**Note**: This phase designs the Overlay class for the eventual integrated system (Phase 4/5). The overlay will be integrated with Bubble in Phase 4, so this phase targets the final architecture where overlay is actually used by Bubble. This code will not be used with Phase 2 code - it's designed for the complete integrated workflow.

## Status

â³ **PLANNING** - Design phase.

## Prerequisites

- Phase 1 (2.6.1.1) must be completed
- Phase 2 (2.6.1.2) must be completed
- See main plan: `2.6.1-code-exec-improvements.md` for overlay architecture details

## Goals

1. Create `Overlay` class for overlay filesystem management
2. Implement overlay creation and mounting
3. Integrate Monitor with overlay upper directory
4. Copy files from overlay to live system after execution (string copying)

## Implementation Details

### Files to Create

- `liboctools/RunCommand/Overlay.vala` - Overlay filesystem creation and management

### Files to Modify

- `liboctools/meson.build` - Add `RunCommand/Overlay.vala` to `octools_src` list (after `RunCommand/Monitor.vala`)
- `docs/meson.build` - Add `RunCommand/Overlay.vala` to valadoc source list (after `RunCommand/Monitor.vala`)

**Note**: Request integration will be handled in Phase 4 (2.6.1.4-integrate-overlay-support.md). This phase only implements the Overlay class.

**Note**: Don't forget to add `RunCommand/Overlay.vala` to both:
- The regular meson.build (`liboctools/meson.build`) in the `octools_src` list
- The valadoc meson.build (`docs/meson.build`) in the `valadoc_docs` input files list

Both should be added after `RunCommand/Monitor.vala` and before `RunCommand/Request.vala` to maintain proper file ordering (Request uses Overlay).

### Overlay Class Design

#### Class: `OLLMtools.RunCommand.Overlay`

**Namespace**: `OLLMtools.RunCommand`

**Inheritance**: `GLib.Object`

**Purpose**: Manages overlay filesystem creation, mounting, and cleanup for isolating writes during command execution.

**FIXME**: This overlay does not handle the following edge cases:
- File aliases (symlinks): Symlinks are copied as regular files (not as symlinks)

#### Properties

```vala
/**
 * Project folder object (is_project = true) - the main project directory.
 */
public OLLMfiles.Folder project { get; set; }

/**
 * Map of path -> Folder objects for project roots that need write access.
 * 
 * Contains all directories that need write access, as determined by project.build_roots().
 * Same structure as Bubble.roots: HashMap mapping paths to Folder objects.
 * Key: Project root path (e.g., "/home/alan/project")
 * Value: Folder object (typically the project Folder reference)
 */
private Gee.HashMap<string, OLLMfiles.Folder> roots { get; private set; default = new Gee.HashMap<string, OLLMfiles.Folder>(); }

/**
 * Base directory for overlay filesystem.
 * Path: ~/.cache/ollmchat/{overlay-datetime}/
 * Example: /home/alan/.cache/ollmchat/overlay-20250115-143022/
 * 
 * Callers can build derived paths using GLib.Path.build_filename():
 * - Upper directory: GLib.Path.build_filename(overlay_dir, "upper")
 * - Work directory: GLib.Path.build_filename(overlay_dir, "work")
 * - Mount point: GLib.Path.build_filename(overlay_dir, "merged")
 */
public string overlay_dir { get; private set; default = ""; }

/**
 * HashMap mapping overlay subdirectory names to real project root paths.
 * Key: Subdirectory name (e.g., "overlay1", "overlay2")
 * Value: Real project root path (e.g., "/home/alan/project")
 * Example:
 *   "overlay1" -> "/home/alan/project"
 *   "overlay2" -> "/home/alan/other-project"
 * 
 * Derived from roots HashMap during create().
 */
public Gee.HashMap<string, string> overlay_map { get; private set; default = new Gee.HashMap<string, string>(); }

/**
 * Monitor instance for tracking filesystem changes in overlay.
 * Created in constructor, started in mount(), stopped before copying files.
 */
private Monitor monitor { get; private set; }

/**
 * Constructor.
 * 
 * Initializes an Overlay instance with the specified project folder.
 * The overlay structure will be created in ~/.cache/ollmchat/{overlay-datetime}/
 * 
 * @param project Project folder object (is_project = true) - the main project directory
 * @throws Error if project is invalid, build_roots() fails, or paths are not absolute
 */
public Overlay(OLLMfiles.Folder project) throws Error
{
    this.project = project;
    
    // Build roots HashMap from project.build_roots()
    foreach (var folder in this.project.build_roots()) {
        this.roots.set(folder.path, this.project);
    }
    
    // Generate unique timestamp-based directory name: overlay-{YYYYMMDD}-{HHMMSS}
    var now = new GLib.DateTime.now_local();
    var timestamp = "%04d%02d%02d-%02d%02d%02d".printf(
        now.get_year(), now.get_month(), now.get_day_of_month(),
        now.get_hour(), now.get_minute(), now.get_second()
    );
    
    // Set overlay_dir to ~/.cache/ollmchat/{overlay-datetime}/
    var cache_dir = GLib.Path.build_filename(
        GLib.Environment.get_home_dir(), ".cache", "ollmchat"
    );
    this.overlay_dir = GLib.Path.build_filename(cache_dir, "overlay-" + timestamp);
    
    // Create Monitor instance (will be started in mount())
    this.monitor = new Monitor(
        this.project,
        GLib.Path.build_filename(this.overlay_dir, "upper"),
        this.overlay_map
    );
}
```

#### Methods

##### `create() throws Error`

```vala
/**
 * Create overlay directory structure with subdirectories for each project root.
 * 
 * Creates the following directory structure:
 * - {overlay_dir}/upper/overlay1/ (for first project root)
 * - {overlay_dir}/upper/overlay2/ (for second project root)
 * - {overlay_dir}/upper/overlay3/ (for third project root)
 * - etc.
 * - {overlay_dir}/work/ (work directory for overlayfs)
 * - {overlay_dir}/merged/ (mount point for overlayfs)
 * 
 * Also builds overlay_map HashMap mapping subdirectory names to real project paths.
 * 
 * @throws GLib.IOError if directory creation fails
 */
public void create() throws Error
```

**Implementation Details**:
- Create `this.overlay_dir` directory (with parents if needed)
- Create `{this.overlay_dir}/upper/` directory
- Create `{this.overlay_dir}/work/` directory
- Create `{this.overlay_dir}/merged/` directory
- Iterate over `this.roots.entries`:
  ```vala
  var entries_array = this.roots.entries.to_array();
  for (int i = 0; i < entries_array.length; i++) {
      var entry = entries_array[i];
      var subdirectory_name = "overlay" + (i + 1).to_string();
      // Create subdirectory
      GLib.File.new_for_path(
          GLib.Path.build_filename(this.overlay_dir, "upper", subdirectory_name)
      ).make_directory_with_parents(null);
      // Add to overlay_map
      this.overlay_map.set(subdirectory_name, entry.key);
  }
  ```
- Handle errors: Wrap GLib.Error in GLib.IOError.FAILED with descriptive message

##### `mount() throws Error`

```vala
/**
 * Mount overlay filesystem and start monitoring.
 * 
 * Mounts the overlay filesystem and starts the Monitor to track changes.
 * 
 * The mount command format:
 * mount -t overlay overlay -o lowerdir={project.path},upperdir={overlay_dir}/upper,workdir={overlay_dir}/work {overlay_dir}/merged
 * 
 * @throws GLib.IOError if mount fails or monitor start fails
 */
public void mount() throws Error
```

**Implementation Details**:
- Build paths inline:
  - `lower_dir = this.project.path`
  - `upper_dir = GLib.Path.build_filename(this.overlay_dir, "upper")`
  - `work_dir = GLib.Path.build_filename(this.overlay_dir, "work")`
  - `mount_point = GLib.Path.build_filename(this.overlay_dir, "merged")`
- Build mount command string:
  - `command = "mount -t overlay overlay -o lowerdir=" + lower_dir + ",upperdir=" + upper_dir + ",workdir=" + work_dir + " " + mount_point`
- Execute mount command using `Process.spawn_command_line_sync()`:
  - Use `Process.spawn_command_line_sync(command, out stdout, out stderr, out exit_status)`
  - Check exit status: If non-zero, throw GLib.IOError.FAILED with stderr message
- Start Monitor: `this.monitor.start()` (monitor was created in constructor)
- Handle errors: Wrap Process errors in GLib.IOError.FAILED

##### `unmount() throws Error`

```vala
/**
 * Unmount overlay filesystem using umount.
 * 
 * Unmounts the overlay filesystem.
 * 
 * The unmount command format:
 * umount {overlay_dir}/merged
 * 
 * @throws GLib.IOError if unmount fails (e.g., busy, not mounted)
 */
public void unmount() throws Error
```

**Implementation Details**:
- Build unmount command string:
  - `command = "umount " + GLib.Path.build_filename(this.overlay_dir, "merged")`
- Execute umount command using `Process.spawn_command_line_sync()`:
  - Use `Process.spawn_command_line_sync(command, out stdout, out stderr, out exit_status)`
  - Check exit status: If non-zero, throw GLib.IOError.FAILED with stderr message
- Handle errors: Wrap Process errors in GLib.IOError.FAILED

##### `copy_files() throws Error`

```vala
/**
 * Copy files from overlay to live system based on Monitor change lists.
 * 
 * Stops monitoring, then processes Monitor change lists to copy files from overlay
 * upper directory to project directories. Also copies file permissions (rwx only).
 * 
 * This should be called after command execution is complete.
 * 
 * Errors are logged via GLib.warning() but do not throw - operation continues for remaining files.
 */
public async void copy_files()
```

**Implementation Details**:
- Stop Monitor: `yield this.monitor.stop()` (async, ensures all inotify events are processed)
- Process Monitor change lists (see "File Copying Implementation" section below for details):
  - **For modified files (this.monitor.updated)**: Copy from overlay to real path, copy permissions
  - **For new files (this.monitor.added)**: Copy from overlay to real path, copy permissions
  - **For deleted files (this.monitor.removed)**: Delete from real path
- All errors logged via `GLib.warning()` - operation continues for remaining files

##### `cleanup() throws Error`

```vala
/**
 * Clean up overlay directory.
 * 
 * Unmounts the overlay filesystem and removes the overlay directory structure.
 * This should be called after copy_files() is complete.
 * 
 * @throws GLib.IOError if unmount or directory removal fails
 */
public void cleanup() throws Error
```

**Implementation Details**:
- Call `this.unmount()` (may throw Error, but continue cleanup even if it fails)
- Remove overlay directory structure:
  - Use `GLib.File.new_for_path(this.overlay_dir)` to get File object
  - Use `file.delete()` to remove directory recursively
  - Handle errors: Wrap GLib.Error in GLib.IOError.FAILED

### Overlay Structure

- Create overlay temporary directory in `.cache/ollmchat/{overlay-datetime}/`
- Overlay structure (required by overlayfs):
  - Lower directory: Original project directory (read-only)
  - Upper directory: `.cache/ollmchat/{overlay-datetime}/upper/` (writable layer)
    - **Multiple folder structure**: Upper directory contains subdirectories for each project root:
      - `upper/overlay1/` - Writes for first project root
      - `upper/overlay2/` - Writes for second project root
      - `upper/overlay3/` - Writes for third project root
      - etc.
    - Each subdirectory name (overlay1, overlay2, etc.) maps to a project root path via `overlay_map`
  - Work directory: `.cache/ollmchat/{overlay-datetime}/work/` (required by overlayfs for internal atomic operations)
- Mount overlay filesystem (using `mount -t overlay`) before bwrap execution
- Bind-mount the overlay mount point into bwrap sandbox at project directory location
- **Overlay map**: HashMap mapping subdirectory names to real project paths:
  - `"overlay1" -> "/home/alan/project"`
  - `"overlay2" -> "/home/alan/other-project"`
  - Created from project root folders (from `project.build_roots()`)
  - Each project root gets a unique subdirectory name (overlay1, overlay2, etc.)
  - Used by Monitor to convert overlay paths to real paths
  - Example: File written to `upper/overlay1/src/main.c` maps to `/home/alan/project/src/main.c`

### Monitor Integration

- Overlay owns Monitor instance (created in constructor)
- Monitor tracks filesystem changes in overlay upper directory
- Monitor change lists (added/updated/removed) are HashMaps of overlay path -> FileBase:
  - Key: Overlay path (string, e.g., "/home/alan/.cache/ollmchat/overlay-12345/upper/overlay1/src/main.c")
  - Value: FileBase object (File or Folder)
- Monitor sees overlay paths directly from inotify events, so it stores them directly as keys
- Overlay converts overlay paths to real paths using overlay_map when copying files

### File Copying Implementation

The `copy_files()` method processes Monitor change lists and copies files from overlay to live system.

**Implementation Details**:

1. **For modified files (this.monitor.updated)**:
   - Iterate over `this.monitor.updated.entries` (no sorting needed - files already exist, parent directories already exist)
   - For each entry:
     - Get overlay path: `entry.key` (overlay path from Monitor - HashMap key)
     - Get FileBase object: `entry.value` (FileBase object from Monitor - HashMap value)
     - Convert overlay path to real path: Use `this.overlay_map` to find matching project root and build real path
     - Copy file from overlay to real path:
       - Copy file: `GLib.File.new_for_path(overlay_path).copy(GLib.File.new_for_path(real_path), GLib.FileCopyFlags.OVERWRITE, null, null)`
       - If copy fails: Output `GLib.warning()` with error message and continue to next file
     - Copy file permissions (rwx only - user cannot change ownership):
       - Get overlay file permissions: Query `GLib.FileAttribute.UNIX_MODE` from overlay file
       - Get real file permissions: Query `GLib.FileAttribute.UNIX_MODE` from real file
       - If permissions differ: Set real file permissions to match overlay file permissions
       - If permission copy fails: Output `GLib.warning()` with error message and continue

2. **For new files (this.monitor.added)**:
   - Sort entries by path (to ensure parent directories are created naturally)
   - Iterate over sorted `this.monitor.added.entries`
   - For each entry:
     - Get overlay path: `entry.key` (overlay path from Monitor - HashMap key)
     - Get FileBase object: `entry.value` (FileBase object from Monitor - HashMap value)
     - Convert overlay path to real path: Use `this.overlay_map` to find matching project root and build real path
     - Copy file from overlay to real path:
       - Copy file: `GLib.File.new_for_path(overlay_path).copy(GLib.File.new_for_path(real_path), GLib.FileCopyFlags.OVERWRITE, null, null)`
       - Parent directories will be created automatically by GLib.File.copy() as needed
       - If copy fails: Output `GLib.warning()` with error message and continue to next file
     - Copy file permissions (rwx only - user cannot change ownership):
       - Get overlay file permissions: Query `GLib.FileAttribute.UNIX_MODE` from overlay file
       - Set real file permissions to match overlay file permissions
       - If permission copy fails: Output `GLib.warning()` with error message and continue

3. **For deleted files (this.monitor.removed)**:
   - Iterate over `this.monitor.removed.entries`
   - For each entry:
     - Get overlay path: `entry.key` (overlay path from Monitor - HashMap key)
     - Get FileBase object: `entry.value` (FileBase object from Monitor - HashMap value)
     - Convert overlay path to real path: Use `this.overlay_map` to find matching project root and build real path
     - Delete file from real path:
       - Use `GLib.File.new_for_path(real_path).delete()` to remove file
       - If delete fails: Output `GLib.warning()` with error message and continue
       - Handle directory removal if needed (for deleted directories)

**Note**: Monitor change lists (added/updated/removed) are HashMaps of overlay path -> FileBase. The key is the overlay path (string), and the value is a FileBase object (File or Folder). This eliminates the need to reconstruct overlay paths - Monitor already sees overlay paths from inotify events, so it stores them directly as keys. Overlay converts overlay paths to real paths using `overlay_map` when copying files.

### File Copying Implementation

#### Simple File Copying Strategy

- Use simple file copying (read file content, write to destination)
- Handle directory creation if needed (for new files in new directories)
- No backup support yet - that comes in Phase 5

#### File Copying Algorithm

1. **Sort file lists**:
   - Sort entries by path (ascending) before processing
   - Ensures parent directories are created naturally as files are processed in order
   - Example: Processing `/home/user/project/src/main.c` before `/home/user/project/src/subdir/file.c` ensures `src/` exists before `src/subdir/` is needed

2. **Copy file**:
   - Use `GLib.File.copy()` to copy file from overlay to real path
   - Use `GLib.FileCopyFlags.OVERWRITE` to overwrite existing files
   - `GLib.File.copy()` automatically creates parent directories as needed
   - Handles both text and binary files efficiently
   - Preserves file metadata (permissions handled separately)

3. **Error handling**:
   - Wrap all GLib.Error in GLib.IOError.FAILED with descriptive messages
   - Include file paths in error messages for debugging

#### Limitations in Phase 3

- **No backup support**: Files are copied directly without creating backups
- **No atomic operations**: File copying is not atomic (partial writes possible on failure)
- **No file metadata preservation**: Only file content and permissions are copied (timestamps, ownership, etc. are not preserved)
- **No transaction rollback**: If copying fails partway through, some files may be copied while others are not

## Implementation Tasks

- [ ] Create `Overlay` class for overlay filesystem management
- [ ] Implement overlay creation in `.cache/ollmchat/{overlay-datetime}/`
- [ ] Implement overlay structure (lower, upper, work directories)
- [ ] Create subdirectories in upper directory for each project root (overlay1, overlay2, etc.)
- [ ] Build overlay_map HashMap mapping subdirectory names to real project paths
- [ ] Mount overlay filesystem (using `mount -t overlay`) before bwrap execution
- [ ] Create Monitor instance in Overlay constructor
- [ ] Start Monitor in mount() method
- [ ] Implement copy_files() method to stop monitor and copy files from overlay to live system
  - [ ] For modified files: Copy from overlay upper directory to project directory (string copying)
  - [ ] For new files: Copy from overlay upper directory to project directory
  - [ ] For deleted files: Remove from project directory
- [ ] After copying files: Check and copy permissions from overlay to real files
  - [ ] Compare permissions between overlay files and real project files for all files in Monitor change lists
  - [ ] If permissions differ, copy permissions from overlay to real files (e.g., chmod +x)
  - [ ] Do NOT add permission changes to Monitor change lists
  - [ ] Do NOT require approval for permission changes
- [ ] Test overlay filesystem creation and cleanup
- [ ] Test file copying from overlay to live system

## Testing

- Test overlay filesystem creation and cleanup
- Test file copying from overlay to live system
- Test with modified files
- Test with new files
- Test with deleted files
- Test with nested directories

## Error Handling

### Overlay Creation Errors

- **Directory creation fails**: Wrap in GLib.IOError.FAILED with message including path
- **Permission denied**: Wrap in GLib.IOError.FAILED with descriptive message
- **Disk full**: Wrap in GLib.IOError.FAILED with descriptive message

### Overlay Mount Errors

- **Mount command fails**: Read stderr from subprocess and include in error message
- **Permission denied (requires root)**: Overlayfs mount may require root privileges - handle gracefully
- **Invalid mount options**: Validate mount options before executing mount command

### Overlay Unmount Errors

- **Unmount command fails**: Read stderr from subprocess and include in error message
- **Device busy**: Overlay may be in use - handle gracefully (may need to retry or force unmount)
- **Not mounted**: umount will fail if not mounted - error will be in stderr

### File Copying Errors

- **Source file not found**: Skip file (log warning) - file may have been deleted after monitoring stopped
- **Destination directory creation fails**: Wrap in GLib.IOError.FAILED with message including path
- **File write fails**: Wrap in GLib.IOError.FAILED with message including source and destination paths
- **Permission denied**: Wrap in GLib.IOError.FAILED with descriptive message

### Permission Copying Errors

- **Overlay file not found**: Skip file (log warning) - file may have been deleted
- **Real file not found**: Skip file (log warning) - file may have been deleted
- **Permission query fails**: Skip file (log warning) - file may not support permission queries
- **Permission set fails**: Wrap in GLib.IOError.FAILED with descriptive message

### Cleanup Errors

- **Unmount fails during cleanup**: Log warning but continue with directory removal
- **Directory removal fails**: Wrap in GLib.IOError.FAILED with message including path
- **Partial cleanup**: If cleanup fails partway through, overlay directory may remain - log warning

## Edge Cases

### Multiple Project Roots

- **Overlay subdirectories**: Each project root gets its own subdirectory in upper directory
- **Path mapping**: Overlay map correctly maps each subdirectory to its project root
- **File copying**: Files from different project roots are copied to correct destinations

### Nested Directories

- **Directory creation**: Parent directories are created recursively when copying files
- **Deep nesting**: Handles deeply nested directory structures (e.g., `src/sub1/sub2/sub3/file.c`)

### Empty Files

- **Zero-length files**: Handled correctly by `GLib.FileUtils.get_contents()` and `set_contents()`
- **Empty directories**: Directories are created even if empty (for new directory structures)

### Symlinks

- **Symlink handling**: Symlinks in overlay are copied as regular files (not as symlinks)
- **Symlink targets**: Symlink targets are resolved during path conversion
- See FIXME note at top of Overlay class design section

### Large Files

- **Memory usage**: Large files are read entirely into memory (may cause issues with very large files)
- **Performance**: File copying is synchronous and may be slow for large files

### Special Files

**FIXME**: Special files are not handled (low priority):
- **Device files**: Not handled (only regular files are copied)
- **Named pipes**: Not handled (only regular files are copied)
- **Sockets**: Not handled (only regular files are copied)

## Implementation Summary

### Class Structure

- **Overlay class**: Manages overlay filesystem lifecycle (create, mount, unmount, cleanup)
- **Properties**: Store overlay paths, mount state, and overlay map
- **Methods**: Create directory structure, mount/unmount filesystem, get paths, cleanup

### Integration Points

- **Overlay class**: Owns Monitor instance, manages complete lifecycle (create, mount, copy_files, cleanup)
- **Monitor class**: Monitors overlay upper directory for filesystem changes (from Phase 2, already supports overlay_map)
- **Request class**: Not modified in Phase 3 (integration happens in Phase 4)
- **Bubble class**: Not modified in Phase 3 (overlay integration happens in Phase 4)

### File Operations

- **File copying**: Simple string-based copying (read content, write content)
- **Directory creation**: Recursive directory creation for new files
- **Permission copying**: Compare and copy file permissions from overlay to live system
- **File deletion**: Remove deleted files from live system

### Workflow

**Design target**: This workflow is designed for Phase 4/5 where overlay is fully integrated with Bubble.

1. Create Overlay instance (constructor creates Monitor)
2. Create overlay directory structure (create())
3. Mount overlay filesystem and start Monitor (mount())
4. Execute command in Bubble (in Phase 4, Bubble will use overlay mount point; Phase 3 designs for this)
5. Copy files from overlay to live system (copy_files() - stops Monitor, copies files and permissions)
6. Cleanup overlay (cleanup() - unmounts and removes directory)

**Note**: In Phase 3, the overlay is created and the infrastructure is ready, but actual integration with Bubble happens in Phase 4. This phase targets the eventual design where all writes go through the overlay.

## Notes

- **Design target**: This phase designs the Overlay class for the eventual integrated system (Phase 4/5)
- **Not for Phase 2**: This code will not be used with Phase 2 code - it targets the final architecture
- **Integration**: Overlay will be integrated with Bubble in Phase 4 (overlay mount point will be bind-mounted into Bubble)
- **Current state**: In Phase 3, overlay infrastructure is created and ready, but actual Bubble integration happens in Phase 4
- **File copying**: Simple string/file copying - no backup support yet (backup support added in Phase 5)
- **Monitor**: Monitor (from Phase 2) already supports overlay_map and will track changes in overlay upper directory
- **File operations**: Files are copied from overlay to live system after command execution
- **Permissions**: Permissions are copied silently (no approval required)

