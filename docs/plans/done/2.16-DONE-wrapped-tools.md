# 2.16. Wrapped Tools

## Status

✅ **Phase 1: COMPLETE** - Foundation and ToolBuilder implementation
✅ **Phase 2: COMPLETE** - Create .tool files
✅ **Phase 3: COMPLETE** - Change existing codebase

## Phases

### Phase 1: Foundation ✅ COMPLETE
- ✅ Create `ToolBuilder` class (`liboctools/ToolBuilder.vala`) - **FULLY IMPLEMENTED**
  - Scans `resources/wrapped-tools/` directory for `*.tool` files
  - Uses `ParamParser` to parse tool definitions
  - Registers simple aliases (only `@name` and `@wrapped`)
  - Creates wrapped tool instances using `Object.new()` and sets parameters from parser
  - Handles error cases (missing tools, non-wrappable tools, duplicate names)
- ✅ Add `WrapInterface` (`libollmchat/Tool/WrapInterface.vala`)
  - Interface with `deserialize_wrapped()` method for wrapped tool execution
- ✅ Add `is_wrapped` property to `RequestBase` (`libollmchat/Tool/RequestBase.vala`)
  - Boolean flag to indicate wrapped tool requests
- ✅ Create `ParamParser` class (`libollmchat/Tool/ParamParser.vala`)
  - Extracted parsing logic from `Tool.vala` for reuse
  - Parses description text and all annotations (@title, @name, @wrapped, @command, @param, @type, @property)
  - Creates parsed `ParamObject` with parameters and type definitions
  - Used by both `ToolBuilder` and will be used by `Tool.vala` in Phase 3
- ✅ Update `liboctools/meson.build` - Add `ToolBuilder.vala` to `octools_src` files list
- ✅ Update `libollmchat/meson.build` - Add `Tool/WrapInterface.vala` and `Tool/ParamParser.vala` to `ollmchat_ollama_src` files list
- ✅ Update `docs/meson.build` - Add all new files to valadoc input list

**Implementation Notes:**
- `ToolBuilder` uses `ParamParser` to parse `.tool` files instead of custom parsing logic
- Wrapped tools are created by instantiating the wrapped tool class type using `Object.new()`
- Function object is created directly (skipping `init()`) and parameters are set from parser
- Function parameters are set using Vala constructor syntax: `new Function(tool) { parameters = parser.parameters }`

### Phase 2: Create .tool Files ✅ COMPLETE
- ✅ `resources/wrapped-tools/glob.tool` - glob pattern matching using find
- ✅ `resources/wrapped-tools/grep.tool` - grep command definition
- ✅ `resources/wrapped-tools/ls.tool` - ls command definition
- ✅ `resources/wrapped-tools/Read.tool` - alias for read_file
- ✅ `resources/wrapped-tools/WebFetch.tool` - alias for web_fetch
- ✅ `resources/wrapped-tools/WebSearch.tool` - alias for google_search

**Tools Referenced in Agents:**
From `grep resources/agents/` for `tools:`:
- ✅ **Read** → `read_file` (alias created: `Read.tool`)
- ✅ **Grep** → `grep` (wrapped, created ✅)
- ✅ **Glob** → `glob` (wrapped, created ✅)
- ✅ **LS** → `ls` (wrapped, created ✅)
- ✅ **WebSearch** → `google_search` (alias created: `WebSearch.tool`)
- ✅ **WebFetch** → `web_fetch` (alias created: `WebFetch.tool`)
- ⏳ **TodoWrite** → `task-tool` (see plan 2.17-create-task-tool.md)

### Phase 3: Change Existing Codebase
- Add `is_wrapped` and `command_template` properties to `BaseTool` (`libollmchat/Tool/Tool.vala`)
- Add settable `name` and `description` properties to `Function` class (or store wrapped values and use them)
- Set wrapped tool name/description/title in `ToolBuilder` when creating wrapped tool instances
- Implement `WrapInterface` in `RunCommand.Tool` and `WebFetch.Tool`
- Implement wrapped tool execution flow in `RequestBase`
- Update `ToolBuilder` to set `is_wrapped` and `command_template` properties on wrapped tool instances

## Purpose

Enable agents to use specialized tools for common commands (e.g., `ls`, `grep`, `find`, etc.) that automatically map to the RunCommand tool for execution.

## Requirements

1. **File-based Definition**: Wrapped tools defined in `.tool` files in `resources/wrapped-tools/`
2. **Automatic Discovery**: ToolBuilder scans the directory at startup and registers all defined tools
3. **Schema Generation**: Generate tool schemas (JSON) internally from `.tool` file definitions
4. **Tool Execution**: Execute wrapped tools by calling the wrapped tool (e.g., `run_command`) with constructed parameters

## Definition File Format

Wrapped tools are defined in `.tool` files using annotation-style syntax matching the existing tool description parser.

### Simple Alias Format

If only `@name` and `@wrapped` are specified, the tool is registered as an alias to the existing tool with no modifications:

```
@name webFetch
@wrapped web_fetch
```

This registers the existing `web_fetch` tool with the name `webFetch` - no modifications required, just an alias.

### Full Wrapped Tool Format

For tools that need custom behavior, include description, title, command template, and parameters:

### glob.tool
```
Find files matching glob patterns using find. The working directory is the project directory by default. To search in other directories, provide the directory path as the first argument. This tool uses find with -type f to find only files. Common usage: [".", "-type", "f", "-name", "*.vala"] to find all .vala files, or ["src/", "-type", "f", "-name", "*.json"] to find JSON files in src directory.

@title Glob Pattern Matching
@name glob
@wrapped run_command
@command find {arguments} -type f
@param arguments {array<string>} [required] Array of strings that will be passed to the command
```

**Format Rules:**
- Description text starts from the first line (can span multiple lines) - optional if only creating alias
- Blank line separates description from annotations
- `@title <tool_title>` - Human-readable tool title (optional for alias)
- `@name <tool_name>` - Tool identifier name (required)
- `@wrapped <tool_name>` - Name of the tool to wrap (e.g., "run_command") (required)
- `@command <command_template>` - Command template with {ARGS} placeholder for arguments array (optional, only for wrapped tools)
- `@param` declarations follow the same format as existing tool parameter descriptions (optional, only for wrapped tools)

## Architecture

### ToolBuilder

**Location**: `liboctools/ToolBuilder.vala`

**Single class** - All wrapped tool functionality is integrated into base tool classes.

**Class Structure:**
```vala
namespace OLLMtools {
    public class ToolBuilder : Object {
        private Gee.HashMap<string, OLLMchat.Tool.BaseTool> tools;
        private string resource_dir;
        
        public ToolBuilder(Gee.HashMap<string, OLLMchat.Tool.BaseTool> tools, string resource_dir) {
            this.tools = tools;
            this.resource_dir = resource_dir;
        }
        
        public void scan_and_build() {
            // Scan resources/wrapped-tools/ for *.tool files
            // For each file:
            //   - Parse annotations: @title, @name, @wrapped, @command, @param
            //   - Extract description (text before annotations)
            //   - Get wrapped tool from tools hashmap using @wrapped name
            //   - Verify tool implements WrapInterface
            //   - If only @name and @wrapped: register alias
            //   - Otherwise: create wrapped tool instance and register
        }
        
        private void parse_tool_file(string file_path) {
            // Read file content
            // Parse description (until blank line before annotations)
            // Parse annotations (@title, @name, @wrapped, @command, @param)
            // Return parsed definition structure
        }
        
        private void register_wrapped_tool(ParsedDefinition def) {
            // Get wrapped tool from tools hashmap
            // Verify implements WrapInterface
            // Create new instance or alias
            // Register with tools hashmap
        }
    }
}
```

**Responsibilities:**
1. **Scan Resource Directory**: Scans `resources/wrapped-tools/` for all `.tool` files
2. **Parse Definitions**: Parses `.tool` files to extract description and annotations
3. **Create Tool Instances**: Creates new tool instances using the wrapped tool name via `GObject.new()` tricks
4. **Register Tools**: Registers discovered tools with the tool hashmap

**Process:**
1. `scan_and_build()` scans `resources/wrapped-tools/` directory for `*.tool` files
2. For each file:
   - Parse annotations: `@title`, `@name`, `@wrapped`, `@command`, `@param`
   - Get wrapped tool from tools hashmap using `@wrapped` annotation name
   - Verify tool implements `WrapInterface` (required for wrapping)
   - If only `@name` and `@wrapped` are present:
     - Get existing tool instance from tools hashmap using `@wrapped` name
     - Register same tool instance with new name (simple alias, no modifications)
   - Otherwise (full wrapped tool):
     - Parse description (from first line until blank line before annotations)
     - Get wrapped tool class type from existing tool instance
     - Create new tool instance using `GObject.new()` - **wrapped tools are instances of the class they wrap**
     - Set tool properties from parsed definition (name, title, description, is_wrapped flag, command template)
     - Register tool with tools hashmap using `@name` as the tool identifier

### WrapInterface

**Location**: `libollmchat/Tool/WrapInterface.vala`

**Interface Definition:**
```vala
public interface WrapInterface : Object {
    public abstract RequestBase? deserialize_wrapped(Json.Node parameters_node, string command_template);
}
```

**Purpose:**
- Only tools that implement `WrapInterface` can be wrapped
- Each tool implements `deserialize_wrapped()` differently based on its needs
- `RunCommand.Tool` might construct a command string from template
- `WebFetch.Tool` might parse arguments differently for URL construction
- Allows each tool to handle wrapped parameters in its own way

### BaseTool Modifications

**Location**: `libollmchat/Tool/Tool.vala` (BaseTool)

**New Properties:**
- `is_wrapped` (bool) - Flag indicating if tool is a wrapped tool
- `command_template` (string) - Command template with {arguments} placeholder

**Behavior:**
- Wrapped tools have `is_wrapped=true` and `command_template` set from `.tool` file
- Tool must implement `WrapInterface` to be wrappable
- No changes needed to abstract properties - they remain as-is

### Function Modifications

**Location**: `libollmchat/Tool/Function.vala`

**Property Changes:**
- Change `name` from read-only getter to regular get/set property with default to `tool.name`
- Change `description` from read-only getter to regular get/set property with default to `tool.description`
- Change `parameter_description` from read-only getter to regular get/set property with default to `tool.parameter_description`
- If not set, fall back to tool properties (for backward compatibility)

**Behavior:**
- `ToolBuilder` creates Function with object initializer syntax:
  ```vala
  var function = new OLLMchat.Tool.Function(new_tool) {
      name = parser.name,
      description = parser.description,
      parameters = parser.parameters
  };
  ```
- For normal (non-wrapped) tools, name/description are not set, so they fall back to tool properties
- Simple and clean - no need to modify BaseTool's abstract properties

### Request Execution Flow

**Location**: `libollmchat/Tool/RequestBase.vala`

**Wrapped Tool Detection:**
- Check if tool has `is_wrapped` property set to true
- If true, follow wrapped tool execution flow

**Wrapped Tool Execution Flow:**
1. `RequestBase.deserialize()` or `RequestBase.execute()` checks `tool.is_wrapped`
2. If wrapped:
   - **The tool itself is an instance of the wrapped class** (e.g., `RunCommand.Tool`) and implements `WrapInterface`
   - Call `tool.deserialize_wrapped(parameters_node, command_template)` on the tool instance
   - This method extracts `arguments` from JSON and converts them according to the tool's needs:
     - `RunCommand.Tool`: Constructs command string from template, replacing `{arguments}` with joined arguments
     - `WebFetch.Tool`: Can simply call the regular `deserialize()` method (no special handling needed)
   - Returns a `RequestBase` instance with properly constructed parameters
3. Execute the returned request
4. Return result

**Example (RunCommand):**
- Tool call: `{"arguments": [".", "-type", "f", "-name", "*.vala"]}`
- Command template: `find {arguments} -type f`
- `RunCommand.Tool.deserialize_wrapped()`:
  - Extracts `arguments` array: `[".", "-type", "f", "-name", "*.vala"]`
  - Replaces `{arguments}` in template with joined arguments: `find . -type f -name '*.vala'`
  - Creates `RunCommand.Request` with: `{"command": "find . -type f -name '*.vala'", "working_dir": "", "network": false}`

**Example (WebFetch):**
- Tool call: `{"arguments": ["https://example.com", "json"]}`
- `WebFetch.Tool.deserialize_wrapped()`:
  - Simply calls `this.deserialize(parameters_node)` - no special handling needed
  - The regular deserialize method handles the parameters as normal

## Implementation Files

### Phase 1: Foundation ✅ COMPLETE
- ✅ `liboctools/ToolBuilder.vala` - **FULLY IMPLEMENTED** - Complete scanning, parsing, and registration logic
  - Uses `ParamParser` for parsing `.tool` files
  - Handles both simple aliases and full wrapped tools
  - Creates wrapped tool instances and sets parameters from parser
- ✅ `libollmchat/Tool/WrapInterface.vala` - Interface with `deserialize_wrapped()` method
- ✅ `libollmchat/Tool/ParamParser.vala` - **NEW** - Reusable parser for tool definitions
  - Extracted from Tool.vala parsing logic
  - Parses description, annotations, and parameters
  - Used by ToolBuilder, will be used by Tool.vala in Phase 3
- ✅ `libollmchat/Tool/RequestBase.vala` - Add `is_wrapped` property
- ✅ `liboctools/meson.build` - Add `ToolBuilder.vala` to `octools_src` files list
- ✅ `libollmchat/meson.build` - Add `Tool/WrapInterface.vala` and `Tool/ParamParser.vala` to `ollmchat_ollama_src` files list
- ✅ `docs/meson.build` - Add all new files to valadoc input list

### Phase 2: Create .tool Files ✅ COMPLETE
- ✅ `resources/wrapped-tools/glob.tool` - glob pattern matching using find
- ✅ `resources/wrapped-tools/grep.tool` - grep command definition
- ✅ `resources/wrapped-tools/ls.tool` - ls command definition
- ✅ `resources/wrapped-tools/Read.tool` - alias for read_file
- ✅ `resources/wrapped-tools/WebFetch.tool` - alias for web_fetch
- ✅ `resources/wrapped-tools/WebSearch.tool` - alias for google_search

**Tools Referenced in Agents:**
From `grep resources/agents/` for `tools:`:
- ✅ **Read** → `read_file` (alias created: `Read.tool`)
- ✅ **Grep** → `grep` (wrapped, created ✅)
- ✅ **Glob** → `glob` (wrapped, created ✅)
- ✅ **LS** → `ls` (wrapped, created ✅)
- ✅ **WebSearch** → `google_search` (alias created: `WebSearch.tool`)
- ✅ **WebFetch** → `web_fetch` (alias created: `WebFetch.tool`)
- ⏳ **TodoWrite** → `task-tool` (see plan 2.17-create-task-tool.md)

### Phase 3: Change Existing Codebase
- `libollmchat/Tool/Tool.vala` (BaseTool) - Add `is_wrapped`, `command_template` properties
  - Refactor to use `ParamParser` instead of custom parsing logic (optional, for consistency)
- `libollmchat/Tool/Function.vala` - Make `name` and `description` get/set properties with defaults
  - Change from read-only getters to settable properties
  - Default to `tool.name` and `tool.description` if not explicitly set
  - Allows ToolBuilder to set custom name/description for wrapped tools
- `libollmchat/Tool/RequestBase.vala` - Add `is_wrapped` check and wrapped tool execution flow in `deserialize()` or `execute()`
- `liboctools/RunCommand/Tool.vala` - Implement `WrapInterface`, `deserialize_wrapped()` constructs command string
- `liboctools/WebFetch/Tool.vala` - Implement `WrapInterface`, `deserialize_wrapped()` can just call `deserialize()`
- `liboctools/ToolBuilder.vala` - Update to set wrapped properties and Function name/description
  - Set `new_tool.is_wrapped = true`
  - Set `new_tool.command_template = parser.command_template`
  - When creating Function, use object initializer to set name, description, and parameter_description:
    ```vala
    var function = new OLLMchat.Tool.Function(new_tool) {
        name = parser.name,
        description = parser.description,
        parameter_description = parser.parameter_description,
        parameters = parser.parameters
    };
    ```

## Error Handling

### Definition File Errors
- Missing required fields (`@name`, `@wrapped`): Log error, skip definition file
- If `@command` is present, `@title` and description are also required (full wrapped tool format)
- Invalid file format: Log error with file path, skip definition file
- Duplicate tool names: Log warning, use first definition found

### Tool Call Errors
- Missing arguments parameter: Return error message indicating arguments array is required
- Invalid arguments type: Return error if arguments is not an array
- Invalid argument values: Return error if array contains non-string values
- Wrapped tool not found: Return error if `@wrapped` tool name doesn't exist
- Tool not wrappable: Return error if `@wrapped` tool doesn't implement `WrapInterface`
