# 1.3.10. Projects Configuration

## Overview

Implement the Projects tab in the Settings dialog for managing project configurations. This includes the ProjectsPage UI component for listing and removing projects. Projects can be added through the main application interface, but this tab provides a centralized view and removal capability.

## Status

⏳ **TODO** - Not implemented yet.

## Related Plans

- **1.3** - Configuration Overview (see 1.3-DONE-configuration-overview.md)
- **1.3.2** - Configuration Interface (see done/1.3.2-DONE-configuration-interface.md)
- **1.3.9** - Agent Configuration (Agents tab)

## Coding Standards

This plan follows the coding standards defined in [.cursor/rules/CODING_STANDARDS.md](.cursor/rules/CODING_STANDARDS.md). All code examples in this document:

- Use **`this.`** prefix for instance members
- Use **`GLib.`** prefix for GLib namespace (no `using` statements)
- Use **brace placement**: line breaks for namespaces/classes/methods, inline for control structures (`if (x) {` on one line, body on following lines)
- Avoid one-line control structures with body; always put opening brace and body on separate lines
- Use early returns for negative tests
- **Use `var` for local variables**; do not declare types (e.g. use `var pos` not `uint pos`, `var c` not `int c`, `var path` not `string path`)
- **Avoid single-use temporaries**; inline the expression (e.g. `this.project_manager.create_project(chooser.select_folder_finish(res).get_path())` instead of `var file = ...; string path = file.get_path(); create_project(path);`)
- Use `.get()` and `.set()` for Gee collections where applicable
- **No defensive null checks** for factory/model flow: the ListView factory always receives a valid Gtk.ListItem, the model is ProjectList (Folder only), and setup stores the row for bind. Only add null checks where the design explicitly requires them (e.g. user cancel).

## Projects Tab

**Purpose**: View all projects and remove projects from the list (clear the `is_project` flag only; no deletion of file or file-history data).

**Components**:
- **Search**: **Gtk.SearchBar** + **Gtk.SearchEntry** (like Models/Agents), always visible in the action bar. Filters the list by project name (basename) or full path (case-insensitive substring).
- **List View**: Displays all projects from `ProjectManager.projects`
  - Backing model chain: **projects** → **Gtk.FilterListModel** (search filter) → **Gtk.SortListModel** (by basename) → **Gtk.SingleSelection** → ListView. ListView virtualizes rows so longer lists perform well
  - **Gtk.SingleSelection** with **`can_unselect = true`** so the user can have no selection; Remove button visibility is **triggered by selection** (only visible when a row is selected)
  - Each row: **two columns** — left = project name (basename, primary text), right = full path (small, light grey, `caption` + `dim-label`) for easy scanning
- **Footer Bar**: Bottom action bar with action buttons
  - **Search** (left): Search bar + entry, then **Add** button
  - **Add Button**: Opens file chooser dialog to add a new project folder
    - Note: This may be a placeholder if projects are primarily added through the main application
  - **Remove Button** (right side): Removes project from the list
    - Only visible when a project is selected in the list view
    - Shows confirmation dialog before removal
    - **Only clears the `is_project` flag** and removes the folder from the projects list; does NOT delete any filebase or file_history records (see rationale below)

**Data Source**: `ProjectManager.projects` (ProjectList — has a backing store, implements GLib.ListModel; not just a ListStore)

**Responsibility split**: All actual actions (adding a project, removing a project from the list, etc.) are handled by **ProjectManager**. The user interface (ProjectsPage) is only responsible for:
- Displaying the list from `project_manager.projects`
- Handling selection and showing/hiding the Remove button
- Showing dialogs (file chooser for Add, confirmation for Remove)
- **Calling** ProjectManager to perform the action (e.g. `project_manager.create_project(path)`, `project_manager.remove_project(project)`)

The UI does not perform any of the underlying data or database operations.

## Implementation Details

### Files to Create

**ProjectsPage**
- **Location**: `ollmapp/SettingsDialog/ProjectsPage.vala`

**ProjectSearchFilter**
- **Location**: `ollmapp/SettingsDialog/ProjectSearchFilter.vala` (separate file in Settings folder)
- **Purpose**: Gtk.Filter subclass with `search_text` property; match by basename or path; emits `changed()` when search_text is set.
- **UI Framework**: Extends `SettingsPage` (like ModelsPage, ConnectionsPage) with:
  - **Search**: Gtk.SearchBar + Gtk.SearchEntry in `action_widget` (like Models); filter has a `search_text` property and emits `changed()` when set so FilterListModel re-filters
  - Model chain: **projects** → **FilterListModel**(filter) → **SortListModel**(by basename) → **SingleSelection**(can_unselect = true) → ListView. Remove button visibility **triggered by selection** (selection_changed)
  - `Adw.PreferencesGroup` wrapping a **Gtk.ScrolledWindow** containing **Gtk.ListView**; **Gtk.SignalListItemFactory** (setup + bind) for rows; each row has two labels (name + path)
  - Footer bar (`Gtk.Box`) as `action_widget`: Search bar, Add button, Remove button
- **Purpose**: Projects tab content
- **Properties**:
  - `dialog` (MainDialog) - Reference to parent SettingsDialog
  - `project_manager` (OLLMfiles.ProjectManager) - Reference to ProjectManager instance
- **Methods** (UI only — all real work is in ProjectManager):
  - `add_project()` - Opens file chooser; on choice, **calls** `project_manager.create_project(path)` (or equivalent)
  - Remove flow - Shows confirmation dialog; on confirm, **calls** `project_manager.remove_project(project)`
  - `on_selection_changed()` - **Triggered by selection**; updates Remove button visibility (visible only when a row is selected). Selection model has **`can_unselect = true`** so no selection is allowed
  - Search: filter with `search_text` property; on search_entry.changed set filter.search_text (filter emits changed so FilterListModel updates)
  - Factory: setup and bind **inlined** in constructor (lambda on `factory.setup.connect` and `factory.bind.connect`); two columns: name label = basename, path label = full path (small/grey)

### Files to Modify

- **Build**: Add new sources to **both** `ollmapp/meson.build` and `docs/meson.build` — include `SettingsDialog/ProjectSearchFilter.vala` and `SettingsDialog/ProjectsPage.vala` in the SettingsDialog section of each.
- `ollmapp/SettingsDialog/MainDialog.vala` - Add Projects tab to view stack (create ProjectsPage, add_titled, append action_widget)
- `libocfiles/ProjectList.vala` - Add **get_folder_in_any_project(string path)** that iterates the backing store (items) with foreach and returns the Folder if any project's folder_map has the path.
- `libocfiles/ProjectManager.vala` - Add methods that the UI and migration will call:
  - `remove_project(Folder project)` — see plan section below (all remove logic lives here)
  - `get_folder_at_path(string path)`, `create_project(string path)` — see "Create project" below
- `libocfiles/ProjectMigrate.vala` - Refactor: keep verification as a private method in ProjectMigrate (migration-specific checks); call **`manager.create_project(normalized)`** only when verification passes. Replace `create_project_from_path()` with verify-then-create (private verify, then manager.create_project).

### How projects are added today (bootstrap / migration)

Configuration and bootstrap code that adds projects does **not** go through the Settings UI. It uses **ProjectMigrate** (`libocfiles/ProjectMigrate.vala`), which reads external editors and, for each path found, calls a method to add the project. That method is better placed on **ProjectManager** so both migration and the Settings "Add" button use the same logic.

1. **Cursor**: Reads `~/.config/Cursor/User/globalStorage/state.vscdb` (SQLite), parses `history.recentlyOpenedPathsList` JSON, extracts paths (e.g. from `folderUri` / `folder`), and for each path calls **`manager.create_project(path)`** (after refactor).
2. **roobuilder**: Reads `~/.config/roobuilder/Projects.list` (JSON object with paths as keys), and for each key calls **`manager.create_project(path)`** (after refactor).
3. **VS Code**: Reads `~/.config/Code/storage.json`, parses `history.recentlyOpenedPathsList`, extracts folder paths, and for each calls **`manager.create_project(path)`** (after refactor).

**Bootstrap flow**: e.g. `AgentFactory` creates a `ProjectMigrate(project_manager)` and calls **`migrate_all()`**, which loads existing projects from DB, then runs `migrate_from_cursor()`, `migrate_from_roobuilder()`, `migrate_from_vscode()`, then syncs the DB.

### Create project — implementation

This section documents the **old** create-project code, the **new** design (verification vs. create_project), and the **proposed** code for review. Null checking is avoided unless absolutely logical; no defensive null checks.

---

#### Old code (ProjectMigrate.create_project_from_path)

The current implementation lives in `libocfiles/ProjectMigrate.vala` as a private method. It performs all validation and creation in one place. (The old code checks `folder_path == null`; the new API does not add defensive null checks — callers pass a non-empty path.)

```vala
		/**
		 * Create a Project from a folder path and save it to the database.
		 *
		 * @param folder_path The path to the folder to create as a project
		 */
		private void create_project_from_path(string folder_path)
		{
			GLib.debug("create_project_from_path: %s", folder_path);

			if (folder_path == null || folder_path == "") {
				GLib.debug("  Skipping (empty path)");
				return;
			}

			// Skip "." and ".." paths explicitly
			if (folder_path == "." || folder_path == "..") {
				GLib.debug("  Skipping (invalid path: '%s')", folder_path);
				return;
			}

			// Resolve to absolute path
			string path = GLib.Path.is_absolute(folder_path)
				? folder_path
				: GLib.Path.build_filename(GLib.Environment.get_current_dir(), folder_path);
			GLib.debug("  Resolved path: %s", path);

			// Normalize the path (remove redundant components)
			try {
				path = GLib.File.new_for_path(path).get_path();
				GLib.debug("  Normalized path: %s", path);
			} catch (GLib.Error e) {
				GLib.debug("  Warning: Failed to normalize path: %s", e.message);
			}

			// Check again after normalization (might have become "." or "..")
			if (path == "." || path == ".." || !GLib.Path.is_absolute(path)) {
				GLib.debug("  Skipping (invalid normalized path: '%s')", path);
				return;
			}

			// Check if path exists and is a directory (IS_DIR implies EXISTS)
			if (!GLib.FileUtils.test(path, GLib.FileTest.IS_DIR)) {
				GLib.debug("  Skipping (does not exist or is not a directory)");
				return;
			}
			GLib.debug("  ✓ Path exists and is a directory");

			// Check if project already exists in projects list
			if (this.manager.projects.path_map.has_key(path)) {
				GLib.debug("  Skipping (project already exists)");
				return;
			}

			// Create new Project
			GLib.debug("  Creating project...");
			var project = new Folder(this.manager);
			project.is_project = true;
			project.path = path;
			project.display_name = GLib.Path.get_basename(path);
			GLib.debug("  ✓ Project created: %s (%s)", project.display_name, project.path);

			// Add to manager
			this.manager.projects.append(project);

			// Save to database (without syncing, we'll sync at the end)
			if (this.manager.db != null) {
				project.saveToDB(this.manager.db, null, false);
				GLib.debug("  ✓ Project saved to database");
			}
		}
```

#### Changed to (ProjectMigrate refactor)

- **Use new create_project after “already a project” check**: Validation (including `projects.path_map.has_key(path)`) stays in ProjectMigrate; once the path is valid and not already a project, call **`manager.create_project(normalized)`** only. No direct `Folder` construction or `projects.append` / `saveToDB` here.
- **Remove unneeded or invalid null checks**: Drop `folder_path == null` (caller passes non-empty path; in Vala string parameters are not null unless explicitly nullable). Drop `if (this.manager.db != null)` before save — persistence is handled inside `create_project`; no defensive DB check here.

Replace **create_project_from_path** with a private verification step then **manager.create_project(normalized)**. Keep only validation that is logically required for untrusted migration input (empty string, "." / "..", resolve, normalize, IS_DIR, already in path_map).

**Private method** (e.g. `try_add_project_path(string folder_path)`) — returns true if a project was added, false if skipped:

```vala
		/**
		 * Verify path and add as project if valid. Migration-specific validation only.
		 * Caller passes non-empty path (no null check). If valid and not already a project, calls manager.create_project(normalized).
		 *
		 * @param folder_path Path from migration source (may be relative)
		 * @return true if create_project was called, false if skipped (invalid or already a project)
		 */
		private bool try_add_project_path(string folder_path)
		{
			if (folder_path == "" || folder_path == "." || folder_path == "..") {
				return false;
			}
			var path = GLib.Path.is_absolute(folder_path)
				? folder_path
				: GLib.Path.build_filename(GLib.Environment.get_current_dir(), folder_path);
			try {
				path = GLib.File.new_for_path(path).get_path();
			} catch (GLib.Error e) {
				return false;
			}
			// get_path() returns absolute, canonical path (or null); "." / ".." cannot appear here
			if (path == null || path == "" || !GLib.Path.is_absolute(path)) {
				return false;
			}
			if (!GLib.FileUtils.test(path, GLib.FileTest.IS_DIR)) {
				return false;
			}
			if (this.manager.projects.path_map.has_key(path)) {
				return false;
			}
			this.manager.create_project(path);
			return true;
		}
```

**At each call site** (Cursor, roobuilder, VS Code): replace `this.create_project_from_path(path)` with `this.try_add_project_path(path);` (or inline the same logic). Remove the old **create_project_from_path** method entirely.

---

#### New design

- **create_project(string path)** is called with a **confirmed path**. The path must already be normalized and must **not** exist in our database as a project. **Callers are responsible** for ensuring this; create_project does not check "already a project" or path overlap. It only creates the Folder, sets properties, appends to projects, and saves to DB. No defensive null or empty checks inside create_project.
- Callers run verification **before** calling create_project:
  - **Settings dialog**: Gets path from file chooser (so it is an existing directory). Normalizes the path (e.g. `GLib.File.new_for_path(path).get_path()`), then checks **`project_manager.projects.path_map.has_key(normalized)`**. If already a project, show an error; otherwise call **create_project(normalized)**.
  - **ProjectMigrate**: Keeps the verification logic **in ProjectMigrate** (private method). For each path from Cursor/roobuilder/VS Code (untrusted), runs that verification (empty / "." / "..", resolve, normalize, IS_DIR, not in path_map); if valid, calls **manager.create_project(normalized)**; otherwise skips. ProjectManager does not contain migration-specific validation.

---

#### ProjectManager API (proposed)

**Lookup before create**: We must avoid creating a duplicate folder for a path we already know. ProjectManager has:

- **projects.path_map** — path ⇒ Folder for project roots. Caller checks this before calling create_project; we do not look here in get_folder_at_path.
- **Per-project folder cache** — each project has `project_files.folder_map` (path ⇒ Folder) for folders under that project. A path might be a folder inside a project but not yet in file_cache (e.g. loaded during scan). “ProjectList’s cache?” **ProjectList** exposes **get_folder_in_any_project(string path)** that iterates its backing store (items) and returns the Folder if any project's folder_map has the path. ProjectManager.get_folder_at_path calls it; we do not iterate from ProjectManager via ListModel.
- **Database** — if not in memory, query filebase for a row with this path and base_type = 'd' (Folder), load the Folder, add to file_cache, return it.

**get_folder_at_path(string path)** — returns **Folder?** (null if not found). Caller must have already verified path is not already a project (Settings check path_map, migration verifies). Lookup order:

1. **projects.get_folder_in_any_project(path)** — check all projects’ `project_files.folder_map.has_key(path)`; if any has it, return that Folder.
2. **Database** — if `db != null`, query filebase `WHERE path = ? AND base_type = 'd' AND delete_id = 0` LIMIT 1; load Folder (FileBase.query typemap), add to file_cache, return it.
3. Otherwise return null.

We do not check path_map (caller already did) or file_cache (folder lookup is via projects' folder_map and DB).

**create_project(string path)** — returns **Folder**. Caller still passes a normalized path; we verify we don’t already have it:

1. **existing = get_folder_at_path(path)**.
2. **project = existing != null ? existing : new Folder(this) { is_project = true, path = path }**.
3. Set **project.is_project = true**; **file_cache.set(project.path, project)**; **projects.append(project)**; saveToDB if db set; return project. (Projects list uses **path_basename**, derived from path; no display_name.)

So we never create a second Folder for the same path; we either return the existing one (possibly promoting it to project) or a new one.

---

#### Proposed code — ProjectManager (libocfiles/ProjectManager.vala)

Settings dialog still normalizes and can check **projects.path_map.has_key(normalized)** before calling create_project (to show “Already a project” without a round-trip). Migration keeps its private verification. **ProjectList** gets **get_folder_in_any_project(string path)** (iterates backing store). ProjectManager has **get_folder_at_path** (calls projects.get_folder_in_any_project then DB) and **create_project**.

**get_folder_at_path** — lookup in order: folder_cached (all projects’ folder_map) → DB. Caller has already verified path is not already a project; we do not check path_map or file_cache.

```vala
		/**
		 * Find a Folder at the given path (e.g. subfolder of a project, or in DB).
		 * Caller must have already verified the path is not already a project (path_map).
		 * Checks each project's folder_map, then the database. Does not check path_map or file_cache.
		 *
		 * @param path Normalized absolute path
		 * @return The Folder if found, null otherwise
		 */
		public Folder? get_folder_at_path(string path)
		{
			var folder = this.projects.get_folder_in_any_project(path);
			if (folder != null) {
				return folder;
			}
			// Per CODING_STANDARDS: no defensive null checks. create_project callers (Settings, migration, CLI) always have db set; we do not check this.db == null.
			var query = FileBase.query(this.db, this);
			var list = new Gee.ArrayList<FileBase>();
			// SQ.Query.select(where, list) takes a literal WHERE; escape path for SQL
			query.select(
				"WHERE path = '%s' AND base_type = 'd' AND delete_id = 0 LIMIT 1".printf(
					path.replace("'", "''")), list);
			
			return list.size == 0 ? null : list.get(0) as Folder;
		}
```

**ProjectList.get_folder_in_any_project** — in `libocfiles/ProjectList.vala`; iterates backing store (items), not ListModel:

```vala
		/**
		 * Return a Folder at the given path if it exists in any project's folder_map.
		 * Uses the backing store (items) so we can foreach; does not use ListModel.
		 *
		 * @param path Normalized absolute path
		 * @return The Folder if found in any project's folder_map, null otherwise
		 */
		public Folder? get_folder_in_any_project(string path)
		{
			foreach (var p in this.items) {
				if (p.project_files.folder_map.has_key(path)) {
					return p.project_files.folder_map.get(path);
				}
			}
			return null;
		}
```

**create_project** — lookup; project = existing or new Folder; then set, file_cache, append, save; return **Folder**:

```vala
		/**
		 * Ensure a project exists at the given path.
		 * Caller must have verified the path is not already a project (path_map).
		 * If we have a Folder at this path (folder_map or DB), promote it; otherwise create new.
		 *
		 * @param path Normalized absolute path to the folder
		 * @return The Folder that is the project at that path (existing or new)
		 */
		public Folder create_project(string path)
		{
			var existing = this.get_folder_at_path(path);
			var project = existing != null
				? existing
				: new Folder(this) {
					is_project = true,
					path = path
				};
			project.is_project = true;
			// Projects list binds to path_basename (FileBase: get_basename(path)); no need to set display_name
			this.file_cache.set(project.path, project);
			this.projects.append(project);
			if (this.db != null) {
				project.saveToDB(this.db, null, false);
				this.db.is_dirty = true;
			}
			return project;
		}
```

---

#### Proposed code — Settings dialog (ProjectsPage.add_project)

The Settings dialog verifies that the path is not already a project before calling create_project. File chooser guarantees an existing directory; we normalize and check the DB:

```vala
		private void add_project()
		{
			var chooser = new Gtk.FileDialog() {
				title = "Add project folder",
				modal = true
			};
			chooser.select_folder(this.dialog, null, (obj, res) => {
				try {
					var path = chooser.select_folder_finish(res).get_path();
					var normalized = GLib.File.new_for_path(path).get_path();
					if (this.project_manager.projects.path_map.has_key(normalized)) {
						// Already a project; show message (optional: use Adw.ToastOverlay or inline message)
						GLib.warning("Project already in list: %s", normalized);
						return;
					}
					this.project_manager.create_project(normalized);
				} catch (GLib.Error e) {
					// User cancelled or I/O error
				}
			});
		}
```

(If a toast or dialog for "Already a project" is desired, replace the warning with UI feedback; the plan leaves that to implementation.)

---

#### ProjectMigrate after refactor

Keep verification **in ProjectMigrate** (migration-specific: empty / "." / "..", resolve to absolute, normalize, IS_DIR, not already in path_map). Refactor the existing private method so it only verifies and returns (bool, normalized_path); then call **manager.create_project(normalized)** when valid. So:

- **Private method in ProjectMigrate** (e.g. `verify_path_then_create(string folder_path)` or keep the logic inline at each call site): do the full validation (empty, "."/"..", resolve, normalize, reject if not absolute, IS_DIR, path_map.has_key). If valid, call `this.manager.create_project(normalized)`; otherwise skip.
- Remove the current **create_project_from_path** that both validated and created. Replace with: verify (private), then **manager.create_project(normalized)**.

Example at each call site (Cursor, roobuilder, VS Code):

```vala
			string normalized;
			if (this.verify_and_normalize_path(path, out normalized)) {
				this.manager.create_project(normalized);
			}
```

Where `verify_and_normalize_path` is a **private** method on ProjectMigrate containing the migration-specific checks (empty / "." / "..", resolve, normalize, IS_DIR, not in manager.projects.path_map).

### ProjectManager.remove_project() Method

**Location**: `libocfiles/ProjectManager.vala`

**Purpose**: Remove a project from the projects list by clearing the `is_project` flag. **Does not delete any filebase or file_history data.**

**Rationale**: There may be cross-references between projects (e.g. files in one project referenced from another). Deleting by path would break those references. A full "rebuild project database" (list active projects, find all files within them, cross-reference against the DB, then clean up orphaned files) may be added later; for now, the only action is to clear the flag and remove from the list.

**Method Signature**:
```vala
public void remove_project(Folder project)
```
(Synchronous is sufficient; no async DB deletes.)

**Behavior** (all of this is in ProjectManager; the UI merely calls this method):
1. **Clear active project if needed**: If this project was the active project, set `this.active_project = null` and emit `active_project_changed(null)`.
2. **Remove from projects list**: Call `this.projects.remove(project)`. ProjectList.remove() already sets `project.is_project = false` and removes the folder from the list (and emits `items_changed`).
3. **Persist is_project in DB** (optional): Update the folder row in the database so `is_project = 0` for this folder (e.g. `UPDATE filebase SET is_project = 0 WHERE id = ?`). Mark database dirty if needed.

**What we do NOT do**:
- Do **not** DELETE any filebase records (paths under this project may be referenced elsewhere).
- Do **not** DELETE or unlink any file_history records.

### Search filter (FilterListModel)

Use a **Gtk.Filter** subclass (e.g. in the same file or a small helper) with a **`search_text`** property so the list can be filtered by project name or path:

- **Property**: `string search_text` (default `""`). When set, emit **`this.changed(Gtk.FilterChange.DIFFERENT)`** (e.g. in `notify["search-text"].connect`) so FilterListModel re-filters.
- **match(item)**: Return `true` if `search_text` is empty; otherwise return true when `Path.get_basename(((Folder)item).path).down().contains(search_text.down())` or `((Folder)item).path.down().contains(search_text.down())`.

Model chain: **projects** → **FilterListModel**(this filter) → **SortListModel**(by basename) → **SingleSelection**(can_unselect = true) → ListView. When the user types in the search entry, set `filter.search_text = search_entry.text`; the filter emits changed and the list updates.

## Code for Review (Prior to Implementation)

The following is concrete Vala structure for the Projects tab using **ListView + ListModel backing** (no BoxedList). Review before implementing.

### ProjectsPage — constructor and list setup

```vala
// ollmapp/SettingsDialog/ProjectsPage.vala
namespace OLLMapp.SettingsDialog
{
	public class ProjectsPage : SettingsPage
	{
		public MainDialog dialog { get; construct; }
		public OLLMfiles.ProjectManager project_manager { get; construct; }

		private Gtk.ListView list_view;
		private Gtk.FilterListModel filtered_projects;
		private Gtk.SortListModel sorted_projects;
		private Gtk.SingleSelection selection_model;
		private Gtk.SearchBar search_bar;
		private Gtk.SearchEntry search_entry;
		private ProjectSearchFilter project_filter;
		private Gtk.Button add_btn;
		private Gtk.Button remove_btn;

		public ProjectsPage(MainDialog dialog, OLLMfiles.ProjectManager project_manager)
		{
			Object(
				dialog: dialog,
				project_manager: project_manager,
				page_name: "projects",
				page_title: "Projects",
				orientation: Gtk.Orientation.VERTICAL,
				spacing: 0
			);

			this.margin_start = 12;
			this.margin_end = 12;
			this.margin_top = 12;
			this.margin_bottom = 12;

			// Search filter (search_text property; emits changed when set)
			this.project_filter = new ProjectSearchFilter();
			this.filtered_projects = new Gtk.FilterListModel(
				this.project_manager.projects,
				this.project_filter
			);
			this.sorted_projects = new Gtk.SortListModel(
				this.filtered_projects,
				new Gtk.CustomSorter((a, b) => {
					var c = GLib.strcmp(
						GLib.Path.get_basename((a as OLLMfiles.Folder).path),
						GLib.Path.get_basename((b as OLLMfiles.Folder).path)
					);
					return (c < 0) ? Gtk.Ordering.SMALLER : (c > 0) ? Gtk.Ordering.LARGER : Gtk.Ordering.EQUAL;
				})
			);
			this.selection_model = new Gtk.SingleSelection(this.sorted_projects) {
				autoselect = false,
				can_unselect = true,
				selected = Gtk.INVALID_LIST_POSITION
			};

			this.list_view = new Gtk.ListView(this.selection_model, null);
			var factory = new Gtk.SignalListItemFactory();
			factory.setup.connect((item) => {
				var row_box = new Gtk.Box(Gtk.Orientation.HORIZONTAL, 8) {
					margin_start = 12,
					margin_end = 12,
					margin_top = 8,
					margin_bottom = 8
				};
				var name_label = new Gtk.Label("") {
					halign = Gtk.Align.START,
					hexpand = true,
					ellipsize = Pango.EllipsizeMode.END,
					css_classes = {"body"}
				};
				var path_label = new Gtk.Label("") {
					halign = Gtk.Align.END,
					hexpand = false,
					ellipsize = Pango.EllipsizeMode.MIDDLE,
					css_classes = {"caption", "dim-label"}
				};
				row_box.append(name_label);
				row_box.append(path_label);
				item.set_data<Gtk.Label>("name_label", name_label);
				item.set_data<Gtk.Label>("path_label", path_label);
				item.child = row_box;
			});
			factory.bind.connect((item) => {
				item.get_data<Gtk.Label>("name_label").label = GLib.Path.get_basename((item.item as OLLMfiles.Folder).path);
				item.get_data<Gtk.Label>("path_label").label = (item.item as OLLMfiles.Folder).path;
			});
			this.list_view.factory = factory;

			this.selection_model.selection_changed.connect(this.on_selection_changed);

			var scrolled = new Gtk.ScrolledWindow() {
				hexpand = true,
				vexpand = true
			};
			scrolled.set_child(this.list_view);
			scrolled.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC);

			var group = new Adw.PreferencesGroup() { title = this.page_title };
			group.add(scrolled);
			this.append(group);

			// Action bar: Search, Add, Remove. Remove visibility triggered by selection.
			this.action_widget = new Gtk.Box(Gtk.Orientation.HORIZONTAL, 6) { hexpand = true };
			this.search_bar = new Gtk.SearchBar();
			this.search_entry = new Gtk.SearchEntry() {
				placeholder_text = "Search Projects",
				hexpand = true
			};
			this.search_entry.changed.connect(() => {
				this.project_filter.query = this.search_entry.text;
			});
			this.search_bar.connect_entry(this.search_entry);
			this.search_bar.set_child(this.search_entry);
			this.search_bar.set_key_capture_widget(this);
			this.search_bar.set_search_mode(true);
			this.action_widget.append(this.search_bar);
			this.add_btn = new Gtk.Button.with_label("Add");
			this.add_btn.clicked.connect(() => this.add_project());
			this.action_widget.append(this.add_btn);

			this.remove_btn = new Gtk.Button.with_label("Remove") {
				css_classes = { "destructive-action" },
				visible = false
			};
			this.remove_btn.clicked.connect(() => this.on_remove_clicked());
			this.action_widget.append(this.remove_btn);

			this.on_selection_changed(); // initial state
		}
	}
}
```

### ProjectSearchFilter (separate file)

**File**: `ollmapp/SettingsDialog/ProjectSearchFilter.vala`

Filter by project name (basename) or full path; when `search_text` is set, emit `changed()` so FilterListModel updates. Public class in namespace `OLLMapp.SettingsDialog`; ProjectsPage instantiates `new ProjectSearchFilter()`.

Row factory (setup + bind) is **inlined** in the constructor: `factory.setup.connect((item) => { ... });` and `factory.bind.connect((item) => { ... });` with the same logic (two-column row: name_label + path_label; bind sets label from project path/basename).

### Selection and Remove button

```vala
		private void on_selection_changed()
		{
			var pos = this.selection_model.selected;
			this.remove_btn.visible = (pos != Gtk.INVALID_LIST_POSITION);
		}

		private void on_remove_clicked()
		{
			var pos = this.selection_model.selected;
			if (pos == Gtk.INVALID_LIST_POSITION) {
				return;
			}

			this.confirm_and_remove_project.begin(this.selection_model.get_item(pos) as OLLMfiles.Folder);
		}
```

### Add project (file chooser) and remove (confirm + call manager)

Add project must verify the path is not already in the DB before calling create_project. See **Create project — implementation** above for the full proposed `add_project()` (normalize path, check `projects.path_map.has_key(normalized)`, then `create_project`). Summary:

```vala
		private void add_project()
		{
			var chooser = new Gtk.FileDialog() {
				title = "Add project folder",
				modal = true
			};
			chooser.select_folder(this.dialog, null, (obj, res) => {
				try {
					var path = chooser.select_folder_finish(res).get_path();
					var normalized = GLib.File.new_for_path(path).get_path();
					if (this.project_manager.projects.path_map.has_key(normalized)) {
						// Already a project — show message to user
						return;
					}
					this.project_manager.create_project(normalized);
				} catch (GLib.Error e) {
					// User cancelled or I/O error
				}
			});
		}
```

		private async void confirm_and_remove_project(OLLMfiles.Folder project)
		{
			var dialog = new Adw.AlertDialog(
				"Remove Project?",
				"This will remove the project from your list. The folder will no longer appear as a project.\n\n" +
				"No file or history data will be deleted.\n\n" +
				"Are you sure you want to remove this project?"
			);
			dialog.add_response("cancel", "Cancel");
			dialog.add_response("remove", "Remove");
			dialog.set_response_appearance("remove", Adw.ResponseAppearance.DESTRUCTIVE);

			var response = yield dialog.choose(this.dialog, null);
			if (response != "remove") {
				return;
			}

			this.project_manager.remove_project(project);
		}
```

### MainDialog — add Projects tab

```vala
		// In MainDialog: add field and in constructor after tools_page:
		private ProjectsPage projects_page;

		this.projects_page = new ProjectsPage(this, this.parent.project_manager);
		this.view_stack.add_titled(
			this.projects_page,
			this.projects_page.page_name,
			this.projects_page.page_title
		);
		this.action_bar_area.append(this.projects_page.action_widget);
		this.projects_page.action_widget.visible = false;
```

**Notes for implementation**:
- **Model**: Use `project_manager.projects` (ProjectList) directly as the ListModel. ProjectList has a backing store (e.g. Gee.ArrayList<Folder>) and implements `GLib.ListModel`; it is not just a ListStore. ListView virtualizes rows so long lists are efficient.
- **Create project**: See **Create project — implementation** above. Add **ProjectManager.get_folder_at_path** (calls projects.get_folder_in_any_project then DB) and **create_project** (returns Folder). create_project looks up path via get_folder_at_path (projects.get_folder_in_any_project → DB; caller checks path_map); if existing and is_project return it; if existing promote to project and return; else create new and return. Settings dialog: normalize path, optionally check path_map before calling create_project; create_project returns Folder?. ProjectMigrate: keep verification as a private method (verify path, then manager.create_project(normalized)). No defensive null checks.
- Get `project_manager` from parent: `(this.dialog.parent as OllmchatWindow).project_manager` (same pattern as ModelsPage and `connection_models`).
- ListView reuses rows via the factory; no manual list building. Selection is handled by `Gtk.SingleSelection`.

## Confirmation Dialog

When the user clicks the Remove button, show a confirmation dialog:

**Title**: "Remove Project?"

**Message**: 
```
This will remove the project from your list. The folder will no longer appear as a project.

No file or history data will be deleted.

Are you sure you want to remove this project?
```

**Buttons**:
- **Cancel** (default) - Closes dialog without action
- **Remove** (destructive) - Proceeds with project removal

## Integration Points

- **ProjectManager**: Projects are managed by `ProjectManager.projects` (ProjectList — has a backing store, implements ListModel). **Database is optional**: `ProjectManager(SQ.Database? db = null)`; `this.db` can be null (no-DB / in-memory). The main app always passes a DB; code must guard DB use with `if (this.db != null)`.
- **SettingsDialog**: Main dialog window that contains the Projects tab
- **FileBase**: Files are stored in database with path-based queries
- **FileHistory**: File history is stored in database with path-based queries

## UI Layout

```
ProjectsPage (SettingsPage / Gtk.Box)
│
├── Adw.PreferencesGroup
│   └── Gtk.ScrolledWindow
│       └── Gtk.ListView
│           model: SingleSelection(can_unselect=true) → SortListModel(by basename) → FilterListModel(ProjectSearchFilter) → projects
│           └── rows via SignalListItemFactory (setup + bind)
│               └── each row: Gtk.Box (horizontal) → name_label (basename) | path_label (full path, caption/dim-label)
│
└── action_widget (Gtk.Box, in dialog action_bar_area)
    ├── SearchBar + SearchEntry ("Search Projects")
    ├── [Add] Button
    └── [Remove] Button (visibility triggered by selection; hidden when no selection)
```

## Future Considerations

- **Project Details**: Show project statistics (number of files, last modified, etc.)
- **Project Settings**: Per-project configuration options
- **Project Export/Import**: Export project configuration and history
- **Bulk Operations**: Select multiple projects for batch removal
- **Full project database rebuild**: List active projects, iterate through and find all files within them, cross-reference against the database, then clean up orphaned files (removed projects’ files that are not referenced elsewhere). Not needed for current "remove = clear flag" behavior.
