# Rendering of links (1.10.10)

- **Goal:**
  - Render parsed links (from plan 1.10.9) as styled text showing the **link text**.
  - Store the **href** and **title** on the tag (tooltip will use both).
  - Handle click (open URL) and hover (e.g. tooltip).
- **Current:**
  - **libocmarkdowngtk/Render.vala** `on_a()` adds a state with blue + underline but then immediately adds the **href** as text and closes the state.
  - So the link text is wrong and the URL is not stored for events.
- **Status:** done.

---

## Prerequisite

- Plan 1.10.9 (parser of links) must emit:
  - `on_a(true, href, title, is_reference)`
  - `on_text(link_text)`
  - `on_a(false, ...)`
- When **is_reference** is true, **href** is the reference label.
- We do **not** resolve reference-style links when rendering; we just store whatever **href** we get (URL or ref label) on the tag.

---

## Phase 1: Update rendering and store link info

- **Two states per link:**
  - **Outer state (formatting):** One state that applies the **shared** tag named `"link"` (lookup on the buffer) — blue, underline. Shared across the whole text view; we cannot store data on it.
  - **Inner state (data tag):** One state that applies a **per-link** tag to the same range; we set `tag.set_data<string>("href", href)` and `tag.set_data<string>("title", title)` on that tag. Phase 2 finds this tag by range and reads href/title.
  - So we need **two states** for each link: one for the outer formatting (shared "link" tag), one for the inner data tag (per-link, href/title).
- **Target behaviour:**
  - On `on_a(true, href, title, is_reference)`:
    - Open **outer** link state (shared tag `"link"` — lookup on buffer).
    - Open **inner** link state (per-link data tag; set_data href and title on that tag).
    - Do **not** add href as text; do not close the state.
  - The following `on_text(link_text)` will be rendered inside both states (so the user sees the link text with link styling).
  - On `on_a(false, ...)`: close **both** states (inner first, then outer, or in the order the state stack expects).
- **Storing href and title:**
  - **Outer state / shared style tag:** Look up the buffer for a tag named `"link"` (or the style name used for links); use it for styling only (blue, underline). Shared across the whole text view.
  - **Inner state / per-link data tag:** Create a tag per link; apply it to the same range as the link (inner state); set `tag.set_data<string>("href", href)` and `tag.set_data<string>("title", title)` on that tag. Phase 2 finds this tag by range (start/end) and reads href/title.
  - **href** is either a URL (inline link) or a reference label (reference-style); we do **not** resolve references.
  - **title** may be empty; tooltip code will use title and url as needed.

---

## Phase 2: Implement hover and click on the box

- **Where:** Connect events on the **Gtk.Box** that holds the TextViews (Render's `box`), with logic to find which child TextView received the event and the position in that view.
- **Identifying link tags and getting data:**
  - When creating the link state in Phase 1 we do a **lookup on the buffer** for a tag named `"link"` (or the style name used for links) — a **shared** tag used for all links in the text view (style only: blue, underline).
  - We **cannot** store href/title on that tag, because it is shared across the whole text view (data would be overwritten).
  - **Two-tag approach:** Use the shared `"link"` tag as an **indicator** only. In the handler: if the iter does **not** have the `"link"` tag, return (no link). If it does, get the **full list** of tags at the iter, then get **start and end** of the link range at this iter, and **find the data tag** — the (per-link) tag that holds `set_data<string>("href", ...)` and `set_data<string>("title", ...)` for this range. Read href/title from that data tag.
  - So: one shared style tag `"link"` (lookup when creating link state); one per-link tag that has the same range and carries href/title via set_data. Handler: check `"link"` → if not present return; if present, get range (start/end), find the tag with data for that range, use href/title.
- **Order / innermost:**
  - Multiple tags can apply at the same iter (e.g. bold + link). We could prefer the **innermost** link range when resolving start/end and finding the data tag, so that over **bold [link](url)** we treat the link as active.
  - If we don't care about nesting, use the first link range / data tag found at the iter.
- **Click (link clicked):**
  - On `button-release-event` (or similar) on the box.
  - Get the event coordinates, find the child at that position, convert to buffer coordinates (e.g. `get_iter_at_position` / `get_iter_at_location`).
  - Get the list of tags at that iter; identify link (find data tag for that range); get href and title.
  - **Signal on the renderer:** Fire a signal on the renderer (e.g. `link_clicked` or `link-activated`) with href and title (and optionally is_reference if we store it). The consumer (app) connects to this signal and decides what to do (e.g. `Gtk.show_uri()`, open in browser, or app-specific handling). Renderer does **not** open the URL itself; it only emits the signal.
- **Hover (tooltip):**
  - On `motion-notify-event` on the box.
  - Find the child at the pointer, get the iter at that position.
  - Identify link tag at that iter (by name or by get_data); get `tag.get_data<string>("href")` and `tag.get_data<string>("title")`.
  - If link tag found, set the widget tooltip using **title** and **url**; otherwise clear or set default tooltip.
  - Set tooltip on the appropriate widget (the child TextView or the box).
- **Cursor:** Set the cursor to a "pointer" when over a link (same tag identification); reset when not over a link. Required.

---

## Summary

| Phase | Component | Change |
|-------|-----------|--------|
| **1** | **libocmarkdowngtk/Render.vala** | In `on_a(true, href, title, ...)`: add **two states** — outer state (shared tag `"link"`, lookup on buffer) and inner state (per-link data tag with `tag.set_data<string>("href", href)` and `tag.set_data<string>("title", title)`); do not add href as text or close state. In `on_a(false, ...)`: close both states. |
| **2** | **libocmarkdowngtk/Render.vala** (box) | Connect `button-release-event` and `motion-notify-event` on the box. Handler: if iter has no `"link"` tag return; else get full list of tags, get link range (start/end), find the data tag for that range, read href/title; on click **emit signal** on the renderer (e.g. `link_clicked(href, title)`) — consumer connects and handles (e.g. `Gtk.show_uri`); on motion set/clear tooltip (using title and url) and set/clear cursor (pointer when over link). Required. |

---

## Verification

- **Phase 1:**
  - Input `[OpenAI](https://openai.com)`.
  - Confirm the visible text is "OpenAI", styled (e.g. blue, underline).
  - Confirm href (and title when present) are stored on the tag.
- **Phase 2:**
  - Confirm that click opens the URL and hover shows tooltip (using title and url).
- Test with title:
  - `[text](url "title")`.
  - Ensure title is stored on the tag and tooltip shows title and/or url as desired.

---

## Concrete code changes

### State.vala

```vala
/**
 * Creates a new State, optionally reusing an existing tag for the same range.
 *
 * @param parent Parent state (null for root)
 * @param render Render instance
 * @param use_tag If non-null, use this tag instead of creating a new one (marks only)
 */
public State(State? parent, Render render, Gtk.TextTag? use_tag = null)
{
	this.parent = parent;
	this.render = render;
	if (parent == null) {
		return;
	}
	this.initialize_from_parent(parent, use_tag);
}

private void initialize_from_parent(State parent, Gtk.TextTag? use_tag = null)
{
	if (use_tag == null) {
		this.initialize_tag_and_marks(parent.end.get_buffer(), parent.end);
		return;
	}
	var buffer = parent.end.get_buffer();
	Gtk.TextIter iter;
	buffer.get_iter_at_mark(out iter, parent.end);
	this.start = buffer.create_mark(null, iter, true);
	this.end = buffer.create_mark(null, iter, true);
	this.style = use_tag;
}

/**
 * Creates a child state. If use_tag is non-null, the child reuses that tag for styling.
 *
 * @param use_tag Optional existing tag to apply (e.g. shared "link" tag)
 * @return The new child state
 */
public State add_state(Gtk.TextTag? use_tag = null)
{
	var new_state = new State(this, this.render, use_tag);
	this.cn.add(new_state);
	this.render.current_state = new_state;
	return new_state;
}
```

### Render.vala — Phase 1

```vala
/** Emitted when the user activates a link. Connect to open URL or handle app-specific navigation. */
public signal void link_clicked(string href, string title);

/**
 * Creates a renderer that appends content to the given box.
 *
 * @param box Gtk.Box to add TextViews to
 */
public Render(Gtk.Box box)
{
	base();
	this.box = box;
	var click_gesture = new Gtk.GestureClick();
	click_gesture.released.connect((n_press, x, y) => {
		this.on_link_click_released(x, y);
	});
	this.box.add_controller(click_gesture);
	var motion = new Gtk.EventControllerMotion();
	motion.motion.connect((x, y) => {
		this.on_link_motion(x, y);
	});
	motion.leave.connect(() => {
		this.on_link_leave();
	});
	this.box.add_controller(motion);
}

// No new method: inline "get or create link tag" at each call site (on_a and get_link_at_iter).
// Before: each link used a new state and we set link_state.style.foreground/underline on that state's new tag.
// Now: one shared tag named "link" per buffer (lookup or create), plus per-link state for href/title only.

/**
 * Callback for link spans. Renders link text with shared style and stores href/title on a per-link tag.
 *
 * @param is_start True for open, false for close
 * @param href URL or reference label
 * @param title Link title (may be empty)
 * @param is_reference True if href is a reference label
 */
public override void on_a(bool is_start, string href, string title, bool is_reference)
{
	if (!is_start) {
		this.current_state.close_state();
		this.current_state.close_state();
		return;
	}
	var link_tag = this.current_buffer.get_tag_table().lookup("link");
	if (link_tag == null) {
		link_tag = this.current_buffer.create_tag("link", null);
		link_tag.foreground = "blue";
		link_tag.underline = Pango.Underline.SINGLE;
	}
	this.current_state.add_state(link_tag);
	var inner = this.current_state.add_state();
	inner.style.set_data<string>("href", href);
	inner.style.set_data<string>("title", title);
}
```

### Render.vala — Phase 2

```vala
private Gtk.TextView? last_link_view = null;
private string last_tooltip_markup = "";

private void on_link_click_released(double x, double y)
{
	Gtk.TextView? view;
	var tag = this.tag_at_iter(x, y, out view);
	if (tag == null) {
		return;
	}
	var href = tag.get_data<string>("href") ?? "";
	var title = tag.get_data<string>("title") ?? "";
	this.link_clicked(href, title);
}

private void on_link_motion(double x, double y)
{
	Gtk.TextView? view;
	var tag = this.tag_at_iter(x, y, out view);
	if (view == null) {
		if (this.last_link_view != null) {
			this.last_link_view.tooltip_markup = null;
			this.last_link_view.set_cursor(null);
			this.last_link_view = null;
			this.last_tooltip_markup = "";
		}
		return;
	}
	if (tag != null) {
		this.last_link_view = view;
		var href = tag.get_data<string>("href") ?? "";
		var title = tag.get_data<string>("title") ?? "";
		var markup =
			(title != "" ? "<b>" + GLib.Markup.escape_text(title, -1) + "</b>\n" : "") +
			GLib.Markup.escape_text(href, -1);
		if (markup == this.last_tooltip_markup) {
			return;
		}
		this.last_link_view.tooltip_markup = markup;
		this.last_tooltip_markup = markup;
		var cursor = Gdk.Cursor.from_name("pointer", null);
		if (cursor != null) {
			this.last_link_view.set_cursor(cursor);
		}
		return;
	}
	if (this.last_link_view != null) {
		this.last_link_view.tooltip_markup = null;
		this.last_link_view.set_cursor(null);
		this.last_link_view = null;
		this.last_tooltip_markup = "";
	}
}

private void on_link_leave()
{
	if (this.last_link_view != null) {
		this.last_link_view.tooltip_markup = null;
		this.last_link_view.set_cursor(null);
		this.last_link_view = null;
		this.last_tooltip_markup = "";
	}
}

/** Returns the link tag at (x, y) in box coordinates, or null. Sets out_view to the TextView at (x, y) when over one. */
private Gtk.TextTag? tag_at_iter(double x, double y, out Gtk.TextView? out_view)
{
	out_view = null;
	var tv = this.box.pick((float) x, (float) y, Gtk.PickFlags.DEFAULT) as Gtk.TextView;
	if (tv == null) {
		return null;
	}
	out_view = tv;
	double bx;
	double by;
	this.box.compute_point(tv, { (float) x, (float) y }, out bx, out by);
	int buf_x;
	int buf_y;
	tv.window_to_buffer_coords((int) bx, (int) by, out buf_x, out buf_y);
	Gtk.TextIter iter;
	if (!tv.get_iter_at_location(out iter, buf_x, buf_y)) {
		return null;
	}
	var buf = tv.get_buffer();
	var link_tag = buf.get_tag_table().lookup("link");
	if (link_tag == null || !iter.has_tag(link_tag)) {
		return null;
	}
	foreach (var tag in iter.get_toggled_tags(false)) {
		if (tag.get_data<string>("href") != null) {
			return tag;
		}
	}
	return null;
}
```

---

## Dependencies

- Plan 1.10.9 (parser of links) must be done first so that `on_a` and `on_text` are emitted correctly.
