# 1.5.2 - Model Usage Initial State and Config Persistence

## Status

DONE — implemented.

## Summary

**Goal**: Fix model usage for initial state so that (1) the config file stores the UI state for model usage, (2) that state is restored when the application starts, and (3) the stored value is updated and synced when the user changes the model in the chat UI, and is verified (valid) on load.

**Findings from investigation** (see Current Behaviour below):

- Config **does** store default model: `config.usage["default_model"]` → `ModelUsage` (connection, model, options).
- Config **is** used for initial state: Manager reads it at construction; sessions copy from `manager.default_model_usage`.
- Config **is not** updated when the user changes the model in the chat dropdown: only `session.activate_model()` is called; the config object is never written and `config.save()` is not called.
- Restore on load **partially** works: UI selection is set from `session.model_usage` in `ChatInput.update_models()`, which ultimately comes from config. Verification on load exists but only logs a warning on failure.

## Problem Statement

1. **Initial state**: The chosen model at startup should come from config and be reflected correctly in the UI.
2. **Persistence**: When the user changes the model in the main chat window (model dropdown), that choice should be written to config and saved so it becomes the default for the next run.
3. **Restore and validation**: On startup, the stored default model should be restored and verified (connection exists, model exists on server); if invalid, it should be corrected or the user guided to fix it.

## Current Behaviour (Investigation)

### Where model usage is stored

- **Config2** (`libollmchat/Settings/Config2.vala`):
  - `usage` is a `Gee.Map<string, Object>`.
  - Key `"default_model"` holds a `ModelUsage` (connection URL, model name, options).
  - Serialized to JSON in `config.2.json` via `Config2.save()`.
  - Path: `Config2.config_path` (e.g. `~/.config/ollmchat/config.2.json`).

- **Manager** (`libollmchat/History/Manager.vala`):
  - Constructor: `this.default_model_usage = app.config.usage.get("default_model") as Settings.ModelUsage`.
  - So `default_model_usage` is a **reference** to the same object in `config.usage`; updating its fields updates config in memory (but saving to disk still requires `config.save()`).
  - Validates that the connection exists; does not persist when UI selection changes.

- **SessionBase** (`libollmchat/History/SessionBase.vala`):
  - Constructor: `this.model_usage = manager.default_model_usage` (reference to config’s default).
  - `activate_model(ModelUsage)` clones the given usage into the session and updates chat; it **does not** update `config.usage["default_model"]` or call `config.save()`.

### When config is saved

- **Bootstrap** (`ollmapp/Window.vala`): After bootstrap dialog, config is created and saved.
- **Initialize** (`ollmapp/Initialize.vala`): `initialize_model()` may set/fix default model and then calls `config.save()`.
- **Settings UI**: ConnectionsPage and MainDialog call `app.config.save()` when user edits connections/settings.
- **Chat model dropdown**: When the user changes the model in the main window, only `manager.session.activate_model(model_usage)` is called in `ChatInput` — **no** update to `config.usage["default_model"]` and **no** `config.save()`.

So: **config is not updated or synced when the user changes the model in the chat UI.**

### Restore on load

- **Manager** is created after `Initialize.run()`; it reads `default_model_usage` from config.
- **EmptySession** is created with `model_usage = manager.default_model_usage`.
- **ChatInput.setup_model_dropdown()** calls `update_models.begin()`, which sets `model_dropdown.selected` from `manager.session.model_usage` (via `sorted_models.find_position(...)`).
- So the **dropdown selection is restored** from config at startup, as long as the session’s `model_usage` matches what’s in config (which it does for the initial empty session).

### Verification on load

- **Initialize.initialize_model()**: If `default_model` is set, it can call `default_model.verify_model(config)`; on failure it clears `default_model.model` and then picks the first available model and calls `config.save()`.
- **Manager.ensure_model_usage()**: Verifies the model exists on the connection; throws on failure. Called from `Initialize.run()` but failure is only logged: `GLib.warning("...");` and initialization continues.
- So: verification **exists** but does not block startup; invalid stored model can remain and may not be corrected in config.

## Requirements

1. **Store UI state in config**
   - The “default” model for the chat UI is already represented by `config.usage["default_model"]`. Ensure this is the single source of truth for “model to show and use at startup and for new sessions”.

2. **Update and sync when user changes model**
   - When the user selects a different model in the main chat model dropdown:
     - Update the `default_model` entry in config (same object as `manager.default_model_usage`, so updating connection/model/options and then saving is enough).
     - Call `config.save()` so the choice is persisted.

3. **Restore on startup**
   - On startup, the app already restores from config (Manager → session → ChatInput). Confirm that:
     - The dropdown shows the stored default.
     - New sessions use the same default until the user changes it again.

4. **Verify on load**
   - When loading config:
     - Ensure the stored default model is valid (connection present and working, model present on that connection).
     - If invalid: either fix in place (e.g. fallback to first available model and save), or prompt the user (e.g. open settings to “models” or show a message), and ensure config is left in a consistent state.

## Why not update config inside `activate_model()`?

`activate_model()` is called from two places:

1. **ChatInput** – when the user selects a model in the dropdown → we *do* want to persist as default.
2. **Manager.create_new_session()** – `empty_session.activate_model(this.session.model_usage)` copies the current session’s model to the new empty session → we *do not* want to persist (creating a new session should not change “default for next app launch”).

So the config update must stay at the call site that represents an explicit user choice (the dropdown), not inside `activate_model()`. Session’s job is to activate a model for this session; “default for next run” is Manager/Config responsibility.

---

## Proposed Code Changes

### Chosen approach: ChatInput updates config and saves (Option A)

**File: `libollmchatgtk/ChatInput.vala`**

In the `model_dropdown.notify["selected"]` handler, after `activate_model(model_usage)` and before the tools binding update, persist the selected model as the default and save config. `manager.default_model_usage` is the same object as `config.usage["default_model"]`, so updating its fields and calling `manager.config.save()` is enough.

**Current code (excerpt, lines ~437–473):**

```vala
this.model_dropdown.notify["selected"].connect(() => {
	// Ignore selection changes while loading models
	if (this.is_loading_models) {
		return;
	}

	if (this.model_dropdown.selected != Gtk.INVALID_LIST_POSITION) {
		var model_usage = this.sorted_models.get_item_typed(this.model_dropdown.selected);
		if (model_usage == null || model_usage.model_obj == null) {
			return;
		}

		// Activate model on session (stores ModelUsage with options overlaid from config)
		this.manager.session.activate_model(model_usage);

		// Update binding to new model's can_call property for automatic visibility updates
		this.update_model_widgets_visibility();
		// ... tools_button_binding, etc.
	}
});
```

**Proposed change:** add the following block immediately after `this.manager.session.activate_model(model_usage);` (and before `update_model_widgets_visibility()`), so we only persist when the selection is valid. No null check on `default_model_usage`: Manager’s constructor calls `GLib.error()` if it is null, so we never have a Manager without it.

```vala
		// Activate model on session (stores ModelUsage with options overlaid from config)
		this.manager.session.activate_model(model_usage);

		// Persist selected model as default for next run (config.usage["default_model"] == default_model_usage)
		var def = this.manager.default_model_usage;
		def.connection = model_usage.connection;
		def.model = model_usage.model;
		def.options = model_usage.options.clone();
		this.manager.config.save();

		// Update binding to new model's can_call property for automatic visibility updates
		this.update_model_widgets_visibility();
```

No other files need to change: Manager already exposes `config` and `default_model_usage` is the config object.

*Option B (Manager method `set_default_model_and_save()`) was considered but not chosen; Option A keeps the change in one place and avoids adding API surface.*

---

### Verification / fix-on-load: pick first non-embedding model (no Settings option)

**File: `ollmapp/Initialize.vala`**

When the stored default is missing or invalid, we should fix it in place by picking the first available **non-embedding** model (so the chat default is a chat model, not an embedding-only model). No Settings dialog option for this – automatic fallback only.

**1. When `ensure_model_usage()` fails** (lines ~112–115): instead of only logging and continuing, call the same fallback path as `initialize_model()` (e.g. re-run `initialize_model(config, working_conn)` so the bad default is cleared and replaced with the first non-embedding model, then save).

**2. In `initialize_model()`** (lines ~165–178): when picking a fallback model, do **not** use “first model” unconditionally. Use the first **non-embedding** model:

- **Single checks (design – one place each):**
  - **Hidden**: Use **`model_obj.is_hidden`** only (Response.Model already has this; ConnectionModels skips `model.is_hidden` so we may not see them; if we iterate and have model_obj, use `model_obj.is_hidden`). No name-based `has_prefix("ollmchat-temp/")` – use the property.
  - **Embedding**: Use **`model_obj.is_embedding`** only. **"embedding"** is the only valid capability value for embed (not "embed"). **Design**: add `is_embedding` on Response.Model as `capabilities.contains("embedding")` (single place) and use it here, in subtitle_markup, and in Child/Parser.
- **`model_obj` required**: If `model_obj` is null we cannot determine hidden/embedding, so skip that model. After `ConnectionModels.refresh()`, each ModelUsage has `model_obj` set.

**Proposed logic in `initialize_model()`** when choosing a fallback (design only; no code until approved):

```vala
			// Pick first non-embedding, non-hidden model (chat default)
			OLLMchat.Settings.ModelUsage? first_chat_model = null;
			foreach (var model_usage in connection_models.values) {
				if (model_usage.model_obj == null 
					|| model_usage.model_obj.is_hidden 
					|| model_usage.model_obj.is_embedding) {
					continue;
				}
				first_chat_model = model_usage;
				break;
			}
			if (first_chat_model == null) {
				// Error: no chat model available – trigger settings dialog so user can add/select a model
				// Caller (run()) must check return and show_settings(..., "models") then continue loop
				return false;  // initialize_model() becomes async bool
			}
			// Then set default_model from first_chat_model (connection, model, options) and config.save()
			return true;
```

**3. When `ensure_model_usage()` throws**: call `yield initialize_model(config, working_conn)` so the invalid default is replaced using the same non-embedding logic, then continue (no need to block or show Settings).

**4. "No non-embedding model" must show Settings:** When `initialize_model()` finds no non-embedding model (or no models at all), it is an error and must trigger the settings dialog so the user can add or select a model. **Design**: (a) `initialize_model()` returns `async bool` (true = default model set, false = could not find one). When no `first_chat_model` is found, return false. When connection_models is null/empty ("No models found for working connection"), return false as well. (b) In `run()`, after `yield initialize_model(config, working_conn)`, if it returns false call `show_settings("No chat model found (only embedding models available). Please add or select a model.", "models")` (or for "no models at all" use a message like "No models found for this connection. Please add or select a model.") and `continue` the loop so the user can fix in Settings and we retry. This ensures the UI always shows the settings dialog for these error conditions.

**In `run()`** after `yield initialize_model(config, working_conn)` add:

```vala
				if (!(yield this.initialize_model(config, working_conn))) {
					if (!(yield this.show_settings(
						"No chat model found (only embedding models available). Please add or select a model.",
						"models"))) {
						return false;
					}
					continue;  // Restart loop after settings dialog closes
				}
```

(If initialize_model() can fail for "no models at all" vs "no non-embedding", use the same show_settings with "models" and a message that covers both; or two distinct messages when we have a way to distinguish. For simplicity, one message is enough.)

**5. Child/Parser** (`liboctools/Child/Parser.vala`): use **`model_obj.is_embedding`** instead of name-based check. Today `select_model_for_agent()` uses `model_name_lower.contains("embed") || model_name_lower.contains("bge")` (lines ~228–232 and ~256–261) with a TODO to use `model_obj.is_embedding()` when added. **Proposed change (design only; no code until approved):** after adding `is_embedding` on Response.Model, replace both checks with `model_usage.model_obj.is_embedding` (Step 2: if `model_usage.model_obj != null && model_usage.model_obj.is_embedding` then skip; Step 3: if `default_model_usage.model_obj != null && !default_model_usage.model_obj.is_embedding` then use it).

---

## Where is default model set in Settings?

**It isn’t.** The default chat model (`config.usage["default_model"]`) is not currently editable in the Settings dialog.

- **Settings → Connections**: lets you choose which **connection** is default (`is_default` on Connection), not which model.
- **Settings → Models**: shows the list of downloaded models and **per-model options** (temperature, etc. in `config.model_options`). There is no “Default model for chat” dropdown or row bound to `config.usage["default_model"]`.
- **Settings → Tools**: each tool can have a ModelUsage (connection + model + options); that’s tool-specific, not the global chat default.

So today the default model is only set by:

1. **Bootstrap** (`Window.vala`): creates empty `default_model` and `title_model` when first run.
2. **Initialize.initialize_model()** (`Initialize.vala`): when the stored default is empty or invalid, picks the first available model and saves.
3. **Main chat window** (after this plan): when the user selects a model in the **chat model dropdown** (ChatInput), we persist that as the default.

If we want users to set the default from Settings as well, we could add a “Default model” row (or section) on the Models page that edits `config.usage["default_model"]`, e.g. using the existing `Rows.ModelUsage` widget with `config` = something that exposes the usage map entry, or a dedicated dropdown bound to `config.get_default_model()` / `config.usage.get("default_model")`. That would be a separate follow-up; this plan only adds persistence when the user changes the model in the main window.

---

## Proposed Approach (summary)

### 1. Sync model selection to config when user changes it (Chat UI)

- **Where**: `libollmchatgtk/ChatInput.vala`, in the `model_dropdown.notify["selected"]` handler (after `manager.session.activate_model(model_usage)`).
- **What**: Inline update of `default_model_usage` (connection, model, options) and `manager.config.save()` in ChatInput (Option A).
- **Edge cases**: Skip when `is_loading_models` is true; only persist when the selected item is valid (already required for `activate_model`).

### 2. Ensure initial state is correct

- **Manager / Session**: Already use `default_model_usage` from config. No change needed for “where” initial state comes from.
- **ChatInput**: Already sets dropdown from `session.model_usage` in `update_models()`. Ensure this runs after Manager and session are created and that we don’t overwrite the restored selection with a default index.

### 3. Verify and fix on load

- **Initialize.run()** / **initialize_model()**:
  - When the stored default is missing or invalid, fix in place by picking the first available **non-embedding** model (see "Verification / fix-on-load" above). No Settings option – automatic fallback only.
  - When `ensure_model_usage()` throws, call `initialize_model(config, working_conn)` so the invalid default is replaced with the first non-embedding model and saved; then continue (no block, no Settings dialog).
  - Use single checks only: **`model_obj.is_hidden`** for hidden (ollmchat-temp/); **`model_obj.is_embedding`** for embedding (design: add `is_embedding` on Response.Model, one place for capability check). If `model_obj` is null, skip that model. No code until plan approved.

### 4. Optional: Explicit “default model” vs “session model”

- Currently “default model” is both “what we show in the UI at startup” and “what new sessions use.” Keeping this single concept is enough for this plan. If later we want “session-specific model” that doesn’t change the global default, we can add that without changing the persistence story above.

## Tasks (checklist)

- [x] **T1** Verify in code: config path and structure for `default_model` (Config2, config.2.json).
- [x] **T2** Implement: when user changes model in chat dropdown, update `config.usage["default_model"]` (via `default_model_usage`) and call `config.save()` (from ChatInput or via Manager).
- [x] **T3** Verify: after T2, change model, restart app; confirm dropdown and session use the new default.
- [x] **T4** Implement (after design approved): add `is_embedding` on Response.Model as `capabilities.contains("embedding")` only; use it in subtitle_markup, Initialize.initialize_model(), and Child/Parser.select_model_for_agent(); in `initialize_model()` use combined skip condition (`model_obj == null || is_hidden || is_embedding`); when `ensure_model_usage()` throws, call `initialize_model(config, working_conn)` to fix and save.
- [x] **T5** Verify: invalid or missing default is corrected to first non-embedding model and saved; no Settings dialog option for this (automatic only).
- [x] **T6** Document: where config is stored, when it is saved, and how restore/verification work (e.g. in this plan or in a config overview).

## Files touched

- `libollmchatgtk/ChatInput.vala` – persist default when model selection changes; update config and save.
- `libollmchat/Response/Model.vala` – use `is_embedding` in subtitle_markup (property already existed).
- `ollmapp/Initialize.vala` – `initialize_model()` async bool; first non-embedding fallback; unset embedding default; re-check embedding on early-return paths.
- `liboctools/Child/Parser.vala` – use `model_obj.is_embedding` in `select_model_for_agent()`.
- `libollmchatgtk/List/ModelUsageSort.vala` – compare: same (connection, model) → EQUAL so config default matches list item for find_position.
- `libollmchat/Call/Models.vala` – v1/models endpoint; `is_openai` for URL (strip /api).
- `libollmchat/Call/Base.vala` – `is_openai` field; build_url() strips /api when is_openai.
- `libollmchat/Settings/Config2.vala` – no change; reference for where usage is stored and saved.

## Related

- **1.3** – Configuration overview (Config2, usage map).
- **1.4** – Client configuration setup (bootstrap, config creation).
- **1.5** – Model list management.
- **1.3.9** – Agent configuration and window state (other UI state in config).

## References

- `libollmchat/Settings/Config2.vala` – `usage`, `get_default_model()`, `save()`.
- `libollmchat/History/Manager.vala` – `default_model_usage`, constructor, `ensure_model_usage()`.
- `libollmchat/History/SessionBase.vala` – `model_usage`, `activate_model()`.
- `libollmchatgtk/ChatInput.vala` – `model_dropdown.notify["selected"]`, `update_models()`.
- `ollmapp/Initialize.vala` – `run()`, `initialize_model()`, `ensure_required_models()`.
