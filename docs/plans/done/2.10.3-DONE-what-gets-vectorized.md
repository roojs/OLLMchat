# 2.10.3. What Gets Vectorized

**Status: DONE** - Implementation complete in `libocvector/Indexing/` (Tree, Analysis, VectorBuilder)

This document shows examples of what gets vectorized for different code element types. Each example shows the formatted document that is sent to the Ollama embeddings API.

## Overview

Not all code elements get LLM-generated descriptions. Some simple elements skip the LLM analysis step and use only their structural information:

- **Skip LLM**: Enum types without documentation, simple properties (get/set only, no logic)
- **Use LLM**: Classes, methods, functions, complex properties, enums with documentation

## Element Types

### 1. Class Declaration

**Example:**
```vala
namespace OLLMvector.Indexing {
    /**
     * Tree-sitter AST parsing and VectorMetadata creation.
     * 
     * Parses source code files using tree-sitter to extract code elements
     * and create VectorMetadata objects with line numbers and documentation.
     */
    public class Tree : Object {
        // ...
    }
}
```

**Vectorized Document:**
```
class: Tree
Namespace: OLLMvector.Indexing
Access: public
File: libocvector/Indexing/Tree.vala
Lines: 27-732
Signature: public class Tree : Object
Description: Tree-sitter AST parsing and VectorMetadata creation. Parses source code files using tree-sitter to extract code elements and create VectorMetadata objects with line numbers and documentation.
Code:
public class Tree : Object
{
    public OLLMfiles.File file { get; private set; }
    public Gee.ArrayList<VectorMetadata> elements { get; private set; default = new Gee.ArrayList<VectorMetadata>(); }
    // ... rest of class implementation
}
```

### 2. Method with Documentation

**Example:**
```vala
namespace OLLMvector.Indexing {
    public class Tree : Object {
        /**
         * Main entry point: parse file and populate elements array.
         * 
         * @throws Error if parsing fails
         */
        public async void parse() throws GLib.Error {
            // implementation
        }
    }
}
```

**Vectorized Document:**
```
method: parse
Namespace: OLLMvector.Indexing
Class: Tree
Access: public
File: libocvector/Indexing/Tree.vala
Lines: 66-106
Signature: public async void parse() throws GLib.Error
Description: Main entry point: parse file and populate elements array. Throws Error if parsing fails.
Code:
public async void parse() throws GLib.Error
{
    // implementation
}
```

### 3. Simple Property (Skip LLM)

**Example:**
```vala
namespace OLLMvector.Indexing {
    public class Tree : Object {
        public OLLMfiles.File file { get; private set; }
    }
}
```

**Vectorized Document:**
```
property: file
Namespace: OLLMvector.Indexing
Class: Tree
Access: public
File: libocvector/Indexing/Tree.vala
Lines: 32-32
Signature: public OLLMfiles.File file { get; private set; }
Code:
public OLLMfiles.File file { get; private set; }
```

**Note:** No "Description:" field - simple properties skip LLM analysis.

### 4. Complex Property (Use LLM)

**Example:**
```vala
namespace OLLMvector.Indexing {
    public class Tree : Object {
        /**
         * Array of VectorMetadata objects extracted from the AST.
         * This is populated by the parse() method after AST traversal.
         */
        public Gee.ArrayList<VectorMetadata> elements { 
            get; 
            private set; 
            default = new Gee.ArrayList<VectorMetadata>(); 
        }
    }
}
```

**Vectorized Document:**
```
property: elements
Namespace: OLLMvector.Indexing
Class: Tree
Access: public
File: libocvector/Indexing/Tree.vala
Lines: 37-37
Signature: public Gee.ArrayList<VectorMetadata> elements { get; private set; default = new Gee.ArrayList<VectorMetadata>(); }
Description: Array of VectorMetadata objects extracted from the AST. This is populated by the parse() method after AST traversal.
Code:
public Gee.ArrayList<VectorMetadata> elements { get; private set; default = new Gee.ArrayList<VectorMetadata>(); }
```

### 5. Enum Type without Documentation (Skip LLM)

**Example:**
```vala
namespace OLLMmarkdown {
    private enum FormatType {
        NONE,
        ITALIC,
        BOLD
    }
}
```

**Vectorized Document:**
```
enum_type: FormatType
Namespace: OLLMmarkdown
Access: private
File: libocmarkdown/Parser.vala
Lines: 51-83
Signature: private enum FormatType
Code:
private enum FormatType {
    NONE,
    ITALIC,
    BOLD,
    // ... other values
}
```

**Note:** No "Description:" field - enum types without documentation skip LLM analysis.

### 6. Enum Type with Documentation (Use LLM)

**Example:**
```vala
namespace OLLMmarkdown {
    /**
     * Format types for markdown text formatting.
     * Used to track inline formatting like bold, italic, code spans.
     */
    private enum FormatType {
        NONE,
        ITALIC,
        BOLD
    }
}
```

**Vectorized Document:**
```
enum_type: FormatType
Namespace: OLLMmarkdown
Access: private
File: libocmarkdown/Parser.vala
Lines: 51-83
Signature: private enum FormatType
Description: Format types for markdown text formatting. Used to track inline formatting like bold, italic, code spans.
Code:
private enum FormatType {
    NONE,
    ITALIC,
    BOLD,
    // ... other values
}
```

### 7. Enum Value

**Example:**
```vala
namespace OLLMmarkdown {
    private enum FormatType {
        NONE,
        ITALIC,
        BOLD
    }
}
```

**Vectorized Document:**
```
enum: FormatType.NONE
Namespace: OLLMmarkdown
File: libocmarkdown/Parser.vala
Lines: 52-52
Signature: NONE
Code:
NONE
```

**Note:** Enum values always skip LLM analysis - they're just identifiers.

### 8. Field

**Example:**
```vala
namespace OLLMvector.Indexing {
    public class Tree : Object {
        private TreeSitter.Parser parser = new TreeSitter.Parser();
    }
}
```

**Vectorized Document:**
```
field: parser
Namespace: OLLMvector.Indexing
Class: Tree
Access: private
File: libocvector/Indexing/Tree.vala
Lines: 44-44
Signature: private TreeSitter.Parser parser = new TreeSitter.Parser();
Code:
private TreeSitter.Parser parser = new TreeSitter.Parser();
```

**Note:** Fields skip LLM analysis unless they have documentation.

### 9. Function (Top-Level)

**Example:**
```vala
namespace OLLMvector.Indexing {
    /**
     * Helper function to extract code snippet from file.
     * 
     * @param file The file to read from
     * @param start_line Starting line number
     * @param end_line Ending line number
     * @return Code snippet as string
     */
    public string extract_snippet(OLLMfiles.File file, int start_line, int end_line) {
        // implementation
    }
}
```

**Vectorized Document:**
```
function: extract_snippet
Namespace: OLLMvector.Indexing
Access: public
File: libocvector/Indexing/Tree.vala
Lines: 203-216
Signature: public string extract_snippet(OLLMfiles.File file, int start_line, int end_line)
Description: Helper function to extract code snippet from file. Returns code snippet as string.
Parameters: file: OLLMfiles.File, start_line: int, end_line: int
Returns: string
Code:
public string extract_snippet(OLLMfiles.File file, int start_line, int end_line) {
    // implementation
}
```

### 10. Method with Parameters

**Example:**
```vala
namespace OLLMvector.Indexing {
    public class Tree : Object {
        /**
         * Extract string from lines array using Vala string range syntax.
         * 
         * @param start_line Starting line number (1-indexed)
         * @param end_line Ending line number (1-indexed, exclusive)
         * @return Code snippet or documentation text
         */
        public string lines_to_string(int start_line, int end_line) {
            // implementation
        }
    }
}
```

**Vectorized Document:**
```
method: lines_to_string
Namespace: OLLMvector.Indexing
Class: Tree
Access: public
File: libocvector/Indexing/Tree.vala
Lines: 203-216
Signature: public string lines_to_string(int start_line, int end_line)
Description: Extract string from lines array using Vala string range syntax. Returns code snippet or documentation text.
Parameters: start_line: int, end_line: int
Returns: string
Code:
public string lines_to_string(int start_line, int end_line) {
    // implementation
}
```

## Decision Rules

### Skip LLM Analysis When:
1. **Enum types** without documentation (`codedoc_start == -1`)
2. **Simple properties** (properties with only get/set accessors, no default value logic, no documentation)
3. **Enum values** (always skip - they're just identifiers)
4. **Fields** without documentation
5. **Delegates** without documentation

### Use LLM Analysis When:
1. **Classes, structs, interfaces** (always use LLM)
2. **Methods, functions** (always use LLM)
3. **Properties with documentation** (`codedoc_start > 0`)
4. **Properties with complex default values** (default = expression, not just literal)
5. **Enum types with documentation** (`codedoc_start > 0`)
6. **Fields with documentation**

## Format Notes

- **Namespace**: Always included if element is in a namespace
- **Class**: Included for methods, properties, fields that belong to a class
- **Access**: Included if element has access modifier (public, private, etc.)
- **Signature**: Always included - shows the full declaration
- **Description**: Only included if LLM analysis was performed
- **Parameters**: Only for methods/functions with parameters
- **Returns**: Only for methods/functions with return types (not void)
- **Code**: Always included - the actual code snippet

