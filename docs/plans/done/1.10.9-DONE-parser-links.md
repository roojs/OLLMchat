# Parser of links (1.10.9)

**DO NOT start changing the code base until all of this plan is approved.**

- **Plan style:** When adding to this plan, use only nested bullet points. Do not add long sentences or paragraphs.
- **Goal:**
  - Parse markdown links (inline `[text](url)` and reference-style `[text][ref]` / `[text][]`).
  - Emit parser events so the renderer can display link text and use the URL for click/hover.
- **Current:**
  - Links are not parsed.
  - Renderer's `on_a()` is a stub (see plan 1.10.10 for rendering).
- **Status:** open.

---

## Goal

- Parse markdown links:
  - **Inline:** `[link text](url)` and optional `[link text](url "title")`.
  - **Reference-style:** `[text][ref]` and `[text][]` (ref empty = use link text as ref).
- Emit (same for both styles):
  - `on_a(true, href, title, is_reference)` — for reference-style, **href** is the reference label (not the URL); **is_reference** is true so the consumer can resolve the ref to a URL. The parser does **not** resolve reference targets.
  - `on_text(link_text)` (the content between `[` and `]`)
  - `on_a(false, href, title, is_reference)`
- **Reference-style:**
  - Parser only parses syntax and emits; does **not** resolve link reference definitions.
  - For `[text][ref]` or `[text][]`: emit **is_reference = true**, **href =** ref label (or normalized link text for `[]`).
  - Consumer (e.g. renderer) resolves the label to a URL if it has definitions.

---

## Investigation: two passes and eat() — short vs longer format

- **Current behaviour:**
  - **MarkerMap.eat()** and **FormatMap** use exact string keys: `[`, `[x`, `[X`, `[ `, `[ ]`, `[x]`, `[X]`.
  - No wildcard.
- **Short vs long:**
  - For `[`: `mp["["] = INVALID` → 1‑char match is INVALID, does not update `max_match_length`.
  - For `[ ]`: exact 3‑char key → TASK_LIST.
  - For `[a`: loop builds sequence `"[a]"`; `map.has_key("[a]")` is false → eat() returns `max_match_length` (0).
  - **eat() has an early return:** `if (last_char.isalpha() && last_char.tolower() != 'x') return max_match_length;`
  - So after the second character `a` we never get to a third character; we never consider a 3‑char sequence like `[ab` for a link.
- **Implication:**
  - Option (1): extend format/eat path with a **wildcard** so a 3‑char "link start" can be recognised (e.g. `[??` = `[` + any + any).
  - Option (2): handle links entirely in the parser when we see `[` and eat() gives no match.
  - This plan chooses (1): add a **lead match** `[??` (3 chars, `?` = any character), **real characters matched first** (exact keys `[ ]`, `[x]`, `[X]` take precedence), and do the rest in the **handler** for that format type.

---

## Lead match: `[??` (3 chars, `?` = any character)

- **Wildcard:**
  - We do **not** have wildcarding in the map today.
  - Use **`?` to mean "any character"** in the key.
  - Link **lead match** = **`[??`** — same length as other 3‑char markers (e.g. `***`, `[ ]`, `[x]`).
- **`[?` (2 chars) = indeterminate / need more characters:**
  - With 2 chars starting with `[`, we cannot yet tell if the third char will be task list (`[ ]`, `[x]`, `[X]`) or link (`[??`).
  - So **open bracket + any character** (including `[x`, `[X`, `[ `) is indeterminate.
  - Add key **`[?`** (2 chars, `?` = any); when matched, **eat() returns -1** so the parser defers.
  - We **don't need** separate exact 2‑char keys for `[x`, `[X`, `[ `` — wildcard `[?` covers them.
- **Real characters first:**
  - Exact keys must win.
  - When the 3‑char sequence is `[ ]`, `[x]`, or `[X]` → use TASK_LIST / TASK_LIST_DONE as now.
  - Only when there is **no exact key** for the current 3‑char sequence do we try a key that contains `?`.
  - If the key is `[??`: match when first character is `[` and the next two are any characters (so `[ab`, `[xy`, etc. match; `[ ]`, `[x]`, `[X]` already matched by exact keys).
- **`[` is "incomplete":**
  - In the code, `[` alone is INVALID.
  - We do **not** want to treat a single `[` as the start of a link.
  - **Minimum** commit is 3 characters: `[??`.
  - Lead match = exactly 3 characters; the rest of the link is parsed in the **handler** (see below).

- **Implementation in MarkerMap / FormatMap:**

- **FormatMap:**
  - Add FormatType `LINK` and key `"[??"` mapped to it.
  - Add **`[?`** (2 chars): indeterminate; eat() returns -1 when matched.
  - No separate 2‑char exact keys for `[x` / `[X` / `[ ` — wildcard `[?` covers them.
  - Keys may contain `?` = "match any character" at lookup.
- **MarkerMap.eat():**
  - **Wildcard sequence:** Build in parallel with `sequence`; alphabetic → `"?"`, else same as sequence (e.g. `[a` → `[?`, `[ab` → `[??`).
  - **Two lookups:** (1) `map.has_key(sequence)`; (2) `map.has_key(wildcard_sequence)`.
  - If wildcard returns INVALID → return -1 (need more chars).
  - Otherwise use matched type and length.
  - **Remove** alpha early-return from before lookups; run it **after** lookups so we can build `[a` / `[ab`. The alpha early-return runs **after** the two lookups (so we still bail for non-wildcard alpha when there’s no match).

---

## Handler for link format: three outcomes

- **Context:** When eat() returns a match for LINK (the `[??` lead), the parser has consumed **3 bytes** (the opening `[` and two "any" characters). The **handler** (code that runs for this format type, analogous to HTML or block handling) must then parse the rest of the link.
- **Three possible outcomes:**
  1. **Not completed yet:** We don't have enough input to decide (e.g. chunk ends before we see `]` or `](`).
     - → Set **leftover_chunk** and return (like HTML or fenced blocks).
  2. **No match:** We have enough input to see it's not a link (e.g. newline before `](`, or the pattern doesn't match).
     - → Treat the 3 consumed characters as literal (emit as text; do not open a link).
     - Optionally backtrack chunk_pos or re‑emit the 3 chars.
  3. **Match:** We find either:
     - **Inline:** `](url)` or `](url "title")` → parse link text, destination, optional title. Emit with **is_reference = false**; href = URL.
     - **Reference-style:** `][ref]` or `][]` → parse link text and ref label (empty ref = use normalized link text as ref). Emit with **is_reference = true**, **href = ref label**. Parser does **not** resolve the ref to a URL.
     - FormatMap has parser reference (2a). **handle_link(chunk, chunk_pos, seq_pos, end_offset)** extracts link_text, href, title, is_reference, then calls **parser.renderer.on_a(true, ...)**, **parser.process_inline(link_text)**, **parser.renderer.on_a(false, ...)**. No delegates; FormatMap calls the parser it holds.
  - Regex (or character rules) once past the third character can match either inline or reference-style in one pass.
- **Where:** In the format-handling path: process result of formatmap.eat() when matched type is LINK (same pattern as HTML after eat() returns HTML).
- **Design rule:** FormatMap holds parser (2a). When a link is found, FormatMap **handle_link** extracts and then calls parser to emit and process_inline. No delegates.
- **Same rule for table:** TableState already holds the parser (constructor). When emitting cell content, TableState calls **parser.process_inline(cells[i])** as a regular method (5e). So both FormatMap (handle_link) and TableState (emit_row) call **parser.process_inline(text)** as a regular method when they need inline content processed. No delegates anywhere.

---

## Line break and formatting

- **Intended behaviour (inline format vs newline):**
  - On newline we call **handle_line_break**.
  - It should: (1) **Reset state_stack** — close any open bold, italic, code span (CommonMark: inline scoped per block). (2) Flush text (`str`), end current block, send newline as text.
  - So: **reset state_stack on newline, before we reset/clear the block.**
- **Current behaviour (to fix):** handle_line_break does **not** clear state_stack today; only **start()** does. Add step 1 above.
- **For links:**
  - Line break **before `](`** → link did not complete.
  - In link handler: **newline before `](`** = "no match" — emit consumed chars as literal text; do not open a link.
  - End of chunk and next chunk might have `](url)` → "incomplete". Newline before `](` → definitive "no match."

---

## Characters allowed in link text and URL

- CommonMark specifies link label (link text), link destination (URL), and reference label in section 6.3.
- For a simple implementation, **use GLib.Regex** (no character loops):
  - Link text: e.g. characters until `]` (with escaped `]` allowed).
  - **Inline:** URL = either `<...>` or a restricted set (no unescaped spaces, no `)`).
  - **Reference-style:** Ref label after `][` until `]` (with escaped `]` allowed); empty `][]` = use link text as ref.
- Align with CommonMark 6.3 where practical.

---

## Interaction with task list

- FormatMap already has `[`, `[x`, `[X`, `[ `, `[ ]`, `[x]`, `[X]`.
- We add **`?`** as **indeterminate (need more characters)**:
  - **`[?`** (2 chars): matches **open bracket + any character** (including x, X, space). When matched, eat() returns **-1** so the parser defers. We **don't need** separate 2‑char exact keys for `[x`, `[X`, `[ ` — they're indeterminate anyway, so the wildcard `[?` covers them all.
- For **3 chars**, matching **real characters first** (exact keys) ensures that `[ ]`, `[x]`, `[X]` are always TASK_LIST / TASK_LIST_DONE.
- The wildcard `[??` is only used when the 3‑char sequence is **not** one of those.
- Task list behaviour is unchanged.

---

## Implementation

- **Chosen approach:** extend FormatMap / MarkerMap eat() (lead match + handler). Do **not** add link parsing inline in Parser.add — add is already too large.
- Add `[??` as 3‑char wildcard key in FormatMap (LINK).
- Extend MarkerMap.eat() to support wildcard; allow building 3 chars when prefix is `[`.
- When eat() returns LINK, handler implements: incomplete (leftover_chunk), no match (emit 3 chars as text), or match (parse full link, emit on_a / on_text / on_a).
- Don't change current design where already approved. For **new** link-parsing code: use **GLib.Regex** for link destination/title and for finding link extent; no character loops (CODING_STANDARDS.md). See CommonMark 6.3.

---

## Concrete code (for review and approval)

All changes below are the exact code to apply. Implementation must not deviate from these.

**Code must follow** `.cursor/rules/CODING_STANDARDS.md`:
- Brace style: inline for control structures.
- `this.` for instance members.
- No character loops; use `GLib.Regex` or string methods.
- `Gee.HashMap` via `.set()` / `.get()`.
- No one-line if-with-body; avoid nullable where possible.

### 1. FormatType enum (libocmarkdown/Parser.vala)

Add one enum value:

- **After `TASK_LIST_DONE`:** `LINK` (wildcard `"[??"` → link lead match).

- `"[?"` (2 chars, need more) uses existing **INVALID**; when that wildcard matches, eat() returns -1.
- No new enum for need-more.

```vala
		// ... unchanged ...
		TASK_LIST,
		TASK_LIST_DONE,
		LINK,
		DEFINITION_LIST,
```

### 2. FormatMap init (libocmarkdown/FormatMap.vala)

- **Remove** 2-char task-list keys `[x`, `[X`, `[ `` — wildcard `[?` covers "open bracket + any"; eat() returns -1 for those.
- **Keep** `[` (INVALID) and 3-char exact keys `[ ]`, `[x]`, `[X]` for TASK_LIST / TASK_LIST_DONE.
- **Add** link wildcard keys `[?` and `[??`.

Replace the existing task-list block (use `Gee.HashMap` `.set()` per CODING_STANDARDS) with the block in §2 below.

### 2a. Parser and FormatMap construction

- **Parser** creates FormatMap in its constructor and passes itself so FormatMap can hold a reference to the parser. FormatMap **handle_link** extracts link data then calls **parser.renderer.on_a**, **parser.process_inline(link_text)**, **parser.renderer.on_a**. No delegates.
- **Concrete code:**

**Parser (libocmarkdown/Parser.vala):** Remove default from formatmap property; assign in constructor:

```vala
		public FormatMap formatmap { get; set; }

		public Parser(RenderBase renderer)
		{
			this.renderer = renderer;
			this.formatmap = new FormatMap(this);
		}
```

**FormatMap (libocmarkdown/FormatMap.vala):** Add field and constructor argument; store weak reference to parser:

```vala
		private weak Parser? parser;

		public FormatMap(Parser parser)
		{
			FormatMap.init();
			base(FormatMap.mp);
			this.parser = parser;
		}
```

### 2b. FormatMap task-list and link keys

Replace the existing task-list block with:

```vala
			// Task list checkboxes: [ ], [x], [X] (GFM). Link lead: "[?" → eat() -1; "[??" → LINK
			mp.set("[", FormatType.INVALID);
			mp.set("[?", FormatType.INVALID);
			mp.set("[??", FormatType.LINK);
			mp.set("[ ]", FormatType.TASK_LIST);
			mp.set("[x]", FormatType.TASK_LIST_DONE);
			mp.set("[X]", FormatType.TASK_LIST_DONE);

			mp.set("<", FormatType.HTML);
```

### 3. MarkerMap.eat() (libocmarkdown/MarkerMap.vala)

**3a. Full existing loop** (for context). Current loop body and what follows. We will add `wildcard_sequence = ""` before the loop and build it each iteration (alpha → `"?"`, else same as sequence); see 3b/3c.

```vala
			for (var cp = chunk_pos; cp < chunk.length; ) {
				var char_at_cp = chunk.get_char(cp);
				sequence += char_at_cp.isdigit() ? "1" : char_at_cp.to_string();
				cp += char_at_cp.to_string().length;
				char_count++;

				var last_char = char_at_cp;
				if (last_char.isalpha() && last_char.tolower() != 'x') {
					return max_match_length;
				}

				if (!map.has_key(sequence)) {
					return max_match_length;
				}

				matched_type = map.get(sequence);

				if (matched_type != FormatType.INVALID) {
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
				}
			}

			// Reached end of chunk (no more characters to eat)
			if (!is_end_of_chunks) {
				// Wildcard INVALID (e.g. "[?") means need more characters to decide
				if (map.has_key(wildcard_sequence) && map.get(wildcard_sequence) == FormatType.INVALID) {
					return -1;
				}
				// Longest possible format marker for * and _ is 3 chars (BOLD_ITALIC)
				if (char_count >= 3) {
					return max_match_length;
				}
				return -1;
			}
			return max_match_length;
```

**3b. Change: maintain a wildcard sequence (starts blank) and do two lookups.**
- Key is the **alpha check (lines 210–212)**: don't return early for alpha; use it to build a **wildcard match string** in parallel with `sequence`.
- **Two lookups:** (1) regular — `map.has_key(sequence)`; (2) wildcard — `map.has_key(wildcard_sequence)`.
- When wildcard returns INVALID → **continue** (let the loop eat another character).
- When we **exit the loop** with no more characters and wildcard match is INVALID → return -1.

- **Wildcard sequence:** Start blank (`wildcard_sequence = ""`). Each time we append to `sequence`, append to `wildcard_sequence`: if the character is alphabetic append `"?"`, else same as `sequence` (digit → `"1"`, else the char). So `wildcard_sequence` is `sequence` with every alphabetic char replaced by `?` (e.g. `[a` → `[?`, `[ab` → `[??`).
- **Remove the alpha early-return** from its current place so we can build 2- and 3-char sequences like `[a` and `[ab`.
- **First lookup:** `map.has_key(sequence)`. If found, set matched_type; if INVALID `continue`, else update max_match_length / byte_length and `continue`.
- **Second lookup:** `map.has_key(wildcard_sequence)`. If found, set matched_type = map.get(wildcard_sequence). If INVALID, **continue** (let the loop eat another character). Else update max_match_length / byte_length and **break** (exit loop; end-of-loop returns max_match_length).
- **Then** the alpha early-return: if we didn’t match and `last_char.isalpha() && last_char.tolower() != 'x'`, return max_match_length.
- **End of loop (reached end of chunk):** When we have no more characters to eat, do the **wildcard check** as well: if `!is_end_of_chunks` and `map.has_key(wildcard_sequence)` and `map.get(wildcard_sequence) == FormatType.INVALID`, return -1 (need more characters). Then the existing logic (char_count >= 3 → return max_match_length, else return -1).

**3c. Concrete change.**

1. **Before the loop** (with `sequence = ""`), add `wildcard_sequence = ""`.
2. **In the loop**, when appending to `sequence`, also append to `wildcard_sequence`: alphabetic → `"?"`, else same as `sequence` (digit → `"1"`, else char). So: `wildcard_sequence += char_at_cp.isalpha() ? "?" : (char_at_cp.isdigit() ? "1" : char_at_cp.to_string());`
3. **Replace** the block from `var last_char` through `matched_type = map.get(sequence);` and the INVALID check with:

```vala
				var last_char = char_at_cp;
				wildcard_sequence += char_at_cp.isalpha() ? "?" : (char_at_cp.isdigit() ? "1" : char_at_cp.to_string());

				if (map.has_key(sequence)) {
					matched_type = map.get(sequence);
					if (matched_type == FormatType.INVALID) {
						continue; // e.g. "[" alone: keep building to try "[a", "[ ]", etc.
					}
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
					continue; // try next char for longer match (e.g. * → ** → ***)
				}
				if (map.has_key(wildcard_sequence)) {
					matched_type = map.get(wildcard_sequence);
					if (matched_type == FormatType.INVALID) {
						continue; // let the loop eat another character
					}
					max_match_length = char_count;
					byte_length = cp - chunk_pos;
					break; // exit loop; end-of-loop returns max_match_length
				}
				if (matched_type != FormatType.NONE) {
					break;
				}
				if (last_char.isalpha() && last_char.tolower() != 'x') {
					return max_match_length;
				}
				return max_match_length;
```

So we **remove** the alpha early-return from the top; we **add** building `wildcard_sequence` each iteration; we do **two** lookups (regular, then wildcard). When wildcard match is INVALID we **continue** (let the loop eat another character). **4. Modify the end of the loop** (“Reached end of chunk”): when `!is_end_of_chunks`, first check `map.has_key(wildcard_sequence) && map.get(wildcard_sequence) == FormatType.INVALID` → return -1; then the existing logic (char_count >= 3 → return max_match_length, else return -1).

We must **not** return early for alpha before trying lookups, so we can build 2- and 3-char sequences like `[a` and `[ab`. The alpha early-return runs only after we've tried exact match and the built lookup key; so we remove it from its current place (before the `has_key` check) and keep it at the end of the block above.

No `wildcard_key_matches` helper — we build a lookup key (first char + `?` / `??` when 2nd/3rd are alpha) and do a normal map lookup. Old **3b. Helper:** `wildcard_key_matches(key, sequence)` (no longer used) — same character length; at each position, key’s character is `?` (matches any) or equals sequence’s character. Used only for the two fixed keys `"[?"` and `"[??"` (2–3 chars), so a short position-wise check is appropriate.

(No separate helper — we maintain wildcard_sequence and do two normal map lookups.)

### 4. handle_line_break — reset state_stack (libocmarkdown/Parser.vala)

In `handle_line_break`, after the two early returns (fenced code, table) and before flushing `str`, reset the formatting stack. Insert **before** `if (str != "")`:

```vala
			// Reset inline formatting so next block starts clean (CommonMark: inline scoped per block)
			this.state_stack.clear();
			if (str != "") {
```

### 5. handle_format_result — LINK branch (libocmarkdown/Parser.vala)

After flushing `str` and computing `seq_pos` (loop that advances past `match_len` characters), **before** `if (matched_format != FormatType.HTML)`:
- Call **eat_link** (parse/consume only; no renderer). If matched (>0), call **formatmap.handle_link(chunk, chunk_pos, seq_pos, link_result)**; FormatMap extracts and calls parser.renderer.on_a, parser.process_inline(link_text), parser.renderer.on_a. Then advance `chunk_pos`.

**eat_link return convention** (standard -1 / 0 / >0):
- **-1** = need more — caller sets `leftover_chunk` and returns true.
- **0** = no match — caller emits the 3 lead chars as text, sets `chunk_pos = seq_pos`, returns false.
- **>0** = matched — byte offset after the consumed link. Caller calls **formatmap.handle_link(chunk, chunk_pos, seq_pos, link_result)**; FormatMap does extract + on_a + process_inline + on_a using its parser reference. Caller then sets `chunk_pos = link_result`, returns false.

```vala
			if (matched_format == FormatType.LINK) {
				var link_result = this.formatmap.eat_link(chunk, chunk_pos, seq_pos, is_end_of_chunks);
				if (link_result == -1) {
					this.leftover_chunk = chunk.substring(chunk_pos, chunk.length - chunk_pos);
					return true;
				}
				if (link_result == 0) {
					this.renderer.on_text(chunk.substring(chunk_pos, seq_pos - chunk_pos));
					chunk_pos = seq_pos;
					return false;
				}
				this.formatmap.handle_link(chunk, chunk_pos, seq_pos, link_result);
				chunk_pos = link_result;
				return false;
			}
```

### 5a. process_inline (libocmarkdown/Parser.vala)

**Purpose:** Parse a string as inline only (no block handling). Used for link text and table cells. Uses formatmap.eat(), on_text, got_format, add_html; escape and code-span literal (5b2); at end pops state_stack and emits closing format callbacks.

**Concrete code** (add this public method to Parser, e.g. before do_block):

```vala
		/**
		 * Parse a string as inline only (no block handling). Uses formatmap.eat(), on_text, got_format, add_html;
		 * escape and code-span literal as in main parser; at end pops state_stack and emits closing format callbacks.
		 * Used for link text and table cells.
		 */
		public void process_inline(string text)
		{
			var pos = 0;
			var str = "";
			while (pos < text.length) {
				// Escape: \ + next char → emit next as literal, advance by 1 + next char byte length
				if (text.get_char(pos) == '\\' && pos + 1 < text.length) {
					this.renderer.on_text(str);
					str = "";
					this.renderer.on_text(text.get_char(pos + 1).to_string());
					pos += 1 + text.get_char(pos + 1).to_string().length;
					continue;
				}
				var matched_format = FormatType.NONE;
				var byte_length = 0;
				var match_len = this.formatmap.eat(text, pos, true, out matched_format, out byte_length);
				// Code-span literal: inside LITERAL/CODE, only same format closes
				if (this.state_stack.size > 0) {
					var top = this.state_stack.get(this.state_stack.size - 1);
					if ((top == FormatType.LITERAL || top == FormatType.CODE) && matched_format != top) {
						match_len = 0;
					}
				}
				if (match_len == -1) {
					this.renderer.on_text(str);
					str = "";
					var c = text.get_char(pos);
					this.renderer.on_text(c.to_string());
					pos += c.to_string().length;
					continue;
				}
				if (match_len == 0) {
					var c = text.get_char(pos);
					str += c.to_string();
					pos += c.to_string().length;
					continue;
				}
				this.renderer.on_text(str);
				str = "";
				if (matched_format == FormatType.LINK) {
					// Inline context (e.g. table cell): try full link; if no match, emit 3 chars as literal.
					var seq_pos = pos + byte_length;
					var link_result = this.formatmap.eat_link(text, pos, seq_pos, true);
					if (link_result == -1) {
						var c = text.get_char(pos);
						this.renderer.on_text(c.to_string());
						pos += c.to_string().length;
						continue;
					}
					if (link_result == 0) {
						this.renderer.on_text(text.substring(pos, byte_length));
						pos += byte_length;
						continue;
					}
					this.formatmap.handle_link(text, pos, seq_pos, link_result);
					pos = link_result;
					continue;
				}
				if (matched_format != FormatType.HTML) {
					this.got_format(matched_format);
					pos += byte_length;
					continue;
				}
				var sub = text.substring(pos + byte_length);
				var rest = this.add_html(sub);
				pos += byte_length + (sub.length - rest.length);
			}
			for (var i = this.state_stack.size - 1; i >= 0; i--) {
				this.do_format(false, this.state_stack.get(i));
			}
			this.state_stack.clear();
			if (str != "") {
				this.renderer.on_text(str);
			}
		}
```

### 5b. Inner link content: same path as table cell content

- **Purpose:**
  - Link text (e.g. `[**bold**](url)`) parsed as inline content.
  - Bold, italic, etc. emitted between `on_a(true)` and `on_a(false)` — not raw `on_text(link_text)`.
- **Same rule for both:** **process_inline** is a regular method on Parser. Whoever needs inline content processed holds the parser and calls **parser.process_inline(text)**:
  - **FormatMap** (handle_link): holds parser (2a); calls **this.parser.process_inline(link_text)** (5d).
  - **TableState** (emit_row): holds parser (constructor); calls **this.parser.process_inline(cells[i])** (5e). Remove **process_cell**; use parser.process_inline as the single path.
- **Shared method:**
  - Parser has **process_inline(string text)** (5a).
  - TableState **emit_row** → **parser.process_inline(cells[i])** (5e) — regular method call.
  - FormatMap **handle_link** → **this.parser.process_inline(link_text)** (5d) — regular method call.
- **Two behaviours:**
  - (1) **eat_link** rejects when link text contains `[` (return 0) → from handle_link, link_text never has `[` → we never see LINK there.
  - (2) **process_inline** when matched_format == LINK: eat_link on remainder; if match → handle_link and advance; if no match → emit 3 chars as literal.
  - Table cells (and any inline context) parse full links; link text stays `[`-free.

### 5b2. process_inline: other gaps (escapes, code span)


- **Required for 1.10.9:** (1) backslash escape, (2) code-span literal mode.
- **1. Escaped characters:**
  - Main parser: `\` sets `escape_next`; next char emitted as literal, format skipped (Parser.vala ~298–310).
  - process_inline: no `\` handling → `\*` becomes literal `\` + start italic.
  - **Fix:** Before eat(): if current char is `\` and next exists → flush str, emit next char as literal, advance by 2, continue.
- **2. Code span literal mode:**
  - Main parser: inside `` ` `` (LITERAL) or `` `` `` (CODE), only same format closes; rest literal (~323–326).
  - process_inline: no such rule → `` `foo *bar*` `` would open italic inside span.
  - **Fix:** After eat(): if state_stack top is LITERAL or CODE and matched_format != top → set match_len = 0 (match_len == 0 branch).

- **Other inline (not required this plan):**
  - Images `![alt](url)` — no IMAGE in FormatMap.
  - Autolinks `<url>` — HTML path (add_html).
  - Hard line breaks — block/line context; single-string could define later.
  - Entity refs — inside HTML.
- **Concrete fixes for 5a:**
  - **Escape:** Before eat(): if `text.get_char(pos) == '\\'` and `pos + 1 < text.length` → flush str, `this.renderer.on_text(text.get_char(pos + 1).to_string())`, advance pos by 2 (byte length of `\` + next char), continue.
  - **Code-span literal:** After `match_len = this.formatmap.eat(...)` and before using it: if `state_stack.size > 0`, `top = state_stack.get(size - 1)`; if `top == LITERAL` or `top == CODE` and `matched_format != top` → set `match_len = 0`.

### 5c. Link callback: remove is_autolink, add is_reference (libocmarkdown/RenderBase.vala and all renderers)

**Purpose:** The parser does not resolve reference targets. For reference-style links it emits the **ref label** as href and **is_reference = true** so the consumer (e.g. renderer) can resolve the ref to a URL if it has link reference definitions.

- **API change:** Remove **is_autolink** (irrelevant for the renderer; autolink `<url>` is a separate syntax not parsed here). Add **is_reference**.
- **Signature:** `on_a(bool is_start, string href, string title, bool is_reference)`
  - **is_reference:** true for reference-style `[text][ref]` / `[text][]`; then **href** is the reference label (not the URL). Consumer resolves if needed.

**Concrete code:** In each file, replace the `on_a` signature and any use of the fourth parameter:

**libocmarkdown/RenderBase.vala:** Replace the virtual declaration:

```vala
		public virtual void on_a(bool is_start, string href, string title, bool is_reference) {}
```

**libocmarkdown/HtmlRender.vala:** Replace the override and any use of the fourth parameter (e.g. in body use `is_reference` instead of `is_autolink`):

```vala
		public override void on_a(bool is_start, string href, string title, bool is_reference)
```

**libocmarkdown/PangoRender.vala:** Same: `on_a(bool is_start, string href, string title, bool is_reference)` and use `is_reference` in body.

**libocmarkdown/DummyRenderer.vala:** Replace signature and printf format (e.g. `is_reference=%s` instead of `autolink=%s`):

```vala
		public override void on_a(bool is_start, string href, string title, bool is_reference)
		{
			// ... in body use is_reference instead of is_autolink in any printf/log
		}
```

**libocmarkdowngtk/Render.vala:** Replace the override: `on_a(bool is_start, string href, string title, bool is_reference)`; update doc comment to say `@param is_reference Whether this is a reference-style link (href is ref label)`.

### 5d. handle_link — FormatMap extracts and calls parser (libocmarkdown/FormatMap.vala)

**Purpose:** FormatMap holds parser (2a). **handle_link(chunk, chunk_pos, seq_pos, end_offset)** extracts link_text, href, title, is_reference, then calls **this.parser.renderer.on_a(true, href, title, is_reference)**, **this.parser.process_inline(link_text)**, **this.parser.renderer.on_a(false, href, title, is_reference)**. No delegates; FormatMap uses its parser reference.

- **eat_link** returns -1 / 0 / >0 (extent only).
- **Parser** (or process_inline) when eat_link returns >0: calls **formatmap.handle_link(chunk, chunk_pos, seq_pos, link_result)**; FormatMap does the rest. Caller then advances chunk_pos / pos.

- **Concrete call:** Already in §5 (handle_format_result LINK branch) and §5a (process_inline LINK branch).

### 5e. TableState — inline cell content through parser (libocmarkdown/TableState.vala)

**Purpose:** Use the same inline path as link text. Remove the **process_cell** method entirely and call **parser.process_inline(cell_text)** directly where cell content is emitted.

**Concrete code:**

1. **Remove** the entire **process_cell** method (the full inline loop and the method).
2. In **emit_row**, where we currently call `this.process_cell(cells[i])`, call **this.parser.process_inline(cells[i])** instead:

```vala
		// In emit_row, for each cell:
		if (is_header) {
			this.parser.renderer.on_table_hcell(true, align);
		} else {
			this.parser.renderer.on_table_cell(true, align);
		}
		this.parser.process_inline(cells[i]);
		if (is_header) {
			this.parser.renderer.on_table_hcell(false, align);
		} else {
			this.parser.renderer.on_table_cell(false, align);
		}
```

### 6. eat_link and handle_link (libocmarkdown/FormatMap.vala)

- FormatMap holds parser (2a). **handle_link** extracts link data then calls **this.parser.renderer.on_a**, **this.parser.process_inline(link_text)**, **this.parser.renderer.on_a**. No delegates.
- **eat_link:** `public int eat_link(...)` — returns -1 need more, 0 no match, >0 byte offset after the consumed link.
- **handle_link:** `public void handle_link(string chunk, int chunk_pos, int seq_pos, int end_offset)` — extracts link_text, href, title, is_reference (same logic as below), then calls **this.parser.renderer.on_a(true, href, title, is_reference)**, **this.parser.process_inline(link_text)**, **this.parser.renderer.on_a(false, href, title, is_reference)**.
- **Shared regex:** One pattern constant **LINK_INNER_PATTERN** (destination + optional title); two lazy-initialized static Regex: **inner_link_regex** (parse inner in handle_link), **inline_link_regex** (match full `](...)` in eat_link). No try/catch needed for match.

**Concrete code:**

- **FormatMap class:** Add shared pattern constant and two static regexes (lazy-initialized; both use the same inner pattern).

```vala
		private const string LINK_INNER_PATTERN =
			"(<[^>]*>|[^\\s\"'()]+)" +
			"(?:\\s+(\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|\\([^)]*\\)))?";
		private static GLib.Regex? inner_link_regex = null;
		private static GLib.Regex? inline_link_regex = null;
```

- Add **handle_link** to FormatMap, inside the class, before the constructor. Extracts then calls parser:

```vala
		/**
		 * Extract verified link data from chunk[chunk_pos..end_offset), then emit via parser: on_a(true,...), process_inline(link_text), on_a(false,...).
		 * seq_pos = byte after the 3-char lead [??; end_offset = byte after the link (e.g. after ')' for inline, after ']' for reference).
		 * Sets is_reference true for reference-style; then href is the ref label (consumer resolves to URL).
		 */
		public void handle_link(
			string chunk,
			int chunk_pos,
			int seq_pos,
			int end_offset
		) {
			var rest = chunk.substring(seq_pos, end_offset - seq_pos);
			var close_idx = rest.index_of_char(']');
			var link_text_val = chunk.substring(chunk_pos + 1, (seq_pos + close_idx) - (chunk_pos + 1));
			var after_close = seq_pos + close_idx + 1;
			var c1 = chunk.get_char(after_close);
			var href = chunk.substring(after_close + 1, (end_offset - 1) - (after_close + 1)).strip();
			var title = "";
			var is_reference = false;
			if (c1 != '(') {
				is_reference = true;
				var ref_start = after_close + 1;
				var ref_end_byte = end_offset - 1;
				href = ref_end_byte > ref_start
					? chunk.substring(ref_start, ref_end_byte - ref_start).strip()
					: link_text_val.strip().down();
			}
			if (c1 == '(') {
				if (inner_link_regex == null) {
					inner_link_regex = new GLib.Regex(
						"^\\s*" + LINK_INNER_PATTERN + "\\s*$");
				}
				GLib.MatchInfo mi;
				if (inner_link_regex.match_full(href, -1, 0, 0, out mi)) {
					var dest = mi.fetch(1);
					href = dest.has_prefix("<") ? dest.substring(1, dest.length - 2) : dest.strip();
					var t = mi.fetch(2);
					if (t != null && t.length >= 2) {
						var raw = t.substring(1, t.length - 2);
						title = raw.replace("\\\\", "\\")
							.replace("\\\"", "\"")
							.replace("\\'", "'")
							.replace("\\" + ")", ")");
					}
				}
			}
			this.parser.renderer.on_a(true, href, title, is_reference);
			this.parser.process_inline(link_text_val);
			this.parser.renderer.on_a(false, href, title, is_reference);
		}
```

- Add **eat_link** to FormatMap, inside the class, before the constructor:

```vala
		/**
		 * Parse and consume a link after the 3-char lead [??. Only eats the chunk; does not extract strings.
		 * Caller uses returned end offset and calls handle_link(chunk, chunk_pos, seq_pos, end_offset).
		 * @return -1 need more input, 0 no match, >0 byte offset in chunk after the consumed link
		 */
		public int eat_link(
			string chunk,
			int chunk_pos,
			int seq_pos,
			bool is_end_of_chunks
		) {
			var rest = chunk.substring(seq_pos, chunk.length - seq_pos);
			var close_idx = rest.index_of_char(']');
			if (close_idx == -1) {
				if (!is_end_of_chunks) {
					return -1;
				}
				return 0;
			}
			// Newline inside link text [..\n..] → not a link (CommonMark); return no match. Newline after the link is valid (no check).
			if (rest.substring(0, close_idx).index_of_char('\n') != -1) {
				return 0;
			}
			// Link text containing '[' → reject (so process_inline(link_text) never sees LINK; table cells still parse links via LINK branch below).
			if (rest.substring(0, close_idx).index_of_char('[') != -1) {
				return 0;
			}
			var after_close = seq_pos + close_idx + 1;
			if (chunk.length - after_close < 2) {
				if (!is_end_of_chunks) {
					return -1;
				}
				return 0;
			}
			var c1 = chunk.get_char(after_close);
			if (c1 != '(' && c1 != '[') {
				return 0;
			}
			if (c1 == '(') {
				// Match full inline link ](dest "title") or ](dest 'title') or ](dest (title)) with regex; no character loop
				if (inline_link_regex == null) {
					inline_link_regex = new GLib.Regex(
						"^\\s*\\(" + LINK_INNER_PATTERN + "\\s*\\)");
				}
				var rest_link = chunk.substring(after_close, chunk.length - after_close);
				GLib.MatchInfo mi;
				if (inline_link_regex.match_full(rest_link, -1, 0, 0, out mi)) {
					var matched = mi.fetch(0);
					return after_close + matched.length;
				}
				if (!is_end_of_chunks) {
					return -1;
				}
				return 0;
			}
			// c1 == '[' — reference-style: ][ref] or ][]. Parser does not resolve refs; just return end offset.
			var ref_start = after_close + 1;
			var ref_end = chunk.index_of_char(']', ref_start);
			if (ref_end == -1) {
				if (!is_end_of_chunks) {
					return -1;
				}
				return 0;
			}
			return ref_end + 1; // Match; handle_link will set is_reference true and href = ref label
		}
```

### 7. do_format — LINK (libocmarkdown/Parser.vala)

In `do_format`, add a case so LINK is not treated as unknown (no-op; link is handled in `formatmap.eat_link`):

```vala
				case FormatType.LINK:
					// Handled in formatmap.eat_link(); no stack push
					break;
				case FormatType.INVALID:
```

(Add before `case FormatType.INVALID:`.)

### 8. got_format — LINK (libocmarkdown/Parser.vala)

- LINK is never pushed via `got_format` (we branch in `handle_format_result` before `got_format`; link parsing is in `formatmap.eat_link`).
- In `got_format` add a case so LINK is not passed to the rest of the switch (defensive).

**Concrete code:** At the start of the `switch (format_type)` in `got_format`, add before `case FormatType.TASK_LIST:`:

```vala
				case FormatType.LINK:
					return; // Handled in handle_format_result / process_inline; never pushed via got_format
				case FormatType.TASK_LIST:
```

---

## Summary

Implementation must follow the **Concrete code** section above; no design changes beyond what is approved there.

| File | Change |
|------|--------|
| **libocmarkdown/RenderBase.vala** (and all renderers) | Remove **is_autolink** from **on_a**; add **is_reference**. Signature: `on_a(bool is_start, string href, string title, bool is_reference)`. When **is_reference** is true, href is the ref label; consumer resolves to URL (see 5c). |
| **libocmarkdown/Parser.vala** | **Construction (2a):** `formatmap` property has no default; in constructor assign `this.formatmap = new FormatMap(this)`. **handle_line_break**: reset **state_stack** before flushing text. Add **public process_inline(string text)** (5a) with escape and code-span literal (5b2). When eat() returns LINK in block path, call **eat_link**; when >0 call **formatmap.handle_link(chunk, chunk_pos, seq_pos, link_result)** then advance chunk_pos. In **process_inline**, when matched_format == LINK, call eat_link; if match, **formatmap.handle_link(...)** and advance; if no match, emit 3 chars as literal. Add do_format/got_format LINK cases (7, 8). No link regex in Parser. |
| **libocmarkdown/FormatMap.vala** | **Construction (2a):** Add `private weak Parser? parser;` and constructor **FormatMap(Parser parser)** storing parser. Remove 2‑char keys `[x`, `[X`, `[ `; add `"[?"` and `"[??"` (LINK) (2b). Add **LINK_INNER_PATTERN** constant and **inner_link_regex** / **inline_link_regex** (shared). Add **handle_link**(chunk, chunk_pos, seq_pos, end_offset): extract link_text, href, title, is_reference, then call **this.parser.renderer.on_a(true,...)**, **this.parser.process_inline(link_text)**, **this.parser.renderer.on_a(false,...)**. Add **eat_link**; both use the shared regex(es). **No delegates.** **eat_link:** reject when link text (between `[` and first `]`) contains `[` (return 0). |
| **libocmarkdown/MarkerMap.vala** | In eat(): maintain **wildcard_sequence** (starts blank; build in parallel with sequence — alphabetic → `?`). **Two lookups:** (1) `map.has_key(sequence)`, (2) `map.has_key(wildcard_sequence)`. If wildcard match is INVALID, return -1. Remove alpha early-return from top; do two lookups, then alpha return at end. |
| **libocmarkdown/TableState.vala** | Remove **process_cell** method. In **emit_row**, call **this.parser.process_inline(cells[i])** where each cell’s content is emitted (see 5e). |

---

## Outstanding / to decide

These are mentioned in Goal or Verification but **not** fully specified in the concrete code. Decide how to handle them before or during implementation.

### 1. Optional title: `](url "title")` — implemented

- **Goal:** "optional `[link text](url "title")`"; Verification: "ensure `on_a(..., title)` receives the title."
- **Implemented in §6 FormatMap (handle_link and eat_link):** `handle_link` parses inner content with **GLib.Regex** (shared **LINK_INNER_PATTERN** / **inner_link_regex**): destination (angle-bracket `<...>` or bare until space/quote/paren) then optional title in `"..."`, `'...'`, or `(...)` with unescape. `eat_link` for inline link finds the **matching** closing `)` via **regex** (no character loop / depth scan).

**CommonMark 6.3 semantics (we implement via regex):**

1. **Inner content** = everything between `(` and the **matching** `)` (counting nested parens if title uses `(title)`).
2. **Destination:**  
   - If inner content starts with `<`, destination = from `<` to the next `>` (angle-bracket form; can contain spaces).  
   - Else destination = run of characters until first space or first `"` or `'` or `(` (bare form; no spaces).
3. **Optional title:** After destination, skip optional whitespace. If next char is `"`, `'`, or `(`, then title is the content until the **matching** closing `"`, `'`, or `)`. Unescape backslashes inside title.
4. **Implementation:** Use **GLib.Regex** only for parsing inner content and for finding the extent of the inline link; no character loops, no index_of_char–based scanning of link content. The concrete code in §5d (handle_link) and §6 (eat_link) uses regex patterns for this.

**Concrete:** The parsing in **handle_link** when `c1 == '('` uses the regex given in §5d. **eat_link** must return the correct end offset (byte after the matching `)`); for title in `(...)` the matching `)` is the link’s closing paren, so end_offset is already that. For bare URL + `"title"` or `'title'`, end_offset is byte after the closing `)` of the link. No change to eat_link return convention; handle_link receives the full range and parses inner.

### 2. Reference-style: `][ref]` and `][]` — decided

- **Decision:** Parser does **not** resolve reference targets. Add **is_reference** to **on_a**. For `[text][ref]` or `[text][]`, parser emits **is_reference = true** and **href =** ref label (or normalized link text for `[]`). Consumer (e.g. renderer) resolves the ref to a URL if it has link reference definitions. **eat_link** returns end offset for reference-style; **handle_link** sets is_reference and href = ref label (see 5c, 5d, §6).

### 3. Verification (post-implementation)

- Not missing implementation — just run the Verification section after implementing. No design decision; ensure tests exist or are added for: `[OpenAI](url)`, task list `[ ]`/`[x]`, streaming chunk boundary.

---

## Verification

- Parser tests: input `[OpenAI](https://openai.com)` and confirm the parser emits `on_a(true, "https://openai.com", null, false)`, `on_text("OpenAI")`, `on_a(false, ...)`.
- Test with title: `[text](url "title")` and ensure `on_a(..., title)` receives the title.
- Test reference-style: `[text][ref]` and `[text][]` (with link reference definition for ref) emit correct href/title.
- Test that task list `[ ]` and `[x]` are still recognized and not consumed as links.
- Test streaming: chunk ending with `[some text` defers correctly until next chunk with `](url)` or `][ref]`.

---

## Dependencies

- None beyond current parser. Rendering of links is in plan 1.10.10.
