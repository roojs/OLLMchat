# 2.6.1.10. Overlay Scanning After Completion

## Overview

Replace the Monitor-based filesystem monitoring with a post-completion scanning approach. After command execution completes, scan the overlay directory structure to detect all changes (additions, modifications, deletions) and synchronize them with the live filesystem and ProjectFiles database.

## Status

✅ **COMPLETE** - Implementation complete.

## Prerequisites

- Phase 1 (2.6.1.1) must be completed
- Phase 2 (2.6.1.2) must be completed
- Phase 3 (2.6.1.3) must be completed
- Phase 4 (2.6.1.4) must be completed
- See main plan: `2.6.1-code-exec-improvements.md` for overlay details

## Goals

1. Remove Monitor class and all inotify-based monitoring
2. Create new Scan class (same constructor signature as Monitor)
3. Implement post-completion overlay scanning using scan_dir() pattern
4. Create handler methods for files, folders, and file aliases (add/remove)
5. Move all Monitor code (including is_whiteout and to_real_path) to Scan class
6. Synchronize overlay changes with ProjectFiles and live filesystem
7. Handle type changes (file ↔ directory ↔ symlink)

## Implementation Details

### Architecture Change

**Current Approach:**
- Monitor class uses inotify (via GLib.FileMonitor) to track changes in real-time
- Tracks added/removed/updated HashMaps during command execution
- Processes changes after command completion

**New Approach:**
- Remove Monitor class entirely
- Create Scan class (constructor takes Overlay instance)
- Scan instance created at start (like Monitor currently is)
- After command completion, call Scan.run() to recursively scan overlay upper directory
- Compare overlay state with ProjectFiles state
- Apply changes (create/modify/delete) based on comparison

### New Scanning Pattern

Follow similar pattern to `Folder.read_dir()`:

```vala
scan_dir(overlay_path, real_path)
  * First loop: Process all items in current directory
    - For each item in overlay:
      - Determine type (file/folder/symlink)
      - Check ProjectFiles for existing filebase using real_path (may be null)
      - Call appropriate handler: handle_file(overlay_path, real_path, filebase?) or handle_folder() or handle_filealias()
      - handle_file checks is_whiteout() internally and calls handle_remove() if needed
      - If folder, add to folders list
  * Second loop: Recurse into folders
    - For each folder in folders list:
      - Call scan_dir() recursively on that folder
  * (Note: Scan loop only processes what exists in overlay - does not detect missing items)
```

### Handler Logic

**Non-remove handlers** (handle_file, handle_folder, handle_filealias) follow this pattern:

**handle_file:**
1. **Check for whiteout first:**
   - If `is_whiteout(overlay_path)` is true:
     - If filebase is not null, call `handle_remove(overlay_path, filebase)`
     - Return early
   - (Note: whiteout files are only created for file deletions, not folders/symlinks)

2. **Use filebase parameter (nullable):**
   - If filebase is null → create_file
   - If filebase exists but not same type → call `handle_remove(overlay_path, filebase)`, then create new file
   - If filebase exists and same type → modify_file

**handle_folder:**
1. **Use filebase parameter (nullable):**
   - If filebase is null → create_folder
   - If filebase exists but not same type → call `handle_remove(overlay_path, filebase)`, then create new folder
   - If filebase exists and same type → do nothing (folders are containers, not modified directly)

**handle_filealias:**
1. **Use filebase parameter (nullable):**
   - If filebase is null → create_filealias
   - If filebase exists but not same type → call `handle_remove(overlay_path, filebase)`, then create new filealias
   - If filebase exists and same type → modify_filealias

**Type Detection:**
- File: regular file (not symlink, not directory)
- Folder: directory
- FileAlias: symlink

**Remove handler** (handle_remove):
- Single method handles all types (file/folder/alias)
- Called by non-remove handlers when whiteout detected
- Called by non-remove handlers when type mismatch detected
- Definitive action - no testing needed
- Takes overlay_path and filebase object as arguments
- Performs deletion immediately (handles all file types)
- **Implementation details:**
  - For files/aliases: Trivial - just delete the file/symlink
  - For folders: Recursive - must delete entire directory tree
  - **Processing order:** Files/aliases must be processed before folders when scanning for removals (to avoid trying to delete files inside folders that are being deleted)

### Scan Class

Create new `Scan` class in `liboctools/RunCommand/Scan.vala`:

- Constructor takes same parameters as Monitor:
  - `project_folder` (OLLMfiles.Folder) - provides access to project_files
  - `base_path` (string) - base path of overlay upper directory
  - `overlay_map` (HashMap<string, string>) - maps overlay subdirectory names to real project paths
- Created at start (like Monitor currently is)
- **Consideration:** Could build `overlay_map` internally from `project_folder.build_roots()` instead of receiving it as a parameter, making Scan more self-contained. Currently follows Monitor pattern for consistency.
- Implements `scan_dir()` method
- Implements handler methods (handle_file, handle_folder, handle_filealias, handle_remove)
- Handler methods perform all actions internally (create/modify/delete/copy files, update database, etc.) - no separate file_added/file_updated methods needed
- Handler methods use helper methods:
  - `copy_permissions()`, `recursive_delete()` (moved from Overlay)
- Implements `create_filebase_from_path()` method (moved from Monitor)
- Implements `is_whiteout()` method (moved from Monitor)
- Implements `to_real_path()` method (moved from Monitor)
- Implements `run()` method to execute the scan after command completion
- Contains `command_timestamp` property (moved from Overlay)
- Calls `FileHistory` class to create backup records for added/modified/deleted files and folders

**What moves from Monitor to Scan:**
- `create_filebase_from_path()` method
- `is_whiteout()` method
- `to_real_path()` method
- `handle_directory_created()`, `handle_file_created()`, `handle_file_modified()`, `handle_file_deleted()` logic (refactored into new handler methods)
- Logic for checking is_ignored based on parent folder (in handlers)
- All scanning and change detection logic
- Constructor parameters (project_folder, base_path, overlay_map)
- Private fields (base_path, overlay_map, project_folder)

**What moves from Overlay to Scan:**
- Logic from `file_added()`, `file_updated()`, `file_removed()` methods (integrated into handle_* methods)
- Logic from `folder_added()`, `folder_removed()` methods (integrated into handle_* methods)
- `copy_permissions()` method (helper method used by handlers)
- `recursive_delete()` method (helper method used by handlers)
- `command_timestamp` property
- FileHistory backup creation logic (calls FileHistory.commit() for added/modified/deleted files and folders)

**What does NOT move:**
- `added`, `removed`, `updated` HashMaps - not needed, handlers perform actions immediately

### Scanning Flow

1. **At start (in Overlay constructor):**
   - Create Scan instance (takes project_folder, base_path, overlay_map - same as Monitor)

2. **After command completion:**
   - Call `scan.run()` to execute the scan
   - `run()` method iterates over `overlay_map` entries
   - For each overlay subdirectory (overlay1, overlay2, etc.):
     - Build overlay subdirectory path: `base_path/overlay1`, `base_path/overlay2`, etc.
     - Get real project path from overlay_map
     - Call `scan_dir()` on the overlay subdirectory path with the real project path
   - `scan_dir()` recursively processes each overlay subdirectory

3. **scan_dir() implementation (in Scan class):**
   - Enumerate directory contents in overlay
   - **First loop: Process all items in current directory**
     - For each item found in overlay:
       - Convert overlay path to real path (using to_real_path())
       - Determine type (file/folder/symlink)
       - Check ProjectFiles for existing filebase using real_path (may be null)
       - Call appropriate handler with filebase parameter (handle_file/handle_folder/handle_filealias)
       - handle_file checks `is_whiteout()` internally and calls handle_remove() if needed
       - If item is a folder, add to folders list
   - **Second loop: Recurse into folders**
     - For each folder in folders list:
       - Call scan_dir() recursively on that folder
   - (Note: Scan loop only processes what exists in overlay - it does not detect missing items)

4. **Handler execution (in Scan class):**
   - Each handler checks ProjectFiles state
   - Performs all actions internally:
     - Creates files/folders/aliases in ProjectFiles and database
     - Copies files from overlay to live filesystem
     - Creates FileHistory records (calls FileHistory.commit() for added/modified/deleted files and folders)
     - (Note: FileHistory records created for folders even though they may not be used)
     - Updates database
     - Modifies files/aliases (copies from overlay, updates database)
     - Deletes files/folders/aliases (removes from live filesystem and database)
   - Handlers use helper methods (copy_permissions, recursive_delete) as needed
   - Handlers call FileHistory class to create backups

### Files to Modify

- `liboctools/RunCommand/Overlay.vala`
  - Remove Monitor instance
  - Add Scan instance (created in constructor with same parameters as Monitor: project_folder, base_path, overlay_map)
  - Remove `start_monitor()` method
  - Modify `copy_files()` to call `scan.run()` (scan handles all actions directly)
  - Keep file copying methods (file_added, file_updated, file_removed, folder_added, folder_removed) - called by Scan handlers
  - Keep `command_timestamp` property
  - Keep `copy_permissions()` method
  - Keep `recursive_delete()` method
  - Make file copying methods accessible to Scan (public or pass Overlay reference to Scan)

- `liboctools/RunCommand/Scan.vala`
  - **CREATE** - New class for overlay scanning
  - Constructor takes same parameters as Monitor (project_folder, base_path, overlay_map)
  - Takes Overlay instance (or reference) to call file copying methods
  - Implements `run()` method to execute scan
  - Implements `scan_dir()` method
  - Implements handler methods (handle_file, handle_folder, handle_filealias, handle_remove)
  - Handler methods call Overlay methods directly to perform actions (no HashMaps)
  - Implements `create_filebase_from_path()` method (moved from Monitor)
  - Implements `is_whiteout()` method (moved from Monitor)
  - Implements `to_real_path()` method (moved from Monitor)
  - Contains private fields: project_folder, base_path, overlay_map, overlay (reference to Overlay)

- `liboctools/RunCommand/Monitor.vala`
  - **DELETE** - Remove entire file

- `liboctools/RunCommand/Bubble.vala`
  - Remove `overlay.start_monitor()` call (no longer needed)
  - Scanning happens automatically in `overlay.copy_files()`

### Scan Class Method Signatures

```vala
// In Scan class
public Scan(OLLMfiles.Folder project_folder, string base_path, Gee.HashMap<string, string> overlay_map)  // Constructor (same as Monitor)
public async void run()  // Main entry point - iterates over overlay_map entries, calls scan_dir() for each overlay subdirectory
private void scan_dir(string overlay_path, string real_path)  // Recursive scanning - two loops: process items, then recurse into folders
private async void handle_file(string overlay_path, string real_path, OLLMfiles.FileBase? filebase)  // File handler - filebase is nullable (null if not in ProjectFiles)
private async void handle_folder(string overlay_path, string real_path, OLLMfiles.FileBase? filebase)  // Folder handler - filebase is nullable (null if not in ProjectFiles)
private async void handle_filealias(string overlay_path, string real_path, OLLMfiles.FileBase? filebase)  // Symlink handler - filebase is nullable (null if not in ProjectFiles)
private async void handle_remove(string overlay_path, OLLMfiles.FileBase filebase)  // Remove handler - handles all types (file/folder/alias), definitive action

// Helper methods (used by handlers)
private void copy_permissions(string overlay_path, string real_path)  // Copy file permissions (moved from Overlay)
private void recursive_delete(string dir_path) throws Error  // Recursively delete directory (moved from Overlay)

// Utility methods
private OLLMfiles.FileBase create_filebase_from_path(string overlay_path, string real_path)  // Create FileBase from path
private bool is_whiteout(string overlay_path)  // Check if path is whiteout file (moved from Monitor)
private string to_real_path(string overlay_path)  // Convert overlay path to real path (moved from Monitor)

// Properties
private int64 command_timestamp { get; private set; default = 0; }  // Moved from Overlay
```

### Type Change Handling

When a file exists in ProjectFiles but overlay has a different type:

1. Delete existing file/folder/alias from ProjectFiles
2. Create new file/folder/alias from overlay
3. Update database accordingly

### Folder Handling

- Folders are containers - they don't get "modified" directly
- If folder exists in ProjectFiles and overlay, do nothing (no modification needed)
- If folder exists in overlay but not ProjectFiles, create it
- If folder exists in ProjectFiles but not overlay, remove it (recursively)

### File/Alias Handling

- If file/alias exists in overlay but not ProjectFiles, create it
- If file/alias exists in ProjectFiles but not overlay, remove it
- If file/alias exists in both, check if modified (compare timestamps or content)
  - If modified, update it (copy from overlay to live filesystem)

## Implementation Phases

### Phase 1: Create Scan Class

- [ ] Create `liboctools/RunCommand/Scan.vala` class
  - [ ] Add constructor taking same parameters as Monitor (project_folder, base_path, overlay_map)
  - [ ] Add private fields: project_folder, base_path, overlay_map
  - [ ] Add `command_timestamp` property (moved from Overlay)
  - [ ] Move `is_whiteout()` from Monitor
  - [ ] Move `to_real_path()` from Monitor
  - [ ] Move `create_filebase_from_path()` from Monitor
  - [ ] Integrate logic from `file_added()`, `file_updated()`, `file_removed()` into handle_file/handle_remove
  - [ ] Integrate logic from `folder_added()`, `folder_removed()` into handle_folder/handle_remove
  - [ ] Move `copy_permissions()` from Overlay (helper method)
  - [ ] Move `recursive_delete()` from Overlay (helper method)
  - [ ] Implement `run()` method
  - [ ] Implement `scan_dir()` method
  - [ ] Implement `handle_file()` method
  - [ ] Implement `handle_folder()` method
  - [ ] Implement `handle_filealias()` method
  - [ ] Implement `handle_remove()` method (handles all types)
- [ ] Add Scan.vala to meson.build
- [ ] Add valadoc documentation for Scan class

### Phase 2: Replace References to Overlay

- [ ] Update `Overlay.vala`:
  - [ ] Remove Monitor instance
  - [ ] Add Scan instance (created in constructor with same parameters as Monitor: project_folder, base_path, overlay_map)
  - [ ] Remove `start_monitor()` method
  - [ ] Modify `copy_files()` to call `scan.run()` (scan handles all actions directly)
  - [ ] Remove `file_added()`, `file_updated()`, `file_removed()` methods (logic integrated into Scan handlers)
  - [ ] Remove `folder_added()`, `folder_removed()` methods (logic integrated into Scan handlers)
  - [ ] Remove `command_timestamp` property (moved to Scan)
  - [ ] Remove `copy_permissions()` method (moved to Scan)
  - [ ] Remove `recursive_delete()` method (moved to Scan)
- [ ] Remove `start_monitor()` call from `Bubble.vala`
- [ ] Update tests to work with new scanning approach

### Phase 3: Remove Monitor and All References

- [ ] Remove Monitor class from `liboctools/RunCommand/Monitor.vala` (DELETE file)
- [ ] Remove Monitor.vala from meson.build
- [ ] Remove Monitor from valadoc
- [ ] Remove all references to Monitor in documentation
- [ ] Verify all tests pass with new scanning approach
- [ ] Verify all file operations work correctly
- [ ] Verify type changes are handled correctly
- [ ] Verify wipeout detection works correctly

## Testing

### Test Scenarios

1. **Basic file operations:**
   - Create new file in overlay
   - Modify existing file in overlay
   - Delete file from overlay

2. **Folder operations:**
   - Create new folder in overlay
   - Delete folder from overlay
   - Create nested folder structure

3. **Symlink operations:**
   - Create new symlink in overlay
   - Modify symlink target in overlay
   - Delete symlink from overlay

4. **Type changes:**
   - File → Directory
   - Directory → File
   - File → Symlink
   - Symlink → File

5. **Wipeout detection:**
   - Delete file (should create whiteout)
   - Verify wipeout is detected correctly
   - Verify file is removed from ProjectFiles

### Test Execution

1. Build project: `meson compile -C build`
2. Run existing tests: `./tests/test-bubble.sh`
3. Verify all tests pass with new scanning approach
4. Add new tests for edge cases if needed

## Notes

- Scanning approach is simpler and more reliable than inotify monitoring
- No race conditions with inotify events
- No need to handle complex event ordering
- Post-completion scanning ensures all changes are captured
- May be slightly slower than real-time monitoring, but more accurate
- Handles edge cases better (type changes, wipeouts, etc.)
- Easier to test and debug

## Migration Notes

- Monitor class will be completely removed
- Scan class replaces Monitor (same constructor signature: project_folder, base_path, overlay_map)
- All Monitor code moves to Scan (including is_whiteout, to_real_path, create_filebase_from_path)
- Logic from Overlay's file copying methods (file_added, file_updated, file_removed, folder_added, folder_removed) integrated into Scan handlers
- Helper methods (copy_permissions, recursive_delete) moved to Scan
- Scan does not need Overlay reference - it's self-contained
- No HashMaps needed - handlers perform all actions immediately during scan
- Overlay.copy_files() now just calls scan.run() - all work done in Scan
- Scan handlers perform all file operations internally (no separate file_added/file_updated methods)
- **Future consideration:** Could move `overlay_map` building from `Overlay.create()` to Scan constructor. Scan could build it from `project_folder.build_roots()` internally, making it more self-contained and independent of Overlay. This would require Scan to know about overlay subdirectory naming convention (overlay1, overlay2, etc.) which is currently handled by Overlay.
- **Future consideration:** Consider simplifying remove/removeFromDB into a single action. Currently, file removal involves multiple steps: filesystem deletion, buffer clearing, parent.children removal, ProjectFiles removal, and database removal. Consolidating this into a single method or action could reduce duplication and ensure consistency across all removal paths.
- **Future consideration:** Look at better delete handling - instead of deleting in-memory data as we go along, consider flagging items for deletion and then having a manager scan all in-memory data structures (ProjectFiles, Folder.children, file_cache, etc.) to remove flagged items in a batch operation. This could be more efficient and avoid potential issues with modifying collections while iterating.
- Tests may need updates to work with new approach
- No database schema changes needed
- No API changes to Bubble class (internal implementation change only)
