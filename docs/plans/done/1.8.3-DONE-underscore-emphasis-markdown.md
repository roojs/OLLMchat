# Plan 1.8.3: Underscore emphasis in markdown — `max_width_chars` loses underscore

## Summary

When text like `max_width_chars` is rendered in the markdown editor, the underscores disappear and the identifier is shown as if the underscores were emphasis delimiters (e.g. "max" + italic "width" + "chars"), so the literal underscores are lost.

## Root cause

The inline parser treats **every** single `_` as a potential emphasis (italic) delimiter. In **CommonMark**, underscore emphasis is **not** allowed inside words: `foo_bar_baz` must **not** create emphasis; only asterisk allows intraword emphasis. Our parser has no "intraword" rule for underscores, so:

- In `max_width_chars`, the first `_` is taken as "start italic".
- The second `_` is taken as "end italic".
- The two underscores are consumed as formatting and never rendered, so the user sees something like "max*width*chars" (with "width" in italic) instead of `max_width_chars`.

Relevant code:

1. **`libocmarkdown/FormatMap.vala`** (lines 166–169): `_`, `__`, `___` are mapped to ITALIC, BOLD, BOLD_ITALIC with no special case.
2. **`libocmarkdown/MarkerMap.vala`** (lines 65–69): Any non-alpha character that appears in the map is considered a match; there is no check for "word" boundaries. So `_` at any position is treated as a delimiter.
3. **`libocmarkdown/Parser.vala`**: `handle_format_result()` and `process_inline()` use the result of `formatmap.eat()` and call `got_format()` for ITALIC/BOLD/BOLD_ITALIC without checking whether the delimiter run is intraword.

So the bug is: **underscore delimiter runs are not rejected when they are intraword** (surrounded by word characters on both sides).

## CommonMark behaviour (spec excerpt)

Emphasis with `_` (and `*`) is defined in terms of **delimiter runs**, **left-flanking**, and **right-flanking** (CommonMark spec §6.2):

- **Delimiter run:** A sequence of one or more `_` (or `*`) that is not preceded or followed by a non–backslash-escaped `_` (or `*`).
- **Left-flanking delimiter run:** (1) Not followed by Unicode whitespace, and either (2a) not followed by Unicode punctuation, or (2b) followed by punctuation and preceded by Unicode whitespace or punctuation. *Line start and line end count as Unicode whitespace.*
- **Right-flanking delimiter run:** (1) Not preceded by Unicode whitespace, and either (2a) not preceded by Unicode punctuation, or (2b) preceded by punctuation and followed by Unicode whitespace or punctuation.

So the **opening** delimiter must be left-flanking (what matters is what is **after** it, and for (2b) what is before). It does **not** have to be preceded by whitespace or a line break; it can be at line start, after punctuation, after space, or after a letter (when not followed by punctuation).

Examples from the spec:

- Left-flanking but not right-flanking: `***abc`, `  _abc`, `**"abc"`, ` _"abc"`.
- Right-flanking but not left-flanking: ` abc***`, ` abc_`, `"abc"**`, `"abc"_.
- Both: ` abc***def`, `"abc"_"def"`.
- Neither: `abc *** def`, `a _ b`.

For underscore, an additional rule prevents **intraword** emphasis: when a `_` run is both left- and right-flanking and is surrounded by word characters (letter, digit, or `_`) on both sides, it is not treated as emphasis. So `max_width_chars` and `foo_bar_baz` render as plain text with underscores visible.

## Proposal (no code changes)

Add an **intraword check for underscore delimiter runs** so that we do not treat `_` / `__` / `___` as emphasis when they sit inside a word.

### 1. Where to implement

- **Option A – Parser:** In both call sites that act on a successful format match for ITALIC/BOLD/BOLD_ITALIC:
  - **`handle_format_result()`** (block-level inline parsing),
  - **`process_inline()`** (link text, table cells),
  before calling `got_format()`, check: if the matched run at the current position starts with `_`, and the character immediately before the run and the character immediately after the run are both "word" characters (Unicode letter, digit, or `_`), then **do not** call `got_format()`. Instead, emit the run as literal text (`on_text(substring)`) and advance the position by the run length. That way `max_width_chars` is rendered as plain text with underscores preserved.
- **Option B – MarkerMap.eat():** When the matched sequence is one of `_`, `__`, `___` (inferrable from `byte_length` and the first character at `chunk_pos`), return 0 (no match) if the run is intraword. This would require MarkerMap (or a FormatMap override) to have access to the chunk and to implement the same before/after word-character check. Option A keeps delimiter semantics in the Parser and avoids touching the generic MarkerMap for a single delimiter type.

**Recommendation:** **Option A** in `Parser.vala` (and the same logic in `process_inline()`), so that:

- Only underscore-based emphasis is special-cased.
- "Intraword" is defined in one place: character before and after the run are both word characters (`.isalnum()` or `== '_'`).
- No change to MarkerMap or FormatMap API.

### 2. Intraword condition (exact rule)

For a delimiter run of length `byte_length` starting at `pos`:

- **Before:** When `pos > 0`, `char_before = chunk.get_char(prev_byte)` (last character before the run). When `pos == 0`, the preceding character is not in the current chunk—use the **tracked preceding character** from the previous chunk (see §3); if none (start of input / line), use a sentinel so it is treated as non-word.
- **After:** `char_after = (pos + run_byte_length < chunk.length) ? chunk.get_char(pos + run_byte_length) : sentinel`.

**Word character:** `u == '_' || u.isalnum()` (Vala `unichar`).

If **both** `char_before` and `char_after` are word characters, treat the run as **intraword** → emit as literal text, advance, do not call `got_format()`.

### 3. Chunk boundaries: the preceding character is not in the current chunk

The above assumes `char_before` can be read from the current chunk at `pos - 1`. In a chunked parser it often **cannot**: the character immediately before the run may be in a **previous** chunk that has already been consumed and is no longer available.

- **Main `add()` loop:** Input is processed in chunks. When we set `leftover_chunk = chunk.substring(saved_chunk_pos, ...)` and return, the next call gets `chunk = leftover_chunk + in_chunk`. The character *before* the start of that combined chunk (i.e. before position 0) was the last character we consumed *before* the leftover—and it is not in the current buffer.
- **So:** We cannot implement the intraword check correctly by only looking at the current chunk. We must **keep track of the preceding character** across chunk boundaries.

**Recommendation:** Maintain parser state for "character before next chunk" (or "last character of previous chunk"):

- **When to set it:** Whenever we are about to set `leftover_chunk`, record the character that immediately precedes the leftover (i.e. the last character we consumed in the current chunk before the leftover). If we consumed nothing before the leftover (e.g. we deferred from the very start of the chunk), use a sentinel meaning "start of input" or "whitespace" so the intraword check treats it as non-word. Also update this "prev char" whenever we advance past a character in inline content so that at the start of the *next* chunk we have the correct preceding character.
- **When to use it:** When evaluating the intraword check for an underscore run at position `pos`, use `char_before = (pos > 0) ? chunk.get_char(prev_byte) : this.last_char_before_chunk` (with a sentinel for "no preceding char" / line start so it is treated as non-word). After the first character of the chunk is processed, `pos > 0` and we can read from the chunk again; we then keep `last_char_before_chunk` in sync for the next time we have a chunk boundary.
- **Scope:** This applies to the **block-level inline path** (`handle_format_result()` / main loop). For `process_inline(string text)` the caller passes a complete string (e.g. one line for link text or table cells), so the preceding character is in the same string when `pos > 0`; no cross-chunk state is needed there unless the caller itself splits the line across chunks.

**Implementation sketch:** Add a field, e.g. `unichar? last_char_before_next_chunk` (or a small enum: none / whitespace / punctuation / word_char). When setting `leftover_chunk`, set `last_char_before_next_chunk` to the character at `saved_chunk_pos - 1` (if `saved_chunk_pos > 0`), else keep or set sentinel. When starting to process a chunk, if `chunk_pos == 0`, use `last_char_before_next_chunk` as `char_before` for the first delimiter run; after consuming any character, update `last_char_before_next_chunk` so it is correct for a future chunk boundary. Reset at line boundaries if the spec treats line start as whitespace (so "before" at line start is non-word).

### 4. Edge cases to preserve

- `_italic_` and `__bold__` at word boundaries (e.g. after space or punctuation) must still produce emphasis.
- `*intraword*` with asterisks can remain as-is (CommonMark allows intraword emphasis for `*` only).
- Escaped `\_` is already handled by the escape branch and should be unchanged.

### 5. Files to change (when implementing)

- **`libocmarkdown/Parser.vala`**
  - **Preceding-character state:** Add a field (e.g. `unichar? last_char_before_next_chunk` or sentinel enum). When setting `leftover_chunk`, set this from the character immediately before the leftover (if any). When processing inline and advancing past a character, update it so the next chunk sees the correct "char before". Use it in the intraword check when `chunk_pos == 0`.
  - In **`handle_format_result()`**: before `got_format(matched_format)` for ITALIC/BOLD/BOLD_ITALIC, if the run at `chunk_pos` starts with `_`, apply the intraword check using `char_before = (chunk_pos > 0) ? chunk.get_char(prev_byte) : last_char_before_next_chunk`; if true, emit the run as literal text, set `chunk_pos = seq_pos`, return false.
  - In **`process_inline()`**: same intraword check when the match is ITALIC/BOLD/BOLD_ITALIC and the run at `pos` starts with `_`; here `char_before` is always in the same string (`pos > 0`), so no cross-chunk state.
  - Ensure `last_char_before_next_chunk` is updated whenever we advance in inline content and when we set `leftover_chunk`, and reset appropriately at line/block boundaries.

Optional: add a small helper, e.g. `is_underscore_run_intraword(string chunk, int run_start_byte, int run_end_byte, unichar? char_before)`, used from both places, to avoid duplication.

### 6. Testing

- Add or extend a markdown test: source `max_width_chars` and `set "max_width_chars"` (and similar with `__`) should render with underscores visible and no italic/bold.
- Existing tests for `_italic_` and `__bold__` at boundaries should still pass.

---

## Alternative: space-only rule for underscore

Instead of full left-flanking/right-flanking and intraword (word-character) checks, we could use a **simpler rule** for underscore only:

- **Opening delimiter:** Treat `_` (or `__`, `___`) as start of emphasis **only** when it is (a) at **start of line**, or (b) **preceded by a space** (i.e. the pattern is ` _`).
- **Closing delimiter:** Treat `_` (or `__`, `___`) as end of emphasis **only** when it is (a) at **end of line**, or (b) **followed by a space** (i.e. the pattern is `_ `).

So:

- `max_width_chars` → first `_` is preceded by `x`, not space → not opener; second `_` is followed by `c`, not space → not closer. Both render as literal. ✓
- ` _italic_ ` → space before first `_` → opener; space after second `_` → closer. ✓
- `_italic_` at start of line → opener (start of line); end of content after second `_` → closer. ✓
- `foo_italic_bar` → no space around the `_` runs → literal underscores. ✓

**Pros:**

- Simpler: no "word character" check, only "space or line boundary".
- Same fix for `max_width_chars` and identifiers.
- For opener at chunk start we still need "preceding character" (or "was last char space / line start?") to allow ` _` after a chunk boundary; we can reuse the same `last_char_before_next_chunk` idea, but the rule is "is it space (or line-start sentinel)?" instead of "is it non-word?".

**Cons:**

- **Not CommonMark:** In CommonMark, `(_italic_)` and `"_italic_"` are valid (punctuation before/after the run). With the space-only rule, `(_italic_)` would not get emphasis (no space before the first `_`). So we'd deviate from the spec for punctuation-flanked emphasis.
- If we don't track preceding character at chunk boundary, a line split as `foo ` + `_italic_` could wrongly treat the leading `_` as not an opener (we don't know the previous chunk ended with space). So the same "track last char before next chunk" (or at least "was it space?") is still needed for correctness when chunks split a line.

**Summary:** The space-only rule is easier to implement and fixes the main issue (identifiers like `max_width_chars`). Choosing it is a trade-off: we accept that `(_italic_)` and similar punctuation-flanked cases won't get underscore emphasis, in exchange for simpler logic and no word-character classification.

---

**Status:** Investigation done; proposal only (no code changes applied).
