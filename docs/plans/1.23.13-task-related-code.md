# 1.23.13 Task-related code

**Note:** Do not add sentences to this plan unless specifically asked — only bullet points or nested bullet points.

**Coding standards:** Follow `.cursor/rules/CODING_STANDARDS.md`. Checklist: nullable avoided where possible; null checks only where design requires; no `@"..."`; no one-use temporaries (inline); braces inline for control flow; **this.**; **GLib.** prefix; default init on properties; **string[]** and **joinv** for string arrays; **continue** in loops; no character loops; try/catch only around minimal throwing code; no leading underscore; no get_* accessors. This plan uses: **step.children**, **children.get(0)** (Gee .get()); **steps** as public property (not steps()).

---

## Overview

- Sub-plan of **1.23.11**. Task-related types and behaviour: TaskList, TaskStep, Task, parsers, Task-built precursor.
- One class per file. TaskList.vala, TaskStep.vala, Task.vala.

**Status:** PLAN — Implementation not started.

**Dependencies:** 1.23.11 (parent), 1.23.2, 1.23.3–1.23.6 (formats), 1.23.12 (context restriction format).

---

## TaskList (`liboccoder/Skill/TaskList.vala`)

- **One class per file.** **TaskStep** → `TaskStep.vala`; **Task** → `Task.vala`.
- **Structure**
  - **Top level always sequential.** TaskList holds an ordered list of **TaskStep**. Each TaskStep is either a single Task or a set of Tasks (children) that run concurrently.
  - Parser (1.23.3 §2) produces task sections → mapped to TaskSteps (e.g. one section = one TaskStep; section with one task = single, section with multiple tasks = concurrent group).
- **What we wait for (two different things)**
  - **Design: we do NOT wait for all tasks to be refined before starting execution.** Refinement is started for all (refine); then run_until_writer / run_all_tasks run immediately. Refinement and execution overlap: e.g. task 1 can be executing while task 2 is still refining. We only wait for **that task's** refinement when we are about to run it (inside run_child: wait_refined first).
  - **Refinement done (per task):** Before running a task we wait for **that task's refinement** only. Done inside **run_child**: first **yield t.wait_refined()**, then run_tools, then post_evaluate.
  - **Execution done (per step):** When a step has multiple children we start several **run_child** (execution) callbacks with .begin(). **wait_exec_done()** waits until **all those executions** for this step are done (num_exec_running reaches 0). So: waiting for **execution** of the current step's children, not for refinement.
  - **Pending exec = no execution result yet:** **has_pending_exec()** is true if any task has **no output** — i.e. that task's **execution** (run_tools + post_evaluate) has not yet completed. Runner uses it to decide whether to do another round or exit.
- **Re-run state**
  - No **previous_proposal** / **previous_proposal_issues** on TaskList; they are local variables in Runner's **prepare_tasks** only (blank first iteration, then set from parser on retry).
- **Reader vs writer**
  - Each task is classified as reader (research/plan) or writer (modify). No separate "change tasks" list; a task that changes something is a normal writer task.
- **API**
  - **has_pending_exec()** — true if any task has no **execution result** (output) yet; early exit. Runner exits loop when `!has_pending_exec()`.
  - **steps** — public property; top-level list of TaskStep (sequential); each step is single task or concurrent group (children). No getter method.
  - **refine(Runner runner)** — async. **Start** refinement for all tasks (each task.refine via .begin). Does **not** block; returns as soon as all are started. run_until_writer / run_all_tasks then run; they wait on **wait_refined** only for the task they are about to run (inside run_child).
  - **run_until_writer(Runner runner)** — for each TaskStep: if children.size == 1 yield run_child(…); else num_exec_running = children.size, run_child.begin per child, yield **wait_exec_done()**. Stop at first step that has a writer task (approval gate).
  - **has_writer_tasks()** — true if any task in any item is a writer task (modify).
  - **run_all_tasks(Runner runner)** — for each TaskStep: if children.size == 1 yield run_child(…); else num_exec_running = children.size, run_child.begin per child, yield **wait_exec_done()**. After the loop, Runner calls **run_post_completion()** directly (no TaskList method).
  - **run_child(Task t, Runner runner)** — private async: **yield t.wait_refined()**, then yield t.run_tools(), yield t.post_evaluate(). Runner sets task properties and callbacks before starting the round; Task does not call runner. When children.size > 1, each .begin callback does run_child.end(res), num_exec_running--.
  - **wait_exec_done()** — yields until **execution** of the current step's children is done (num_exec_running is 0). Caller sets num_exec_running = children.size before starting the .begin() calls.
  - **Execution order**
  - **Refinement:** started once (refine); no blocking until we run a task — then run_child does wait_refined first.
  - **run_until_writer / run_all_tasks:** per step, either one run_child (yield) or several run_child.begin + **wait_exec_done**. Top level sequential; within a step, one task or concurrent children.

**Proposed code — TaskList:**

```vala
public Gee.ArrayList<TaskStep> steps { get; set; default = new Gee.ArrayList<TaskStep>(); }

/** Number of run_child (execution) callbacks still running for the current step. Caller sets = children.size before .begin(); each callback does num_exec_running--. */
private int num_exec_running = 0;

/** True if any task has no execution result (output) yet; returns as soon as one is found. */
public bool has_pending_exec()
{
	foreach (var step in this.steps) {
		foreach (var t in step.children) {
			if (!t.exec_done) {
				return true;
			}
		}
	}
	return false;
}

/** Yields until execution of the current step's children is done (num_exec_running is 0). Caller sets num_exec_running before starting .begin() calls. */
private async void wait_exec_done() throws GLib.Error
{
	while (this.num_exec_running != 0) {
		yield GLib.Idle.add((GLib.SourceFunc) () => false);
	}
}

/** Start refinement for all tasks (non-blocking). Launch each task's refine via .begin. Does not wait for any refinement to complete; run_child waits for that task's refinement when it runs. */
public async void refine(Runner runner) throws GLib.Error
{
	foreach (var step in this.steps) {
		foreach (var t in step.children) {
			t.refine.begin();
		}
	}
}

/** For each TaskStep: if size == 1 yield run_child(…); else num_exec_running = children.size, run_child.begin per child, yield wait_exec_done(). Stop when step.has_writer_task(). */
public async void run_until_writer(Runner runner) throws GLib.Error
{
	foreach (var step in this.steps) {
		if (step.has_writer_task()) {
			break;
		}
		var children = step.children;
		if (children.size == 1) {
			yield this.run_child(children.get(0), runner);
			continue;
		}
		this.num_exec_running = children.size;
		foreach (var t in children) {
			this.run_child.begin(t, runner, (o, res) => {
				this.run_child.end(res);
				this.num_exec_running--;
			});
		}
		yield this.wait_exec_done();
	}
}

private async void run_child(Task t, Runner runner) throws GLib.Error
{
	yield t.wait_refined();
	yield t.run_tools();
	yield t.post_evaluate();
}

public bool has_writer_tasks()
{
	foreach (var step in this.steps) {
		if (step.has_writer_task()) {
			return true;
		}
	}
	return false;
}

/** For each TaskStep: if size == 1 yield run_child(…); else num_exec_running = children.size, run_child.begin per child, yield wait_exec_done(). */
public async void run_all_tasks(Runner runner) throws GLib.Error
{
	foreach (var step in this.steps) {
		var children = step.children;
		if (children.size == 1) {
			yield this.run_child(children.get(0), runner);
			continue;
		}
		this.num_exec_running = children.size;
		foreach (var t in children) {
			this.run_child.begin(t, runner, (o, res) => {
				this.run_child.end(res);
				this.num_exec_running--;
			});
		}
		yield this.wait_exec_done();
	}
}
```

---

## TaskStep (`liboccoder/Skill/TaskStep.vala`)

- **One class per file.** Wrapper: holds list of Tasks (**children**). Top-level iteration is over TaskSteps; within a step, children run concurrently when children.size > 1.
- **API:** **children** — public list of Task (size 1 = single, >1 = concurrent). **has_writer_task()** — true if any task in this step is a writer. **wait_refined()** — async; when children.size == 1, blocks until that task has finished refining. For steps with children.size > 1, each child runs as soon as that task is refined (per-task wait in run_child).

**Proposed code — TaskStep:**

```vala
public class TaskStep : Object
{
	public Gee.ArrayList<Task> children { get; set; default = new Gee.ArrayList<Task>(); }

	public bool has_writer_task()
	{
		foreach (var t in this.children) {
			if (t.is_writer) {
				return true;
			}
		}
		return false;
	}

	/** When children.size == 1, block until that task has finished refining. For size > 1, run_child waits per task. */
	public async void wait_refined() throws GLib.Error
	{
		if (this.children.size != 1) {
			return;
		}
		yield this.children.get(0).wait_refined();
	}
}
```

---

## Task (`liboccoder/Skill/Task.vala`)

- **One class per file.**
- **is_writer** (or equivalent) — Classified from skill or task list format; used for **reader_tasks_without_output()** vs **writer_tasks_without_output()** and for **has_writer_tasks()**.
- **wait_refined()** — async; blocks until this task's refine has completed (so run_tools/post_evaluate can run). Used by single-task step.wait_refined() and by run_child for concurrent children.
- **Task extends OLLMchat.Agent.Base.** Constructor takes (Runner runner, OLLMchat.Agent.Factory factory, OLLMchat.History.SessionBase session); calls base(factory, session); sets this.runner = runner. Runner creates Task with (this, this.factory, this.session) when building the task list from the parser. Task thus has chat_call and uses the normal agent send path (no Runner.send_system_user).
- **refine()** — Task holds **reference to Runner** for context (env(), project description, current_file, task_definition) and for **content_for_reference(target)** when building the task reference block. Runner validates all skills and populates task_definition before any refinement (1.23.14). Task fills "task_refinement" template, builds messages (Message("system", system_content), Message("user", user_content)), yields **this.chat_call.send(messages)**; parses response.
- **run_tools()** — Task **emits tool_call_requested** (or equivalent) per tool; Runner is connected and executes, returns output via completion. Task stores tool outputs for executor precursor.
- **post_evaluate()** — Task builds executor precursor (reference_contents() + tool_outputs); reads task_definition from Runner. Task builds system/user messages, yields **this.chat_call.send(messages)**; sets **this.result_parser = new TaskResultParser(response_text)**, calls **result_parser.extract_exec(this)**; on success sets **this.exec_done = true**. Output: **task.result**, **task.result_document**.

**Proposed code — Task:**

```vala
public class Task : OLLMchat.Agent.Base
{
	public string what_is_needed { get; set; default = ""; }
	public string skill_name { get; set; default = ""; }
	public string references_markdown { get; set; default = ""; }
	public string expected_output { get; set; default = ""; }
	public bool is_writer { get; set; default = false; }

	/** Reference to Runner. Task reads from runner when filling (env(), project description, current_file, task_definition) and asks runner for each reference target's content when building the task reference block. */
	public weak Runner runner { get; set; }

	/** Parser for last refinement or executor response; set in refine() and replaced in post_evaluate(). After exec_done, callers read result and result_document on this task. */
	public TaskResultParser? result_parser { get; set; default = null; }

	/** Runner creates Task with (runner, factory, session, task_data). task_data is key → Block from ListItem.to_key_map(). Task initialises fields from map; expands references from "references" block (collect_link_hrefs), validates each href — if any invalid sets ref_issues (parser checks and appends with context). Task uses Base(factory, session) so it has chat_call and uses the agent send path for refine/post_evaluate. */
	public string ref_issues { get; set; default = ""; }

	/** task_data from ListItem.to_key_map(); keys may be bold labels ("What is needed", "Skill", "References", "Expected output") or snake_case (what_is_needed, skill_name, references, expected_output). Accept both so parse_step and update_props share the same to_key_map() output. */
	public Task(Runner runner, OLLMchat.Agent.Factory factory, OLLMchat.History.SessionBase session, Gee.Map<string, Markdown.Document.Block> task_data)
	{
		base(factory, session);
		this.runner = runner;
		this.what_is_needed = (task_data.get("What is needed") ?? task_data.get("what_is_needed"))?.to_markdown() ?? "";
		this.skill_name = (task_data.get("Skill") ?? task_data.get("skill_name"))?.to_markdown() ?? "";
		var ref_block = task_data.get("References") ?? task_data.get("references");
		this.references_markdown = ref_block?.to_markdown() ?? "";
		if (ref_block != null) {
			foreach (var href in this.collect_link_hrefs(ref_block)) {
				if (GLib.Path.is_absolute(href) || href == "project_description" || href.has_prefix("plan:")) {
					this.reference_targets.add(href);
					continue;
				}
				this.ref_issues = "Invalid reference target \"" + href + "\". Use only: absolute file path (e.g. /home/.../file.ext), project_description, or plan:section_or_task_output.";
				return;
			}
		}
		this.expected_output = (task_data.get("Expected output") ?? task_data.get("expected_output"))?.to_markdown() ?? "";
		this.is_writer = (task_data.get("is_writer")?.to_markdown() ?? "") == "true";
	}

	/** Update task properties from refinement output. Map from ListItem.to_key_map(); keys = bold labels ("What is needed", "Skill", "References", "Expected output") or snake_case — same convention as constructor. Sets what_is_needed, skill_name, references_markdown, expected_output; re-validates references (collect_link_hrefs, reference_targets, ref_issues). Caller (parser) validates required keys before calling. */
	public void update_props(Gee.Map<string, Markdown.Document.Block> refined_map)
	{
		this.what_is_needed = (refined_map.get("What is needed") ?? refined_map.get("what_is_needed"))?.to_markdown() ?? "";
		this.skill_name = (refined_map.get("Skill") ?? refined_map.get("skill_name"))?.to_markdown() ?? "";
		var ref_block = refined_map.get("References") ?? refined_map.get("references");
		this.reference_targets.clear();
		this.ref_issues = "";
		if (ref_block != null) {
			foreach (var href in this.collect_link_hrefs(ref_block)) {
				if (GLib.Path.is_absolute(href) || href == "project_description" || href.has_prefix("plan:")) {
					this.reference_targets.add(href);
					continue;
				}
				this.ref_issues = "Invalid reference target \"" + href + "\". Use only: absolute file path (e.g. /home/.../file.ext), project_description, or plan:section_or_task_output.";
				return;
			}
		}
		this.expected_output = (refined_map.get("Expected output") ?? refined_map.get("expected_output"))?.to_markdown() ?? "";
	}

	/** Collect all LINK node .href values from a block (traverse nodes). */
	private Gee.ArrayList<string> collect_link_hrefs(Markdown.Document.Block block) { return new Gee.ArrayList<string>(); }

	/** Reference targets for this task (from task creation: project_description, current_file, file paths, plan sections). Runner loops over these and resolves each using Runner context; the resulting block is stored per task and read at refinement fill time. */
	public Gee.ArrayList<string> reference_targets { get; set; default = new Gee.ArrayList<string>(); }

	/** Tool/skill calls to run. Task fills this by parsing attached_code_blocks (e.g. in run_tools); parser only attaches the raw code blocks from refinement. */
	public Gee.ArrayList<OLLMchat.Response.ToolCall> tool_calls { get; set; default = new Gee.ArrayList<OLLMchat.Response.ToolCall>(); }

	/** Outputs from run_tools; Runner uses these when setting precursor for post_evaluate. */
	public Gee.ArrayList<string> tool_outputs { get; set; default = new Gee.ArrayList<string>(); }

	/** Code blocks parsed after this task's list in the section (e.g. refinement output). Parser appends via attach_code_block(Block). */
	public Gee.ArrayList<string> attached_code_blocks { get; set; default = new Gee.ArrayList<string>(); }
	public void attach_code_block(Markdown.Document.Block code_block) { this.attached_code_blocks.add(code_block.to_markdown()); }

	/** True when post_evaluate has completed successfully; output is on this task (result, result_document). */
	public bool exec_done { get; set; default = false; }

	/** Executor output: summary (from "Result summary" section). Filled by TaskResultParser.extract_exec(this). */
	public string result { get; set; default = ""; }
	/** Executor output: the full parsed document. Filled by TaskResultParser.extract_exec(this). */
	public Markdown.Document.Document? result_document { get; set; default = null; }


	private bool refined_done = false;
	private GLib.Error? refine_error = null;

	public async void wait_refined() throws GLib.Error
	{
		while (!this.refined_done) {
			yield GLib.Idle.add((GLib.SourceFunc) () => false);
		}
		if (this.refine_error != null) {
			throw this.refine_error;
		}
	}

	/** Refinement: fill template. Runner has already validated skills and populated task_definition (1.23.14), so definition is non-null. Task builds task_reference_contents by looping reference_targets and asking Runner for each item (see "Building the task reference block"). */
	public async void refine() throws GLib.Error
	{
		this.refined_done = false;
		this.refine_error = null;
		var definition = this.runner.task_definition.get(this);  // non-null: Runner validated before refine
		var tpl = PromptTemplate.template("task_refinement");
		var user_content = tpl.fill(
			"coarse_task", this.coarse_task_markdown(),
			"skill_input_requirements", definition.skill_input_requirements(),
			"current_skill_call_issues", "",
			"environment", this.runner.env(),
			"project_description", this.runner.project_manager.active_project != null ? this.runner.project_manager.active_project.summary() : "",
			"current_file", this.runner.current_file,
			"task_reference_contents", this.reference_contents());
		var system_content = tpl.system_fill();
		var messages = new Gee.ArrayList<OLLMchat.Message>();
		messages.add(new OLLMchat.Message("system", system_content));
		messages.add(new OLLMchat.Message("user", user_content));
		string response_text;
		try {
			var response = yield this.chat_call.send(messages, null);
			response_text = response != null ? (response.content ?? "") : "";
		} catch (GLib.Error e) {
			this.refine_error = e;
			this.refined_done = true;
			return;
		}
		this.result_parser = new TaskResultParser(response_text);
		this.result_parser.extract_refinement(this);
		if (this.result_parser.issues != "") {
			this.refine_error = new GLib.IOError.INVAL(this.result_parser.issues);
		}
		this.refined_done = true;
	}

	/** Coarse task as bulleted list: bold key, value (no "Key: value" line format). */
	private string coarse_task_markdown()
	{
		return "- **What is needed** — " + this.what_is_needed + "\n"
			+ "- **Skill** — " + this.skill_name + "\n"
			+ "- **References** — " + this.references_markdown + "\n"
			+ "- **Expected output** — " + this.expected_output;
	}

	/** Resolved reference block for this task: loop reference_targets, ask Runner for content for each; each item is a header plus body in a fenced code block. Assemble in order. */
	private string reference_contents()
	{
		string[] parts = {};
		foreach (var target in this.reference_targets) {
			var content = this.runner.content_for_reference(target);
			if (content == null || content == "") {
				continue;
			}
			parts += this.reference_block(target, content);
		}
		return string.joinv("\n\n", parts);
	}

	/** One reference: header (e.g. ### target) then body in a fenced code block. Use a fence that does not appear at line-start in content so nested ``` does not close our block (CommonMark: use tildes when content has ```). */
	private string reference_block(string target, string content)
	{
		var fence = (content.contains("\n```") || content.has_prefix("```")) ? "~~~~" : "```";
		return "### " + target + "\n\n" + fence + "\n" + content + "\n" + fence;
	}

	/** Executor precursor: reference_contents() (same refs as refine) then each tool output as a headed code block (e.g. ### Tool output 1). */
	private string executor_precursor()
	{
		string[] parts = {};
		parts += this.reference_contents();
		for (var i = 0; i < this.tool_outputs.size; i++) {
			parts += this.reference_block("Tool output " + (i + 1).to_string(), 
				this.tool_outputs.get(i));
		}
		return string.joinv("\n\n", parts);
	}

	public async void run_tools() throws GLib.Error
	{
		foreach (var call in this.tool_calls) {
			// Emit tool_call_requested(call, done_cb); yield until Runner (connected) invokes done_cb with output
			var out = yield this.emit_tool_call(call);
			this.tool_outputs.add(out);
		}
	}

	/** Executor: fill template. Precursor = same reference content as refine (reference_contents()) plus this task's tool_outputs in same header+code-block format; Task builds it from what it already has (refs from Runner per reference_targets, tool_outputs from run_tools). Reads task_definition from Runner. */
	public async void post_evaluate() throws GLib.Error
	{
		var definition = this.runner.task_definition.get(this);
		if (definition == null) {
			throw new GLib.IOError.NOT_FOUND("Skill not found: " + this.skill_name);
		}
		var tpl = PromptTemplate.template("task_execution");
		var user_content = tpl.fill(
			"query", this.what_is_needed,
			"skill_definition", definition.full_content,
			"precursor", this.executor_precursor());
		var system_content = tpl.system_fill();
		var messages = new Gee.ArrayList<OLLMchat.Message>();
		messages.add(new OLLMchat.Message("system", system_content));
		messages.add(new OLLMchat.Message("user", user_content));
		var response = yield this.chat_call.send(messages, null);
		this.result_parser = new TaskResultParser(response != null ? (response.content ?? "") : "");
		this.result_parser.extract_exec(this);
		if (this.result_parser.issues == "") {
			this.exec_done = true;
		}
	}
}
```

- **Tool call** — use existing **OLLMchat.Response.ToolCall** (function.name, function.arguments). Parser only attaches refinement code blocks to the task; Task parses attached_code_blocks into tool_calls (e.g. when run_tools runs).
- **Runner** holds shared context (env(), project_manager, current_file) and exposes **content_for_reference(string target)** so Task can ask for the content for a single reference. Runner holds per-task **task_definition**. **Task extends OLLMchat.Agent.Base**: Task uses **this.chat_call.send(messages)** for refine and post_evaluate (no send_system_user on Runner). Runner performs tool execution when Task requests it (tool_call_requested or equivalent). Task builds the refinement reference block by looping reference_targets and calling Runner.content_for_reference for each; Task builds the **executor** precursor itself (reference_contents() + tool_outputs), not from Runner (see below).

**Building the task reference block (Task's job)**

- Task creation outputs tasks whose **References** field contains link items (e.g. `[Project description](project_description)`, `[Current file](current_file)`, file paths, plan sections). The task list parser turns those into a list of **reference targets** per task (`reference_targets` on Task).
- It is the **Task's** job to **build** the resolved reference block for refinement. The **Task** loops through its `reference_targets` and, for each reference, **asks the Runner** for the content for that item. The Runner has the context and can provide each piece (project_description, current_file, environment, file contents, plan section, prior task output, etc.); Runner does not build or store the block.
- Task assembles the returned content (in reference order) into a single block and uses it when filling the refinement template (e.g. as `task_reference_contents`). So: Task builds it; Runner is the data source for the individual items. For the **executor** prompt, Task builds the precursor from the **same** reference content (reference_contents()) plus this task's **tool_outputs** (each as a headed code block, same format); info comes from Task (refs already built as in refine, tool_outputs from run_tools). No separate Runner-held task_precursor.
- **Reference content format:** Each resolved reference is output as a **header** (e.g. `### target`) plus the **body in a fenced code block**. So the refinement prompt receives a series of headed code blocks. **Nested code block markers:** If the body itself contains ``` at line start, that would close our fence. Per CommonMark: use a **longer or different fence** for the wrapper — in reference_block: if content has ``` at line start use `~~~~`, otherwise use ```.

---

## Task list output format (headings) — from 1.23.3; prompt updates in 1.23.14

- **Required ## section headings (exact text):** **Original prompt**, **Goals / summary**, **General information for all tasks**, **Tasks**. Optional when rectifying: **Issues with the tasks (rectified)**.
- **Under ## Tasks:** level-3 headings only: **### Task section 1**, **### Task section 2**, … (heading text **Task section 1**, **Task section 2**, etc.). Each such section contains **one list per task with a break between each**: a top-level list where each list item is one task (blank line or structural break between items). Within each list item: a **nested list** with **What is needed**, **Skill**, **References**, **Expected output**. After refinement, section content may be: list, code block, list, code block, … (code block is attached to the previous task). Parser walks section contents; does not stop at first non-list. **1.23.14** must update task-creation and post-completion prompts to require this format (list per task, break between tasks).

---

## New classes (or equivalent)

- **Document.heading_contents(Block heading)** — Returns **only the content nodes** for that section (from after the heading until the next heading of any level; next heading not included). Does not return heading blocks — only content (e.g. List, CodeBlock). Use **document.headings** to get a section by name, then **heading_contents(that_block)** to get that section’s contents.
- **List.to_hashmap()** — Method on **Markdown.Document.List**: for each list item, key = first bold text (e.g. "What is needed"), value = block of remaining elements of that list item. Returns **Gee.Map<string, Markdown.Document.Block>**. Assumes nested list (each item has label then content).
- **ListItem.to_key_map()** — Generic method on **Markdown.Document.ListItem**: returns **Gee.Map<string, Markdown.Document.Block>** (key = first bold label per sub-item or block, value = block of remaining content). Uses nested List.to_hashmap() or parses blocks. Task-list parser calls to_key_map() and uses the map with task field names (what_is_needed, skill_name, references, expected_output, is_writer); Task constructor takes that map.
- **Single result parser** — Document is built in the **constructor** from the response string (Markdown.Document.Render). Then **extraction methods** are called to get specific data; they read from the stored document.
  - **Constructor: TaskResultParser(string response)** — Build the document once: use Markdown.Document.Render, parse(response), store the document. No separate parse step.
  - **parse_task_list(Runner runner)** — Check required sections with **has_key** (Original prompt, Goals / summary, General information for all tasks, Tasks). Iterate **headings** under ## Tasks that start with **Task section**; pass each to **parse_step(runner, heading)**. **parse_step** **walks** **section_heading.contents()** in order: **List** → parse each list item as task (to_key_map), add to step; **CodeBlock** → append to previous task (attach_code_block); other content ignored. Does **not** stop at first non-list. Caller checks **parser.issues == ""** for success (no valid property). **Needs Runner** to build Task instances.
  - **extract_refinement(Task task)** — Update the task from the refinement response (1.23.4). Same pattern as parse_step: (1) Section "Refined task" — heading.contents(), walk for List → first ListItem.to_key_map(), validate required keys (What is needed, Skill, References, Expected output), task.update_props(map). (2) Section "Skill call" — heading.contents(), each Block (FENCED_CODE) → task.attach_code_block(block). Appends to **issues** if sections missing, keys missing, or no fenced blocks. Does not parse into ToolCalls; Task does that. Task.refine() uses: `this.result_parser = new TaskResultParser(response_text); this.result_parser.extract_refinement(this);` then result_parser.issues.
  - **extract_exec(Task task)** — Fill in task.result from "Result summary" section and set task.result_document = this.document. No filename or details parsing. Task.post_evaluate() uses: `this.result_parser = new TaskResultParser(response_text); this.result_parser.extract_exec(this);` then task.result, task.result_document; on success sets this.exec_done = true.
  - One parser instance per response: constructor takes that response and builds the document; caller then calls the relevant extract_* method. Task sets this.result_parser per phase (refine then exec); after exec, task.result and task.result_document hold the output.
  - **Issue messages must include context:** Every string appended to **issues** must tell the LLM **where** in the output the problem is (e.g. "Section \"Task section 1\"", "list item 2", "top-level structure"), **what** is wrong, and **what** to do. Never append a bare error like "Invalid reference" or "No list found" without that context — the LLM cannot guess which section or task is meant.
- **Task list validation (Runner, 1.23.14):** After parse_task_list(), Runner validates (1) **skills** — every task's skill exists; (2) **reference content length** — no task's total resolved reference content may exceed a max; if too long, Runner appends to parser.issues. Runner passes parser.issues as previous_proposal_issues so the task creation prompt receives all errors and can revise the plan accordingly.
- **Template fill**
  - We use the **templating system**: prompt templates define structure; we **fill** placeholders with key-value pairs. **Task** holds a reference to **Runner**. When filling refinement, Task builds the task reference block itself (loops its reference_targets, asks Runner for content for each via e.g. **content_for_reference(target)**; Runner provides the individual items). Task also reads shared context (env(), project description, current_file) and per-task **task_definition** from Runner; for executor, Task builds precursor from reference_contents() + tool_outputs (see **Building the task reference block**). Optionally a small helper to format one "header + content" section; the actual assembly is the template's. Optionally filter by relevance once 1.23.12 defines the format.

**Proposed code — TaskResultParser (single class):**

- **Constructor** builds the document from the response. **Extraction methods** read from the document; **parse_task_list(Runner)** needs Runner to build Task instances.

```vala
public class TaskResultParser : Object
{
	/** Document built in constructor; extraction methods read from this. */
	private Markdown.Document.Document document;

	// — parse_task_list() result
	public TaskList? task_list { get; set; default = null; }
	public string proposal { get; set; default = ""; }
	/** Append to this on each validation failure (do not overwrite) so multiple errors can be reported. Use append_issue(msg). Every message must include context so the LLM can locate the problem: which section/task, what is wrong, what to do. */
	public string issues { get; set; default = ""; }
	private void append_issue(string msg) { this.issues = this.issues == "" ? msg : this.issues + "\n" + msg; }

	// — extract_exec() writes to Task (result, result_document); no parser result properties

	/** Build document from response (Markdown.Document.Render). Call extract_* next. */
	public TaskResultParser(string response)
	{
		this.proposal = response;
		var render = new Markdown.Document.Render();
		render.parse(response);
		this.document = render.document;
	}

	/** Parse task list from document; needs Runner to build Task instances. Appends to issues on each failure. Caller checks parser.issues == "" for success. */
	public void parse_task_list(Runner runner)
	{
		this.issues = "";
		this.task_list = null;

		var required = new string[] { "Original prompt", "Goals / summary", "General information for all tasks", "Tasks" };
		foreach (var key in required) {
			if (!this.document.headings.has_key(key)) {
				this.append_issue("Top-level structure: the response must contain these ## sections in order — Original prompt, Goals / summary, General information for all tasks, Tasks. Missing or misnamed: \"" + key + "\".");
				return;
			}
		}

		this.task_list = new TaskList();
		foreach (var entry in this.document.headings.entries) {
			if (!entry.key.has_prefix("Task section")) {
				continue;
			}
			var section_heading = entry.value;
			TaskStep? step = this.parse_step(runner, section_heading);
			if (step == null) {
				continue;  // issue already appended; collect further errors from other sections
			}
			this.task_list.steps.add(step);
		}
	}

	/** Build one TaskStep from a task section heading: walks heading_contents(section_heading). First ignore (not Block and not List → continue). Then rule out Block that is not fenced code (continue). Then: Block with kind fenced code → attach to last_task; List → parse list items as tasks. (List does not extend Block.) Returns null only when section has no list at all (append issue). */
	private TaskStep? parse_step(Runner runner, Markdown.Document.Block section_heading)
	{
		var step = new TaskStep();
		var contents = section_heading.contents();
		var section_title = section_heading.to_markdown();
		Task? last_task = null;
		var found_any_list = false;
		foreach (var node in contents) {
			if (!(node is Markdown.Document.Block) && !(node is Markdown.Document.List)) {
				continue;
			}
			if (node is Markdown.Document.Block) {
				if (last_task == null) {
					continue;
				}
				var block = (Markdown.Document.Block) node;
				if (block.kind != Markdown.Document.BlockKind.FENCED_CODE) {
					continue;
				}
				last_task.attach_code_block(block);
				continue;
			}
			// node is List; list children are ListItem (per document model)
			found_any_list = true;
			var list_block = (Markdown.Document.List) node;
			foreach (var list_child in list_block.children) {
				var list_item = (Markdown.Document.ListItem) list_child;
				var task_data = list_item.to_key_map();
				var task = new Task(runner, runner.factory, runner.session, task_data);
				if (task.ref_issues != "") {
					this.append_issue("Section \"" + section_title + "\", a task in this section (References): " + task.ref_issues);
					continue;
				}
				step.children.add(task);
				last_task = task;
			}
		}
		if (!found_any_list) {
			this.append_issue("Section \"" + section_title + "\": this section must contain at least one list of tasks. Each list item is one task (nested list with **What is needed**, **Skill**, **References**, **Expected output**). No list was found under \"" + section_title + "\" — add a list there as in the output format.");
			return null;
		}
		return step;
	}

	/** Parses single-task refinement output. Section "Refined task": walk contents — List → first ListItem.to_key_map() → task.update_props(map); Block (FENCED_CODE) → task.attach_code_block(block). Task reports issues (e.g. ref_issues); no requirement for attachments. Content we parse (plan/prompt format):
	 *   - **What is needed** ...
	 *   - **Skill** ...
	 *   - **References** ...
	 *   - **Expected output** ...
	 *   - **Skill call** ...
	 *   ``` possibly a code block... ``` */
	public void extract_refinement(Task task)
	{
		var section_title = "Refined task";
		var refined_heading = this.document.headings.get(section_title);
		if (refined_heading == null) {
			this.append_issue("Refinement output must include a \"Refined task\" section. No such section was found. Produce a Refined task section with a list containing **What is needed**, **Skill**, **References**, **Expected output**, and **Skill call**.");
			return;
		}
		var contents = refined_heading.contents();
		var found_list = false;
		foreach (var node in contents) {
			if (!(node is Markdown.Document.Block) && !(node is Markdown.Document.List)) {
				continue;
			}
			if (node is Markdown.Document.Block) {
				var block = (Markdown.Document.Block) node;
				if (block.kind != Markdown.Document.BlockKind.FENCED_CODE) {
					continue;
				}
				task.attach_code_block(block);
				continue;
			}
			found_list = true;
			var list_block = (Markdown.Document.List) node;
			if (list_block.children.size == 0) {
				this.append_issue("Section \"" + section_title + "\": the list must contain at least one item (the refined task with **What is needed**, **Skill**, **References**, **Expected output**, **Skill call**).");
				return;
			}
			var list_item = (Markdown.Document.ListItem) list_block.children.get(0);
			var refined_map = list_item.to_key_map();
			task.update_props(refined_map);
			if (task.ref_issues != "") {
				this.append_issue("Section \"" + section_title + "\" (References): " + task.ref_issues);
			}
			break;
		}
		if (!found_list) {
			this.append_issue("Section \"" + section_title + "\": must contain a list with one item (nested list **What is needed**, **Skill**, **References**, **Expected output**, **Skill call**). No list was found — add a list there as in the output format.");
			return;
		}
	}

	/** Fill in the summary on the task and add the document to the task. That's it — no parsing of filename or details. Single pass: find section "Result summary" → task.result = section content; task.result_document = this.document. If no Result summary section, append issue. Content we expect (task_execution.md / 1.23.6):
	 *   ## Result summary
	 *   We have the information we need; it is complete. */
	public void extract_exec(Task task)
	{
		task.result = "";
		task.result_document = this.document;
		var heading = this.document.headings.get("Result summary");
		if (heading == null) {
			this.append_issue("This task's executor output must include a \"Result summary\" section (required). It was missing or not found in the response. Produce a result summary (what was found or produced; whether complete or more work needed).");
			return;
		}
		var section_contents = heading.contents();
		var parts = new Gee.ArrayList<string>();
		foreach (var node in section_contents) {
			if (node is Markdown.Document.Block) {
				parts.add(((Markdown.Document.Block) node).to_markdown());
			}
		}
		task.result = string.joinv("\n\n", parts.to_array()).strip();
	}
}
```

---

## Types to introduce

- **TaskList**, **TaskStep**, **Task** — One class per file (see sections above). TaskStep = wrapper (single task or concurrent set of tasks); top level always sequential.
- **Tool call** — use existing **OLLMchat.Response.ToolCall**; Task parses attached_code_blocks into tool_calls; extract_refinement(Task) only attaches the raw fenced code blocks to the task.
- **Block.contents()** — Method on the section heading (Block) returns content nodes until the next heading. Return type e.g. Gee.ArrayList&lt;Node&gt;. Not on Document.
- **List.to_hashmap()** — Returns Gee.Map&lt;string, Block&gt;: key = first bold text per list item, value = block of remaining elements (nested list structure).
- **ListItem.to_key_map()** — Generic: returns **Gee.Map<string, Markdown.Document.Block>** (key = bold label, value = block). Parser uses it with task field names. Task constructor and **update_props** accept both bold labels ("What is needed", "Skill", "References", "Expected output") and snake_case (what_is_needed, skill_name, references, expected_output) so the same map works from parse_step and extract_refinement.
- **Task(Runner, Factory, Session, Gee.Map<string, Markdown.Document.Block> task_data)** — Constructor initialises from map (keys from to_key_map()); **update_props(map)** same key convention. Expands **references** block (collect_link_hrefs), validates each href, sets **ref_issues** if any invalid (parser checks and appends with section context). **attach_code_block(Block)** / **attached_code_blocks** — parser appends code blocks that follow a task's list in the section (e.g. refinement output).
- **Definition.skill_input_requirements()** — Returns the skill's input-requirements section (e.g. from body under "Input requirements" heading); see 1.23.11 Definition. Task.refine() uses it for `{skill_input_requirements}`.
- **TaskResultParser** — single class; **constructor(string response)** builds document (Markdown.Document.Render). **issues** is a string; **append** to it on each failure (e.g. append_issue(msg)) so multiple errors can be reported. **parse_task_list(Runner)** → task_list, proposal, issues. Caller checks parser.issues == "" for success (no **valid** property). **extract_refinement(Task task)** — same walk as parse_step: "Refined task" section → List → first ListItem.to_key_map() → task.update_props(map); Block (FENCED_CODE) → task.attach_code_block. Task reports issues; no requirement for attachments. **extract_exec(Task task)** → task.result, task.result_document; appends to issues if no Result summary section. Runner uses parser.issues for previous_proposal_issues. Task checks result_parser.issues.

---

## References

- 1.23.11 (parent); 1.23.2 (orchestration); 1.23.3 (task creation format); 1.23.4 (refinement); 1.23.5 (post completion format); 1.23.6 (executor format); 1.23.12 (context restriction).
