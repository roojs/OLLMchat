# 1.8.1 Markdown render issues (remaining)

- **Goal:** Fix remaining markdown test failures (formatting, indented fenced blocks).
- **Status:** open.
- **Coding standards:** Verify against `.cursor/rules/CODING_STANDARDS.md` (brace placement, `this.` prefix, no one-line if with body, no unnecessary temporaries, line breaking).

---

## 1. Formatting (HTML) — test 1

- Code span must not parse inline formatting inside backticks.
- `**bold**` / `*italic*` inside `` `code` `` → output literal, not `<strong>`/`<em>`.
- **Clarification:** Literals (inline backtick spans) are not code blocks. Emit their content as regular text (e.g. via `on_text` within the code-span wrapper), not as block code.

**Proposed change (string instead of bool):**
- `string is_literal = ""` — off (not in code span).
- is_literal = one backtick char — literal span (close on one `).
- is_literal = two backtick chars — code span (close on two ``).
- So we know which delimiter closes; no formatting inside either.

**formatmap.peek_literal(...):**
- Returns 0 (no match, treat char as literal), -1 (need more data), or N (match length in bytes; closing delimiter).
- Simple case first: when is_literal == one backtick: if c == '`' return 1; else return 0. Never -1.
- When is_literal == two backticks: if only one char in chunk and it's ` return -1; if two chars and `` return 2; else return 0.

```vala
// FormatMap: add method
// @return 0 no match, -1 need more, N match length (bytes to advance)
public int peek_literal(string chunk, int chunk_pos, bool is_end_of_chunks, string is_literal)
{
    if (is_literal == "" || chunk_pos >= chunk.length) {
        return 0;
    }
    var c0 = chunk.get_char(chunk_pos);
    if (c0 != '`') {
        return 0;
    }
    // Simple case: one backtick span — close on one `
    if (is_literal.length == 1) {
        return 1;
    }
    // Two backtick span — need `` to close (c0 is `, so 1 byte)
    if (chunk_pos + 1 >= chunk.length) {
        if (!is_end_of_chunks) {
            return -1;
        }
        return 0;
    }
    var c1 = chunk.get_char(chunk_pos + 1);
    if (c1 != '`') {
        return 0;
    }
    return 2;
}
```

**Parser block (after escape, before startmap/leftmap/rightmap/formatmap):**

```vala
if (this.is_literal != "") {
    var result = this.formatmap.peek_literal(chunk, chunk_pos, is_end_of_chunks, this.is_literal);
    if (result == -1) {
        this.leftover_chunk = str + chunk.substring(chunk_pos, chunk.length - chunk_pos);
        str = "";
        return;
    }
    if (result == 0) {
        str += c.to_string();
        chunk_pos += c.to_string().length;
        this.at_line_start = false;
        continue;
    }
    // result == N: closing delimiter matched, advance N
    this.renderer.on_text(str);
    str = "";
    this.state_stack.remove_at(this.state_stack.size - 1);
    this.do_format(false, this.is_literal.length == 1 ? FormatType.LITERAL : FormatType.CODE);
    this.is_literal = "";
    chunk_pos += result;
    this.at_line_start = false;
    continue;
}
```

**Implementation:**
- Add `string is_literal { get; set; default = ""; }` to Parser (replace bool in_literal when done; property with default per CODING_STANDARDS).
- In do_format: when opening LITERAL set is_literal = one backtick; when opening CODE set is_literal = two backticks; when closing set is_literal = "".
- Add FormatMap.peek_literal(chunk, chunk_pos, is_end_of_chunks, is_literal); implement as above.
- Insert parser block after escape, before startmap; on result N use stack top (or is_literal) to call do_format(false, LITERAL) or do_format(false, CODE).
- Apply same is_literal + peek_literal logic in process_inline.

**Issues with this fix:**
- None for single-backtick test.
- Double-backtick span: fixed by peek_literal (returns 2 when `` seen; -1 when only one ` and need more).

**Terminology:**
- **Code span (inline):** One or two backticks. Set is_literal to one or two backtick chars when opened; cleared on close. peek_literal decides close.
- **Code block:** Fenced or indented; block-level, does not set is_literal.

**Caveats (optional):**
- Set at_line_start = false in close branch.

**Options:**

- **A. Early flush (chosen)**
  - When `in_literal`: if not backtick → append, advance, continue; if backtick → close LITERAL here. No formatmap.eat.
- **B. Skip maps when in literal**
  - Add `if (in_literal) skip` before startmap, leftmap, rightmap
  - After formatmap.eat: zero match_len unless LITERAL/CODE and matches stack top
- **C. Zero after eat only**
  - Current: zero match_len when in_literal and not LITERAL
  - Fails: leftmap matches `**` before formatmap
  - Need A or B

---

## 2. Indented fenced blocks (trace) — test 5

- CODE_TEXT includes leading list-item indent (e.g. `"   void main() {"`).
- Fix: strip indent from code block lines before CODE_TEXT callback.
- Update expected trace to word-split TEXT (match blocks/links) when fixing CODE_TEXT.
