# 2.4.1. URGENT - Edit Tool Migrate to Use Project Manager and Buffer

## Overview

Migrate `libollmchat/Tools/RequestEditMode` to use `ProjectManager` and buffer-based file operations instead of direct file I/O. This ensures consistent file handling, proper backup management, and eliminates race conditions when counting file lines after writes.

## Status

ðŸš¨ **URGENT** - In Progress

## Problem

The current `libollmchat/Tools/RequestEditMode` implementation:
- Uses direct file I/O (`DataInputStream`/`DataOutputStream`) instead of buffers
- Reads files directly from disk after writing, causing race conditions
- Does not use `ProjectManager` for file access
- Does not benefit from automatic backup management
- Line counting fails due to file system caching/timing issues

The `liboctools/RequestEditMode` already uses the correct approach with buffers and `ProjectManager`.

## Goals

1. Migrate `libollmchat/Tools/RequestEditMode` to use `ProjectManager` and buffers
2. Remove all direct file I/O operations
3. Use `file.buffer.read_async()` for reading
4. Use `file.buffer.write()` for writing (automatic backups)
5. Use `file.buffer.get_line_count()` for line counting (no disk reads)
6. Ensure `EditMode` tool class has `project_manager` property

## Implementation Plan

### Phase 1: Add ProjectManager Support to EditMode Tool

- [x] Add `project_manager` property to `libollmchat/Tools/EditMode` class
- [x] Update `EditMode` constructor to accept optional `ProjectManager` parameter
- [x] Ensure `project_manager` is passed from `Window.vala` when creating the tool

### Phase 2: Migrate File Access to Use ProjectManager

- [x] Update `RequestEditMode.apply_all_changes()` to:
  - Get or create `File` object using `project_manager.get_file_from_active_project()`
  - Create fake file if not in project: `File.new_fake(project_manager, path)`
  - Ensure buffer exists: `file.manager.buffer_provider.create_buffer(file)`
- [x] Update `build_perm_question()` to check if file is in active project (skip permission for project files)
- [x] Update `count_file_lines()` to use ProjectManager and buffer-based line counting
- [x] Make `apply_all_changes()`, `apply_edits()`, and `create_new_file_with_changes()` async and accept File parameter

### Phase 3: Migrate File Reading to Buffer

- [x] For edit mode (non-complete_file):
  - Replace `apply_edits()` streaming approach with buffer-based approach
  - Use `file.buffer.read_async()` to load file if needed
  - Use `file.buffer.get_text()` or `file.buffer.apply_edits()` for applying changes
  - Remove `process_edits()` method that uses `DataInputStream`
- [x] Remove temporary file creation and file move operations

### Phase 4: Migrate File Writing to Buffer

- [ ] For complete_file mode:
  - Replace `create_new_file_with_changes()` direct file writing
  - Use `file.buffer.write(replacement_content)` instead
  - Remove `DataOutputStream` usage
- [ ] For edit mode:
  - Use `file.buffer.apply_edits(changes)` if available
  - Or use `file.buffer.write(final_content)` after reconstructing in memory
- [ ] Ensure all writes go through buffer (automatic backups for project files)

### Phase 4.5: Handle Newly Created Files in Project

When creating a new file (complete_file mode), ensure proper integration with project management:

- [ ] Before writing new file, check if file path is within active project:
  - Check if `active_project != null` and file path starts with `active_project.path`
  - If file is within active project:
    - Check if file already exists in project: `project_manager.get_file_from_active_project(normalized_path)`
    - If file doesn't exist yet (new file):
      - Create proper `File` object (not fake) using `File.new_from_info()` or `File(manager)` + set properties
      - Query file info from disk after creation: `GLib.File.query_info()` to get FileInfo
      - Find parent folder: Get parent path using `GLib.Path.get_dirname(normalized_path)`, then find folder in project tree
      - Set file's `parent` property and `parent_id`
      - Add file to parent folder's `children` list: `parent_folder.children.append(file)`
      - Add file to `project_manager.file_cache`: `project_manager.file_cache.set(file.path, file)`
      - File will have `id = 0` (new file, not fake with id = -1)
    - If file already exists in project:
      - Use existing file object (already in tree)
  - If file is outside active project:
    - Keep using fake file (id = -1) - no project integration needed
- [ ] After writing via `file.buffer.write()`:
  - For project files (id >= 0): `buffer.write()` automatically saves to DB (see FileBuffer documentation)
  - For fake files (id = -1): No DB operations (as expected)
- [ ] After file creation and write, update ProjectFiles list:
  - Call `active_project.project_files.update_from(active_project)` to rebuild the list
  - This ensures the new file appears in project file lists/trees
- [ ] Notify project manager (optional, for consistency):
  - Call `project_manager.notify_file_changed(file)` after write completes
  - This marks DB as dirty and ensures consistency
- [ ] Verify that newly created project files appear in:
  - Project file tree/dropdown
  - Project file search
  - Database (with proper id > 0)
- [ ] Note on events/signals:
  - `file.changed()` signal is emitted by `FileBuffer.write()` after write completes
  - `ProjectManager.active_file_changed()` signal is only for active file changes
  - Currently no `file_added` signal exists - `update_from()` rebuilds the list synchronously
  - If UI needs to react to new files, it should listen to `file.changed()` or check ProjectFiles list after `update_from()`

### Phase 5: Fix Line Counting to Use Buffer

- [ ] Replace `count_file_lines()` disk reading with buffer-based counting
- [ ] For complete_file mode: After writing to buffer, use `file.buffer.get_line_count()`
- [ ] For edit mode: After applying edits, use `file.buffer.get_line_count()`
- [ ] Remove all `DataInputStream` usage for line counting
- [ ] Remove all character-by-character loops for line counting
- [ ] Use buffer's built-in `get_line_count()` method (no manual counting needed)

### Phase 6: Update Permission Handling

- [ ] Check if file is in active project before permission prompts
- [ ] Skip permission checks for files in active project (auto-approved)
- [ ] Only prompt for files outside active project

### Phase 7: Testing and Validation

- [ ] Test complete_file mode (new file creation)
- [ ] Test complete_file mode (overwrite existing file)
- [ ] Test edit mode (single edit)
- [ ] Test edit mode (multiple edits)
- [ ] Test edit mode (insertions at end of file)
- [ ] Verify line counting is accurate
- [ ] Verify backups are created for project files
- [ ] Verify no race conditions in line counting

## Files to Modify

- `libollmchat/Tools/EditMode.vala` - Add `project_manager` property
- `libollmchat/Tools/RequestEditMode.vala` - Migrate to buffer-based operations
- `ollmchat/Window.vala` - Pass `project_manager` to `EditMode` constructor

## Reference Implementation

See `liboctools/RequestEditMode.vala` for the correct implementation pattern:
- Uses `project_manager.get_file_from_active_project()`
- Uses `file.buffer.read_async()` for reading
- Uses `file.buffer.write()` for writing
- Uses `file.buffer.get_line_count()` for counting
- Handles fake files for files outside project

## Notes

- The `liboctools` version is the reference implementation
- This migration should make `libollmchat` version match `liboctools` approach
- All file operations must go through buffers - no direct I/O
- Buffer operations handle backups automatically for project files
- Buffer operations are async and thread-safe

