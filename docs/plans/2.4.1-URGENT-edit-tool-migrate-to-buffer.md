# 2.4.1. URGENT - Edit Tool Migrate to Use Project Manager and Buffer

## Overview

Migrate `libollmchat/Tools/RequestEditMode` to use `ProjectManager` and buffer-based file operations instead of direct file I/O. This ensures consistent file handling, proper backup management, and eliminates race conditions when counting file lines after writes.

## Status

ðŸš¨ **URGENT** - In Progress

## Problem

The current `libollmchat/Tools/RequestEditMode` implementation:
- Uses direct file I/O (`DataInputStream`/`DataOutputStream`) instead of buffers
- Reads files directly from disk after writing, causing race conditions
- Does not use `ProjectManager` for file access
- Does not benefit from automatic backup management
- Line counting fails due to file system caching/timing issues

The `liboctools/RequestEditMode` already uses the correct approach with buffers and `ProjectManager`.

## Goals

1. Migrate `libollmchat/Tools/RequestEditMode` to use `ProjectManager` and buffers
2. Remove all direct file I/O operations
3. Use `file.buffer.read_async()` for reading
4. Use `file.buffer.write()` for writing (automatic backups)
5. Use `file.buffer.get_line_count()` for line counting (no disk reads)
6. Ensure `EditMode` tool class has `project_manager` property

## Implementation Plan

### Phase 1: Add ProjectManager Support to EditMode Tool

- [x] Add `project_manager` property to `libollmchat/Tools/EditMode` class
- [x] Update `EditMode` constructor to accept optional `ProjectManager` parameter
- [x] Ensure `project_manager` is passed from `Window.vala` when creating the tool

### Phase 2: Migrate File Access to Use ProjectManager

- [x] Update `RequestEditMode.apply_all_changes()` to:
  - Get or create `File` object using `project_manager.get_file_from_active_project()`
  - Create fake file if not in project: `File.new_fake(project_manager, path)`
  - Ensure buffer exists: `file.manager.buffer_provider.create_buffer(file)`
- [x] Update `build_perm_question()` to check if file is in active project (skip permission for project files)
- [x] Update `count_file_lines()` to use ProjectManager and buffer-based line counting
- [x] Make `apply_all_changes()`, `apply_edits()`, and `create_new_file_with_changes()` async and accept File parameter

### Phase 3: Migrate File Reading to Buffer

- [x] For edit mode (non-complete_file):
  - Replace `apply_edits()` streaming approach with buffer-based approach
  - Use `file.buffer.read_async()` to load file if needed
  - Use `file.buffer.get_text()` or `file.buffer.apply_edits()` for applying changes
  - Remove `process_edits()` method that uses `DataInputStream`
- [x] Remove temporary file creation and file move operations

### Phase 4: Migrate File Writing to Buffer

- [x] For complete_file mode:
  - Replace `create_new_file_with_changes()` direct file writing
  - Use `file.buffer.write(replacement_content)` instead
  - Remove `DataOutputStream` usage
- [x] For edit mode:
  - Use `file.buffer.apply_edits(changes)` if available
  - Or use `file.buffer.write(final_content)` after reconstructing in memory
- [x] Ensure all writes go through buffer (automatic backups for project files)

### Phase 4.5: Handle Newly Created Files in Project

When creating a new file (complete_file mode) within the active project, convert the fake file to a proper File object (id = 0) after the file is written to disk:

**Step 1: Create directory and write file (already done)**
- `create_new_file_with_changes()` already:
  - Creates parent directory if needed: `dir.make_directory_with_parents()`
  - Writes file using fake file: `file.buffer.write()` (file has id = -1 at this point)

**Step 2: After write completes, convert to real file if within project**
- [ ] Create new method `deal_with_new_file(File file)`:
  - Early return if file is outside active project:
    - Check if `active_project == null` or `!normalized_path.has_prefix(active_project.path)`
    - If outside project, return early (keep as fake file, id = -1)
  - File is within project and has id = -1 (fake file):
    - Get parent directory path: `GLib.Path.get_dirname(normalized_path)`
    - Find or create parent folder objects in project tree (walk from `active_project` down the path, creating Folder objects as needed)
    - Query file info from disk: `GLib.File.query_info()` to get FileInfo
    - Convert fake file to real File object:
      - Create new File: `new File(project_manager)` (not `new_fake()`)
      - Set `file.path = normalized_path`
      - Set `file.parent = parent_folder` and `file.parent_id = parent_folder.id`
      - Set `file.id = 0` (new file, will be inserted on save)
      - Set properties from FileInfo: `is_text`, `last_modified`, `language`, etc.
    - Add file to parent folder's children: `parent_folder.children.append(file)`
    - Add file to `project_manager.file_cache`: `project_manager.file_cache.set(file.path, file)`
    - Replace buffer's file reference (or recreate buffer with new file object)
    - Save file to DB: `file.saveToDB(project_manager.db, null, false)` (gets id > 0)
    - Update ProjectFiles list: `active_project.project_files.update_from(active_project)`
    - This will trigger `file_added` signal from ProjectFiles (if signal exists)
- [ ] Add `new_file_added` signal to ProjectFiles:
  - Add signal declaration: `public signal void new_file_added(File file)`
  - Do NOT emit in `append()` or `insert()` (those are called during scans)
  - Only emit when explicitly adding a new file (e.g., in `deal_with_new_file()` after converting fake to real)
  - This allows UI components to react only when new files are created, not during directory scans
- [ ] In `create_new_file_with_changes()`, after `yield file.buffer.write()`:
  - Only call `yield this.deal_with_new_file(file)` if `file.id == -1` (fake file)

### Phase 5: Fix Line Counting to Use Buffer

- [x] Replace `count_file_lines()` disk reading with buffer-based counting
- [x] For complete_file mode: After writing to buffer, use `file.buffer.get_line_count()`
- [x] For edit mode: After applying edits, use `file.buffer.get_line_count()`
- [x] Remove all `DataInputStream` usage for line counting
- [x] Remove all character-by-character loops for line counting
- [x] Use buffer's built-in `get_line_count()` method (no manual counting needed)

### Phase 6: Update Permission Handling

- [x] Check if file is in active project before permission prompts
- [x] Skip permission checks for files in active project (auto-approved)
- [x] Only prompt for files outside active project

### Phase 7: Testing and Validation

- [ ] Test complete_file mode (new file creation)
- [ ] Test complete_file mode (overwrite existing file)
- [ ] Test edit mode (single edit)
- [ ] Test edit mode (multiple edits)
- [ ] Test edit mode (insertions at end of file)
- [ ] Verify line counting is accurate
- [ ] Verify backups are created for project files
- [ ] Verify no race conditions in line counting

## Files to Modify

- `libollmchat/Tools/EditMode.vala` - Add `project_manager` property
- `libollmchat/Tools/RequestEditMode.vala` - Migrate to buffer-based operations
- `ollmchat/Window.vala` - Pass `project_manager` to `EditMode` constructor

## Reference Implementation

See `liboctools/RequestEditMode.vala` for the correct implementation pattern:
- Uses `project_manager.get_file_from_active_project()`
- Uses `file.buffer.read_async()` for reading
- Uses `file.buffer.write()` for writing
- Uses `file.buffer.get_line_count()` for counting
- Handles fake files for files outside project

## Notes

- The `liboctools` version is the reference implementation
- This migration should make `libollmchat` version match `liboctools` approach
- All file operations must go through buffers - no direct I/O
- Buffer operations handle backups automatically for project files
- Buffer operations are async and thread-safe

