# 2.6.1.5. Full Backup Support

## Overview

Implement full backup support using the same system as the edit file tool. Create backups for modified and deleted files, update ProjectManager file data, and handle file metadata.

## Status

⏳ **PLANNING** - Design phase.

## Prerequisites

- Phase 1 (2.6.1.1) must be completed
- Phase 2 (2.6.1.2) must be completed
- Phase 3 (2.6.1.3) must be completed
- Phase 4 (2.6.1.4) must be completed
- See main plan: `2.6.1-code-exec-improvements.md` for backup system details

## Goals

1. Create backups for modified and deleted files (same system as edit file tool)
2. Update ProjectManager file data for all changed files
3. Handle file metadata (last_modified, last_approved_copy_path, etc.)
4. Integrate with ProjectManager database

## Implementation Details

### Summary

Add backup support to overlay file copying:
1. Add `create_backup()` method to File class
2. Update `Overlay.copy_files()` to create backups and integrate with ProjectManager

### Files to Modify

#### 1. `libocfiles/File.vala`

**Add to File class:**
```vala
/**
 * Create backup of the existing file.
 * 
 * Copies file from its current path to backup location and updates file metadata.
 * Just copies the file - no buffer needed. Buffer can use this method if needed.
 * 
 * @throws Error if backup creation fails
 */
public async void create_backup() throws Error;
```

**Implementation:**
- Move all backup logic from `FileBuffer.create_backup_if_needed()` to `File.create_backup()`
- `File.create_backup()` handles all "if needed" logic:
  - Only creates backup if `this.id > 0` (file is in database)
  - Checks if backup already exists for today (skips if exists)
  - Copies file from `this.path` to backup location
  - Updates `this.last_approved_copy_path` and saves to database
- `FileBuffer.create_backup_if_needed()` simplifies to just call `this.file.create_backup()`
- No code duplication - backup logic lives in File class

#### 2. `libocfiles/FileBuffer.vala`

**Add to FileBuffer interface:**
```vala
/**
 * Clear buffer contents to empty.
 * 
 * Used when file is deleted - buffer should reflect empty state.
 * 
 * @throws Error if clearing fails
 */
public abstract async void clear() throws Error;
```

**Implement in DummyFileBuffer and GtkSourceFileBuffer:**
- DummyFileBuffer: Set `this.lines = new string[0]` (empty array)
- GtkSourceFileBuffer: Clear GTK buffer contents

#### 3. `liboctools/RunCommand/Overlay.vala`

**Modify `copy_files()` method:**

For **modified files** (iterate `this.monitor.updated.entries`):
- `entry.key` = overlay path (where modified file is)
- `entry.value` = File object from ProjectFiles (always exists, no null checks needed, always id > 0)
- `yield entry.value.create_backup()` (backup existing file before overwriting)
- Copy file from `entry.key` (overlay) to `entry.value.path` (real path)
- If buffer exists: `yield entry.value.buffer.read_async()` to reload new content
- Update metadata: `this.project.manager.on_file_contents_change(entry.value)`

For **new files**:
- Copy file from overlay to real path first
- Create fake file: `new OLLMfiles.File.new_fake(this.project.manager, real_path)`
- Convert to real: `yield this.project.manager.convert_fake_file_to_real(fake_file, real_path)`
- No buffer needed (file is new, no existing buffer to sync)

For **deleted files** (iterate `this.monitor.removed.entries`):
- `entry.key` = overlay path
- `entry.value` = File object from ProjectFiles (always exists, no null checks needed, always id > 0)
- `yield entry.value.create_backup()` (backup existing file before deleting)
- Set `entry.value.is_deleted = true`
- Delete file from disk: `GLib.FileUtils.unlink(entry.value.path)`
- If buffer exists: `yield entry.value.buffer.clear()` to empty contents
- Save to database: `entry.value.saveToDB(this.project.manager.db, null, false)`

**No new helper methods needed** - use existing ProjectManager methods directly.

#### 4. `liboctools/RunCommand/Bubble.vala`

**No changes needed** - `Overlay.copy_files()` uses `this.project.manager` internally.

### Backup System

- **Use same backup system as edit file tool**: `~/.cache/ollmchat/edited/`
- **Same storage format**: `{id}-{date YY-MM-DD}-{basename}`
- **Same logic**: `File.create_backup()` handles all backup logic (moved from `FileBuffer.create_backup_if_needed()`)
- **Backup rules**:
  - Only for files in database (id > 0)
  - One backup per file per day (skips if backup exists for today)
  - Backup path stored in `file.last_approved_copy_path`

## Step-by-Step Implementation

### Step 1: Verify `Overlay.copy_files()` Method Signature

**File**: `liboctools/RunCommand/Overlay.vala` (line 270)

**NO CHANGE NEEDED**:
```vala
// CURRENT (no change):
public async void copy_files()
```

**Reason**: ProjectManager is already available via `this.project.manager` property. No parameter needed.

### Step 2: Add `create_backup()` to File class and `clear()` to FileBuffer

**File**: `libocfiles/File.vala` (add to File class)

**Add to File class:**
```vala
/**
 * Create backup of the existing file.
 * 
 * Copies file from its current path to backup location and updates file metadata.
 * Just copies the file - no buffer needed. Buffer can use this method if needed.
 * 
 * @throws Error if backup creation fails
 */
public async void create_backup() throws Error;
```

**Implementation:**
- Move all backup logic from `FileBuffer.create_backup_if_needed()` to `File.create_backup()`
- `File.create_backup()` handles all "if needed" logic:
  - Only creates backup if `this.id > 0` (file is in database)
  - Checks if backup already exists for today (skips if exists)
  - Copies file from `this.path` to backup location
  - Updates `this.last_approved_copy_path` and saves to database
- `FileBuffer.create_backup_if_needed()` simplifies to just call `this.file.create_backup()`
- No code duplication - backup logic lives in File class

**File**: `libocfiles/FileBuffer.vala` (add to interface)

**Add to FileBuffer interface:**
```vala
/**
 * Clear buffer contents to empty.
 * 
 * Used when file is deleted - buffer should reflect empty state.
 * 
 * @throws Error if clearing fails
 */
public abstract async void clear() throws Error;
```

**Implement in DummyFileBuffer and GtkSourceFileBuffer:**
- DummyFileBuffer: Set `this.lines = new string[0]` (empty array)
- GtkSourceFileBuffer: Clear GTK buffer contents

### Step 3: Rewrite `copy_files()` Method Implementation

**File**: `liboctools/RunCommand/Overlay.vala` (lines 201-262)

**Implementation** (matches summary at top):
```vala
public async void copy_files()
{
	// Stop Monitor (existing)
	yield this.monitor.stop();
	
	// Access ProjectManager via this.project.manager
	var project_manager = this.project.manager;
	
	// Process modified files (this.monitor.updated)
	// entry.value is always a File object (no null checks needed, always id > 0)
	foreach (var entry in this.monitor.updated.entries) {
		// Create backup (all modified files are in database, id > 0)
		yield (entry.value as OLLMfiles.File).create_backup();
		
		// Copy modified file from overlay to real path
		try {
			GLib.File.new_for_path(entry.key).copy(
				GLib.File.new_for_path(entry.value.path),
				GLib.FileCopyFlags.OVERWRITE,
				null,
				null
			);
		} catch (GLib.Error e) {
			GLib.warning("Cannot copy file from overlay to real path (%s -> %s): %s", 
				entry.key, entry.value.path, e.message);
			continue;
		}
		
		// Copy file permissions (existing)
		this.copy_permissions(entry.key, entry.value.path);
		
		// Reload buffer with new content (only if buffer already exists)
		var file = entry.value as OLLMfiles.File;
		if (file.buffer != null) {
			yield file.buffer.read_async();
		}
		
		// Update metadata (existing method)
		project_manager.on_file_contents_change(file);
	}
    
	// Process new files (this.monitor.added)
	// Sort entries by path (to ensure parent directories are created naturally)
	var added_entries = new Gee.ArrayList<string>.wrap(this.monitor.added.keys.to_array());
	added_entries.sort((a, b) => {
		return strcmp(a, b);
	});
	
	foreach (var key in added_entries) {
		// Copy file from overlay to real path first
		// convert_fake_file_to_real() handles directory creation via make_children()
		try {
			GLib.File.new_for_path(key).copy(
				GLib.File.new_for_path(this.monitor.added.get(key).path),
				GLib.FileCopyFlags.OVERWRITE,
				null,
				null
			);
		} catch (GLib.Error e) {
			GLib.warning("Cannot copy file from overlay to real path (%s -> %s): %s", 
				key, this.monitor.added.get(key).path, e.message);
			continue;
		}
		
		// Copy file permissions (existing)
		this.copy_permissions(key, this.monitor.added.get(key).path);
		
		// Create fake file and convert to real (existing method handles directory creation)
		var fake_file = new OLLMfiles.File.new_fake(project_manager, this.monitor.added.get(key).path);
		yield project_manager.convert_fake_file_to_real(fake_file, this.monitor.added.get(key).path);
		// No buffer needed - file is new, no existing buffer to sync
	}
    
	// Process deleted files (this.monitor.removed)
	// entry.value is always a File object (no null checks needed, always id > 0)
	foreach (var entry in this.monitor.removed.entries) {
		var file = entry.value as OLLMfiles.File;
		
		// Create backup (all deleted files are in database, id > 0)
		// Don't create buffer - backup doesn't need buffer, just copy file
		yield file.create_backup();
		
		// Set is_deleted flag
		file.is_deleted = true;
		
		// Delete file from disk
		try {
			GLib.FileUtils.unlink(file.path);
		} catch (GLib.Error e) {
			GLib.warning("Cannot delete file from real path (%s): %s", file.path, e.message);
			continue;
		}
		
		// Clear buffer contents to empty (only if buffer already exists)
		if (file.buffer != null) {
			yield file.buffer.clear();
		}
		
		// Save to database
		file.saveToDB(project_manager.db, null, false);
	}
}
```

### Step 4: Verify `Bubble.exec()` Method

**File**: `liboctools/RunCommand/Bubble.vala` (line 173)

**NO CHANGE NEEDED**:
```vala
// CURRENT (no change):
yield this.overlay.copy_files();
```

**Reason**: Overlay now uses `this.project.manager` internally, so no parameter is needed.

### Step 5: Handle Edge Cases

**Edge Cases to Handle**:
1. **ProjectManager is null**: Log warning, continue with basic file copying (no backups, no DB updates)
2. **File not in database (id = 0)**: Skip backup creation, but still copy file
3. **File not found in ProjectManager**: For modified files, skip backup but still copy; for new files, create entry
4. **Backup already exists for today**: Skip backup creation (handled in `create_backup_for_file()`)
5. **Directory creation fails**: Log warning, continue with next file
6. **File copy fails**: Log warning, continue with next file
7. **Database save fails**: Log warning, continue (file still copied to disk)

## Implementation Tasks

- [ ] **Step 1**: Verify `Overlay.copy_files()` method signature (no change needed - uses `this.project.manager`)
- [ ] **Step 2**: Add `create_backup()` to File class and `clear()` to FileBuffer interface
  - [ ] Add `create_backup()` method to File class in `libocfiles/File.vala`
  - [ ] Extract shared backup logic from FileBuffer.create_backup_if_needed()
  - [ ] Both File.create_backup() and FileBuffer.create_backup_if_needed() use shared helper
  - [ ] Add `clear()` method to FileBuffer interface in `libocfiles/FileBuffer.vala`
  - [ ] Implement `clear()` in DummyFileBuffer and GtkSourceFileBuffer
- [ ] **Step 3**: Rewrite `copy_files()` method implementation with backup-aware logic:
  - [ ] Access ProjectManager via `this.project.manager` at start of method
  - [ ] Process modified files: backup creation, copy, metadata update
  - [ ] Process new files: create File entry, copy, metadata update
  - [ ] Process deleted files: backup creation, set is_deleted, remove from disk
- [ ] **Step 4**: Verify `Bubble.exec()` method (no change needed - Overlay uses `this.project.manager` internally)
- [ ] **Step 5**: Test edge cases (null ProjectManager, files not in DB, etc.)
- [ ] **Step 6**: Verify backups are created using same system as edit file tool (`~/.cache/ollmchat/edited/`)
- [ ] **Step 7**: Verify `last_approved_copy_path` is set correctly (uses same format as edit file tool)
- [ ] **Step 8**: Verify file metadata updates (last_modified, etc.)
- [ ] **Step 9**: Verify database persistence (files saved to DB with correct metadata)

## Code Removals

**NO CODE REMOVALS**: All existing code is preserved and enhanced:
- Existing file copying logic in `copy_files()` is **REPLACED** (not removed) with backup-aware version
- Existing permission copying logic (`copy_permissions()`) is **PRESERVED** and still called
- Existing Monitor stop logic is **PRESERVED**
- All existing error handling is **PRESERVED** and enhanced

## Testing Requirements

### Unit Tests

1. **Test `create_backup_for_file()` method**:
   - [ ] Test backup creation for file with id > 0
   - [ ] Test skip backup for file with id = 0 (not in database)
   - [ ] Test skip backup if backup already exists for today
   - [ ] Test backup filename format: `{id}-{date YY-MM-DD}-{basename}`
   - [ ] Test backup directory creation: `~/.cache/ollmchat/edited/`
   - [ ] Test `last_approved_copy_path` is set correctly
   - [ ] Test database save after backup creation

2. **Test `get_file_from_project_manager()` method**:
   - [ ] Test returns File object for file in database
   - [ ] Test returns null for file not in database
   - [ ] Test returns null when ProjectManager is null

3. **Test `create_new_file_entry()` method**:
   - [ ] Test creates File entry for new file
   - [ ] Test saves to database (gets id > 0)
   - [ ] Test adds to file_cache
   - [ ] Test sets `last_approved_copy_path = ""` (no backup for new files)
   - [ ] Test handles directory creation for parent folders

4. **Test `update_file_metadata()` method**:
   - [ ] Test updates `last_modified` from FileInfo
   - [ ] Test triggers `project_manager.on_file_contents_change()`

### Integration Tests

1. **Test modified files processing**:
   - [ ] Execute command that modifies existing file
   - [ ] Verify backup is created in `~/.cache/ollmchat/edited/`
   - [ ] Verify backup filename format matches edit tool format
   - [ ] Verify file is copied from overlay to project directory
   - [ ] Verify `file.last_approved_copy_path` is set
   - [ ] Verify `file.last_modified` is updated
   - [ ] Verify file is saved to database
   - [ ] Verify file permissions are copied

2. **Test new files processing**:
   - [ ] Execute command that creates new file
   - [ ] Verify File entry is created in ProjectManager
   - [ ] Verify File entry is saved to database (id > 0)
   - [ ] Verify File entry is added to file_cache
   - [ ] Verify `file.last_approved_copy_path = ""` (no backup)
   - [ ] Verify file is copied from overlay to project directory
   - [ ] Verify parent directory is created if needed
   - [ ] Verify file permissions are copied

3. **Test deleted files processing**:
   - [ ] Execute command that deletes existing file
   - [ ] Verify backup is created before deletion
   - [ ] Verify backup filename format matches edit tool format
   - [ ] Verify `file.is_deleted = true` is set
   - [ ] Verify file is removed from project directory
   - [ ] Verify File record is kept in database (not removed)
   - [ ] Verify file is saved to database with is_deleted flag

4. **Test edge cases**:
   - [ ] Test with ProjectManager = null (fallback behavior)
   - [ ] Test with file not in database (id = 0, skip backup)
   - [ ] Test with backup already exists for today (skip creation)
   - [ ] Test with file copy failure (error handling)
   - [ ] Test with database save failure (error handling)
   - [ ] Test with multiple files modified/deleted/created in one command

5. **Test backup system compatibility**:
   - [ ] Verify backups use same directory as edit tool: `~/.cache/ollmchat/edited/`
   - [ ] Verify backups use same filename format as edit tool: `{id}-{date YY-MM-DD}-{basename}`
   - [ ] Verify backups are cleaned up by `ProjectManager.cleanup_old_backups()`
   - [ ] Verify backup creation logic matches `FileBuffer.create_backup_if_needed()` exactly

### Manual Testing Checklist

1. **Basic functionality**:
   - [ ] Run command that modifies a file → verify backup created
   - [ ] Run command that creates a file → verify File entry created
   - [ ] Run command that deletes a file → verify backup created and is_deleted set

2. **Backup verification**:
   - [ ] Check backup directory: `~/.cache/ollmchat/edited/`
   - [ ] Verify backup filenames match format: `{id}-{date YY-MM-DD}-{basename}`
   - [ ] Verify backup contents match original file
   - [ ] Verify only one backup per file per day

3. **Database verification**:
   - [ ] Check database for updated file records
   - [ ] Verify `last_approved_copy_path` is set correctly
   - [ ] Verify `last_modified` is updated
   - [ ] Verify `is_deleted` flag is set for deleted files

4. **File system verification**:
   - [ ] Verify modified files are copied to project directory
   - [ ] Verify new files are copied to project directory
   - [ ] Verify deleted files are removed from project directory
   - [ ] Verify file permissions are preserved

## Dependencies

### Required Classes/Methods

1. **OLLMfiles.ProjectManager**:
   - `get_file_from_active_project(string path)` - Get File object from active project
   - `file_cache` (HashMap) - File cache for lookups
   - `db` (SQ.Database) - Database instance for saves
   - `on_file_contents_change(File file)` - Trigger background scanning
   - `cleanup_old_backups()` - Static method to cleanup old backups

2. **OLLMfiles.File**:
   - `id` (int64) - File ID (0 = new, >0 = in database, <0 = fake)
   - `path` (string) - File path
   - `last_approved_copy_path` (string) - Backup path
   - `last_modified` (int64) - Last modification timestamp
   - `is_deleted` (bool) - Deletion flag
   - `saveToDB(SQ.Database db, FileBase? new_values, bool sync)` - Save to database
   - `new_from_info(ProjectManager, Folder?, FileInfo, string)` - Create from FileInfo

3. **OLLMfiles.Folder**:
   - `manager` (ProjectManager) - ProjectManager instance
   - `project_files` (ProjectFiles) - Project files collection
   - `project_files.find_container_of(string path)` - Find parent folder

4. **GLib.File** (async I/O):
   - `read_async()` - Async file reading
   - `replace_async()` - Async file writing
   - `splice_async()` - Async stream copying
   - `copy()` - File copying
   - `query_info()` - File metadata query

5. **ProjectManager.cleanup_old_backups()**:
   - Static method (already exists)
   - Cleans up backups older than 7 days
   - Called after backup creation (non-blocking)

### Existing Code Dependencies

- **Monitor class** (already exists):
  - `monitor.updated` - HashMap of modified files
  - `monitor.added` - HashMap of new files
  - `monitor.removed` - HashMap of deleted files
  - `monitor.stop()` - Stop monitoring (async)

- **Overlay class** (already exists):
  - `overlay.project` - Project folder
  - `overlay.overlay_map` - Overlay path mapping
  - `copy_permissions()` - Copy file permissions (existing method)

- **Bubble class** (already exists):
  - `bubble.project` - Project folder
  - `bubble.project.manager` - ProjectManager instance

## Notes

- Uses exact same backup system as `FileBuffer.write()` in edit file tool
- Backups cleaned up by `ProjectManager.cleanup_old_backups()` (files older than 7 days)
- File scanner updates (is_deleted flag) will be added in Phase 6
- All file operations are async (using GLib.File async I/O)
- Error handling: Logs warnings but continues processing remaining files
- ProjectManager is optional: If null, falls back to basic file copying (no backups, no DB updates)

## Summary

This phase implements full backup support for the RunCommand tool by:

1. **Adding backup creation** for modified and deleted files using the same system as the edit file tool
2. **Integrating with ProjectManager** to update file data and metadata in the database (using existing `this.project.manager`)
3. **Handling new files** by creating File entries and saving to database
4. **Handling deleted files** by creating backups and setting is_deleted flag
5. **Preserving existing functionality** while adding backup and database integration

**Key Changes**:
- `Overlay.copy_files()` **NO PARAMETER CHANGE** - uses `this.project.manager` internally
- **ADD METHOD**: `File.create_backup()` - method in File class (no parameters, uses file.path)
- **NO CODE DUPLICATION**: Extract shared backup logic from `FileBuffer.create_backup_if_needed()` into helper
- **USE EXISTING METHODS**: No helper methods needed - use existing ProjectManager methods directly:
  - `file.create_backup()` - create backup of existing file
  - `project_manager.convert_fake_file_to_real()` - new file creation (handles everything!)
  - `project_manager.on_file_contents_change()` - metadata updates (handles everything!)
- `Bubble.exec()` **NO CHANGE** - Overlay uses `this.project.manager` internally

**Key Design Decisions**:
- **Backup Method in File Class**: Add `create_backup()` to File class (no parameters, uses file.path)
- **No Buffer Creation**: Only use buffer if it already exists (don't create for backup/delete)
- **Use Existing Facilities**: All methods use `this.project.manager` - no parameters needed
- **No Code Duplication**: Shared backup logic between File.create_backup() and FileBuffer.create_backup_if_needed()
- **Reuse Existing Methods**: Use `ProjectManager.convert_fake_file_to_real()` instead of duplicating file creation logic

**No Breaking Changes**: All changes are additive - existing functionality is preserved and enhanced. No API changes to public methods.

