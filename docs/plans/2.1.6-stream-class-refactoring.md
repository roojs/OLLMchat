# 2.1.6. Stream Class Refactoring for EditMode

## Overview

Refactor streaming content processing from Request class into a separate Stream class. This improves code organization by separating concerns: Request handles setup and applying changes, while Stream handles all streaming content parsing and code block detection.

## Status

ðŸ“‹ **PLANNED** - Part of 2.1.4 AST Path Support for EditFile Integration

## Checklist (coding standards)

- [ ] **Nullable types**: No new APIs/properties use nullable types unless absolutely required; prefer default objects/flags.
- [ ] **Null checks**: Plan does not rely on generic null checks; only uses them where the design explicitly requires null.
- [ ] **String interpolation**: Any new/changed code avoids `@"..."` string interpolation except for multi-line usage/help text or docs.
- [ ] **Temporary variables**: New code avoids one-use temporaries and trivial aliases; only aliases long chains where needed.
- [ ] **Brace placement**: New/changed Vala code keeps brace style consistent with coding standards.
- [ ] **`this.` prefix**: New/changed Vala code uses `this.` for instance members.
- [ ] **GLib prefix & using statements**: New/changed code uses `GLib.*` prefixes and does not introduce `using` imports.
- [ ] **Property initialization**: New properties use defaults (`get; set; default =` or field defaults) instead of constructor init.
- [ ] **Line length & breaking**: Plan anticipates breaking long calls/concats over multiple lines for readability.

## Related Plans

- **2.1.4** - AST Path Support for EditFile Integration (main plan)
- **2.1.7** - Line Number Mode (Legacy) and Mode Separation
- **2.1.8** - AST Path Mode (Incremental Application)

## Purpose

Separate streaming content processing from Request class to improve code organization. Request class will focus on initial setup and applying changes, while Stream class handles all streaming content parsing and code block detection.

## Implementation

This refactoring is split into three phases:

### Phase 1: Create Stream Class

- [ ] **Create Stream Class:**
  - [ ] Create new file: `liboctools/EditMode/Stream.vala`
  - [ ] Class name: `OLLMtools.EditMode.Stream`
  - [ ] Stream class will be instantiated in `Request.execute_request()` when tool activates (Phase 3)
  - [ ] Stream instance will be stored in `Request` as `private Stream? stream_handler = null;` (Phase 3)

- [ ] **Stream Class Interface:**
  - [ ] Constructor signature:
    ```vala
    public Stream(
        Request request,           // Reference to parent Request (for send_ui calls)
        OLLMfiles.File file,       // File object (stored in Stream, passed to FileChange for AST resolution) - Request ensures this is never null
        bool write_complete_file,  // Complete file mode parameter
        OLLMfiles.ProjectManager project_manager  // For AST path resolution (passed to FileChange)
    )
    ```
  - [ ] **Note:** Stream can get file path from `file.path` for error messages and logging. No need to pass `normalized_path` separately.
  - [ ] Public method to process streaming chunks:
    ```vala
    public void process_chunk(string new_text, bool is_thinking)
    ```
  - [ ] Public method to process non-streaming content (for fallback):
    ```vala
    public void process_complete_content(string content)
    ```
  - [ ] No separate finalize method needed - just call `add_linebreak()` directly to flush remaining content (inline, no wrapper)
  - [ ] Public property to check if any changes were captured:
    ```vala
    public bool has_changes { get; private set; default = false; }
    ```
  - [ ] Public property to access captured changes:
    ```vala
    public Gee.ArrayList<OLLMfiles.FileChange> changes { get; private set; }
    ```
  - [ ] Public property to access error messages:
    ```vala
    public Gee.ArrayList<string> error_messages { get; private set; }
    ```
  - [ ] Stream will call methods on Request instance for UI messages:
    ```vala
    // Stream calls this method on Request for UI feedback:
    //   request.send_ui(string type, string title, string message)  // Existing method
    ```

- [ ] **Methods to Move from Request to Stream:**
  - [ ] `on_stream_chunk()` â†’ `Stream.process_chunk()`
    - [ ] Move entire method implementation
    - [ ] Update to use Stream's internal state instead of Request's state
  - [ ] `add_text()` â†’ `Stream.add_text()` (private method)
    - [ ] Move method implementation
    - [ ] Updates `current_line` (Stream's state)
    - [ ] If `in_code_block == true` and `current_change != null`, appends text to `current_change.replacement`
    - [ ] **Note:** For Phase 1, assume FileChange has `ast_path`, `operation_type`, `result`, and `completed` properties (will be added in Phase 2)
  - [ ] `add_linebreak()` â†’ `Stream.add_linebreak()` (private method)
    - [ ] Move method implementation
    - [ ] Calls `try_parse_code_block_opener()` when code block starts (creates new FileChange, sets `current_change`)
    - [ ] If `in_code_block == true` and `current_change != null`, appends "\n" to `current_change.replacement`
    - [ ] When code block closes (``` detected):
      - [ ] Finalizes `current_change.replacement` (removes trailing ``` markers)
      - [ ] If `current_change.ast_path != ""`, **starts async resolution immediately** via `current_change.resolve_ast_path.begin(file, project_manager)` (doesn't wait - resolution happens in parallel)
      - [ ] If `current_change.ast_path == ""` (line number format), sets `current_change.result = "applied"` (no resolution needed)
      - [ ] Adds `current_change` to Stream's `changes` array
      - [ ] Sets `current_change = null` and `in_code_block = false`
    - [ ] If format errors occur: Sets `current_change.result = "error message"` and `current_change.completed = true` (error stored in FileChange, not Stream)
    - [ ] Calls `request.send_ui()` for UI error messages
  - [ ] `try_parse_code_block_opener()` â†’ `Stream.try_parse_code_block_opener()` (private method)
    - [ ] Move method implementation
    - [ ] Returns `bool` to indicate if code block was successfully entered
    - [ ] Creates new FileChange object
    - [ ] If AST path format: Sets `FileChange.ast_path` and `FileChange.operation_type` (does NOT resolve yet)
    - [ ] If line number format: Sets `FileChange.start` and `FileChange.end` directly
    - [ ] If format is invalid: Sets `FileChange.result = "error message"`, `FileChange.completed = true`, and `FileChange.start/end = -2` (marks as failed)
    - [ ] Sets `current_change` to the new FileChange
    - [ ] Sets `in_code_block = true`
  - [ ] `enter_code_block()` â†’ **REMOVE or SIMPLIFY** (no longer needed - `try_parse_code_block_opener()` creates FileChange directly)
    - [ ] If kept, just sets `in_code_block = true` and creates empty FileChange

- [ ] **State to Move from Request to Stream:**
  - [ ] `current_line` â†’ `Stream.current_line` (private) - Current line being parsed
  - [ ] `in_code_block` â†’ `Stream.in_code_block` (private) - Whether we're inside a code block
  - [ ] `current_change` â†’ `Stream.current_change` (private, FileChange?) - The FileChange being built (null when not in code block)
  - [ ] `file` â†’ `Stream.file` (private) - File object (passed from Request, used for AST path resolution)
  - [ ] `changes` array â†’ `Stream.changes` (public property, read-only) - Contains FileChange objects
  - [ ] `error_messages` array â†’ `Stream.error_messages` (public property, read-only) - Only for non-FileChange errors (general streaming issues). Format errors are stored in FileChange.result
  
- [ ] **Note:** `used_ast_paths` tracking removed - cannot be accurately tracked during processing (AST resolution is async). Phase 7 will handle mode switching based on detected formats.
- [ ] **Note:** Format errors (invalid line numbers, invalid AST paths) are stored in `FileChange.result` and `FileChange.completed = true`, not in Stream.error_messages. This keeps each change's error state with the change itself.
  
- [ ] **State that moves to FileChange (not Stream):**
  - [ ] `current_start_line` â†’ **FileChange.start** (already exists in FileChange)
  - [ ] `current_end_line` â†’ **FileChange.end** (already exists in FileChange)
  - [ ] `pending_ast_path` â†’ **FileChange.ast_path** (new property in FileChange - Phase 2)
  - [ ] `current_operation_type` â†’ **FileChange.operation_type** (new property in FileChange - Phase 2)
  - [ ] `current_block` â†’ **FileChange.replacement** (already exists in FileChange, accumulates during streaming)

- [ ] **Stream Class Implementation Details:**
  - [ ] Stream class will handle ALL streaming content parsing and state management
  - [ ] Stream class will detect code block openers and closers
  - [ ] Stream manages `current_change` (FileChange being built) - when code block opens, creates new FileChange
  - [ ] During streaming: Text is appended to `current_change.replacement`
  - [ ] When code block closes: Finalizes `current_change`, adds to `changes` array, triggers AST resolution if needed
  - [ ] If FileChange has AST path: Calls `current_change.resolve_ast_path()` async (doesn't wait - resolution happens in parallel)
  - [ ] Stream class will add FileChange to its own `changes` array immediately (even if AST resolution not done yet)
  - [ ] Stream class stores format errors in `FileChange.result` (not in error_messages array)
  - [ ] Stream class will add to its own `error_messages` array only for general streaming errors (not format errors)
  - [ ] Stream class will call `request.send_ui()` for UI error messages
  - [ ] Stream class will track minimal state: `current_line`, `in_code_block`, `current_change` (FileChange object)
  - [ ] Stream class manages its own `changes` and `error_messages` arrays - Request reads from these when needed (Phase 3)
  - [ ] **Key improvement:** No race conditions - AST resolution happens AFTER code block is fully captured
  - [ ] **Key improvement:** All change-specific state (start, end, ast_path, operation_type, replacement) is in FileChange, not Stream

- [ ] **FileChange Class Properties (Required for Phase 1):**
  - [ ] Add `ast_path` property (string):
    ```vala
    public string ast_path { get; set; default = ""; }
    ```
  - [ ] Add `completed` property (bool, tracks if AST path resolution is done):
    ```vala
    public bool completed { get; private set; default = false; }
    ```
  - [ ] Add `operation_type` property (string):
    ```vala
    public string operation_type { get; set; default = "replace"; } // "replace", "insert_before", "insert_after", "delete"
    ```
  - [ ] Add `result` property (string):
    ```vala
    public string result { get; set; default = ""; } // Result message: "" = not yet determined, "applied" = success, error message = failure (format errors, AST resolution errors, etc.)
    ```
  - [ ] Add method to get change description:
    ```vala
    public string get_description()
    {
        if (this.ast_path != null && this.ast_path != "") {
            return "ast-path:" + this.ast_path;
        } else {
            return "lines " + this.start.to_string() + "-" + this.end.to_string();
        }
    }
    ```
  - [ ] Add placeholder method for AST path resolution (full implementation in Phase 2):
    ```vala
    public async void resolve_ast_path(OLLMfiles.File file, OLLMfiles.ProjectManager project_manager)
    {
        // Placeholder: Full implementation in Phase 2
        // For Phase 1, just mark as completed if no AST path
        if (this.ast_path == "") {
            this.completed = true;
            return;
        }
        // TODO: Phase 2 will implement full AST path resolution
        this.completed = true;
    }
    ```
  - [ ] **Note:** These properties and method placeholder are needed in Phase 1 so Stream can set and use them. Full implementation of `resolve_ast_path()` comes in Phase 2.

### Phase 2: FileChange Class Enhancements

- [ ] **FileChange Class Enhancements:**
  - [ ] **Note:** Properties (`ast_path`, `completed`, `operation_type`, `result`) and `get_description()` method were added in Phase 1. This phase implements the full `resolve_ast_path()` method.
  - [ ] Implement full `resolve_ast_path()` method (replaces placeholder from Phase 1):
    ```vala
    public async void resolve_ast_path(OLLMfiles.File file, OLLMfiles.ProjectManager project_manager)
    {
        if (this.ast_path == "") {
            // No AST path to resolve - mark as completed
            this.completed = true;
            return;
        }
        
        try {
            // Get Tree instance and parse
            var tree = project_manager.tree_factory(file);
            yield tree.parse();
            
            // Lookup AST path
            int start, end;
            if (tree.lookup_path(this.ast_path, out start, out end)) {
                this.start = start;
                this.end = end;
                // Adjust start/end based on operation_type
                if (this.operation_type == "insert_before") {
                    this.end = this.start; // Insert before: use start_line for both
                } else if (this.operation_type == "insert_after") {
                    this.start = this.end; // Insert after: use end_line for both
                } else if (this.operation_type == "delete") {
                    // Delete: keep full range, replacement should be empty
                    if (this.replacement.strip() != "") {
                        this.replacement = ""; // Force empty for delete
                    }
                }
                // "replace" operation: keep full range as-is
                this.result = "applied";
                this.completed = true;
            } else {
                // AST path not found - mark as failed
                this.start = -2;
                this.end = -2;
                this.result = "AST path not found: " + this.ast_path;
                this.completed = true; // Completed but failed
            }
        } catch (GLib.Error e) {
            // Error during resolution - mark as failed
            GLib.warning("Error resolving AST path '%s': %s", this.ast_path, e.message);
            this.start = -2;
            this.end = -2;
            this.result = "Error resolving AST path: " + e.message;
            this.completed = true; // Completed but failed
        }
    }
    ```
  - [ ] **Note:** FileChange handles errors internally. On failure, `start` and `end` are set to `-2`, and `completed` is still set to `true`. Request checks for `start == -2 || end == -2` to detect failures.
  - [ ] **Note:** FileChange.resolve_ast_path() also handles operation_type adjustments (insert_before, insert_after, delete) after resolving the AST path.
  - [ ] **Note:** FileChange now handles its own AST path resolution. Stream just creates FileChange with `ast_path` set, then calls `resolve_ast_path()` async.

- [ ] **Remove from Request (moved to FileChange):**
  - [ ] `resolve_ast_path()` â†’ **Move to FileChange.resolve_ast_path()** (not Stream)
    - [ ] Move method implementation to FileChange class
    - [ ] FileChange will resolve its own AST path when `resolve_ast_path()` is called
  - [ ] `resolve_ast_path_and_update_lines()` â†’ **REMOVE** (no longer needed)
    - [ ] This method is replaced by FileChange.resolve_ast_path()
    - [ ] FileChange handles its own resolution and updates its own start/end properties

### Phase 3: Remove and Integrate with Request

- [ ] **State to Keep in Request:**
  - [ ] `file` (OLLMfiles.File?) - File object representing the file being edited. Request keeps reference (nullable internally), but ensures it's set (real or fake) before passing to Stream constructor (non-nullable in Stream).
  - [ ] `normalized_path` (string) - Normalized file path. Request keeps reference for its own use (permissions, apply_all_changes, etc.). Stream doesn't need it - can use `file.path` instead.
  - [ ] `complete_file` (bool) - Parameter flag: if true, replace entire file; if false, edit specific line ranges. Request keeps reference, passes to Stream constructor as `write_complete_file`.

- [ ] **Request Class Changes:**
  - [ ] Add `stream_handler` property:
    ```vala
    private Stream? stream_handler = null;
    ```
  - [ ] In `execute_request()`: Create Stream instance after file is set up:
    ```vala
    // After file is set up (around line 189)
    this.stream_handler = new Stream(
        this,                    // Request reference (Stream calls send_ui() on this)
        this.file,               // File object (Stream can get path from file.path, project_manager from file.manager)
        this.complete_file       // Complete file mode (passed as write_complete_file)
    );
    ```
  - [ ] **Note:** Stream manages its own `changes` and `error_messages` arrays. Request reads from `stream_handler.changes` and `stream_handler.error_messages` when needed.
  - [ ] **Note:** Format errors are stored in `FileChange.result`, not in Stream.error_messages. Stream.error_messages is only for general streaming errors. Request collects errors from FileChange.result when building the reply.
  - [ ] Update `on_stream_chunk()` to delegate to Stream:
    ```vala
    public override void on_stream_chunk(string new_text, bool is_thinking, OLLMchat.Response.Chat response)
    {
        // stream_handler is created in execute_request() and stream chunks only arrive when tool is active
        this.stream_handler.process_chunk(new_text, is_thinking);
    }
    ```
  - [ ] Update `on_message_completed()` to delegate to Stream and wait for AST resolutions:
    ```vala
    public override void on_message_completed(OLLMchat.Response.Chat response)
    {
        // ... existing validation code ...
        
        // Process non-streaming content if needed
        // stream_handler is created in execute_request() and on_message_completed() only happens when tool is active
        if (!this.agent.chat().stream && response.message.content != "") {
            this.stream_handler.process_complete_content(response.message.content);
        }
        
        // Finalize stream processing (inline - no wrapper method needed)
        this.stream_handler.add_linebreak();
        
        // Check if we have any changes (read from Stream)
        if (this.stream_handler.changes.size == 0) {
            // ... cleanup code ...
            return;
        }
        
        // Wait for all AST path resolutions to complete before applying changes
        this.wait_for_changes_applied.begin((obj, res) => {
            wait_for_changes_applied.end(res);
            this.handle_changes_applied_complete(response);
        });
    }
    
    private bool has_changes_applied()
    {
        // Check if all FileChanges have completed resolution
        // (FileChanges without AST paths are marked completed immediately)
        foreach (var change in this.stream_handler.changes) {
            if (!change.completed) {
                return false;
            }
        }
        return true;
    }
    
    private async void wait_for_changes_applied()
    {
        // AST path resolutions are already started when each code block closes (in Stream.add_linebreak())
        // We just need to wait for all of them to complete
        
        // Try up to 5 times (5 * 200ms = 1 second total wait time)
        int attempts = 0;
        while (attempts < 5) {
            if (this.has_changes_applied()) {
                return; // All resolutions complete
            }
            
            // Wait 200ms before checking again (200 milliseconds = 0.2 seconds)
            GLib.Timeout.add(200, () => {
                wait_for_changes_applied.callback();
                return false;
            });
            yield;
            attempts++;
        }
        
        // After 5 attempts, cancel all changes that are not finished
        foreach (var change in this.stream_handler.changes) {
            if (!change.completed) {
                change.result = "AST path resolution timeout";
                change.completed = true; // Mark as completed (but failed)
            }
        }
    }
    
    private void handle_changes_applied_complete(OLLMchat.Response.Chat response)
    {
        // All changes are now marked as completed (either successfully or with timeout error)
        
        // Build summary message from individual change results
        int applied_count = 0;
        int failed_count = 0;
        var summary_lines = new Gee.ArrayList<string>();
        
        foreach (var change in this.stream_handler.changes) {
            // Check result (format errors and AST resolution errors are already stored in change.result)
            if (change.result != "applied") {
                failed_count++;
                string error_msg = change.get_description() + " was not applied: " + (change.result != "" ? change.result : "unknown error");
                summary_lines.add("  â€¢ " + error_msg);
                this.stream_handler.error_messages.add(error_msg); // Collect for reply_with_errors()
                continue;
            }
            
            applied_count++;
            summary_lines.add("  â€¢ " + change.get_description() + " applied");
        }
        
        // Build summary message
        var summary = "All changes were applied.\n\n";
        if (failed_count > 0 && applied_count > 0) {
            summary = "Some changes were applied.\n\n";
        } else if (failed_count > 0) {
            summary = "No changes were applied.\n\n";
        }
        
        foreach (var line in summary_lines) {
            summary += line + "\n";
        }
        
        // Store summary in error_messages if there were failures, or use as success message
        if (failed_count > 0) {
            this.stream_handler.error_messages.insert(0, summary);
        }
        
        // Now apply changes (only those that succeeded)
        this.apply_all_changes.begin((obj, res2) => {
            this.handle_apply_changes_response(res2, response);
        });
    }
    ```
  - [ ] Remove all moved methods and state from Request class:
    - [ ] Remove `on_stream_chunk()` implementation (now delegates to Stream)
    - [ ] Remove `add_text()` method (moved to Stream)
    - [ ] Remove `add_linebreak()` method (moved to Stream)
    - [ ] Remove `try_parse_code_block_opener()` method (moved to Stream)
    - [ ] Remove `enter_code_block()` method (if exists, no longer needed)
    - [ ] Remove `resolve_ast_path()` method (moved to FileChange)
    - [ ] Remove `resolve_ast_path_and_update_lines()` method (replaced by FileChange.resolve_ast_path())
    - [ ] Remove `current_line` state (moved to Stream)
    - [ ] Remove `in_code_block` state (moved to Stream)
    - [ ] Remove `current_block` state (replaced by FileChange.replacement)
    - [ ] Remove `current_start_line` state (replaced by FileChange.start)
    - [ ] Remove `current_end_line` state (replaced by FileChange.end)
    - [ ] Remove `pending_ast_path` state (replaced by FileChange.ast_path)
    - [ ] Remove `resolving_ast_path` state (no longer needed)
    - [ ] Remove `current_operation_type` state (replaced by FileChange.operation_type)
    - [ ] Remove `used_ast_paths` state (no longer tracked)
    - [ ] Remove `changes` array (moved to Stream)
    - [ ] Remove `error_messages` array (moved to Stream)
  - [ ] Update `apply_all_changes()` to read `changes` from `stream_handler.changes` instead of `this.changes`
  - [ ] Update `reply_with_errors()` to read `error_messages` from `stream_handler.error_messages` instead of `this.error_messages`

- [ ] **Benefits of This Refactoring:**
  - [ ] Request class becomes focused on: initial setup, permission handling, waiting for AST resolutions, applying changes (from Stream), replying to LLM
  - [ ] Stream class becomes focused on: ALL streaming content parsing, detecting code blocks, creating FileChanges, managing changes and errors
  - [ ] FileChange class becomes self-contained: handles its own AST path resolution
  - [ ] Clear separation of concerns: Stream captures code blocks, FileChange resolves itself, Request applies results
  - [ ] No race conditions: AST resolution happens AFTER code block is fully captured
  - [ ] Better error handling: FileChange can report resolution failures via `completed` flag
  - [ ] Easier to test streaming logic independently
  - [ ] Easier to add new streaming features in the future
  - [ ] Request class becomes simpler and more maintainable

- [ ] **Testing:**
  - [ ] Test that streaming still works correctly after refactoring
  - [ ] Test that code blocks are still captured correctly
  - [ ] Test that AST path resolution still works
  - [ ] Test that error handling still works
  - [ ] Test that non-streaming mode (fallback) still works

## Files to Modify

### Phase 1: Stream Class
- [ ] `liboctools/EditMode/Stream.vala` - **NEW FILE** - Create new class for streaming content processing
- [ ] `libocfiles/FileChange.vala` - Add required properties and method placeholder for Stream to use
  - [ ] Add `ast_path`, `completed`, `operation_type`, `result` properties
  - [ ] Add `get_description()` method
  - [ ] Add `resolve_ast_path()` method placeholder (full implementation in Phase 2)

### Phase 2: FileChange Enhancements
- [ ] `libocfiles/FileChange.vala` - Implement full AST path resolution
  - [ ] Implement full `resolve_ast_path()` method (replaces placeholder from Phase 1)

### Phase 3: Request Integration
- [ ] `liboctools/EditMode/Request.vala` - Remove streaming code and integrate with Stream class
  - [ ] Add `stream_handler` property
  - [ ] Create Stream instance in `execute_request()`
  - [ ] Update `on_stream_chunk()` to delegate to Stream
  - [ ] Update `on_message_completed()` to delegate to Stream and wait for AST resolutions
  - [ ] Remove all moved methods and state
  - [ ] Update `apply_all_changes()` to read from `stream_handler.changes`
  - [ ] Update `reply_with_errors()` to read from `stream_handler.error_messages`
