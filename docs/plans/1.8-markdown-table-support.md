
# Add Table Support with ParserTable Class

## Overview

Refactor the parser architecture to use a `ParserBase` base class with shared methods, and create a separate `ParserTable` class that handles all table parsing logic. The main `Parser` will create a `ParserTable` instance when it detects a table and delegate parsing to it. For Phase 1, only implement the class structure without renderer table methods.

## Architecture Changes

### 1. Create ParserBase Abstract Class

Create new file `libocmarkdown/ParserBase.vala`:

- **Purpose**: Base class containing shared parsing utilities
- **Methods to extract from Parser**:
  - `peekMap()` - Generic map matching logic (currently private in Parser, line 308)
  - `peekFormat()` - Format tag detection (uses peekMap, line 408)
  - `peekHTML()` - HTML tag detection (line 680)
- **Properties**:
  - `protected RenderBase renderer` - Renderer instance
  - `protected string leftover_chunk` - For handling partial chunks
  - `protected bool in_literal` - Literal mode flag
- **Static members**:
  - `protected static Gee.HashMap<string, FormatType> format_map` - Format map (from Parser)
- **Abstract methods**:
  - `public abstract void add(string in_chunk, bool is_end_of_chunks = false)`
  - `public abstract void flush()`
  - `public abstract void start()`

### 2. Integrate ParserTable into Parser (Structure Only)

Modify `libocmarkdown/Parser.vala`:

- **Add property**: `private ParserTable? table_parser = null`
- **In `add()` method** (around line 760-831, after fenced code block handling):
  - Add placeholder check for table block (commented out or minimal, doesn't disturb current flow):
  ```vala
  // TODO: Table parsing - will be implemented in next step
  // if (this.current_block == FormatType.TABLE) {
  //     // Table parsing will be handled here
  // }
  ```

- **In `peekBlockHandler()`** (around line 1082-1186):
  - Add table detection placeholder (commented out, doesn't disturb current flow):
  ```vala
  // TODO: Table detection - will be implemented in next step
  // Check for table start: line beginning with |
  // if (first_char == '|' || ...) {
  //     this.current_block = FormatType.TABLE;
  //     return 0;
  // }
  ```

- **In `start()` method** (around line 285):
  - Add: `this.table_parser = null;` (safe to add, just initialization)

- **In `flush()` method** (around line 273):
  - Add placeholder: `// TODO: if (this.table_parser != null) this.table_parser.flush();`

### 3. Refactor Parser to Extend ParserBase

Modify `libocmarkdown/Parser.vala`:

- Change class declaration: `public class Parser : ParserBase`
- Move `peekMap()`, `peekFormat()`, `peekHTML()` to ParserBase (change visibility to `protected`)
- Move `format_map` static variable to ParserBase
- Keep Parser-specific methods:
  - `peekBlock()`, `peekListBlock()`, `peekBlockHandler()`
  - `got_format()`, `do_format()`, `do_block()`
  - `peekFencedEnd()`, `add_html()`
  - Main `add()` loop logic
  - `block_map` static variable (stays in Parser)

### 4. Create ParserTable Class

Create new file `libocmarkdown/ParserTable.vala`:

- **Class declaration**: `public class ParserTable : ParserBase`
- **Purpose**: Handles all table parsing logic independently
- **State variables**:
  - `str: string` - Accumulates table content
  - `state: TableState` - Current parsing state (NONE, HEADER, ALIGNMENT, ROWS)
  - `column_count: int` - Number of columns
  - `alignments: Gee.ArrayList<TableAlignment>` - Column alignments
  - `started: bool` - Track if on_table(start) was called (for cleanup)
- **Static members**:
  - `private static Gee.HashMap<string, FormatType> tag_map` - Format map for table cell content
  - `static construct { setup_table_map(); }`
- **Methods**:
  - `public ParserTable(RenderBase renderer)` - Constructor
  - `public override void add(string in_chunk, bool is_end_of_chunks = false)` - Main parsing entry point
    - Returns: Number of characters consumed, or -1 if need more data, or 0 if table ended/failed
    - Similar structure to `Parser.add()` but focused on table parsing
  - `public override void flush()` - Finalize table parsing
  - `public override void start()` - Reset table state
  - `private static void setup_table_map()` - Initialize tag_map (similar to Parser.setup_maps())
  - `private int handleTableRow(string chunk, int chunk_pos, bool is_end_of_chunks)` - Parse single row
  - `private int parseCell(string chunk, int chunk_pos, bool is_end_of_chunks)` - Parse cell content with inline formatting
  - `private bool isAlignmentRow(string line)` - Check if line is alignment row
  - `private TableAlignment parseAlignment(string align_str)` - Parse alignment from `:---`, `:---:`, `---:`

### 5. Create Table Enums

Add to `libocmarkdown/ParserTable.vala`:

```vala
private enum TableState {
    NONE,
    HEADER,      // Parsing header row
    ALIGNMENT,   // Parsing alignment row (| --- | --- |)
    ROWS         // Parsing data rows
}

private enum TableAlignment {
    LEFT,
    CENTER,
    RIGHT
}
```

### 6. Activate ParserTable Integration in Parser

Now activate the integration code added in step 2:

- **In `add()` method**:
  - Uncomment and implement the table block handling:
  ```vala
  // If we're in a table block, delegate to table parser
  if (this.current_block == FormatType.TABLE) {
      if (this.table_parser == null) {
          // Create table parser on first table content
          this.table_parser = new ParserTable(this.renderer);
          this.table_parser.start();
      }
      
      var remaining_chunk = chunk.substring(chunk_pos, chunk.length - chunk_pos);
      var table_result = this.table_parser.add(remaining_chunk, is_end_of_chunks);
      
      if (table_result == -1) {
          // Need more data
          this.leftover_chunk = remaining_chunk;
          return;
      }
      if (table_result == 0) {
          // Table ended or failed - clean up
          this.table_parser = null;
          this.current_block = FormatType.NONE;
          // Continue processing remaining content
          continue;
      }
      // Table consumed characters
      chunk_pos += table_result;
      // Check if still in table after handling
      if (this.current_block == FormatType.TABLE) {
          // Still in table - assume all characters were eaten
          continue;
      }
      // Table ended - continue with normal processing
      this.table_parser = null;
      continue;
  }
  ```

- **In `peekBlockHandler()`**:
  - Uncomment and implement table detection:
  ```vala
  // Check for table start: line beginning with |
  var first_char = chunk.get_char(chunk_pos);
  if (first_char == '|' || 
      (first_char.isspace() && chunk.index_of_char('|', chunk_pos) != -1)) {
      this.current_block = FormatType.TABLE;
      // Don't create table_parser here - let add() method create it
      // Return 0 to indicate we need to process this in add()
      return 0; // Will be handled in main add() loop
  }
  ```

- **In `flush()` method**:
  - Uncomment: `if (this.table_parser != null) this.table_parser.flush();`

### 7. ParserTable.add() Stub Implementation (Phase 1)

For Phase 1, implement a basic structure that:

- Accumulates content in `str`
- Detects when table ends (line doesn't start with `|`)
- Returns appropriate values:
  - `-1`: Need more data
  - `0`: Table ended or parsing failed
  - `>0`: Number of bytes consumed
- Does NOT emit any renderer callbacks (no `on_table`, `on_table_cell`, etc.)
- Tracks state transitions: NONE → HEADER → ALIGNMENT → ROWS
- Validates basic table structure (column count consistency)

## Files to Create/Modify

### New Files:

1. `libocmarkdown/ParserBase.vala` - Base class with shared utilities
2. `libocmarkdown/ParserTable.vala` - Table parser class

### Modified Files:

1. `libocmarkdown/Parser.vala` - Extend ParserBase, integrate ParserTable
2. `libocmarkdown/meson.build` - Add new source files to build

## Phase 2 (Future)

After Phase 1 class structure is complete:

- Implement full table parsing logic in `ParserTable.add()`
- Add table renderer methods to `RenderBase`
- Implement cell content parsing with inline formatting using `peekFormat()`
- Handle table alignment parsing
- Add error handling and cleanup callbacks (`on_table_end()`, `on_table_remove()`)

## Testing Considerations (Phase 1)

- Verify class structure compiles
- Verify Parser still works after refactoring to extend ParserBase
- Verify table detection triggers correctly
- Verify ParserTable is created and destroyed properly
- Verify ParserTable.add() returns correct values
- No table rendering yet - just structure validation

