# 1.23.4 Task Refinement Prompt

## Overview

Sub-plan of 1.23.2: **create the prompt** for **task refinement**. The job is to write the actual prompt we use when the refiner turns one coarse task (with a skill name) plus precursor data into a detailed task list with exact **Skill call** parameters. That means defining **what we tell the model** (its role, what it’s going to create and do), **what we give it** (coarse task, precursor data for the skill), and **what we ask it to produce** (detailed tasks including Skill call blocks). This plan covers both the prompt content and the input/output format — they go together.

**Primary purpose of refinement:** Take the **"What is needed"** section from the coarse task (output of the initial plan from 1.23.3) and **fill in arguments to the task section** — i.e. turn the natural-language "what we need" into concrete, structured **skill call arguments** that the Runner can pass to the skill executor. The refiner has access to the same precursor contents (injected file bodies, prior task outputs, project description) so it can derive exact values (paths, queries, options) from context.

That means defining **what we tell the model** (its role, what it's going to create and do), **what we give it** (coarse task, precursor data for the skill), and **what we ask it to produce** (detailed tasks including Skill call blocks with full arguments). This plan covers both the prompt content and the input/output format — they go together.

## Skills and structured input

A **skill** is similar to a **tool**: it has **structured input**. The refiner must produce the exact arguments the skill expects. Different skills have different argument shapes:

- **Simple string:** e.g. a command-line execution skill may take a single string (the command to run).
- **Complex arguments:** e.g. a research-summarize skill may take a list of file paths, a summary format, and optional constraints.
- **Mixed:** some skills take one required string plus optional key-value options.

The refinement prompt (and skill catalog / precursor data) must make each skill's **parameter schema** clear so the refiner can fill in arguments from "What is needed" and from the injected precursor contents.

## Example skill argument shapes

These illustrate the range of input complexity refinement must handle. The refiner reads "What is needed" and the precursor block, then emits the appropriate arguments.

| Skill type | Example | Argument shape | Notes |
|------------|---------|----------------|-------|
| **Research — web search** | Find current best practices for X | `query: string`, optional `max_results`, `sources` | Single query string; options for scope. |
| **Research — summarize files** | Summarize a series of files for context | `paths: string[]`, optional `format`, `max_length` | List of absolute paths; refiner gets paths from task references and precursor. |
| **Planning — plan from files** | Create a plan based on input of a few files | `paths: string[]`, `goal: string`, optional `constraints` | Files + goal (from "What is needed" or plan); may reference prior task output. |
| **Implementation — execute command** | Run a shell command | `command: string` | Single string; refiner fills from "What is needed" and context. |
| **Implementation — modify file** | Edit a file (apply change, insert, replace section) | `path: string`, `edit_type`, `content` or `search_replace` / `insert_at` etc. | Path from references; edit instructions from "What is needed"; may need line range or anchor. |

Further skills (e.g. semantic search, grep, read file) can be added with their schemas; the refinement prompt and Runner must support at least simple (single string) and complex (object or list of arguments) shapes.

## Status

**PLAN** — Implementation not started. Expand this document with the full prompt text, placeholders, and input/output format before implementation.

## Dependencies

- Plan 1.23.2 (Three Prompt Types and Orchestration).
- Plan 1.23.3 (Task creation initial prompt): coarse task format that refinement receives.

## Scope

- **Creating the prompt:** Write the prompt file for task refinement. The prompt must tell the model what it is doing (turning a coarse task into a detailed, executable task list with full skill parameters), what it has (one coarse task + precursor data for the skill + precursor contents in a markdown precursor area when the task references them), and what it must produce (detailed tasks with **Skill call** blocks the Runner can parse and execute). Define the **Skill call** syntax in the prompt so the model’s output is parseable.

## 1. Prompt content (to expand)

- **Role and task:** What we tell the model (e.g. you take a coarse task and produce exact calling conventions for the skill). What it’s going to create (a detailed task list with skill name and full parameters).
- **Input:** Coarse task (markdown) + precursor data for the skill (skill requirements, expected output, parameter schema if any) + **precursor contents** for any precursor the task references. The coarse task from 1.23.3 contains references only (e.g. link to `current_file`, path, prior task output). When the task mentions precursor information that is relevant, the Runner **injects the actual contents** into a **markdown precursor area** in the refinement prompt (e.g. current file body, project description, outputs from earlier tasks). So the refiner sees the real content it needs to define exact parameters.
- **Placeholders:** e.g. `{coarse_task}`, `{precursor_data}` (skill), `{precursor_contents}` or a dedicated precursor block — where the Runner injects the coarse task, skill precursor data, and the injected precursor contents (file bodies, prior outputs) for anything the task referenced.

## 2. Output format we tell the model to produce (to expand)

- **Result summary** — Short. Optional?
- **Tasks** — One or more detailed tasks. Each task: **Query**, **Reference**, **Skill call** (skill name + full parameters), **Output**. The **Skill call** block must use a defined syntax (e.g. fenced block or key-value list) so the Runner can parse and invoke the skill.
- **Skill call syntax:** Exact markdown we ask for (e.g. “run semantic_search with query X, top_k 5”). Grammar and examples in the prompt. Parsing rules for the Runner.

## 3. Parsing and validation (to expand)

- How the Runner extracts tasks and Skill call blocks from the model’s output. What to do if parse fails (e.g. re-run with feedback).

## 4. Examples (to expand)

- One full example in the prompt: coarse task + precursor data → example refinement output with Skill call.

## Deliverable

- The **prompt** for task refinement: full text, placeholders, input shape, and output format (including Skill call syntax). File in `resources/skill-prompts`. Runner uses this prompt and parses output per the format defined here.

## References

- Plan 1.23.2 §3 (refinement step), §4 (precursor data).
- Plan 1.23.3 (task creation initial prompt): coarse task format; task list uses precursor references only; refinement receives injected contents.
- Plan 1.23.11 (Runner implementation): Runner uses this prompt; injects precursor contents into markdown precursor area (Phase 3).
