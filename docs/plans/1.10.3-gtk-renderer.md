# Table support Phase 3: GTK renderer (markdowngtk) (1.10.3)

**Status: planning** – no implementation until this phase is triggered.

Part of the phased implementation for markdown table support; see **1.8.2-table-support-current-design.md** for the overall design and phase order. Depends on **1.10.1-renderer-interface.md** and **1.10.2-html-dummy.md**.

---

## Goal

Add table support in the markdowngtk **Render** class so that table callbacks manage a table (Grid of cells). Tables render **onto the box** like other content – not nested into a textarea, no frame/child-anchor. **Render** just relays the four table callbacks into **Table**; **Table** handles everything, including switching the renderer's target so cell content goes to each cell's TextView.

## Assumptions

- Do **not** rely on any existing Table/TableCell code (e.g. frame, child anchor, `store_cell_content`, `build_and_insert_table`). When implementing: remove or replace that code; table = a **Gtk.Grid** added to the box; each cell = a **TextView** with its own buffer. No frame (we render onto the box, not into a textarea).

## Files

- **Modify:** `libocmarkdowngtk/Render.vala` – add `current_table`, override the four table methods and relay to Table.
- **Create or rewrite:** `libocmarkdowngtk/Table.vala` – owns Grid and cell TextViews; when in a cell, switches renderer's `current_buffer` / `current_textview` so all on_XXX and text go to that cell's TextView.

## Render.vala: relay only

- **State:** Add `Table? current_table = null`.
- **on_table(bool is_start):**
  - If start: create `Table(renderer, col_count)`, set `current_table`.
  - If end: tell Table to finish (e.g. add grid to box), set `current_table = null`.
- **on_table_row(bool is_start):** Relay to `current_table.on_row(is_start)` (or equivalent). Table handles it.
- **on_table_hcell(bool is_start):** Relay to `current_table.on_hcell(is_start)`. Table handles it.
- **on_table_cell(bool is_start):** Relay to `current_table.on_cell(is_start)`. Table handles it.

No cell buffering in Render – no `current_cell_text`, no `store_cell_content`. All logic lives in Table.

## Table: own the Grid and switch renderer target when in a cell

- **Table** owns a **Gtk.Grid**. Each cell is a **TextView** (with its own buffer).
- When we enter a cell (on_hcell(true) or on_cell(true)):
  - Table creates or selects the current cell's TextView.
  - Table **sets the renderer's current_buffer and current_textview** to that cell's buffer/TextView (save the previous values so we can restore).
  - From then on, all **on_XXX** (on_text, on_strong, on_em, etc.) and text insertion go to the **cell's TextView** – no special handling in Render beyond the relay.
- When we leave the cell (on_hcell(false) or on_cell(false)):
  - Table **restores** the renderer's `current_buffer` and `current_textview` to what they were before the cell.
- So Table is responsible for: *create a fake buffer (the cell's TextView buffer) and update the renderer's current_buffer when in a td – so all on_XXX and text get given to the cell's TextView.*

- On table end: add the Grid to the box (e.g. append the grid widget to the same box we use for other content). No frame; no child anchor in a text area.

## Summary

| Who        | Responsibility |
|-----------|----------------|
| **Render** | Hold `current_table`; on table callbacks, relay to `current_table`. No cell buffering. |
| **Table**  | Own Grid and cell TextViews. On cell start: set renderer's current_buffer/current_textview to cell's TextView. On cell end: restore. On table end: add grid to box. |
