# Table support Phase 3: GTK renderer (markdowngtk) (1.10.3)

**Status: planning** – no implementation until this phase is triggered.

Part of the phased implementation for markdown table support; see **1.8.2-table-support-current-design.md** for the overall design and phase order. Depends on **1.10.1-renderer-interface.md** and **1.10.2-html-dummy.md**.

---

## Context (from 1.8.2)

- **Parser design**
  - Block state: `current_block` (FormatType); block detection: BlockMap.peek() at line start.
  - When BlockMap returns TABLE: parser consumes a 3-line block (header, separator, first body row) and passes lines to **handle_table_line(line)**.
  - Subsequent table rows (4th, 5th, …): passed one line at a time.
  - See 1.8.2 sections 3.0, 3.1a, 3.2.
- **Table detection**
  - We do *not* emit table start until we have the 3rd line (first body row).
  - Parser buffers: line 1 (header), line 2 (separator/alignment).
  - On line 3: emit **on_table(true)**, then header row (tr + hcells with align per cell), then that body row (tr + cells with align per cell). Parser passes **align** on each cell from a column map built when parsing line 2 (separator).
  - Rows 4+: same per-line path: tr start → cells (with format.eat()) → tr end.
  - See 1.8.2 §3.1a.
- **Cell content**
  - Same inline formatting as paragraph text: formatmap.eat() and same format handlers (on_text, on_strong, on_em, etc.) between cell start and cell end.
  - No new FormatMap; reuse existing path.
  - See 1.8.2 §3.6.

---

## Renderer interface (from 1.8.2 §6)

- **API** (RenderBase; 1.10.1 + align param below):
  - **on_table(bool start)** – table start (true) or table end (false).
  - **on_table_row(bool start)** – table row (tr) start or end.
  - **on_table_hcell(bool start, int align)** – header cell start or end (first row only). **align**: -1 = left (default), 0 = center, 1 = right.
  - **on_table_cell(bool start, int align)** – body cell start or end. **align**: -1 = left (default), 0 = center, 1 = right.
- **Cell content**
  - Sent via same path as paragraph text (on_text, on_strong, on_em, etc.) **between** cell start and cell end.

---

## Callback sequence (parser contract)

- **Order of calls** (from 1.8.2 §3.1a):
  1. **Table start**: `on_table(true)` – once, when parser has seen 3 lines (header, separator, first body row).
  2. **Header row**: `on_table_row(true)` → `on_table_hcell(true, align)` → (cell content) → `on_table_hcell(false, align)` [repeat for each header cell; parser passes **align** for that column] → `on_table_row(false)`.
  3. **Alignment**
     - Parser parses line 2 (separator) and builds a **hashmap**: column index → align (-1 left, 0 center, 1 right).
     - Parser passes **align** on each table cell (on_table_hcell and on_table_cell). No separate alignment callback.
  4. **Body rows**: For each body row (including first, line 3): `on_table_row(true)` → `on_table_cell(true, align)` → (cell content) → `on_table_cell(false, align)` [repeat per cell; parser passes align for that column] → `on_table_row(false)`.
  5. **Table end**: When next line does *not* look like a table row, parser calls `do_block(false, TABLE)` → `on_table(false)`.
- **Implications**
  - **Table** must handle alternating row/cell start–end; header row uses hcell, body rows use cell.
  - **Table** keeps **current_row** and **current_cell** only. Grid does not need total rows/columns: on cell start we **attach** a new TextView at (current_cell, current_row) and create the cell. Alignment from parser (align param on each cell).

---

## Goal

- Add table support in markdowngtk **Render** so table callbacks manage a table (Grid of cells).
- Tables render **onto the box** like other content:
  - Not nested into a textarea; no frame/child-anchor.
- **Render**: relay the four table callbacks into **Table** only.
- **Table**: handle everything, including switching the renderer's target so cell content goes to each cell's TextView.

---

## Assumptions

- **Existing code**
  - Do **not** rely on any existing Table/TableCell code (e.g. frame, child anchor, `store_cell_content`, `build_and_insert_table`).
  - When implementing: remove or replace that code.
  - Table = **Gtk.Grid** added to the box; each cell = **TextView** with its own buffer; no frame (render onto box, not into textarea).
- **Grid layout**
  - Table keeps **current_row** and **current_cell**; no need for total rows/columns.
  - On cell start: create TextView, **grid.attach**(child, current_cell, current_row, 1, 1). Row/cell indices updated on row start and cell end (e.g. on cell end increment current_cell; on row start reset current_cell, optionally increment current_row).
  - If a row has fewer/more cells than another: we just attach what we get; Grid lays out by position.
- **Alignment**
  - Parser builds column→align hashmap when parsing line 2 (separator); passes **align** (-1/0/1) on each on_table_hcell and on_table_cell.
  - Table applies align to each cell (e.g. halign on the TextView or child).

---

## Files

- **Modify:** `libocmarkdowngtk/Render.vala` – add `current_table`, override the four table methods and relay to Table.
- **Create or rewrite:** `libocmarkdowngtk/Table.vala` – owns Grid and cell TextViews; when in a cell, switches renderer's `current_buffer` / `current_textview` so all on_XXX and text go to that cell's TextView.

---

## Render.vala: relay only

- **State:** Add `Table? current_table = null`.
- **on_table(bool is_start):**
  - If start: create `Table(renderer)` (no col_count; Table uses current_row/current_cell and attach on each cell start).
  - If end: set `current_table = null` (grid was appended to box at table start).
- **on_table_row(bool is_start):** Relay to `current_table.on_row(is_start)` (or equivalent). Table handles it.
- **on_table_hcell(bool is_start, int align):** Relay to `current_table.on_hcell(is_start, align)`. Table handles it.
- **on_table_cell(bool is_start, int align):** Relay to `current_table.on_cell(is_start, align)`. Table handles it.

No cell buffering in Render – no `current_cell_text`, no `store_cell_content`. All logic lives in Table.

---

## Table: own the Grid and switch renderer target when in a cell

- **Table** owns a **Gtk.Grid**. State: **current_row**, **current_cell** (that's it; Grid does not need total rows/columns).
- When we enter a cell (on_hcell(true, align) or on_cell(true, align)):
  - Create a **TextView** for this cell; apply **align** (-1 left, 0 center, 1 right).
  - **grid.attach**(child, current_cell, current_row, 1, 1).
  - Table **sets the renderer's current_buffer and current_textview** to that cell's buffer/TextView (save previous to restore).
  - From then on, all **on_XXX** and text go to the **cell's TextView**.
- When we leave the cell (on_hcell(false, align) or on_cell(false, align)):
  - Table **restores** the renderer's `current_buffer` and `current_textview`.
  - Increment **current_cell** (next cell in same row).
- On **row start** (on_table_row(true)): reset **current_cell** to 0; if not first row, increment **current_row** (or increment current_row on row end – pick one convention).
- On table end: add the Grid to the box. No frame; no child anchor in a text area.

**Row vs header vs body:** First row after on_table(true) is header (on_table_row + on_table_hcell); subsequent rows are body (on_table_row + on_table_cell). Table only needs current_row and current_cell to know where to attach; no separate "column count" or total dimensions.

---

## Phased implementation (from 1.8.2 §7)

| Phase | Plan file | Summary |
|-------|-----------|---------|
| 1.10.1 | 1.10.1-DONE-renderer-interface.md | Add table methods to RenderBase. |
| 1.10.2 | 1.10.2-DONE-html-dummy.md | HtmlRender and DummyRenderer (tags / log). |
| **1.10.3** | **1.10.3-gtk-renderer.md** | **markdowngtk Render: Grid, Table, cell TextViews, relay.** |
| 1.10.4 | 1.10.4-table-handling.md | handle_table_line(line) in Parser. |
| 1.10.5 | 1.10.5-calling-code-types.md | handle_block_result TABLE; add() TABLE branch; handle_line_break and do_block. |
| 1.10.6 | 1.10.6-blockmap-parser.md | Table detection in BlockMap.peek(). |

---

## Proposed code (for review and approval)

Concrete Vala class definitions and Render changes. Table and TableCell are in `libocmarkdowngtk/`; Render changes are in the same library. **TableCell** is no longer used in this design (each cell is a plain **Gtk.TextView** created and attached by Table); the existing `TableCell.vala` can be removed or kept as an empty stub so the build list does not need to change.

---

### 1. Table class (`libocmarkdowngtk/Table.vala`)

Replace the existing Table (frame, anchor, store_cell_content, build_and_insert_table) with this implementation. No `col_count`; no frame; no child anchor. Grid is appended to the box at table start so the container is in the flow immediately; rows and cells are then attached to it.

```vala
namespace MarkdownGtk
{
	internal class Table
	{
		private Render renderer;
		private Gtk.Grid grid;
		private int current_row = 0;
		private int current_cell = 0;

		public Table(Render renderer)
		{
			this.renderer = renderer;
			this.grid = new Gtk.Grid() {
				column_homogeneous = false,
				row_homogeneous = false,
				column_spacing = 4,
				row_spacing = 4,
				margin_start = 2,
				margin_end = 2,
				margin_top = 2,
				margin_bottom = 2
			};
			if (this.renderer.box == null) {
				return;
			}
			this.renderer.box.append(this.grid);
		}

		public void on_row(bool is_start)
		{
			if (is_start) {
				this.current_cell = 0;
				return;
			}
			this.current_row++;
		}

		public void on_hcell(bool is_start, int align)
		{
			if (is_start) {
				this.create_cell(align);
				return;
			}
			this.renderer.clear();
			this.current_cell++;
		}

		public void on_cell(bool is_start, int align)
		{
			if (is_start) {
				this.create_cell(align);
				return;
			}
			this.renderer.clear();
			this.current_cell++;
		}

		private void create_cell(int align)
		{
			var cell_view = new Gtk.TextView() {
				editable = false,
				cursor_visible = false,
				wrap_mode = Gtk.WrapMode.WORD,
				hexpand = true,
				vexpand = false
			};

			switch (align) {
				case 0:
					cell_view.halign = Gtk.Align.CENTER;
					break;
				case 1:
					cell_view.halign = Gtk.Align.END;
					break;
				default:
					cell_view.halign = Gtk.Align.START;
					break;
			}

			this.grid.attach(cell_view, this.current_cell, this.current_row, 1, 1);
			this.renderer.current_textview = cell_view;
			this.renderer.current_buffer = cell_view.buffer;
			this.renderer.top_state = new TopState(this.renderer);
			this.renderer.top_state.initialize();
			this.renderer.current_state = this.renderer.top_state;
		}
	}
}
```

---

### 2. TableCell (`libocmarkdowngtk/TableCell.vala`)

Not used in the attach-per-cell design. Either remove from the build and delete the file, or keep a minimal stub so `meson.build` can stay unchanged. If kept as stub:

```vala
namespace MarkdownGtk
{
	// No longer used: table cells are Gtk.TextView created and attached by Table.
	internal class TableCell {}
}
```

(Or leave the existing class and document it as deprecated; remove when convenient.)

---

### 3. Render changes (`libocmarkdowngtk/Render.vala`)

**3a. New state for current table**

Add after the list stack / code block handler fields (e.g. after `current_list_indentation`):

```vala
		// Table: current table when inside on_table(true)..on_table(false)
		internal Table? current_table { get; private set; default = null; }
```

**3b. Enter table: clear**

When we enter a table we clear all state. In on_table(true): call existing `this.clear()` (it calls `end_block()` which sets current_textview, current_buffer, top_state, current_state to null, and clears sourceview handlers). Then current_table = new Table(this). No new method—use existing `clear()`.

**3c. Leaving a cell**

Table calls existing `renderer.clear()` when leaving a cell. `clear()` already calls `end_block()` which sets current_textview, current_buffer, top_state, current_state to null. Entering a cell is done in Table: Table sets renderer.current_textview, current_buffer, creates TopState(renderer), initializes it, sets renderer.top_state and current_state.

**3d. Exit table**

In on_table(false): current_table = null. (Existing current_* stay as they are—cleared after last cell pop, or caller sets target for next content.)

**3e. Table callbacks – relay to current_table**

Replace the current empty overrides with:

```vala
		public override void on_table(bool is_start)
		{
			if (is_start) {
				this.clear();
				this.current_table = new Table(this);
				return;
			}
			this.current_table = null;
		}

		public override void on_table_row(bool is_start)
		{
			if (this.current_table == null) {
				return;
			}
			this.current_table.on_row(is_start);
		}

		public override void on_table_hcell(bool is_start, int align)
		{
			if (this.current_table == null) {
				return;
			}
			this.current_table.on_hcell(is_start, align);
		}

		public override void on_table_cell(bool is_start, int align)
		{
			if (this.current_table == null) {
				return;
			}
			this.current_table.on_cell(is_start, align);
		}
```

**3f. add() guard**

Today `add()` errors if `current_textview == null && current_source_view_handler == null`. When we are inside a table cell, `current_textview` is the cell’s view (Table set it), so we do not need to allow `current_table != null` there. If we ever call `add()` before the first cell is pushed (e.g. between `on_table(true)` and first `on_table_row(true)`), then `current_textview` would still be the main view. So no change to the `add()` guard is required.

---

### 4. Summary of proposed edits

| File | Action |
|------|--------|
| `Table.vala` | Replace with new class: Grid only, current_row/current_cell, on_row/on_hcell/on_cell, create_cell. Constructor appends grid to renderer.box at start. On cell start Table sets renderer.current_textview/buffer/top_state/current_state (new TopState); on cell end call renderer.clear(). |
| `TableCell.vala` | Stub or remove (cells are plain Gtk.TextView; no TableCell instance). |
| `Render.vala` | Add current_table; on table start call existing clear(); on table end current_table = null; relay table callbacks to current_table. Table uses existing clear() when leaving a cell. Render must expose current_textview, current_buffer, top_state, current_state settable so Table can set them. No extra data. |

---

## Open issues / TBD

*(Use this section to work out issues before or during implementation.)*

1. *(Add more as we work through implementation.)*

---

## Summary

| Who        | Responsibility |
|-----------|----------------|
| **Render** | Hold `current_table`; on table callbacks, relay to `current_table`. No cell buffering. |
| **Table**  | Own Grid; keep **current_row** and **current_cell** only. On cell start: create TextView, grid.attach, apply align, set renderer.current_textview/buffer/top_state/current_state (new TopState). On cell end: renderer.clear(), increment current_cell. On row start: reset current_cell; advance current_row as needed. Grid appended to box at table start. Header row = hcells, body rows = cells. |
