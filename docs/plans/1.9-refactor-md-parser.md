# Refactor Markdown Parser to State-Based Architecture

## Overview

Explore refactoring the markdown parser to use separate parser classes for different parsing states, similar to the ParserTable approach. Each parser would handle a specific context (code blocks, literal mode, HTML, lists, formatting, etc.) and the main parser would delegate to the appropriate sub-parser based on current state.

## Proposed Architecture

### Parser Classes

1. **ParserStart** - Handles block-level parsing at line start (headings, horizontal rules, blockquotes, etc.)
2. **ParserCodeBlock** - Handles fenced code blocks (``` or ~~~)
3. **ParserLiteral** - Handles literal/inline code spans (`code`)
4. **ParserHtml** - Handles HTML tag parsing
5. **ParserList** - Handles list parsing (ordered, unordered, task lists, continuation)
6. **ParserFormatting** - Handles inline formatting (bold, italic, strikethrough, etc.)

### Design Decisions

#### 1. Initialization Strategy

**DECIDED: Option A - Initialize all parsers at start**
- All parsers created in main Parser constructor
- No allocation overhead during parsing
- Simple state management
- Fast switching between parsers
- Memory overhead acceptable (parsers are lightweight)

#### 2. Reset Strategy

**DECIDED: Option B - start() method**
- Consistent with current Parser API
- Clear intent
- Can be called multiple times safely
- Each parser implements: `public void start()`

#### 3. State Management

**DECIDED: Each parser maintains its own state**

**Main Parser State:**
- `current_block: FormatType` - Current block type (stored in main parser)
- `current_parser: ParserBase?` - Currently active sub-parser
- `at_line_start: bool` - At start of line (main parser tracks this)
- `last_line_block: FormatType` - Previous line's block type (main parser)

**Sub-Parser State:**
- Each sub-parser maintains its own internal state
- Sub-parsers have reference to main parser (passed in constructor)
- When sub-parser finishes, it tells main parser who's next
- Main parser updates `current_parser` based on sub-parser's return

**State Transitions:**
- Sub-parsers return control to parent when done
- Sub-parsers can delegate to other sub-parsers (e.g., ParserList -> ParserFormatting)
- Main parser tracks `current_block` (not sub-parsers)
- Nested states handled by sub-parser delegation (e.g., formatting inside list items)

#### 4. Parser Hierarchy

**DECIDED: Main parser does NOT extend ParserBase, sub-parsers DO**

```
Parser (main orchestrator - does NOT extend ParserBase)
  ├── Contains instances of:
  │   ├── ParserBase (abstract)
  │   │   ├── ParserTable extends ParserBase
  │   │   ├── ParserCodeBlock extends ParserBase
  │   │   ├── ParserLiteral extends ParserBase
  │   │   ├── ParserHtml extends ParserBase
  │   │   ├── ParserList extends ParserBase
  │   │   └── ParserFormatting extends ParserBase
  │   └── ParserStart (may or may not extend ParserBase - TBD)
```

**Rationale:**
- Main Parser orchestrates and delegates
- Sub-parsers share common utilities via ParserBase
- Main Parser has direct access to renderer and main state

## Analysis of Current Parser Flow

### Current add() Method Flow

1. Handle newlines (end blocks, reset state)
2. Check if in fenced code block → handle specially
3. Check if at line start → peekBlockHandler()
4. Handle escape sequences
5. Handle format sequences (peekFormat)
6. Handle HTML tags
7. Accumulate text

### Potential Parser Delegation Points

1. **At line start**: Delegate to ParserStart
   - Detects blocks (headings, HR, blockquotes, lists, tables)
   - Returns block type and bytes consumed

2. **In code block**: Delegate to ParserCodeBlock
   - Handles code content until closing fence
   - Returns bytes consumed

3. **In literal mode**: Delegate to ParserLiteral
   - Handles code span content until closing backtick
   - Returns bytes consumed

4. **HTML tag detected**: Delegate to ParserHtml
   - Parses HTML tag and attributes
   - Returns bytes consumed

5. **In list block**: Delegate to ParserList
   - Handles list items, continuation, nesting
   - Returns bytes consumed

6. **Formatting detected**: Delegate to ParserFormatting
   - Handles inline formatting (bold, italic, etc.)
   - Manages format stack
   - Returns bytes consumed

## Benefits of State-Based Architecture

1. **Separation of Concerns**: Each parser handles one responsibility
2. **Maintainability**: Easier to modify individual parser logic
3. **Testability**: Can test each parser independently
4. **Extensibility**: Easy to add new parser types (e.g., ParserTable)
5. **Code Organization**: Related logic grouped together

## Challenges

1. **State Coordination**: Multiple parsers need to coordinate state
2. **Performance**: Overhead of switching between parsers
3. **Complexity**: More classes to manage
4. **Shared State**: Some state needs to be shared (renderer, leftover_chunk)
5. **Error Handling**: Need consistent error handling across parsers

## Proposed Implementation Approach

### Phase 1: Extract ParserBase (from 1.8 plan)
- Create base class with shared utilities
- Move peekMap, peekFormat, peekHTML to base
- Sub-parsers will extend this

### Phase 2: Extract ParserFormatting
- Extends ParserBase
- Takes main_parser reference in constructor
- Handles format stack and inline formatting
- Only activated when needed (not always active)
- Returns control to parent when done
- Test with existing parser

### Phase 3: Extract ParserCodeBlock
- Extends ParserBase
- Takes main_parser reference in constructor
- Already has distinct handling in current code
- Clear boundaries (fenced code blocks)
- Updates main_parser.current_block when finished
- Test with existing parser

### Phase 4: Extract ParserList
- Extends ParserBase
- Takes main_parser reference in constructor
- Complex logic (continuation, nesting)
- Delegates to ParserFormatting for item content
- Returns control to parent when done
- Test with existing parser

### Phase 5: Extract ParserHtml
- Extends ParserBase
- Takes main_parser reference in constructor
- Already has separate add_html() method
- Clear boundaries
- Returns control to parent when done
- Test with existing parser

### Phase 6: Extract ParserStart
- Block detection at line start
- May or may not extend ParserBase (TBD)
- Integrates with other parsers
- Delegates to appropriate parser based on block type
- Returns control to main parser
- Test with existing parser

### Phase 7: Extract ParserLiteral
- Extends ParserBase
- Takes main_parser reference in constructor
- Handles inline code spans
- Works with ParserFormatting
- Returns control to parent when done
- Test with existing parser

## Architecture Details

### Main Parser Structure

**Main Parser Properties:**
```vala
public class Parser {
    private RenderBase renderer;
    
    // All sub-parsers initialized in constructor
    private ParserStart parser_start;
    private ParserCodeBlock parser_code_block;
    private ParserLiteral parser_literal;
    private ParserHtml parser_html;
    private ParserList parser_list;
    private ParserFormatting parser_formatting;
    private ParserTable? parser_table; // From 1.8 plan
    
    // Main parser state
    private ParserBase? current_parser = null; // Currently active sub-parser
    private FormatType current_block = FormatType.NONE; // Block-level state
    private bool at_line_start = true;
    private FormatType last_line_block = FormatType.NONE;
    private string leftover_chunk = "";
}
```

### Sub-Parser Communication

**Sub-Parser Constructor:**
```vala
public ParserFormatting(Parser main_parser, RenderBase renderer)
{
    base(renderer);
    this.main_parser = main_parser;
}
```

**Sub-Parser Return Values:**
- `int` - Number of characters consumed
- `-1` - Need more data (save to leftover_chunk, return)
- `0` - Finished, return control to parent
- `>0` - Consumed N characters, continue with this parser

**Control Flow in Main Parser:**
```vala
public void add(string in_chunk, bool is_end_of_chunks = false)
{
    var chunk = this.leftover_chunk + in_chunk;
    this.leftover_chunk = "";
    var chunk_pos = 0;
    
    while (chunk_pos < chunk.length) {
        // If sub-parser is active, delegate to it
        if (this.current_parser != null) {
            var remaining = chunk.substring(chunk_pos);
            var result = this.current_parser.add(remaining, is_end_of_chunks);
            
            if (result == -1) {
                // Need more data
                this.leftover_chunk = remaining;
                return;
            }
            if (result == 0) {
                // Sub-parser finished, determine next parser
                this.current_parser = null;
                // Continue with main parsing logic
                continue;
            }
            // Sub-parser consumed characters
            chunk_pos += result;
            continue;
        }
        
        // Main parsing logic (determine which parser to activate)
        // ...
    }
}
```

### Parser Activation

**ParserFormatting:**
- Only active when expected (not always active)
- Activated by ParserStart after block detection
- Activated by ParserList for list item content
- Activated by other parsers when they need inline formatting

**Parser Flow Example:**
```
Main Parser.add()
  -> At line start: current_parser = parser_start
     -> ParserStart.add() detects list block
        -> Sets main_parser.current_block = FormatType.UNORDERED_LIST
        -> Returns 0 (finished)
     -> Main parser: current_parser = parser_list
     -> ParserList.start()
     -> ParserList.add() processes list item
        -> For item content: current_parser = parser_formatting
        -> ParserFormatting.start()
        -> ParserFormatting.add() processes inline formatting
           -> Returns 0 (finished)
        -> ParserList continues (current_parser = null, back to ParserList)
     -> ParserList returns 0 (finished)
     -> Main parser: current_parser = null, current_block = FormatType.NONE
```

**Key Points:**
- `current_block` is stored in main parser (not sub-parsers)
- Sub-parsers update `main_parser.current_block` when needed
- Sub-parsers set `main_parser.current_parser` to delegate to other parsers
- When sub-parser returns 0, main parser sets `current_parser = null`
- Main parser determines next parser based on state

### Nested States

**Handled by Sub-Parser Delegation:**
- ParserList delegates to ParserFormatting for item content
- ParserFormatting can delegate to ParserLiteral for code spans
- No explicit "nested state stack" - handled by call chain
- Main parser only tracks `current_block` (block-level state)

## Resolved Questions

1. ✅ **ParserFormatting activation**: Only active when expected (not always active)
2. ✅ **Nested states**: Handled by sub-parser delegation (ParserList -> ParserFormatting)
3. ✅ **Parser delegation**: Yes, parsers can delegate to other parsers
4. ⏳ **Error recovery**: To be determined during implementation
5. ⏳ **ParserText**: To be determined - may not be needed if ParserFormatting handles plain text

## Remaining Questions

1. Should ParserStart extend ParserBase or be a separate class?
2. How should error recovery work? (if ParserHtml fails, fall back to text?)
3. Should there be a ParserText for plain text accumulation, or does ParserFormatting handle it?
4. How should leftover_chunk be managed? (main parser or sub-parsers?)

## Next Steps

1. Review this architecture with team
2. Decide on initialization and reset strategies
3. Create detailed design for each parser class
4. Implement Phase 1 (ParserBase) from 1.8 plan first
5. Then proceed with Phase 2 (ParserFormatting) as proof of concept
