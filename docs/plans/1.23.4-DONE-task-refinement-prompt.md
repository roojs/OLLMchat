# 1.23.4 Task Refinement Prompt

## Overview

Sub-plan of 1.23.2: **create the prompt** for **task refinement**. The job is to write the actual prompt we use when the refiner turns **one** coarse task (with a skill name) plus skill input requirements and precursor contents into a detailed task with exact **Skill call** parameters. That means defining **what we tell the model** (its role, what it’s going to create and do), **what we give it** (one coarse task, skill input requirements, precursor contents only when the task references them), and **what we ask it to produce** (one detailed task with a **Skill call** block). This plan covers both the prompt content and the input/output format — they go together.

**Task creator controls what refinement sees:** Environment, project description, current file, and other precursor content are **not relevant** to refinement unless the **task creator** (creation prompt, 1.23.3) said they are relevant. We must ensure the **task creator can add those items as link references** in the task's **References**. When the planner assigns a task, it lists in **References** only the precursor it needs (e.g. `[Project description](project_description)`, `[Current file](current_file)`, file links, plan sections). The Runner injects into the refinement prompt **only** the content that corresponds to those references — so environment, project description, current file, and precursor contents are included **only when the task creator added them as references** for that task. The creation prompt (1.23.3) must therefore support and document these as valid link types so the planner can add them when relevant.

**Single-task scope:** The **creation** prompt (1.23.3) may produce **multiple** coarse tasks (across task sections). The Runner **splits** the task list and invokes the **refinement** prompt **once per task**. Each refinement call receives **exactly one** coarse task. The refinement prompt therefore only ever deals with one task at a time; it does not see or output multiple tasks.

**Primary purpose of refinement:** Take the **"What is needed"** from that single coarse task and **fill in arguments** for the skill — i.e. turn the natural-language "what we need" into concrete, structured **skill call arguments** that the Runner can pass to the skill executor. The refiner has access only to precursor contents that the task creator listed in this task's References; it uses those to derive exact values (paths, queries, options) from context.

## Skill input requirements (extracted from the skill)

From each skill definition we **extract** the **actual content** that specifies the skill's **input requirements** — i.e. the exact details the skill needs to be invoked: parameter schema, call format and grammar, required and optional arguments, constraints. This is **not** "pre-execution" activity; it is the **skill's execution specification** or **skill input requirements** — the specification of what input the skill expects and in what form. That content (the skill's own specification) is injected into the refinement prompt so the refiner knows exactly what arguments to produce and what call syntax to use. The Runner extracts this from the skill (e.g. a dedicated section in the skill file, such as "Input requirements" or "Skill call format") and injects it via a placeholder (e.g. `{skill_input_requirements}`). No ad-hoc skills; the refiner only sees the input requirements for the **one** skill assigned to this task. Document this in the skill layout (1.23.2 Conventions) and Runner (1.23.11): the exact location and format of the skill input requirements block, and that it defines call syntax, parameters, and any parsing rules.

## Skills and structured input

A **skill** is similar to a **tool**: it has **structured input**. The refiner must produce the exact arguments the skill expects. Different skills have different argument shapes:

- **Simple string:** e.g. a command-line execution skill may take a single string (the command to run).
- **Complex arguments:** e.g. a research-summarize skill may take a list of file paths, a summary format, and optional constraints.
- **Mixed:** some skills take one required string plus optional key-value options.

The refinement prompt (and skill catalog / precursor data) must make each skill's **parameter schema** clear so the refiner can fill in arguments from "What is needed" and from the injected precursor contents.

## Example skill argument shapes

These illustrate the range of input complexity refinement must handle. The refiner reads "What is needed" and the precursor block, then emits the appropriate arguments.

| Skill type | Example | Argument shape | Notes |
|------------|---------|----------------|-------|
| **Research — web search** | Find current best practices for X | `query: string`, optional `max_results`, `sources` | Single query string; options for scope. |
| **Research — summarize files** | Summarize a series of files for context | `paths: string[]`, optional `format`, `max_length` | List of absolute paths; refiner gets paths from task references and precursor. |
| **Planning — plan from files** | Create a plan based on input of a few files | `paths: string[]`, `goal: string`, optional `constraints` | Files + goal (from "What is needed" or plan); may reference prior task output. |
| **Implementation — execute command** | Run a shell command | `command: string` | Single string; refiner fills from "What is needed" and context. |
| **Implementation — modify file** | Edit a file (apply change, insert, replace section) | `path: string`, `edit_type`, `content` or `search_replace` / `insert_at` etc. | Path from references; edit instructions from "What is needed"; may need line range or anchor. |

Further skills (e.g. semantic search, grep, read file) can be added with their schemas; the refinement prompt and Runner must support at least simple (single string) and complex (object or list of arguments) shapes.

## Status

**DONE** — This plan has been completed. The task refinement prompt has been implemented in **`resources/skill-prompts/task_refinement.md`**. The content below the divider is the exact prompt text; the Runner should use that file and inject placeholders as specified in this plan.

## Dependencies

- Plan 1.23.2 (Three Prompt Types and Orchestration).
- Plan 1.23.3 (Task creation initial prompt): coarse task format that refinement receives.

## Scope

- **Creating the prompt:** Write the prompt file for task refinement. The prompt must tell the model what it is doing (turning **one** coarse task into a detailed, executable task with full skill parameters), what it has (one coarse task + **skill input requirements** extracted from the skill + precursor contents for that task's references), and what it must produce (one detailed task with **one or more Skill/tool call** blocks the Runner can parse and execute). A **skill may use more than one tool**; the refiner is responsible for generating **all** tool calls for that task (which may be multiple). The output format is defined per skill (in skill input requirements); the refiner follows whatever the skill requests. This prompt does not define call syntax itself.

## 1. Prompt content (to expand)

- **Role and task:** What we tell the model (e.g. you take **one** coarse task and produce exact calling conventions for the skill). What it’s going to create (one detailed task with skill name and full parameters).
- **Input — one coarse task:** The refinement prompt receives a **single** coarse task (What is needed, Skill, References, Expected output) as produced by the creation prompt. The Runner invokes refinement once per coarse task; see 1.23.11.
- **Input — precursor information (same format as creation, restricted):** Precursor information is supplied in the **same format** as in the task creation prompt (1.23.3): environment, project description, file contents, plan sections, etc. It is **restricted** to what the creation task has specified for this task — i.e. only the precursor content that corresponds to this task's **References**. Environment, project description, and current file are included only if the task creator added them as references for this task. The Runner resolves this task's links and injects the corresponding content into the refinement prompt's precursor area; it does not inject precursor for other tasks.
- **Input — skill input requirements:** The Runner **extracts from the skill** the **actual content** that specifies the skill's input requirements (parameter schema, call format, required and optional arguments — the skill's execution specification). That block is injected via `{skill_input_requirements}` so the refiner knows exactly what arguments and call syntax to produce.
- **Placeholders:** e.g. `{coarse_task}`, `{skill_input_requirements}` (extracted from the skill), optional `{current_skill_call_issues}` (only when re-running after invalid/parse failure — issues with the current call to rectify), and precursor block placeholders as 1.23.3 but filled **only** for references this task lists: `{environment}`, `{project_description}`, `{current_file}`, resolved link contents for files/plan sections this task references. All annotations and placeholder descriptions live **above** the template divider; the template below contains only the prompt text and placeholder tokens, no inline annotations.

## 2. Output format we tell the model to produce (to expand)

- **Refined task replicates input and appends Skill/tool call(s):** The output must **replicate the same structure as the input** (What is needed, Skill, References, Expected output) and **append** the **Skill/tool call(s)** (concrete call(s) with full parameters). The skill may require **multiple** tool calls; the refiner produces **all** of them for this task. So the refined task has: **What is needed**, **Skill**, **References**, **Expected output**, and **Skill call** (or multiple call blocks, per skill format). Same terminology as the coarse task; no separate "Query" — use **What is needed**. The Runner uses this as the executable task (ready to run when the Skill call(s) are valid).
- **Result:** Effectively either the task is **ready to run** (valid Skill call) or the Runner will re-run refinement with feedback (see re-run below). We do not model "more information needed" / return to task creator for now.
- **Result summary** — Largely irrelevant; optional short sentence if helpful. Omit or keep minimal.
- **Skill call syntax:** Defined in the skill (in the skill input requirements block, injected via `{skill_input_requirements}`); the refiner produces output that conforms to the format, grammar, and parsing rules specified there.

## 3. Parsing and validation (to expand)

- How the Runner extracts the single task and one or more Skill/tool call blocks from the model's output (format and multiplicity per skill). **Re-run when format is invalid:** Refinement may be run **multiple times** if the Skill call format is invalid or parse fails. When re-running, the Runner injects an **optional user section: "Issues with the current call"** — the problems with the previous attempt (e.g. invalid syntax, missing required argument, unparseable block). The refinement prompt must instruct the model: **if the user section includes issues with the current skill call, refine the call to rectify the issues listed**. So the prompt has an optional placeholder (e.g. `{current_skill_call_issues}`) filled only on re-run; and an instruction that when this section is present, the refiner must fix the Skill call to address those issues.

## 4. Examples (to expand)

- One full example in the prompt: coarse task + precursor data → example refinement output with Skill call.

## Deliverable

- The **prompt** for task refinement: full text, placeholders, input shape, and output format. Skill call syntax is defined per skill (in skill input requirements), not in this prompt. File in `resources/skill-prompts`. Runner uses this prompt and parses output per the format defined by each skill.

## References

- Plan 1.23.2 §3 (refinement step), §4 (precursor data).
- Plan 1.23.3 (task creation initial prompt): coarse task format; task list uses precursor references only; **must allow task creator to add** environment, project description, current file, files, plan sections **as link references** in References; refinement receives one task and injected precursor only for references that task lists.
- Plan 1.23.2 (Conventions): executor skill layout; document skill input requirements block (location, format) in executor skills.
- Plan 1.23.11 (Runner implementation): Runner splits tasks and invokes refinement once per task; injects skill input requirements and precursor contents into refinement prompt (Phase 3).

## Template — exact prompt content only (no annotations below)

**Rule for this and all prompt-creation plans:** The content below the `---` is the **exact** content that will be used as the prompt. **No annotations, no explanatory text, no parenthetical notes** (e.g. no "(optional)", "(for this task)", "(only when re-running)") may appear below the divider. Placeholder tokens (e.g. `{coarse_task}`) are the only exception. All annotation, placeholder meanings, and injection rules belong in the sections **above** this line. Anything below is copy-paste prompt content only.

---

You are a **refiner**. Your only job is to take **one** coarse task and turn it into a **single detailed task** with a concrete **Skill call** (skill name plus full arguments). You do **not** execute anything or run tools. You only produce the refined task with exact parameters the Runner can pass to the skill.

## What you receive

- **One coarse task:** What is needed, Skill name, References (markdown links), Expected output. This is the output of the task creation step for a single task.
- **Skill input requirements:** The skill's own specification of input — parameter schema, call format, required and optional arguments. Use this to know exactly what arguments and syntax the skill expects. Produce a **Skill call** that matches this specification.
- **Precursor information:** Content that the task creator added as references for this task (environment, project description, current file, file contents, plan sections). Use it to fill in exact values (paths, queries, options) for the Skill call.
- **Issues with the current call:** When this section is present, the previous refinement attempt had problems. Rectify the Skill call to address the issues listed here. Produce a corrected Skill call that satisfies the skill input requirements and fixes the reported issues.

## Output format

Produce your response in the following structure. Use markdown **headings** as indicated.

1. **Refined task** — Replicate the input task and append the Skill call. Use the same terminology as the coarse task:
   - **What is needed**
   - **Skill**
   - **References**
   - **Expected output**
   - **Skill call** — Produce the Skill call in the exact format and syntax specified in the skill input requirements. Include the skill name and all required and optional arguments with concrete values derived from "What is needed" and the precursor contents. If the user message includes an "Issues with the current call" section, rectify the Skill call to address those issues.

---

{coarse_task}

## Skill input requirements

{skill_input_requirements}

{current_skill_call_issues}

## Precursor information

{environment}
{project_description}
{current_file}
{precursor_contents}
