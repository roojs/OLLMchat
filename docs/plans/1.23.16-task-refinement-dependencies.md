# 1.23.16 Task refinement dependencies

**FORBIDDEN:** Never write long paragraphs in this plan. They are unreadable. **ALWAYS** use short bullet points and nested bullet points only.

**Scope:** Prerequisites that must exist or change before **Task.Tool** (Tool.vala) can be wired into the build and used by ResultParser/Details. Does **not** add Tool.vala to meson.

**Coding standards:** Follow `.cursor/rules/CODING_STANDARDS.md`.

---

## Overview

- **Purpose:** Implement the dependencies listed in 1.23.15 §5 (Prerequisites) so that Tool.vala can later be added to meson and used.
- **Dependencies:** 1.23.15 (task refinements); 1.23.13 (task-related code, DONE)
- **Status:** In progress. §1–§3, §6–§9 done.
- **Remaining:** §5 (Runner API — do in 1.23.14); then §4 (add Task namespace to liboccoder meson).

---

## 1. Markdown.Document headings keyed by anchor — DONE

- **Current:** Document keys headings by heading text (e.g. `"Result summary"`, `"Tool Calls"`). 1.23.15 uses "Tool Calls" for the Tool Calls section.
- **Deliverable:** Key headings by GFM-style anchor (no separate helper). Update Document only at add-heading time; update all consumers to use anchor keys.
- **Rules for key:** Lowercase; each run of non-alphanumeric (spaces, punctuation) → single hyphen; trim leading/trailing hyphens. Examples: "Task" → "task", "Tool Calls" → "tool-calls", "Result summary" → "result-summary", "aa+++aaa" → "aa-aaa".
- **Done:** `Document.register_heading()` in libocmarkdown/document/Document.vala now computes anchor from `b.text_content().strip()` using GLib.Regex (`[^a-z0-9]+` → hyphen, then trim leading/trailing hyphens) and uses that as the key.

- **Update all consumers** to use anchor keys (string literals only, no variables for keys):
  - ResultParser: extract_refinement() use **task** (section "Task"); Tool Calls walk use **tool-calls**; extract_exec() use **result-summary** (replace "Result summary").
  - Any other code that uses document.headings (e.g. Skill.Definition **available-skills**) must use the anchor for that section.

---

## 2. ResultParser.extract_refinement() — DONE

- **Current:** Walk of Tool Calls section (anchor key **tool-calls**); for each fenced block, create Tool instance, parse block, add to task.tools.
- **Status:** Fixed.

---

## 3. OLLMchat.Tool.BaseTool — title and example_call abstract + examples — DONE

- **Current:** `title` and `example_call` were concrete properties (get; set; default = ""). Task.Tool.to_instructions() appends example when non-empty.
- **Design:**
  - **Abstract:** `title` and `example_call` are abstract getters (same pattern as `description`); every child class implements them. No private backing, no null strings.
  - **Wrapped:** Wrapped clones use the base tool’s title/example_call. ParamParser has `@example`; resources/wrapped-tools/*.tool have @example; ToolBuilder uses parser.title (no assignment to tool.title; title is get-only).
  - **Example format:** One-line JSON `{"name": "<tool_name>", "arguments": { ... }}`. to_instructions() appends "Example: " + example_call when non-empty.
- **Done:** BaseTool has abstract `title` and `example_call`. All concrete tools (ReadFile, RunCommand, WebFetch, EditMode, GoogleSearch, CodebaseSearchTool, Child.Tool) override both; Child.Tool uses `agent_example` from frontmatter. ParamParser has `example` and `@example`; all wrapped .tool files have @example. ToolBuilder does not set title on clone (get-only).

---

## 4. Task namespace — add to meson (after §1–§3)

- **Current:** No Task/*.vala files are in liboccoder’s meson.build. Details.vala, ResultParser.vala, Tool.vala (and any Task/ deps) exist but are not built by meson.
- **Deliverable:** Add Task namespace to liboccoder meson: Task sources (Tool.vala, Details.vala, ResultParser.vala; plus Task/List.vala, Task/Step.vala if dependencies) so the library builds. Then Details.tools and run_tools() (already in code) work: ResultParser (§2) populates task.tools; run_tools() iterates and yields tool.execute().
- **Depends on:** §3 and §5–§9 below. Task sources removed from meson until those are done.
- **Task code uses:** `task.runner.session.manager.tools`, `BaseTool.function`, `BaseTool.example_call`, `task.tool_outputs`, `task.tool_calls`; Tool.parse(), validate(), execute().
- **Typo fixes already applied in Task code:** GLib.IOError.INVAL → INVALID_ARGUMENT; response.content → response.message.content.

---

## 5. Runner API (task definition, env, project_manager, current_file, reference_content)

- **Do this work in 1.23.14**, not here. 1.23.16 §4 (add Task to meson) depends on that work.
- **In 1.23.14:** Add to Runner: **get_definition(string)**, **env()**, **project_manager**, **current_file**, **reference_content(string href)**; use **task-resolved definition** (no task_definition map, no populate_task_definitions; Details gets definition via runner.get_definition(skill_name) from task_data "Skill"). Update prepare_tasks to remove populate_task_definitions(); update Details to use get_definition(skill_name). All code and href list live in **1.23.14** Runner section.

---

## 6. Block.contents() — section content (default: exclude sub-headings) — DONE

- **Done:** Block.contents(bool with_sub_headings) in libocmarkdown/document/Block.vala; document().children + index_of; early continue for non-Block / non-heading; combined break condition.
- **Design (1.23.13):** **Block.contents()** on the section heading returns content nodes. **Default:** do not include sub-headings (stop at next heading of any level). **Option** `with_sub_headings = true`: stop at next heading with level ≤ this.level. Use **document().children** and **index_of**.

---

## 7. Block.links() — collect link nodes among block’s direct children — DONE

- **Done:** Block.links() in libocmarkdown/document/Block.vala (direct children only). Details.reference_targets is `Gee.ArrayList<Markdown.Document.Format>`; fill_task_data() assigns from `this.task_data.get("References").links()`. Task.Link removed; Format used for href/title everywhere.
- **Design:** Links are **Format** with **kind == FormatType.LINK** (href, title). Block.links() loops this block’s direct children; no recursion.

---

## 8. Task.Tool: access to chat_call — DONE

- **Done:** Tool.vala execute() uses `this.task.chat()` and `tool_impl.execute(this.task.chat(), this.tool_call)` (no chat_call).

---

## 9. Details.wait_refined() async wait — DONE

- **Done:** Option C (resume_refined callback): private `resume_refined` field; wait_refined() sets callback and yields; refine() calls resume_refined() when refined_done = true.

---

## References

- 1.23.15 (task refinements — §5 Prerequisites, §4 Build/meson)
- 1.23.13 (task-related code, DONE)
- [Ollama tool calling](https://docs.ollama.com/capabilities/tool-calling)
