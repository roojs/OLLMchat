# 1.2.6.2. Update Session to Use Agent Instead of Direct Chat Access

## Overview

Refactor message flow to go through Manager: UI creates Message objects and calls `manager.send(fid, message)`, which routes to `session.send(message)`. Session adds the Message to session history, and if message.role == "user", delegates to AgentHandler. AgentHandler builds the full message history from session data and sends it to Chat. Remove `this.chat` from SessionBase (it was a temporary solution). Session should only manage message history, and Chat should be created per request by AgentHandler. Also update Chat's `send()` method to take messages array as argument and reset everything when called.

**Parent Plan**: [1.2.6. Update Legacy Methods](./1.2.6-update-legacy-methods.md)

**Prerequisite**: [1.2.6.1. Update Client Method Signatures](./1.2.6.1-update-client-method-signatures.md) must be complete

## Status

✅ **COMPLETE** - All phases implemented and cleanup completed.

## Goal

1. Add `Manager.send(fid, message)` as the entry point for UI to send messages (message is a Message object)
2. Add `Session.agent` property (AgentHandler?) - Session has reference to AgentHandler, not retrieved from manager
3. Update `Session.send(message)` to add Message to history and delegate to `this.agent.send_async()` if `message.role == "user"`
4. Update `AgentHandler.send_async(message, cancellable)` method to:
   - Build system prompt at this point in time (simple implementation in base, CodeAssistantHandler overrides)
   - Filter messages from `session.messages` to get API-compatible messages (system, user, assistant, tool)
   - Exclude non-API message types (user-sent, ui, etc.) - these are for UI/persistence only
   - Build full message array and send to Chat using `chat.send(messages, cancellable)`
5. Handle AgentHandler changes - when user changes AgentHandler, copy chat/messages from old AgentHandler to new AgentHandler
6. Update Chat's `send()` method to take messages array as argument and reset state
7. Remove `this.chat` from `SessionBase` - Session should only manage message history
8. Refactor all code that uses `session.chat` - Chat is created per request by AgentHandler, not stored on Session

## Implementation Steps

### Phase 1: Add Chat.send() Method (Add New, Keep Old Working) ✅
1. ✅ Add new `send()` method with signature: `send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null)`
2. ✅ Implement `send()` with its own complete implementation (duplicate logic from `exec_chat()`, do NOT call `exec_chat()`)
3. ✅ Add state reset logic in `send()` (reset `streaming_response`, set `cancellable`, etc.)
4. ✅ Keep `exec_chat()` working as-is (no breaking changes, independent implementation)
5. ✅ **Do NOT update call sites yet** - that happens in later phases

### Phase 2: Move `fid` Ownership from Chat to Session (Add New, Keep Old Working) ✅
1. ✅ Add `fid` property to `SessionBase` with `public get, protected set` (no backing storage)
2. ✅ Generate `fid` in `Session` constructor from timestamp
3. ✅ Keep `Chat.fid` working - have it delegate to `chat.agent.session.fid` when agent is set, fallback to generated value
4. ✅ Update `Session.fid` getter to return `this.fid` instead of `this.chat.fid` (if chat exists, copy fid from chat first time)
5. ✅ Update code that can use `session.fid` to prefer it over `chat.fid`
6. ✅ **Do NOT remove Chat.fid yet** - that happens in cleanup phase

### Phase 3: Add Manager.send() and Update Session.send() (Add New, Keep Old Working) ✅
1. ✅ Add `Manager.send(fid, message)` method (message is a Message object) - new entry point
2. ✅ Add `Session.agent` property (AgentHandler?) - set when session is created or AgentHandler is changed
3. ✅ Add new `Session.send(message)` method alongside existing `Session.send_message()` - keep both working
4. ✅ New `Session.send(message)` adds Message to session history and delegates to `this.agent.send_async()` if `message.role == "user"`
5. ✅ Add new `AgentHandler.send_async(message, cancellable)` method (or rename existing `send_message_async`) to:
   - Build system prompt at this point in time (simple implementation in base, CodeAssistantHandler overrides)
   - Filter messages from `session.messages` to get API-compatible messages (system, user, assistant, tool)
   - Exclude non-API message types (user-sent, ui, etc.)
   - Use `chat.send(messages, cancellable)` with filtered message array
6. ✅ Handle agent changes - when user changes agent, copy chat/messages from old AgentHandler to new AgentHandler
7. ✅ **Keep old `Session.send_message()` and `AgentHandler.send_message_async()` working** - UI can use either
8. ✅ **Do NOT update UI code yet** - that happens in Phase 5

### Phase 4: Prepare for Removing `this.chat` from SessionBase (Add Alternatives, Keep Old Working) ✅
1. ✅ Add alternative access patterns for Chat (e.g., `session.get_chat()` or access via `message.message_interface`)
2. ✅ Update `Session.on_message_created()` to work with both `this.chat` and alternative patterns
3. ✅ Update `Session.on_stream_chunk()` to work with both `this.chat` and alternative patterns (get Chat from message or AgentHandler)
4. ✅ Update `SessionPlaceholder` and `EmptySession` to support both patterns (they use `this.chat` which is compatible with `get_chat()`)
5. ✅ Update `SessionBase.permission_provider` setter to work with both `this.chat` and alternatives
6. ✅ **Keep `this.chat` property working** - code can use either pattern
7. ✅ **Do NOT remove `this.chat` yet** - that happens in cleanup phase

### Phase 5: Update UI Access Pattern (Gradual Migration) ✅
1. ✅ Update UI code to create Message objects and call `manager.send(session, message)` - new preferred method
2. ✅ Keep old UI code paths working (e.g., `session.send_message()`) for backward compatibility
3. ✅ Update UI code that accesses `session.chat` to use alternative access patterns where possible
4. ✅ Update signal connection from `add_message` to `message_added` in ChatWidget
5. ✅ **Do NOT remove old UI code yet** - that happens in cleanup phase

### Phase 6: Cleanup - Remove Old Methods and Properties ✅
1. ✅ **Remove `exec_chat()` method** - Update any remaining call sites to use `send()` instead, then remove method
2. ✅ **Remove `Chat.fid` field** - Update any remaining code that uses `chat.fid` to use `chat.agent.session.fid` or `session.fid`, then remove field
3. ✅ **Remove `SessionBase.chat` property** - Update any remaining code that uses `session.chat`, then remove property
4. ✅ **Remove old `Session.send_message()` method** - Update any remaining call sites to use `Session.send()`, then remove method
5. ✅ **Remove old `AgentHandler.send_message_async()` method** - Update any remaining call sites to use `AgentHandler.send_async()`, then remove method
6. ✅ **Remove `Manager.add_message()` signal and migrate to `message_added` everywhere** - This is the old implementation. New code uses `message_added` signal instead. 
   - ✅ Remove `add_message` signal from `Manager.vala`
   - ✅ Update `Session.on_message_created()` to use `manager.message_added()` instead of `manager.add_message()`
   - ✅ Update `SessionBase.add_message()` method to use `manager.message_added()` instead of `manager.add_message()`
   - ✅ Update any UI code that connects to `manager.add_message` to connect to `manager.message_added` instead
   - ✅ Remove `SessionBase.add_message()` method if no longer needed, or update it to use `message_added`
   - ✅ Ensure all message notification uses `message_added` signal (new flow) instead of `add_message` (old flow)
7. ✅ **Remove old UI code paths** - Remove UI code that uses deprecated methods
8. ✅ Update documentation/comments that reference removed methods (minor references remain in comments/docs only, not in code)

## Architectural Changes

### 1. Remove `this.chat` from SessionBase

**Current State**:
- `SessionBase` has `public Call.Chat? chat { get; set; }` (line 32 in `SessionBase.vala`)
- `SessionBase` constructor creates `this.chat` (line 157)
- Session uses `this.chat` for various operations (fid, reply, cancellation, etc.)

**New State**:
- Remove `this.chat` property from `SessionBase`
- Session should only have access to AgentHandler (via `session.agent` property)
- Users can get chat from AgentHandler: `agent_handler.get_chat()` or similar method (if needed)
- **Note**: AgentHandler creates Chat objects per request, so there may not be a persistent Chat on Session. Need to determine how UI accesses Chat for display.

**Impact**:
- `Session.fid` currently returns `this.chat.fid` (line 54) - **Change**: `fid` should be owned by Session, not Chat
- `Session.send()` uses `this.chat` for reply() and cancellation - needs refactoring
- UI accesses `session.chat` - needs alternative access pattern
- `SessionPlaceholder` and `EmptySession` create/use `this.chat` - needs refactoring

### 1.1. Move `fid` Ownership from Chat to Session

**Current State**:
- `Chat` has `public string fid = ""` field (line 100 in `Chat.vala`)
- `Chat` constructor generates `fid` from timestamp (line 113)
- `Session.fid` is computed property that returns `this.chat.fid` (line 54 in `Session.vala`)
- `Session.on_message_created()` copies `fid` from new chat: `this.chat.fid = new_chat.fid` (line 115)

**Rationale**:
- `fid` (file ID) is a session identifier, not a chat identifier
- Session is the persistent entity that owns the conversation history
- Chat is a transient request object that should not own session-level data
- This aligns with the principle that Chat should be stateless and reusable

**New State**:
- `fid` should be a property on `SessionBase` with `public get, protected set` (no backing storage needed)
- `Session` constructor should generate `fid` from timestamp
- `Chat.fid` should be **removed completely** - users can access via `chat.agent.session.fid` (where `chat.agent` is AgentHandler)
- Remove `fid` field from `Chat` constructor
- Remove `this.chat.fid = new_chat.fid` assignment in `Session.on_message_created()`

**Implementation**:
```vala
// SessionBase.vala
// File ID: Format Y-m-d-H-i-s (e.g., "2025-01-15-14-30-45")
// Owned by Session, not Chat
public abstract string fid { get; protected set; }

// Session.vala
public Session(Manager manager, Call.Chat chat)
{
    // ... existing code ...
    // Generate fid from current timestamp (format: YYYY-MM-DD-HH-MM-SS)
    var now = new DateTime.now_local();
    this.fid = now.format("%Y-%m-%d-%H-%M-%S");
    // ... rest of constructor ...
}

// Chat.vala
// Note: fid is removed completely from Chat
// Users can access via: chat.agent.session.fid

public Chat(Settings.Connection connection, string model, Call.Options? options = null)
{
    // ... existing code ...
    // Note: fid is no longer generated here - it's owned by Session
    // ... rest of constructor ...
}
```

### 2. Update Chat's `send()` Method

**Current State**:
- `Chat.exec_chat()` uses `this.messages` array (line 447)
- Messages array must be prepared before calling `exec_chat()`

**New State**:
- `send()` should take messages array as argument: `public async Response.Chat send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null)`
- `send()` should reset all state when called:
  - Clear/reset `streaming_response`
  - Clear/reset any internal state
  - Use the provided messages array instead of `this.messages`

**Benefits**:
- Makes Chat more stateless and reusable
- Each call is independent
- No need to clear messages array before calling
- Clearer API - messages are passed explicitly

## Flow Context

**Proposed New Flow**:
```
UI → Manager.send(fid, message) 
  → Session.send(message)
    → Session adds Message to session history
    → If message.role == "user": Session passes to AgentHandler
      → AgentHandler builds full message history from Session.messages
      → AgentHandler creates Chat and calls chat.send(messages, cancellable)
```

**Manager.send() Signature**:
```vala
public async void send(string fid, Message message, GLib.Cancellable? cancellable = null) throws Error
```

**Session.send() Signature**:
```vala
public async void send(Message message, GLib.Cancellable? cancellable = null) throws Error
```

**Flow Details**:
1. **UI calls `manager.send(fid, message, cancellable)`**
   ```vala
   var user_msg = new Message(null, "user", "Hello!");
   yield manager.send("2025-01-15-14-30-45", user_msg, cancellable);
   ```
   - `fid` (string): Session identifier, e.g., "2025-01-15-14-30-45"
   - `message` (Message): Message object with type and content, e.g., `new Message(null, "user", "Hello!")`
   - `cancellable` (GLib.Cancellable?): Optional cancellation token
   - Manager finds session by `fid` and calls `session.send(message, cancellable)`

2. **Session.send(message, cancellable) adds Message to history**
   ```vala
   public async void send(Message message, GLib.Cancellable? cancellable = null) throws Error
   {
       // Add to session history
       this.messages.add(message);  // Add to session.messages array
       this.manager.message_added(message, this);  // Emit signal to notify UI (new flow)
   }
   ```
   - Receives `Message` object (already created by UI)
   - Adds `message` to `session.messages` array
   - Emits `manager.message_added(message, this)` signal to notify UI
   - UI receives signal immediately and can display the user message

3. **If message.role == "user", Session passes to AgentHandler**
   ```vala
   if (message.role == "user") {
       // Session has reference to agent (AgentHandler)
       if (this.agent != null) {
           yield this.agent.send_async(this, message, cancellable);
       } else {
           throw new OllamaError.INVALID_ARGUMENT("No agent available for session");
       }
   }
   ```
   - Session has `agent` property (AgentHandler) - set when session is created or when AgentHandler is changed
   - If user changes AgentHandler, need to copy chat/messages from old AgentHandler to new AgentHandler
   - Calls `this.agent.send_async(message, cancellable)`:
     - `message` (Message): The user message that was just added to session
     - `cancellable` (GLib.Cancellable?): Cancellation token
     - AgentHandler uses `this.session` (set in constructor) to access session.messages

4. **AgentHandler.send_async(message, cancellable) builds full message history**
   ```vala
   // AgentHandler.vala
   public async void send_async(Message message, GLib.Cancellable? cancellable = null) throws Error
   {
       var messages = new Gee.ArrayList<Message>();
       
       // Build system prompt at this point in time
       // CodeAssistant does this, BasicAgent does nothing
       string system_content = this.agent.generate_system_prompt();
       if (system_content != "") {
           messages.add(new Message(null, "system", system_content));
       }
       
       // Filter and add messages from this.session.messages (full conversation history)
       // Note: The user message was already added to session.messages in step 2
       // AgentHandler filters messages to get API-compatible messages (system, user, assistant, tool)
       // Filters out: "user-sent", "ui", and other non-API message types
       foreach (var msg in this.session.messages) {
           // Filter: only include API-compatible message roles
           if (msg.role == "system" || msg.role == "user" || msg.role == "assistant" || msg.role == "tool") {
               messages.add(msg);
           }
           // Skip: "user-sent", "ui", etc. (these are for UI/persistence only)
       }
       
       // Create Chat for this request
	   // add fixme that this should not be using client and needs to be fixed
       var chat = new Call.Chat(this.session.client.connection, this.session.model) {
           cancellable = cancellable,
           stream = true,
           think = true,
           options = this.get_options_for_model(this.session.model)
       };
       
       // Send full message array
       var response = yield chat.send(messages, cancellable);
   }
   ```
   - Receives `message` (the user message that was just added to session)
   - Uses `this.session` (set in AgentHandler constructor) to access session.messages
   - **System prompt generation**: AgentHandler builds system prompt at this point in time
     - **BaseAgentHandler**: Simple implementation - calls `agent.generate_system_prompt()`
     - **CodeAssistantHandler**: Overrides to build complex system prompt with current context (regenerated each call)
   - **Message filtering**: AgentHandler filters `session.messages` to get API-compatible messages
     - **Includes**: "system", "user", "assistant", "tool" roles
     - **Excludes**: "user-sent", "ui", and other non-API message types (these are for UI/persistence only)
   - Prepares complete message array: system messages + filtered `session.messages`
   - Creates new `Call.Chat` object for this request (not stored on session)
   - Calls `chat.send(messages, cancellable)` with full message array
   
   **Note**: This logic is already in AgentHandler (see `libollmchat/Prompt/AgentHandler.vala`), but needs to be updated to:
   - Filter messages from `session.messages` instead of building messages differently
   - Build system prompt at this point (simple implementation in base, CodeAssistantHandler overrides)
   - Use the new `chat.send(messages, cancellable)` signature

5. **Chat.send(messages, cancellable) executes the request**
   ```vala
   public async Response.Chat send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null) throws Error
   {
       // Reset state
       this.streaming_response = null;
       this.cancellable = cancellable;
       
       // Send request with provided messages array
       // Streams response back via callbacks/streaming handlers
   }
   ```
   - Sends full message array to API
   - Streams response back to AgentHandler via streaming callbacks/handlers
   - AgentHandler receives chunks via streaming handlers (not shown in signature, but handled internally)

6. **AgentHandler processes streaming response and adds assistant message**
   ```vala
   // Inside AgentHandler.send_async(), after chat.send() returns or during streaming:
   // AgentHandler receives streaming chunks and builds assistant message
   var assistant_msg = new Message(null, "assistant", response_content);
   yield session.send(assistant_msg);
   ```
   - AgentHandler receives streaming response from Chat (via callbacks/handlers)
   - AgentHandler creates assistant `Message` object from response content
   - AgentHandler calls `session.send(assistant_message)`:
     - `assistant_message` (Message): The assistant's response message
   - `session.send()`:
     - Adds `assistant_message` to `session.messages` array
     - Emits `manager.message_added(assistant_message, session)` signal
   - UI receives signal and displays the assistant message

**Current Architecture (Temporary)**:
- `SessionBase` has `this.chat` created in constructor
- Session uses `this.chat` for operations
- UI accesses `session.chat` for display

**New Architecture (Target)**:
- `SessionBase` does NOT have `this.chat`
- Session manages message history (`session.messages`)
- Manager routes messages via `manager.send(fid, message)` where message is a Message object
- Session adds messages to history
- AgentHandler builds full history and sends to Chat
- Chat is created per request by AgentHandler, not stored on Session

**How Messages Flow Through the System**:
1. **UI → Manager**: UI creates `Message` object, calls `manager.send(fid, message)`
2. **Manager → Session**: Finds session by `fid`, calls `session.send(message)`
3. **Session adds Message**: Calls `session.send(message)` which adds to `session.messages` and emits `message_added` signal
4. **Session → AgentHandler**: If `message.role == "user"`, calls `agent_handler.send_async(message, cancellable)`
5. **AgentHandler builds history**: Reads `session.messages`, prepares full message array
6. **AgentHandler → Chat**: Creates `Call.Chat`, calls `chat.send(messages, cancellable)`
7. **Chat → API**: Sends request, streams response back to AgentHandler
8. **AgentHandler processes response**: Receives streaming response, creates assistant Message objects
9. **AgentHandler → Session**: Sees it's an assistant message, calls `session.send(assistant_message)`
10. **Session → Manager**: `send()` emits `manager.message_added(message, session)` signal
11. **Manager → UI**: UI receives signal and displays message

**Session.send()** (line 299):
- Method that adds message to `session.messages` array
- Emits `manager.message_added(message, this)` signal to notify UI
- UI receives `SessionBase` so it can access `session.client` and session properties

**Manager.message_added()** signal (line 93 in `Manager.vala`):
- Signal emitted when a message is added to a session
- Emitted with `(Message, SessionBase?)` parameters
- UI connects to this signal to display messages
- Messages carry all necessary information for display
- Session can be accessed via `session.fid` to identify which session the message belongs to

## Current Implementation

### SessionBase.chat Property

**File**: `libollmchat/History/SessionBase.vala` (line 32)

```vala
public Call.Chat? chat { get; set; }
```

**Created in constructor** (line 157):
```vala
this.chat = new Call.Chat(this.client.connection, model) {
    stream = true,
    think = false
};
```

**Used in**:
- `Session.fid` getter (line 54): `return this.chat.fid;` - **Will change**: `fid` owned by Session, not Chat
- `Session.send()` (line 425, 429, 434, 469): Uses `this.chat` for stream, reply, cancellation
- `Session.on_message_created()` (line 108-115): Updates `this.chat` properties from new chat (including `this.chat.fid = new_chat.fid` which will be removed)
- `Session.on_stream_chunk()` (line 172, 184, 203, 208): Creates Messages with `this.chat`
- `SessionPlaceholder.load()` (line 69, 79, 106, 120, 129): Uses `this.chat`
- `EmptySession.send()` (line 36, 76): Uses `this.chat`
- `SessionBase.permission_provider` setter (line 50): Sets on `this.chat`

### Chat.send() Method

**File**: `libollmchat/Call/Chat.vala` (line 444)

**Current**:
```vala
public async Response.Chat exec_chat() throws Error
{
    // Agent/handler must prepare the messages array before calling exec_chat()
    if (this.messages.size == 0) {
        throw new OllamaError.INVALID_ARGUMENT("Chat messages array is empty...");
    }
    // ... uses this.messages
}
```

**Problem**: Uses `this.messages` array, requires preparation before calling.

## Proposed Changes

### 1. Add Manager.send() Method

**New Method**:
```vala
// Manager.vala
// HashMap for fast fid lookup (fid -> SessionBase)
private Gee.HashMap<string, SessionBase> sessions_by_fid = new Gee.HashMap<string, SessionBase>();

public async void send(string fid, Message message, GLib.Cancellable? cancellable = null) throws Error
{
    // Find session by fid using HashMap lookup
    var session = this.sessions_by_fid.get(fid);
    if (session == null) {
        throw new OllamaError.INVALID_ARGUMENT("Session with fid '%s' not found", fid);
    }
    
    // Delegate to session
    yield session.send(message, cancellable);
}
```

**Note**: Manager should maintain `sessions_by_fid` HashMap:
- Add to HashMap when session is created: `sessions_by_fid.set(session.fid, session)`
- Remove from HashMap when session is removed: `sessions_by_fid.unset(session.fid)`
- Update HashMap when session.fid changes (if that's allowed)

### 2. Add New Session.send() Method (Alongside Existing send_message())

**New Method Signature** (added in Phase 3, old method kept working):
```vala
// SessionBase.vala
public abstract async void send(Message message, GLib.Cancellable? cancellable = null) throws Error;
```

**Session.send() Implementation** (new method, old `send_message()` still works):
```vala
// Session.vala
public async void send(Message message, GLib.Cancellable? cancellable = null) throws Error
{
    // Add to session history
    this.messages.add(message);
    
    // Emit signal to notify UI
    this.manager.message_added(message, this);
    
    // If user message, pass to AgentHandler
    if (message.role == "user") {
        // Session has reference to AgentHandler
        if (this.agent != null) {
            yield this.agent.send_async(message, cancellable);
        } else {
            throw new OllamaError.INVALID_ARGUMENT("No agent available for session");
        }
    }
}
```

**Note**: Old `Session.send_message(string text, ...)` method is kept for backward compatibility. Both methods work during migration period.

**Session.agent Property**:
```vala
// SessionBase.vala
public AgentHandler? agent { get; set; }
```

**AgentHandler Change Handling**:
- When user changes AgentHandler, need to copy chat/messages from old AgentHandler to new AgentHandler
- Session maintains reference to current AgentHandler
- AgentHandler is set when session is created or when user changes AgentHandler
- AgentHandler is created from BaseAgent (via `BaseAgent.create_handler(client, session)`)

### 3. Add New AgentHandler.send_async() Method (Alongside Existing send_message_async())

**New Method Signature** (added in Phase 3, old method kept working):
```vala
// AgentHandler.vala
public async void send_async(Message message, GLib.Cancellable? cancellable = null) throws Error
{
    // Build full message history from this.session
    var messages = new Gee.ArrayList<Message>();
    
    // Build system prompt at this point in time
    // BaseAgentHandler: Simple implementation - just calls agent.generate_system_prompt()
    // CodeAssistantHandler: Overrides to build complex system prompt with current context
    string system_content = this.agent.generate_system_prompt();
    if (system_content != "") {
        messages.add(new Message(null, "system", system_content));
    }
    
    // Filter and add messages from this.session.messages (full conversation history)
    // Filter to get API-compatible messages (system, user, assistant, tool)
    // Exclude non-API message types (user-sent, ui, etc.)
    foreach (var msg in this.session.messages) {
        if (msg.role == "system" || msg.role == "user" || msg.role == "assistant" || msg.role == "tool") {
            messages.add(msg);
        }
    }
    
    // Create Chat for this request
    var chat = new Call.Chat(this.session.client.connection, this.session.model) {
        cancellable = cancellable,
        stream = true,
        think = true,
        options = this.get_options_for_model(this.session.model)
    };
    
    // Send full message array using new send() method
    var response = yield chat.send(messages, cancellable);
    
    // Process response and add assistant messages to session via session.send()
    // ...
}
```

**Note**: Old `AgentHandler.send_message_async(string user_input, ...)` method is kept for backward compatibility. Both methods work during migration period. Old method is removed in Phase 6 cleanup.

### 4. Prepare for Removing `this.chat` from SessionBase (Phased Approach)

**Phase 2: Move `fid` ownership from Chat to Session** (add new, keep old working):
1. Add `fid` property to `SessionBase` with `public get, protected set` (no backing storage)
2. Generate `fid` in `Session` constructor from timestamp
3. Keep `Chat.fid` working - have it delegate to `chat.agent.session.fid` when agent is set
4. Update `Session.fid` getter to return `this.fid` instead of `this.chat.fid`
5. **Do NOT remove Chat.fid yet** - that happens in Phase 6 cleanup

**Phase 4: Prepare alternatives for `this.chat`** (add new, keep old working):
1. Add alternative access patterns for Chat (e.g., `session.get_chat()` or access via `message.message_interface`)
2. Update code to support both `this.chat` and alternative patterns
3. **Keep `this.chat` property working** - code can use either pattern
4. **Do NOT remove `this.chat` yet** - that happens in Phase 6 cleanup

**Phase 6: Cleanup - Remove old properties**:
1. Remove `Chat.fid` field after all code migrated
2. Remove `SessionBase.chat` property after all code migrated
3. Remove Chat creation from `SessionBase` constructor

**Alternative Access Patterns**:
- **For fid**: Store `fid` directly on SessionBase as a property with `public get, protected set`. `Chat.fid` is removed - users access via `chat.agent.session.fid` (where `chat.agent` is AgentHandler)
- **For reply()**: Create new Chat or get from AgentHandler
- **For cancellation**: Track cancellable separately or via AgentHandler
- **For Messages**: Messages have `message_interface` which can be Chat
- **For UI**: Access Chat via `message.message_interface` or via AgentHandler

### 2. Update Chat.send() Method

**New Signature**:
```vala
public async Response.Chat send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null) throws Error
```

**Behavior**:
- Takes messages array as argument (instead of using `this.messages`)
- Resets all state when called:
  - `this.streaming_response = null`
  - Clear any internal state
  - Use provided messages array (don't modify `this.messages`)
- Returns Response.Chat

**Implementation (Phase 1 - Add New Method, Keep Old Working)**:
```vala
public async Response.Chat send(Gee.ArrayList<Message> messages, GLib.Cancellable? cancellable = null) throws Error
{
    if (messages.size == 0) {
        throw new OllamaError.INVALID_ARGUMENT("Chat messages array is empty. Provide messages to send.");
    }
    
    // Reset state
    this.streaming_response = null;
    this.cancellable = cancellable;
    
    // Store provided messages in this.messages (for serialization/access)
    this.messages = messages;
    
    // Debug: output messages being sent
    GLib.debug("Chat.send: Sending %d message(s):", this.messages.size);
    for (int i = 0; i < this.messages.size; i++) {
        var msg = this.messages[i];
        GLib.debug("  Message %d: role='%s', content='%s'%s", 
            i + 1, 
            msg.role, 
            msg.content,
            msg.thinking != "" ? @", thinking='$(msg.thinking)'" : "");
    }
    
    // Execute with streaming or non-streaming (duplicate logic from exec_chat, do NOT call exec_chat)
    if (this.stream) {
        return yield this.execute_streaming();
    }
    
    return yield this.execute_non_streaming();
}
```

**Note**: In Phase 1, we add `send()` with its own complete implementation (duplicated from `exec_chat()`). The new `send()` method does NOT call `exec_chat()` - it has independent logic. This keeps both methods working independently and makes it easier to remove `exec_chat()` later.

**Later phases will migrate call sites**:
- Phase 3: `AgentHandler.send_async()` will use `chat.send(messages, cancellable)` 
- Phase 3: `CodeAssistantHandler.send_async()` will use `chat.send(messages, cancellable)`
- Phase 6: Remove `exec_chat()` after all call sites are migrated

## Test

1. Verify Session still works for first message
2. Verify reply() still works for subsequent messages
3. Verify UI can still access Chat for display
4. Verify cancellation still works
5. Verify fid is still accessible

## Result (After All Phases Complete)

- `fid` is owned by Session (via SessionBase property with `public get, protected set`) - `Chat.fid` removed in Phase 6
- UI creates Message objects and calls `manager.send(fid, message)` to send messages (migrated in Phase 5)
- `Session.send(message)` adds Message to history, delegates to AgentHandler if `message.role == "user"` (added in Phase 3, old `send_message()` removed in Phase 6)
- `AgentHandler.send_async()` builds full message history from `this.session.messages` and sends to Chat (added in Phase 3, old `send_message_async()` removed in Phase 6)
- Chat's `send()` method takes messages array and resets state (added in Phase 1, `exec_chat()` removed in Phase 6)
- Session no longer has `this.chat` - only manages message history (`session.messages`) (removed in Phase 6)
- Chat is created per request by AgentHandler, not stored on Session (migration completed in Phase 3-4)

## Files to Modify (By Phase)

### Phase 1: Add Chat.send() Method
- `libollmchat/Call/Chat.vala` - **Add** new `send(messages, cancellable)` method with its own complete implementation (duplicate logic from `exec_chat()`, do NOT call `exec_chat()`); **Keep** `exec_chat()` working independently

### Phase 2: Move fid Ownership
- `libollmchat/History/SessionBase.vala` - **Add** `fid` property with `public get, protected set`
- `libollmchat/History/Session.vala` - **Add** `fid` generation in constructor; **Update** `fid` getter to use `this.fid`
- `libollmchat/Call/Chat.vala` - **Update** `fid` to delegate to `chat.agent.session.fid` when available; **Keep** `fid` field working

### Phase 3: Add Manager.send() and Session.send()
- `libollmchat/History/Manager.vala` - **Add** `send(fid, message)` method; **Add** `sessions_by_fid` HashMap; **Add** `message_added` signal (new flow, explicit); Maintain HashMap when sessions are created/removed
- `libollmchat/History/SessionBase.vala` - **Add** `agent` property (AgentHandler?); **Add** abstract `send(message)` method
- `libollmchat/History/Session.vala` - **Add** `send(message)` implementation that emits `manager.message_added()` signal (new flow, explicit); Set `agent` property; **Keep** old `send_message()` working
- `libollmchat/Prompt/AgentHandler.vala` - **Add** `send_async(message, cancellable)` method; **Keep** old `send_message_async()` working
- `liboccoder/Prompt/CodeAssistantHandler.vala` - **Add** `send_async()` override; **Keep** old `send_message_async()` working

### Phase 4: Prepare for Removing this.chat
- `libollmchat/History/SessionBase.vala` - **Add** alternative access patterns for Chat; **Keep** `this.chat` working
- `libollmchat/History/Session.vala` - **Update** to support both `this.chat` and alternatives
- `libollmchat/History/SessionPlaceholder.vala` - **Update** to support both patterns
- `libollmchat/History/EmptySession.vala` - **Update** to support both patterns

### Phase 5: Update UI Access Pattern
- UI files (e.g., `ChatWidget.vala`) - **Update** to use `manager.send(fid, message)`; **Keep** old code paths working during migration

### Phase 6: Cleanup - Remove Old Methods
- `libollmchat/Call/Chat.vala` - **Remove** `exec_chat()` method; **Remove** `fid` field
- `libollmchat/History/SessionBase.vala` - **Remove** `this.chat` property and creation
- `libollmchat/History/Session.vala` - **Remove** old `send_message()` method; **Remove** `this.chat` usage
- `libollmchat/Prompt/AgentHandler.vala` - **Remove** old `send_message_async()` method
- `liboccoder/Prompt/CodeAssistantHandler.vala` - **Remove** old `send_message_async()` method
- `libollmchat/Client.vala` - **Update** to use `chat.send(messages, cancellable)` instead of `exec_chat()`
- UI files - **Remove** old code paths that use deprecated methods

## Related Plans

- [1.2.6.1. Update Client Method Signatures](./1.2.6.1-update-client-method-signatures.md) - Prerequisite
- [1.2.7. Move Signals to Chat](./1.2.7-move-signals-to-chat.md) - Related plan for signal architecture
- [1.10. Refactor Agents as Interface](./1.10-refactor-agents-interface.md) - Documents the planned UI → Manager → Agent → Chat flow
