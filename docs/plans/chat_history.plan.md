# Chat History System Plan

This document outlines the plan for implementing a comprehensive chat history system for OLLMchat, including persistent storage, browsing, restoration, and advanced features like chat rewinding and multiple chat sessions.

**üìã Future Enhancements (Not for Initial Implementation)**:
- Full client_config support: Load and restore full client configuration (api_key, keep_alive, etc.) from config system using URL as identifier

## Overview

The chat history system will:
- Save all chat conversations to disk in a structured format
- Provide a summary index for quick browsing
- Use LLM to generate meaningful titles for conversations
- Enable browsing and restoring old conversations
- Support advanced features like hidden messages and chat rewinding
- Support multiple concurrent chat sessions
- Transform the test-window into a proper `ollmchat` application with about dialog and polished UI

## Directory Structure

### Storage Locations

```
~/.local/share/ollmchat/
‚îî‚îÄ‚îÄ history/
    ‚îú‚îÄ‚îÄ 2025/
    ‚îÇ   ‚îî‚îÄ‚îÄ 01/
    ‚îÇ       ‚îî‚îÄ‚îÄ 15/
    ‚îÇ           ‚îú‚îÄ‚îÄ 14-30-45.json    # Individual chat session files
    ‚îÇ           ‚îî‚îÄ‚îÄ 15-22-10.json
    ‚îî‚îÄ‚îÄ ...
```

**Note**: Summary index is stored in SQLite database using `SQ/Database.vala` instead of `history.json`.

### File Format

#### Individual Chat File (`history/{YYYY}/{mm}/{dd}/{h-i-s}.json`)

Each chat session is saved as a JSON file with the following structure:

```json
{
  "id": "2025-01-15-14-30-45",
  "updated_at": "2025-01-15 15:22:10",
  "title": "System log analysis and kernel version check",
  "model": "llama3.2:latest",
  "child_chats": ["2025/01/15/15-00-12", "2025/01/15/15-30-45"],
  "messages": [
    {
      "role": "user",
      "content": "Please read the first few lines of /var/log/syslog...",
      "thinking": "",
      "timestamp": "2025-01-15 14:30:45",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "I'll read the syslog file for you...",
      "thinking": "",
      "timestamp": "2025-01-15 14:30:52",
      "hidden": false,
      "tool_calls": [...]
    }
  ],
  "total_messages": 4,
  "total_tokens": 1234,
  "duration_seconds": 45
}
```

**Key Points**:
- `id` is the filename (without extension) - timestamp format `{y-m-d-h-i-s}` (contains creation timestamp)
- File location: `history/{YYYY}/{mm}/{dd}/{h-i-s}.json`
- `updated_at` uses format `Y-m-d H:i:s` (no timezone, not portable)
- `title` is generated by LLM from the first user message (or updated if conversation evolves)
- `child_chats` is an optional array of relative file paths in format `YYYY/mm/dd/h-i-s` (file location relative)
- `messages` array contains all messages in the conversation
- `hidden` flag on messages allows storing messages that weren't sent to the server
- Metadata fields (`total_messages`, `total_tokens`, `duration_seconds`) are flattened directly on the session object

#### Summary Index (SQLite Database)

The summary index is stored in SQLite using `SQ/Database.vala` instead of a JSON file. See `SQ/Database.vala` and `/home/alan/gitlive/roobuilder/src/Palete/SymbolFile.vala` for examples of how to use serializable data with SQLite.

**Key Points**:
- Uses `SQ.Query<Session>` for database operations
- Session objects are stored directly in SQLite (not JSON serializable)
- No version field needed
- Queries can be sorted by `updated_at` (most recent first)

## Implementation Plan

### Phase 1: Core Storage Infrastructure

#### 1.1 Chat History Manager (`History/Manager.vala`)

**Namespace**: `OLLMchat.History`

**Responsibilities**:
- Manage chat session files in `~/.local/share/ollmchat/history/{YYYY}/{mm}/{dd}/`
- Maintain the summary index in SQLite using `SQ/Database.vala`
- Provide methods to save, load, and list chat sessions
- Handle file I/O and JSON serialization/deserialization
- Connect to Client signals to auto-save when chats are created/updated

**Key Methods**:
```vala
public class Manager : Object
{
    public string history_dir { get; private set; }
    public Gee.ArrayList<Session> sessions { get; private set; default = new Gee.ArrayList<Session>(); }
    
    // Register a Client to monitor for chat events
    public void register_client(Client client);
    
    // Save a chat session
    public async string save_chat(Session session) throws Error;
    
    // Load a chat session by ID (path format: YYYY/mm/dd/h-i-s)
    public async Session? load_chat(string id) throws Error;
    
    // Load all chat sessions from SQLite database and store in manager
    public void load_sessions();
    
    // Generate unique ID from current timestamp
    public static string generate_id();
    
    // Generate file path from ID
    public static string id_to_path(string id);
}
```

**File Location**: `OLLMchat/History/Manager.vala` (main library, not under src)

**Integration**:
- `register_client()` connects to Client signals to detect when new chats are created or messages are added
- Auto-saves chat sessions when these events occur
- `load_sessions()` loads all sessions from SQLite database and stores them in the `sessions` property

#### 1.2 Chat Session Data Class

**Session** (`History/Session.vala`):
```vala
namespace OLLMchat.History
{
    /**
     * Session is a wrapper around Call.Chat that provides history persistence.
     * It uses SQ (SQLite) for database storage, not Json.Serializable.
     * 
     * Properties are wrappers around this.chat.client.model, etc.
     * Messages come from this.chat.messages with a flag to include extra info during JSON encoding.
     */
    public class Session : Object
    {
        public int64 id { get; set; default = -1; }
        public Call.Chat chat { get; set; }
        public string updated_at { get; set; default = ""; }  // Format: Y-m-d H:i:s
        public string title { get; set; default = ""; }
        
        // Wrapper properties around chat.client
        public string model {
            get { return this.chat.client.model; }
            set { this.chat.client.model = value; }
        }
        
        // Metadata flattened on session (not separate class)
        public int total_messages { get; set; default = 0; }
        public int64 total_tokens { get; set; default = 0; }
        public int64 duration_seconds { get; set; default = 0; }
        
        // Child chats as array of filename paths (placeholder - not currently used)
        // Format: "YYYY/mm/dd/h-i-s" (relative file path)
        public Gee.ArrayList<string> child_chats { get; set; default = new Gee.ArrayList<string>(); }
        
        // Messages wrapper - uses this.chat.messages
        // Add flag to Message class to include extra info (timestamp, hidden) during JSON encoding
        public Gee.ArrayList<Message> messages {
            get { return this.chat.messages; }
        }
        
        // File path for JSON storage (format: YYYY/mm/dd/h-i-s.json)
        public string file_path { get; set; default = ""; }
        
        /**
         * Write session to JSON file.
         * Uses this.file_path to determine where to write.
         * Serializes the session including messages with history info (timestamp, hidden).
         */
        public async void write() throws Error;
        
        /**
         * Read session from JSON file.
         * Uses this.file_path to determine where to read from.
         * Loads into a temporary Session object using Json.Serializable,
         * copies messages from loaded object to this.chat.messages,
         * then disposes of the temporary object.
         */
        public async void read() throws Error;
        
        /**
         * For JSON serialization: set flag on messages to include extra info.
         * Used internally by write() method.
         */
        private Json.Node to_json() {
            // Set flag on messages for extra info
            // Serialize
            // Unset flag
        }
    }
}
```

**File Location**: `OLLMchat/History/Session.vala` (main library, not under src)

**Key Points**:
- Session is stored in **both SQLite and JSON files**:
  - **SQLite**: Stores metadata (id, updated_at, title, model, total_messages, total_tokens, duration_seconds, file_path) for quick browsing/searching
  - **JSON files**: Store complete session data including all messages and child_chats
- Session is NOT Json.Serializable for SQLite, but uses JSON serialization for file storage
- Session wraps `Call.Chat` - properties are wrappers around `this.chat.client.model`, etc.
- `messages` property returns `this.chat.messages`
- `write()` method serializes session to JSON file with messages including history info (timestamp, hidden)
- `read()` method loads from JSON into temporary object, copies messages to this.chat.messages, then disposes temporary object
- Add a flag to `Message` class to include extra info (timestamp, hidden) when JSON encoding
- Metadata fields (`total_messages`, `total_tokens`, `duration_seconds`) are flattened directly on Session
- `child_chats` is an array of filename paths (format: "YYYY/mm/dd/h-i-s") - placeholder, not currently used
- UIDs should be added to Chat rather than Session (future enhancement)

**Message Flag for Extra Info**:
- Add a property to `Message` class (e.g., `include_history_info`) that controls whether `timestamp` and `hidden` are included during JSON serialization
- Set this flag before serializing, then unset it after

**SQLite Database Schema**:

The Session object is stored in both SQLite (for metadata/summary) and JSON files (for full data including messages). The SQLite table structure:

```sql
CREATE TABLE sessions (
   id INTEGER PRIMARY KEY,
   updated_at TEXT NOT NULL,
   title TEXT NOT NULL DEFAULT '',
   model TEXT NOT NULL DEFAULT '',
   total_messages INTEGER NOT NULL DEFAULT 0,
   total_tokens INT64 NOT NULL DEFAULT 0,
   duration_seconds INT64 NOT NULL DEFAULT 0,
   file_path TEXT NOT NULL  -- Path to JSON file: YYYY/mm/dd/h-i-s.json
);
```

**Note on SQLite Usage**:
- See `/home/alan/gitlive/roobuilder/src/Palete/SymbolFile.vala` for example of how to use SQ with serializable data
- Use `SQ.Query<Session>` for database operations
- Session properties map to SQLite columns automatically via SQ.Query
- Messages and child_chats are stored in JSON files, not in SQLite
- SQLite stores metadata for quick browsing/searching
- JSON files store complete session data including all messages

#### 1.3 Integration with Client

**‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL WARNING ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è**

**üö® THIS SECTION HAS NOT BEEN REVIEWED - DO NOT IMPLEMENT YET üö®**

**This integration section needs review before implementation. All code and design decisions in this section are subject to change.**

---

**History Manager should be tied to Client, not UI**

The History Manager should be integrated with the `Client` class, not the UI layer. This keeps history management separate from UI concerns and allows it to work regardless of which UI (or no UI) is being used.

**Setup Flow**:
1. When a `Client` is set up, create a `History.Manager` instance
2. Register the client with the History Manager using `register_client()`
3. History Manager connects to Client signals to detect chat events

**Client Signals Available**:
- `chat_send` - Emitted when a chat request is sent (needs to be updated to include `Call.Chat` argument)
- `stream_chunk` - Emitted for each streaming chunk (can check `response.done` to detect completion)
- `stream_content` - Emitted for content chunks only
- `stream_start` - Emitted when streaming starts
- `tool_message` - Emitted when tools send status messages

**Required Changes to Client Signal**:
- Update `chat_send` signal to include `Call.Chat` as argument: `public signal void chat_send(Call.Chat chat)`
- This allows History Manager to access the chat object directly

**Session ID Tracking**:
- Add `fid` (session ID) property to `Call.Chat` object to track which session this chat belongs to
- History Manager maintains a `HashMap<string, Session>` mapping `fid => session`
- When a new chat starts, generate a unique `fid` and assign it to the `Call.Chat` object

**Session Registration**:
- When `chat_send` signal is emitted with `Call.Chat` argument, check if `chat.fid` is set
- If `fid` is not set (new chat), generate session ID and assign to `chat.fid`
- Create Session object and store in HashMap: `sessions[chat.fid] = session`
- Write session to both SQLite database and JSON file
- **Note**: When `reply()` is called, it uses the same `Call.Chat` object, so `fid` is already set and preserved automatically

**Response Saving**:
- When a response is complete (not streaming, but toolcalls or done response), save the session
- Need to detect final response completion:
  - Check `response.done == true` in `stream_chunk` handler
  - For tool calls: Only save when it's the final response (after all tool calls are executed)
  - For non-streaming: Response is always done when returned
- Save to both SQLite database and JSON file

**Key Changes to `Call/Chat.vala`**:
```vala
// Add session ID property to track which history session this chat belongs to
// Set in constructor - will always be set
public string fid { get; set; }

public Chat(Client client)
{
    base(client);
    this.url_endpoint = "chat";
    this.http_method = "POST";
    // fid will be set when Session is created
    this.fid = "";
}
```

**Key Changes to `Client.vala`**:
```vala
// Update chat_send signal to include Call.Chat argument
public signal void chat_send(Call.Chat chat);
```

**Key Changes to `Call/Chat.vala`** (update signal emissions):
```vala
// In execute_non_streaming() method (line ~336):
this.client.chat_send(this);  // Pass 'this' (the Call.Chat object)

// In execute_streaming() method (line ~371):
this.client.chat_send(this);  // Pass 'this' (the Call.Chat object)
```

**Key Changes to `History/Manager.vala`**:
```vala
// HashMap to track sessions by fid
private Gee.HashMap<string, Session> sessions_by_fid = new Gee.HashMap<string, Session>();

// Register a Client to monitor for chat events
public void register_client(Client client)
{
    // Connect to chat_send signal to detect new chat sessions
    client.chat_send.connect((chat) => {
        // Create new session with chat and manager
        // Session constructor will generate fid and assign to chat.fid
        var session = new Session(chat, this);
        
        // Store in HashMap
        this.sessions_by_fid.set(chat.fid, session);
        
        // Write initial session to DB and file
        this.save_session_async.begin(session);
    });
    
    // Connect to stream_chunk to detect response completion
    client.stream_chunk.connect((new_text, is_thinking, response) => {
        // Save when response is done (not streaming, but toolcalls or done response)
        if (response.done) {
            // Get session by fid from the chat object
            var session = this.sessions_by_fid.get(response.call.fid);
            // Save session to DB and file
            this.save_session_async.begin(session);
        }
    });
}

// Save session to both DB and file
private async void save_session_async(Session session);
```

**Note on UI Integration**:
- UI integration (restoring chats, browsing history) is separate and will be implemented later
- This section focuses only on automatic history saving via Client signals

### Phase 2: LLM Title Generation

#### 2.1 Title Generator (`History/TitleGenerator.vala`)

**Namespace**: `OLLMchat.History`

**Responsibilities**:
- Generate concise, meaningful titles from chat conversations
- Use the Ollama client to call a lightweight model for title generation
- Cache titles to avoid redundant API calls

**Implementation**:
```vala
namespace OLLMchat.History
{
    public class TitleGenerator : Object
    {
        private Client client;
        
        public async string generate_title(Gee.ArrayList<Message> messages) throws Error;
        
        // Generate title from first user message (quick)
        public async string generate_title_from_preview(string first_message) throws Error;
    }
}
```

**File Location**: `OLLMchat/History/TitleGenerator.vala` (main library, not under src)

**Title Generation Prompt**:
```
Generate a concise title (maximum 8 words) for this chat conversation based on the first user message:

"{first_message}"

Respond with ONLY the title, no explanation or quotes.
```

**Usage**:
- Generate title asynchronously after first message exchange
- Update title if conversation significantly diverges (optional enhancement)
- Store in both session JSON file and SQLite database

### Phase 3: UI Features

#### 3.1 History Browser Widget (`UI/HistoryBrowser.vala`)

**Namespace**: `OLLMchat.UI`

**Responsibilities**:
- Display list of past chat sessions
- Show title, preview, date, and model for each session
- Allow filtering and searching
- Enable selection and restoration of chats

**UI Design**:
- Use `Adw.OverlaySplitView` (libadwaita) for side panel
- List view with search entry at top
- Each item shows:
  - Title (bold)
  - Preview text (truncated)
  - Date/time (relative: "2 hours ago", "Yesterday", etc.)
  - Model name (small, secondary text)

**Key Methods**:
```vala
public class HistoryBrowser : Adw.Bin
{
    public signal void chat_selected(string session_id);
    public signal void chat_deleted(string session_id);
    
    public void refresh_list();
    public void set_search_query(string query);
}
```

#### 3.2 History Overlay Integration

**Modifications to Main Window**:
- Add `Adw.OverlaySplitView` as main container
- Left side: History browser (collapsible)
- Right side: Chat widget
- Toggle button to show/hide history panel

**File**: Transform `TestWindow.vala` ‚Üí `OllmchatWindow.vala` or enhance `TestWindow.vala`

**Structure**:
```vala
public class OllmchatWindow : Adw.ApplicationWindow
{
    private Adw.OverlaySplitView split_view;
    private UI.HistoryBrowser history_browser;
    private UI.ChatWidget chat_widget;
    private Adw.HeaderBar header_bar;
    
    // Toggle history panel
    private void toggle_history();
}
```

#### 3.3 About Dialog

**Add About Dialog** (`UI/AboutDialog.vala`):
```vala
public class AboutDialog : Adw.AboutWindow
{
    public AboutDialog(Gtk.Window parent)
    {
        this.application_icon = "org.roojs.ollmchat";
        this.application_name = "OLLMchat";
        this.version = "1.0.0";
        this.developer_name = "Alan Knowles";
        this.website = "https://github.com/...";
        this.issue_url = "https://github.com/.../issues";
        this.copyright = "¬© 2025 Alan Knowles";
        this.license_type = Gtk.License.LGPL_3_0;
        this.transient_for = parent;
    }
}
```

**Add to Header Bar**:
- Menu button with "About" option
- Or direct "About" button in header bar

### Phase 4: Advanced Features

#### 4.1 Hidden Messages

**Purpose**: Store messages that are not sent to the server but are part of the conversation context (e.g., draft messages, notes, annotations).

**Implementation**:
- Add `hidden` boolean property to `Message` class (already exists in plan)
- Hidden messages are:
  - Serialized in chat history files
  - Not included in API calls to Ollama
  - Displayed in UI with visual distinction (grayed out, italic, or with icon)
  - Can be toggled to visible/hidden state

**UI Indicator**:
- Show hidden messages with reduced opacity or special styling
- Toggle button to show/hide hidden messages in chat view
- Context menu option to mark message as hidden/visible

**Modifications**:
- `Ollama/Message.vala`: Add `hidden` property
- `UI/ChatView.vala`: Render hidden messages with special styling
- `Ollama/Call/ChatCall.vala`: Filter out hidden messages when building API request

#### 4.2 Chat Rewinding

**Purpose**: Allow users to "rewind" a conversation to a previous point, edit messages, and continue from there (creating a new branch/version).

**Concept**:
- User can select a message in the chat
- Click "Rewind to here" action
- All messages after that point are removed from active conversation
- User can edit the selected message or add new messages
- This creates a new chat session (new ID) that branches from the original

**Implementation**:
```vala
// In ChatWidget
public async void rewind_to_message(int message_index) throws Error;
public async void create_branch_from_session(string session_id, int message_index) throws Error;
```

**UI**:
- Context menu on messages: "Rewind to here"
- Confirmation dialog: "This will remove all messages after this point. Continue?"
- After rewinding, show indicator that this is a branched conversation
- Store reference to parent session in metadata

**Session Enhancement for Branching**:
- Add properties to `Session` class:
  - `parent_session_id` (string) - ID of parent session
  - `branch_point` (int) - Message index where branch occurred
  - `is_branch` (bool) - Whether this is a branched conversation
- These are stored as SQLite columns, not in JSON metadata

#### 4.3 Multiple Chat Sessions

**Current State**: Application designed for single chat widget.

**Challenges**:
- `clear/reload` operations affect permissions
- Single `ChatWidget` instance
- Client state management

**Proposed Solution**:
- **Option A**: Single chat widget with session switching
  - When restoring/starting new chat, clear current widget and load new session
  - Simpler implementation
  - One chat at a time
  
- **Option B**: Multiple chat widgets with tabs
  - `Adw.TabView` with multiple `ChatWidget` instances
  - Each tab is a separate chat session
  - More complex but allows true multi-chat
  
- **Option C**: Single widget with session management
  - Dropdown/selector to switch between active sessions
  - Only one visible at a time, but can switch quickly
  - Middle ground

**Recommendation**: Start with **Option A** (session switching), then consider **Option C** if needed.

**Implementation for Option A**:
```vala
// In ChatWidget
public async void start_new_chat();
public async void switch_to_chat(string session_id) throws Error;

// Clear current state
private void clear_chat_state();
```

**Permission Handling**:
- Permissions are tied to the client, not the chat session
- When switching sessions, permissions remain (they're application-level)
- If needed, can store permission state per session in metadata

### Phase 5: Application Transformation

#### 5.1 Rename TestWindow to OllmchatWindow

**File**: `TestWindow.vala` ‚Üí `OllmchatWindow.vala` (or keep name but enhance)

**Changes**:
- Update class name
- Add proper application ID: `org.roojs.ollmchat`
- Add about dialog
- Improve styling and polish
- Set default directory to user's home (already done via `~/.config/ollmchat/`)

#### 5.2 Build Configuration

**Update `meson.build`**:
- Rename `test-window` executable to `ollmchat`
- Update install configuration (optional: install to system)
- Add proper application metadata

**Changes**:
```meson
ollmchat = executable('ollmchat',
  dependencies: test_window_deps,
  sources: ['OllmchatWindow.vala', ollmchat_resources],
  link_with: [ollmchat_base_lib, ollmchat_ui_lib],
  install: true  # Install to system
)
```

#### 5.3 Application Metadata

**Create `.desktop` file** (`data/org.roojs.ollmchat.desktop`):
```ini
[Desktop Entry]
Name=OLLMchat
Comment=Chat with Ollama LLM models
Exec=ollmchat
Icon=org.roojs.ollmchat
Terminal=false
Type=Application
Categories=Network;Chat;
StartupNotify=true
```

**Create app icon** (`data/org.roojs.ollmchat.svg` or `.png`)

#### 5.4 Styling Improvements

**Enhancements**:
- Use libadwaita styling throughout
- Consistent spacing and margins
- Better color scheme
- Smooth animations for history panel
- Professional header bar with menu

**CSS Updates** (`resources/style.css`):
- Add styles for history browser
- Style hidden messages
- Improve overall polish

## Implementation Order

### Phase 1: Foundation (Core Storage)
1. Create `OLLMchat/History/Manager.vala` with basic save/load and `register_client()` method
2. Create `OLLMchat/History/Session.vala` as wrapper around `Call.Chat` using SQ (SQLite)
3. Add flag to `Message` class for including extra info (timestamp, hidden) during JSON encoding
4. Set up SQLite table for Session using `SQ/Database.vala`
5. Integrate auto-save via Client signal connections in Manager
6. Test: Save and load a simple chat

### Phase 2: Title Generation
1. Create `OLLMchat/History/TitleGenerator.vala` (main library)
2. Integrate async title generation after first message
3. Update SQLite database with titles
4. Test: Verify titles are generated and stored

### Phase 3: Basic UI
1. Create `UI/HistoryBrowser.vala` with list view
2. Add `Adw.OverlaySplitView` to main window
3. Implement chat selection and restoration
4. Test: Browse and restore old chats

### Phase 4: Polish
1. Add about dialog
2. Improve styling
3. Add search/filter to history browser
4. Test: Full user experience

### Phase 5: Advanced Features (Post-MVP)
1. Implement hidden messages
2. Implement chat rewinding
3. Consider multiple chat sessions if needed
4. Test: Advanced workflows

### Phase 6: Application Transformation
1. Rename/refactor main window
2. Update build configuration
3. Add desktop file and icon
4. Final polish and testing

## Technical Considerations

### File I/O
- Use `GLib.File` and `GLib.FileIOStream` for async file operations
- Handle file locking if multiple instances run (optional)
- Error handling for corrupted JSON files
- Migration path for future format changes

### Performance
- Lazy loading: Only load full chat when selected
- SQLite database keeps memory usage low for browsing
- Async operations to avoid blocking UI
- Consider pagination for large history lists

### Data Migration
- SQLite schema can be migrated using standard ALTER TABLE statements
- Backward compatibility when possible
- Clear migration path documented

### Security
- API keys stored in history files (consider encryption option)
- File permissions: `~/.local/share/ollmchat/` should be user-readable only
- Option to clear history or export without sensitive data

## Open Questions

1. **Title Update Strategy**: Should titles be updated if conversation evolves significantly, or only generated once?
   - **Recommendation**: Generate once after first exchange, allow manual edit

2. **History Size Limits**: Should there be a maximum number of stored chats or automatic cleanup?
   - **Recommendation**: No hard limit initially, add cleanup option later

3. **Export/Import**: Should users be able to export chats for backup or sharing?
   - **Recommendation**: Add export to JSON/Markdown in future phase

4. **Search Functionality**: Full-text search across all chats?
   - **Recommendation**: Start with title/preview search, add full-text later

5. **Branch Visualization**: How to show chat branches in history browser?
   - **Recommendation**: Indent or tree view for branches, or separate "Branches" section

6. **Multiple Instances**: Should multiple app instances share the same history?
   - **Recommendation**: Yes, but handle file locking for concurrent writes

## Dependencies

### New Dependencies
- **libadwaita-1**: For `Adw.OverlaySplitView`, `Adw.AboutWindow`, modern UI components
  - Already likely available if using GTK4

### Existing Dependencies
- All current dependencies remain
- JSON serialization (json-glib)
- File I/O (GLib)

## Testing Strategy

1. **Unit Tests**:
   - History manager save/load
   - Title generation
   - Message serialization with hidden flag

2. **Integration Tests**:
   - Full chat save/restore cycle
   - History browser interaction
   - Rewind functionality

3. **Manual Testing**:
   - Create multiple chats
   - Browse and restore
   - Test rewinding
   - Test hidden messages
   - Verify UI polish

## Future Enhancements

- **Cloud Sync**: Optional sync to cloud storage
- **Tags/Categories**: Organize chats with tags
- **Favorites**: Mark important chats
- **Statistics**: Token usage, model performance over time
- **Export Formats**: Markdown, PDF, HTML
- **Search**: Full-text search across all messages
- **Chat Templates**: Save and reuse common conversation starters

