# 2.6.1.4. Integrate Basic Overlay Support

## Overview

Integrate Overlay and Monitor classes with Bubble class to create a complete workflow: overlay creation → command execution → file copying → cleanup.

## Status

⏳ **PLANNING** - Design phase.

## Prerequisites

- Phase 1 (2.6.1.1) must be completed
- Phase 2 (2.6.1.2) must be completed
- Phase 3 (2.6.1.3) must be completed
- See main plan: `2.6.1-code-exec-improvements.md` for integration details

## Goals

1. Integrate Overlay with Bubble class
2. Integrate Monitor with Overlay (monitor overlay upper directory)
3. Update RunCommand/Request to use complete overlay system
4. Test full workflow end-to-end

## Implementation Details

### Files to Modify

- `liboctools/RunCommand/Request.vala` - Integrate Bubble, Overlay, and Monitor
- `liboctools/RunCommand/Bubble.vala` - Add overlay mount point support

### Integration Workflow

1. **Pre-execution**:
   - Create Bubble instance (with project folder)
   - Bubble constructor creates Overlay instance (but doesn't create/mount yet)

2. **Execution**:
   - Call bubble.exec(command)
   - exec() calls overlay.create() and overlay.mount() (lazy initialization)
   - Overlay mount point is available via overlay.overlay_dir + "/merged"
   - Monitor is started automatically by Overlay.mount()
   - Bubble uses overlay.overlay_map to get project root paths (instead of roots.entries)
   - Bubble binds overlay mount point at each project root location
   - Execute command in bwrap sandbox (writes go to overlay upper directory)
   - Monitor tracks changes during execution (already started by Overlay.mount())

3. **Post-execution** (handled inside bubble.exec()):
   - Call overlay.copy_files() (stops Monitor, copies files from overlay to live system)
   - Call overlay.cleanup() in finally block (unmounts overlay and tmpfs, removes directories)

### Detailed Code Changes

#### 1. Modify `Bubble.vala` - Add Overlay Support

**Add Overlay reference property:**

```vala
/**
 * Overlay instance for write isolation.
 * 
 * The overlay filesystem is used for write isolation.
 * The overlay mount point is bind-mounted into the sandbox instead of
 * directly binding project roots. All project root binds are replaced with
 * a single overlay mount point bind.
 */
private Overlay overlay;
```

**Modify constructor to create overlay instance (but not create/mount):**

```vala
public Bubble(OLLMfiles.Folder project, bool allow_network = false) throws Error
{
    this.project = project;
    this.allow_network = allow_network;
    
    // Create overlay instance for write isolation (but don't create/mount yet)
    // Overlay constructor already calls project.build_roots() internally and builds overlay_map
    this.overlay = new Overlay(project);
    
    // Note: roots HashMap is removed - Overlay already has all root information in overlay_map
}
```

**Modify `exec()` method to create, mount, execute, and cleanup overlay:**

```vala
public async string exec(string command) throws Error
{
    // Create and mount overlay (lazy initialization)
    this.overlay.create();
    this.overlay.mount();
    
    try {
        // Build bubblewrap command arguments using build_bubble_args(command)
        var args = this.build_bubble_args(command);
        
        // ... execute command (existing exec() code) ...
        
        // Copy files from overlay to live system (stops Monitor, copies files)
        yield this.overlay.copy_files();
        
        // Return output
        return output;
        
    } finally {
        // Always cleanup overlay (unmounts overlay and tmpfs, removes directories)
        try {
            this.overlay.cleanup();
        } catch (Error cleanup_error) {
            GLib.warning("Failed to cleanup overlay: %s", cleanup_error.message);
        }
    }
}
```

**Modify `build_bubble_args()` method:**

Current implementation binds each project root directly:
```vala
// Add root folder binds: Iterate over roots HashMap, for each path add "--bind", path, path
foreach (var entry in this.roots.entries) {
    args += "--bind";
    args += entry.key;
    args += entry.key;
}
```

**New implementation:**
```vala
// Bind overlay mount point for each project root
var overlay_mount_point = GLib.Path.build_filename(this.overlay.overlay_dir, "merged");
// Use overlay_map.values to get project root paths (Overlay already has all root info)
foreach (var root_path in this.overlay.overlay_map.values) {
    args += "--bind";
    args += overlay_mount_point;  // Source: overlay mount point
    args += root_path;            // Destination: project root path from overlay_map
}

// Add tmpfs mount for /tmp (clean temporary directory)
args += "--tmpfs";
args += "/tmp";
```

#### 2. Modify `Request.vala` - Integrate Overlay Workflow

**Modify `execute_tool_async()` method:**

Current implementation (lines 235-272):
```vala
private async string execute_tool_async() throws Error
{
    // ... validation code ...
    
    // Create Bubble instance
    var bubble = new Bubble(project, false);
    
    // Execute command
    var output = yield bubble.exec(this.command);
    
    // ... output handling ...
}
```

**New implementation with overlay support:**

```vala
private async string execute_tool_async() throws Error
{
    if (this.command == "") {
        throw new GLib.IOError.INVALID_ARGUMENT("Command cannot be empty");
    }
        
    // Check if bubblewrap can be used
    if (!Bubble.can_wrap()) {
        // Running in Flatpak or bwrap not available - use old permission system
        return yield this.execute_with_subprocess();
    }
    
    // Not in Flatpak and bwrap available - use bubblewrap with overlay
    // Get project folder from ProjectManager via tool
    var run_command_tool = (Tool) this.tool;
    var project_manager = run_command_tool.project_manager;
    if (project_manager == null || project_manager.active_project == null) {
        throw new GLib.IOError.FAILED("No active project available for bubblewrap execution");
    }
    var project = project_manager.active_project;  // OLLMfiles.Folder
    
    // Create Bubble instance (creates overlay, mounts in exec())
    Bubble? bubble = null;
    try {
        bubble = new Bubble(project, false);
        
        // Execute command in bwrap sandbox (writes go to overlay upper directory)
        // exec() handles overlay creation, mounting, file copying, and cleanup internally
        var output = yield bubble.exec(this.command);
        
        // Truncate output if needed
        output = this.truncate_output(output, 50);
        
        // Send output as second message via message_created
        this.send_ui("txt", "", output);
        
        // Return output to LLM
        return output;
        
    } catch (Error e) {
        // Cleanup is handled inside bubble.exec() finally block, so we just re-throw
        throw e;
    }
}
```

**Note**: The error handling ensures that:
1. Files are copied even if command execution fails
2. Overlay is cleaned up in all cases (success, error, exception)
3. Warnings are logged for cleanup failures but don't prevent execution

#### 3. Overlay Integration Details

**Overlay class already handles Monitor integration:**
- Monitor is created in Overlay constructor
- Monitor is started in Overlay.mount()
- Monitor is stopped in Overlay.copy_files()
- Bubble owns the Overlay instance and handles its lifecycle

**Bubble-Overlay integration:**
- Bubble always creates Overlay instance in constructor (overlay is never null)
- Bubble.exec() handles full overlay lifecycle:
  - Calls overlay.create() and overlay.mount() before execution
  - Executes command in sandbox
  - Calls overlay.copy_files() after execution (even on error)
  - Calls overlay.cleanup() in finally block (always executes)
- Bubble uses overlay.overlay_map.values instead of roots.entries for project root paths
- Request.vala just calls bubble.exec() - no need to access overlay directly

**Overlay mount point structure:**
- Overlay mount point: `{overlay_dir}/merged`
- This is a merged view of lower (project) + upper (writes) directories
- When bind-mounted into bwrap, writes go to upper directory
- Monitor tracks changes in upper directory

**Multiple project roots handling:**
- Overlay creates subdirectories in upper: `overlay1/`, `overlay2/`, etc.
- Each subdirectory maps to a project root via `overlay_map` (key: subdirectory name, value: project root path)
- Bubble uses `overlay.overlay_map` instead of `roots.entries` to get project root paths
- Bubble binds overlay mount point at each project root location from `overlay_map.values`
- Writes to project root in sandbox → overlay mount point → upper/overlayN/ → tracked by Monitor
- Monitor converts overlay paths to real paths using `overlay_map`

### Bwrap Integration Details

**Overlay mount point binding:**
- Instead of `--bind /home/alan/project /home/alan/project` (direct bind)
- Use `--bind /home/alan/.cache/ollmchat/overlay-12345/merged /home/alan/project` (overlay bind)
- Writes to `/home/alan/project/file.c` in sandbox → overlay mount point → upper/overlay1/file.c
- Monitor sees change in `upper/overlay1/file.c` and converts to `/home/alan/project/file.c`

**Multiple project roots:**
- For each project root in `overlay.overlay_map.values`:
  - Bind overlay mount point at that root's path in sandbox
  - Example: `--bind {overlay_mount_point} /home/alan/project`
  - Example: `--bind {overlay_mount_point} /home/alan/other-project`
- All writes go through the same overlay mount point
- Overlay filesystem routes writes to correct upper subdirectory based on path
- `roots` HashMap is removed from Bubble - Overlay already has all root information in `overlay_map`
- Bubble uses `overlay.overlay_map.values` to get project root paths

**Temporary directory (`/tmp`):**
- Add tmpfs mount for `/tmp` using `--tmpfs /tmp`
- Provides a clean, isolated temporary directory for each command execution
- Files in `/tmp` are not tracked by Monitor (temporary files only)
- `/tmp` is automatically cleaned up when bwrap sandbox exits
- Prevents commands from accessing or modifying the host system's `/tmp` directory

### Monitor Integration Details

**Monitor is already integrated in Overlay class:**
- Monitor created in Overlay constructor with:
  - `project_folder`: Project folder object
  - `base_path`: `{overlay_dir}/upper` (overlay upper directory)
  - `overlay_map`: HashMap mapping subdirectory names to real project paths
- Monitor started in `Overlay.mount()` (called by Bubble.exec() when overlay is created)
- Monitor stopped in `Overlay.copy_files()` (async, ensures all inotify events processed)
- Monitor change lists accessed via `overlay.monitor.added`, `overlay.monitor.updated`, `overlay.monitor.removed`

**Note**: Monitor is private in Overlay class, so neither Bubble nor Request.vala access it directly. Overlay.copy_files() handles all file copying using Monitor change lists. Bubble.exec() handles the full overlay lifecycle including cleanup.

## Implementation Tasks

- [ ] Add `overlay` property to Bubble class (Overlay type, always created)
- [ ] Remove `roots` property from Bubble class (Overlay has all root information)
- [ ] Modify Bubble constructor to create Overlay instance (but not create/mount)
- [ ] Remove roots initialization and population from Bubble constructor
- [ ] Modify `exec()` method in Bubble to:
  - Call overlay.create() and overlay.mount() before execution
  - Call overlay.copy_files() after execution (even on error)
  - Call overlay.cleanup() in finally block (always executes)
- [ ] Modify `build_bubble_args()` in Bubble to use `overlay.overlay_map.values` instead of `roots.entries`
- [ ] Add tmpfs mount for `/tmp` in `build_bubble_args()` (clean temporary directory)
- [ ] Modify `execute_tool_async()` in Request to create Bubble instance and call bubble.exec()
- [ ] Add error handling to ensure overlay cleanup on errors
- [ ] Test full workflow: overlay creation → command execution → file copying → cleanup
- [ ] Test with various command types (build, test, git, etc.)
- [ ] Test with complex commands (pipes, redirects, etc.)
- [ ] Test overlay cleanup on success
- [ ] Test overlay cleanup on error
- [ ] Test with multiple project roots
- [ ] Consider removing `roots` HashMap in future refactoring (use overlay.overlay_map instead)

## Testing

### Test Cases

1. **Basic command execution with overlay:**
   - Run simple command (e.g., `echo "test" > file.txt`)
   - Verify file is created in overlay upper directory
   - Verify file is copied to live system after execution
   - Verify overlay is cleaned up

2. **File modification:**
   - Create file in project: `echo "original" > file.txt`
   - Run command: `echo "modified" > file.txt`
   - Verify file is modified in overlay
   - Verify file is copied to live system
   - Verify original file is overwritten

3. **File deletion:**
   - Create file in project: `echo "test" > file.txt`
   - Run command: `rm file.txt`
   - Verify file is deleted in overlay
   - Verify file is deleted from live system

4. **Multiple project roots:**
   - Project with multiple build roots
   - Run command that writes to both roots
   - Verify writes go to correct overlay subdirectories
   - Verify files are copied to correct project roots

5. **Command failure:**
   - Run command that fails (e.g., `false`)
   - Verify files are still copied from overlay
   - Verify overlay is cleaned up even on error

6. **Complex commands:**
   - Run command with pipes: `ls | grep test`
   - Run command with redirects: `echo "test" > file.txt 2>&1`
   - Verify overlay works with complex commands

7. **Overlay cleanup on error:**
   - Simulate error during command execution
   - Verify overlay cleanup happens in finally block
   - Verify no overlay directories remain

8. **Temporary directory (`/tmp`) usage:**
   - Run command that uses `/tmp` (e.g., `mktemp /tmp/test.XXXXXX`)
   - Verify `/tmp` is accessible and writable in sandbox
   - Verify files created in `/tmp` are not tracked by Monitor
   - Verify `/tmp` is isolated from host system's `/tmp`
   - Verify `/tmp` is cleaned up when sandbox exits

## Error Handling

### Overlay Creation Errors

- **Directory creation fails**: Error thrown, caught in Request, overlay not created
- **Mount fails**: Error thrown, caught in Request, cleanup attempted
- **Monitor start fails**: Error thrown from mount(), caught in Request

### Command Execution Errors

- **Command fails (non-zero exit)**: Normal case, files still copied, overlay cleaned up
- **Subprocess creation fails**: Error thrown, caught in Request, cleanup in finally
- **I/O errors during execution**: Error thrown, caught in Request, cleanup in finally

### File Copying Errors

- **Copy fails for individual file**: Warning logged, operation continues (handled in Overlay.copy_files())
- **Permission copy fails**: Warning logged, operation continues (handled in Overlay.copy_permissions())
- **Monitor stop fails**: Error may be thrown, caught in Request, cleanup attempted

### Cleanup Errors

- **Unmount fails**: Warning logged in Overlay.cleanup(), directory removal attempted
- **Directory removal fails**: Error thrown, logged as warning in Request finally block
- **Partial cleanup**: Overlay directory may remain, logged as warning

## Edge Cases

### Multiple Project Roots

- Each project root gets its own overlay subdirectory (overlay1, overlay2, etc.)
- Bubble binds overlay mount point at each root location
- Writes to different roots go to different overlay subdirectories
- Monitor tracks all subdirectories and converts paths correctly

### Nested Directories

- New directories created in overlay are tracked by Monitor
- Parent directories are created automatically during file copy
- Deep nesting is handled correctly

### Empty Overlay (No Writes)

- If command doesn't write any files, Monitor change lists are empty
- copy_files() completes quickly (no files to copy)
- Cleanup proceeds normally

### Overlay Already Exists

- Overlay directory names include timestamp, so collisions are unlikely
- If directory exists, create() will fail with appropriate error
- Error is caught and handled in Request

## Notes

- This phase completes the basic overlay workflow
- Monitor integration is already complete in Overlay class (Phase 3)
- Backup support will be added in Phase 5
- Network access will be added in Phase 7
- Overlay cleanup is critical - ensure finally block always executes

