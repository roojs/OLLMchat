# Round-trip failures: markdown → document JSON → markdown

**Test:** `tests/test-markdown-doc.sh` — for each `tests/markdown/*.md`, run md→JSON (into build dir), then JSON→md, then diff original vs round-trip.

---

**Process (important):** When dealing with an issue, **do not jump in and start fixing code**. First: document what's wrong, explain causes, and write a proposed fix in this plan. Get the approach agreed (or at least written down). Only then implement. This keeps the plan the single place for "what we're doing and why" and avoids ad‑hoc edits that don't match the intended design.

**Coding standards:** All code in this plan must follow `.cursor/rules/CODING_STANDARDS.md`. In particular: no building strings in loops (use `string.nfill()` / `replace()` or `string.joinv()`); no character loops; plans must request and respect coding standards.

---

## Current round-trip failures

**Test:** `tests/test-markdown-doc.sh` with input such as `tests/markdown/renderer-test-suite.md`. After md→JSON→md, diff shows three regressions:

### Issue A: Nested blockquote loses one level

**Observed**

- Expected (original): `> > Nested blockquote.`
- Actual (round-trip): `> Nested blockquote.`

**Cause**

- **Parser:** In `BlockMap.handle_block_result`, when `current_block != FormatType.NONE` we skip starting a new block (`return false`). So when we're already inside a BLOCKQUOTE we never open a *nested* BLOCKQUOTE for a line like `> > Nested blockquote.`.
- **Parser:** In `Parser.handle_line_break`, for any block that is not a list we call `do_block(false, this.current_block)`, so we **end BLOCKQUOTE on every newline**. So after the first blockquote line we close the blockquote; the next line `> > ` is then seen with `current_block == NONE`, so we start a **new** BLOCKQUOTE with level = 2 (from `marker_string.length / 2`) as a **sibling** of the first, not as a child.
- **Document / to_markdown:** We therefore have two sibling `Block(BLOCKQUOTE)` nodes (level 1 then level 2). `Block.to_markdown()` for BLOCKQUOTE always emits a single `"> "` prefix and `inner.replace("\n", "\n> ")`; it does **not** use `this.level` to emit `"> "` repeated `level` times. So the second blockquote is emitted as `"> Nested blockquote."` instead of `"> > Nested blockquote."`.

**Summary:** Nested blockquote is lost because (1) the blockquote is closed on every newline so level-2 is never a child of level-1, and (2) even if it were, `Block.to_markdown()` for BLOCKQUOTE does not emit multiple `"> "` by level.

**Simpler design: store blockquotes as flat lines (no nested array)**

Blockquotes are not critical like lists; we can store them as one block per line with a level, and emit using that level in `to_markdown()` — no nested tree, no merge/nest in the renderer.

- **Parser:** Keep current behaviour (end BLOCKQUOTE on newline; one on_block start/end per line with level). No change.
- **Callback stream / GTK:** No change (receives START/END per line with level).
- **Document renderer:** **Revert to simple** — no rationalization. Use the original single line: `this.on_block(is_start ? new Block(FormatType.BLOCKQUOTE) { level = (uint)v1 } : null);` so each blockquote line becomes a sibling `Block(BLOCKQUOTE)` with its level set.
- **Block.to_markdown() for BLOCKQUOTE:** Emit `"> "` repeated `this.level` times, then the inner content with newlines replaced by `"\n" + that_prefix`. So a level-2 block emits `"> > " + inner.replace("\n", "\n> > ")`. Round-trip works with a flat list of blocks.

**Concrete code changes**

1. **document/Render.vala** — Restore the original BLOCKQUOTE branch (remove merge/nest logic):

```vala
case FormatType.BLOCKQUOTE:
	this.on_block(is_start ? new Block(FormatType.BLOCKQUOTE) {
		level = (uint)v1 } : null);
	return;
```

2. **document/Block.vala** — In `to_markdown()`, for `case FormatType.BLOCKQUOTE:` use `this.level` with fill (per CODING_STANDARDS: no string building in loops):

```vala
case FormatType.BLOCKQUOTE:
	return string.nfill((int)this.level, '>').replace(">", "> ") + inner;
```

(One block per line; no line breaks within a blockquote block. No nested blockquote nodes required.)

---

### Issue B: Table round-trip loses structure (pipes, newlines, alignment row)

**Observed**

- Expected: full GFM table with header row, alignment row, and body rows (pipes and newlines).
- Actual: single concatenated line of cell text, e.g. `Header 1Header 2Header 3leftcenterright**bold***italic*`code``.

**Cause**

- The document model correctly builds TABLE → TABLE_ROW → TABLE_HCELL / TABLE_CELL with inlines.
- **Block.to_markdown()** in `document/Block.vala` has no `case` for `FormatType.TABLE`, `TABLE_ROW`, `TABLE_HCELL`, or `TABLE_CELL`. They all fall through to `default: return inner;`. So a TABLE node simply concatenates all children’s markdown with no separators: no `|`, no newlines, no alignment row. Table serialization to markdown is not implemented.

**Proposed fix (document/Block.vala)**

Add explicit cases in `to_markdown()` so tables emit GFM with header row, alignment row, and body rows. Use string concatenation (no `GLib.StringBuilder` per CODING_STANDARDS); assume TABLE/TABLE_ROW children are `Block` (no null checks).

**Concrete code changes (document/Block.vala)**

In `Block.to_markdown()`, add the following cases **before** `default:` in the existing `switch (this.kind)`:

```vala
				case FormatType.TABLE: {
					if (this.children.size == 0) {
						return "";
					}
					var first_row = (Block) this.children.get(0);
					var align_row = "| ";
					for (int i = 0; i < first_row.children.size; i++) {
						align_row += (i > 0) ? " | " : "";
						switch (((Block) first_row.children.get(i)).align) {
							case 0:
								align_row += ":---:";
								break;
							case 1:
								align_row += "---:";
								break;
							default:
								align_row += ":---";
								break;
						}
					}
					align_row += " |\n";
					var body_rows = "";
					for (int r = 1; r < this.children.size; r++) {
						body_rows += this.children.get(r).to_markdown();
					}
					return first_row.to_markdown() + align_row + body_rows;
				}
				case FormatType.TABLE_ROW: {
					string result = "| ";
					bool first = true;
					foreach (var c in this.children) {
						result += ((!first) ? " | " : "") + c.to_markdown();
						first = false;
					}
					result += " |\n";
					return result;
				}
				case FormatType.TABLE_HCELL:
				case FormatType.TABLE_CELL:
					return inner;
```

---

### Issue C: Content between lines lost on round-trip

**Observed**

- Input with a block of lines (e.g. in `renderer-test-suite.md`: first line `$$`, blank line, line `\int_{-\infty}^{\infty} e^{-x^2} dx = \sqrt{\pi}`, then `$$`). Expected: that middle line preserved on round-trip. Actual: empty between the two `$$` lines.

**Cause**

- At line start the first line `$$` gets no block match (`block_match == 0`), so the parser starts a paragraph and consumes the line. After newline, that paragraph is closed. The next line(s) (blank or the LaTeX line) again get no block match, so they should become further paragraph(s); in principle the middle line should end up as a paragraph and be emitted (PARAGRAPH returns `inner`). The content can be lost if: **(1) Chunking** — the middle line stays in `leftover_chunk` (parser returns early needing more input) and a subsequent `add()` never runs. **(2) Backslash escaping** — in the main loop, `\` sets `escape_next` and the next character is emitted as literal (backslash dropped); that can corrupt the line; only in some path would the whole line be dropped. **(3) Other block path** — the line is treated as starting a different block that is not implemented or is closed immediately, and the line content is never attached to any block.

**Proposed direction (diagnose and fix the loss)**

- Reproduce with a minimal input (e.g. three lines: `$$`, `\int ...`, `$$`) and a single `add(chunk, true)` with the full string so chunking is not involved. If the content still disappears, chunking is ruled out.
- If it is preserved with one chunk but lost when the same string is fed in smaller chunks, trace `leftover_chunk`: when the parser returns early, the remainder is in `leftover_chunk`; the next `add()` prepends it. If the caller only calls `add()` once (e.g. round-trip test reads the whole file and passes it in one go), leftover is irrelevant. If the caller streams chunks, ensure the final chunk is passed with `is_end_of_chunks = true` and that no content remains in `leftover_chunk` after the last `add()`.
- If the line starts with `\`, confirm in the main loop that we open a paragraph (block_match == 0) and then process the line with `process_inline` or the character loop; check that the escaped character and the rest of the line are emitted as TEXT and attached to the current block.
- Add targeted logging (e.g. when we open/close PARAGRAPH and when we emit TEXT for a line that contains backslash) to see which path runs for the middle line. Fix the path that drops the content (e.g. ensure paragraph is opened and line is fed to inline processing, or fix leftover handling so the line is not left unparsed).

**Concrete code (after diagnosis) — apply only once cause is known**

**Option A — Leftover not flushed when input ends (Parser.vala):** In `add()`, after the main chunk loop, when `is_end_of_chunks` is true and `this.leftover_chunk` is non-empty, feed the remainder so it is parsed instead of dropped:

```vala
// At end of add(), when is_end_of_chunks and leftover_chunk non-empty:
if (is_end_of_chunks && this.leftover_chunk != "") {
	var remainder = this.leftover_chunk;
	this.leftover_chunk = "";
	this.add(remainder, false);
	return;
}
```

**Option B — Line not attached to paragraph (Parser.vala or BlockMap.vala):** If diagnosis shows the middle line never reaches `process_inline` or the paragraph’s children, ensure at line start when `block_match == 0` we set `current_block = PARAGRAPH`, call `do_block(true, PARAGRAPH)`, then continue so the line content is processed into that block (no early return that skips the character loop or `process_inline`). Exact location depends on trace.

**Option C — Backslash or other inline path drops content:** If the line starts with `\` or similar and the character loop or format map consumes it incorrectly, fix the relevant branch in the parser’s main loop (e.g. ensure TEXT is emitted and appended to `current_block_with_inlines`). Exact code depends on diagnosis.

