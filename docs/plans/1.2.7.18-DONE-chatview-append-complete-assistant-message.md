# 1.2.7.18. ChatView.append_complete_assistant_message() - Get Chat and Client from Session

## Overview

`ChatView.append_complete_assistant_message()` currently tries to get Chat from `message.message_interface` with a fallback to `session.agent.chat`, and gets client from `session.client`. This approach has FIXME comments indicating it needs cleanup.

**Parent Plan**: [1.2.7. Move Remaining Signals from Client to Chat](./1.2.7-DONE-move-signals-to-chat.md)

## Status

✅ **DONE** - All implementation steps complete. Chat/Response.Chat dependency removed, is_active checks added, unread count display implemented, and running state indicator added.

## Implementation Steps

### Step 1: Remove Chat/Response.Chat Dependency
- [x] Step 1a: `process_new_chunk_direct()` method created and works correctly
- [x] Step 1a: `end_block_direct()` method created and works correctly
- [x] Step 1a: `finalize_assistant_message_direct()` method created and works correctly
- [x] Step 1b: Performance metrics stored as "ui" message in `finalize_streaming()` when response completes
- [x] Step 1b: "ui" message with metrics is added to messages array and saved
- [x] Step 1c: `append_complete_assistant_message()` updated to use new direct methods
- [x] Step 1c: Messages loaded from history (with null `message_interface`) display correctly
- [x] Step 1c: Thinking content is rendered correctly (using message.thinking)
- [x] Step 1c: Regular content is rendered correctly (using message.content)
- [x] Step 1c: Performance metrics are displayed from "ui" role messages in messages array
- [x] Step 1d: Old methods removed or refactored to use new direct methods

### Step 2: is_active Checks
- [x] `Session.on_message_created()` only relays to Manager if `is_active`
- [x] `Session.handle_stream_chunk()` only relays to Manager if `is_active`
- [x] `Session.handle_stream_chunk()` still increments `unread_count` when inactive
- [x] `SessionBase.add_message()` only relays to Manager if `is_active`
- [x] Inactive sessions don't update UI when messages/streaming arrive
- [x] Active sessions still update UI correctly

### Step 3: Unread Count Display
- [x] Step 3a: `css_classes` property added to SessionBase
- [x] Step 3a: `css_classes` returns "oc-has-unread" when `unread_count > 0`
- [x] Step 3a: `css_classes` property is not serialized
- [x] Step 3a: `notify_property("css_classes")` called when `unread_count` changes
- [x] Step 3a: `notify_property("css_classes")` called in `activate()` when clearing unread_count
- [x] Step 3b: `css_classes` bound to row_box widget classes in HistoryBrowser
- [x] Step 3c: Unread label widget added to HistoryBrowser factory in `on_setup_row()`
- [x] Step 3c: Unread label positioned in secondary_box (after info_label, before date_label)
- [x] Step 3c: `css_classes` bound to unread_label widget classes
- [x] Step 3c: CSS styling applied correctly (background color, unread label visibility)
- [x] Step 3c: UI updates when `css_classes` property changes

### Step 4: Running State Indicator
- [x] Step 4a: `is_running` property added to SessionBase
- [x] Step 4a: `is_running` property is not serialized
- [x] Step 4b: `is_running` set to true in `Session.send()` when starting request
- [x] Step 4b: `is_running` set to false in `Session.finalize_streaming()` when done
- [x] Step 4b: `is_running` reset to false if agent not available in `send()`
- [x] Step 4c: Spinner widget added to HistoryBrowser factory in `on_setup_row()`
- [x] Step 4c: Spinner positioned in secondary_box
- [x] Step 4c: `is_running` bound to spinner `visible` property
- [x] Step 4c: `is_running` bound to spinner `spinning` property
- [x] Step 4c: Spinner shows and spins when `session.is_running == true`
- [x] Step 4c: Spinner hides and stops when `session.is_running == false`

### Integration Testing
- [ ] Loading a session from history renders messages correctly (no Chat dependency)
- [ ] History messages render correctly when switching to a session
- [ ] New messages can be sent after loading history
- [ ] Switching between sessions works correctly
- [ ] Inactive sessions don't update UI when receiving messages/streaming
- [ ] Unread count displays correctly in history browser
- [ ] Running state indicator shows/hides correctly
- [ ] All functionality still works correctly after cleanup
- [ ] No regressions in history loading or message display

## Goal

1. **Restore agent (and Chat) when switching to a historical session**: When a session is activated (e.g., when switching to a historical session), the agent should be created immediately so that `agent.chat` exists. This ensures Chat is set up correctly for history restoration.
2. Clean up how Chat and Client are obtained in `ChatView.append_complete_assistant_message()`

## Session Activation Flow

### EmptySession Flow (New Chat)

**Note**: EmptySession is only used as the initial session in Manager constructor. When user clicks "New Chat", `Manager.create_new_session()` creates a real Session directly, not an EmptySession.

```
User clicks "New Chat" button
  └─> Window.new_chat_button.clicked
      └─> Manager.create_new_session()
          ├─> Creates new Session (real Session, not EmptySession)
          ├─> Sets agent_name and model from current session
          └─> Returns Session to UI
      └─> ChatWidget.switch_to_session(new_session)
          └─> Manager.switch_to_session(session)
              ├─> session.deactivate() - sets is_active=false
              ├─> session.load() - no-op for Session (already loaded)
              ├─> session.activate() - activates session
              │   └─> [CURRENT] Sets is_active=true, clears unread_count
              └─> Manager.session_activated signal emitted
          └─> ChatWidget.load_messages() - renders messages (empty for new session)
              └─> [NOTE] For new sessions, no history messages to render, so no problem yet

User types message and sends
  └─> ChatWidget.on_send_clicked()
      └─> Session.send(message)
          ├─> Session.add_message() - adds message to session.messages
          │   └─> [CURRENT] Always calls manager.message_added() (no is_active check)
          │   └─> [TO ADD Step 2] Only relay if is_active
          ├─> Session.ensure_agent_handler() - creates agent if needed
          └─> agent.send_async() - sends message via agent
              └─> agent.chat - Chat already exists (created when agent was created)
              └─> Session.handle_stream_chunk() - receives streaming chunks
                  └─> [CURRENT] Always calls manager.stream_chunk() (no is_active check)
                  └─> [TO ADD Step 2] Only relay if is_active, else increment unread_count
```

### SessionPlaceholder Flow (Existing Chat from History)

```
User clicks on existing session in history browser
  └─> HistoryBrowser.session_selected signal
      └─> ChatWidget.switch_to_session(session) - session is SessionPlaceholder
          └─> Manager.switch_to_session(session)
              ├─> session.deactivate() - sets is_active=false
              ├─> session.load() - SessionPlaceholder.load()
                  ├─> Creates new Session from placeholder data
                  ├─> Loads JSON file into SessionJson
                  ├─> Copies messages from JSON to Session.messages
                  ├─> Replaces placeholder in manager.sessions
                  └─> Returns real Session
              ├─> loaded_session.activate() - activates session
                  └─> [CURRENT] Sets is_active=true, clears unread_count
              └─> Manager.session_activated signal emitted
          └─> ChatWidget.load_messages() - renders history messages
              └─> For each message: append_complete_assistant_message()
                  └─> [CURRENT] Tries message.message_interface (often null), falls back to session.agent.chat
                      └─> [PROBLEM] session.agent.chat is NULL - Chat object needed here to create Response.Chat
                      └─> Method returns early with warning, message not displayed
                  └─> [TO ADD Step 1] Works directly with Message object, no Chat/Response.Chat needed

User sends new message to existing chat
  └─> ChatWidget.on_send_clicked()
      └─> Session.send(message)
          ├─> Session.add_message() - adds message to session.messages
          │   └─> [CURRENT] Always calls manager.message_added() (no is_active check)
          │   └─> [TO ADD Step 3] Only relay if is_active
          └─> Session.ensure_agent_handler() - creates agent if needed
          └─> agent.send_async() - sends message via agent
              └─> Session.handle_stream_chunk() - receives streaming chunks
                  └─> [CURRENT] Always calls manager.stream_chunk() (no is_active check)
                  └─> [TO ADD Step 2] Only relay if is_active, else increment unread_count and return early
```

**Legend**:
- `[CURRENT]` - Current behavior (before this plan)
- `[TO ADD Step N]` - What will be added/changed by this plan
**Key Points**:
- **SessionPlaceholder**: `load()` converts placeholder to Session, `activate()` sets is_active
- **EmptySession**: Not used for new chats - Manager.create_new_session() creates a real Session directly
- **Chat dependency issue**: 
  - `[CURRENT]` `append_complete_assistant_message()` needs a Chat object to create Response.Chat, but history messages don't have `message_interface` set, and `session.agent.chat` doesn't exist until `send()` is called. This causes the method to fail when rendering history.
  - `[TO ADD Step 1]` Remove Chat/Response.Chat dependency entirely - work directly with Message objects. This eliminates the need for Chat when rendering history.
- **Deactivation behavior**: 
  - `[CURRENT]` `deactivate()` only sets `is_active=false`. Deactivated sessions still emit messages (`manager.message_added()`) and streaming (`manager.stream_chunk()`) to Manager. The only difference is `unread_count` is incremented for inactive streaming chunks (Session.handle_stream_chunk line 161-163). The UI may display messages/streaming from inactive sessions if they arrive while Manager signals are connected - there's no filtering based on `is_active` status.
  - `[TO ADD Step 2]` After Step 2, deactivated sessions will NOT relay messages/streaming to Manager. Only active sessions will update the UI. Inactive sessions will still increment `unread_count` for streaming chunks but won't emit to Manager.

## Issue

1. **Chat dependency for history rendering**: `ChatView.append_complete_assistant_message()` currently needs a Chat object to create a Response.Chat wrapper, but history messages don't have `message_interface` set, and `session.agent.chat` doesn't exist until `send()` is called. This causes the method to fail when rendering history messages.

2. **Unnecessary Chat/Response.Chat dependency**: The method only needs the Chat object to create Response.Chat, which is then used to pass `is_thinking` state through the processing pipeline. We can work directly with Message objects instead.

## Current State

- `libollmchatgtk/ChatView.vala` lines 641-655:
```vala
// Get client and chat from message or session
// FIXME - we want to get rid of this message_interface klduget
var call = message.message_interface as OLLMchat.Call.Chat;
if (call == null) {
    // Fallback: try to get chat from session's agent
    if (session.agent != null && session.agent.chat != null) {
        call = session.agent.chat;
    } else {
        GLib.warning("ChatView.append_complete_assistant_message: cannot get Chat from message or session");
        return;
    }
}
// Get connection from default_model_usage
var connection = session.manager.config.connections.get(session.manager.default_model_usage.connection);
```

**Note**: The code already gets connection correctly (line 654), but the plan incorrectly mentioned `session.client` which was already removed in plan 1.2.7.7.

## Review and Analysis

### Current Implementation Issues

1. **Primary path is unreliable**: The code tries `message.message_interface` first, but:
   - Messages loaded from history may have `null` `message_interface` (see `SessionPlaceholder.load()` line 138: "message_interface will be set when Chat is created by AgentHandler")
   - `message_interface` is only set when Chat deserializes its own messages (see `Call.Chat.deserialize_property()` line 314)
   - For history messages, `message_interface` is typically null until a Chat is created for a new request

2. **Agent may not exist when loading history**: This is a **critical bug**:
   - When switching to any session (placeholder or already-loaded), `Manager.switch_to_session()` calls `session.activate()` (Manager line 241)
   - `SessionBase.activate()` only sets `is_active = true` and does NOT create the agent (SessionBase line 193-204)
   - The agent is only created lazily when `send()` is called (Session line 569 calls `ensure_agent_handler()`)
   - But `load_messages()` is called immediately after `switch_to_session()` (ChatWidget line 215)
   - So when `append_complete_assistant_message()` tries to access `session.agent.chat`, the agent is `null`!
   - **This affects both scenarios**:
     - SessionPlaceholder → Session: New Session created by `load()`, then `activate()` called
     - Already-loaded Session: Existing Session, `activate()` called when switching to it
   - **This means restoring from history does NOT set up Chat correctly** - the agent (and thus `agent.chat`) doesn't exist until the first message is sent

3. **Fallback is the correct path**: `session.agent.chat` is the proper source:
   - Agent is created when session is activated or when `activate_agent()` is called
   - Agent creates Chat in its constructor (`Agent.Base` line 106)
   - Chat is reused for all requests on that session
   - This is the authoritative source per the architecture

3. **Connection retrieval is correct**: The code already uses:
   ```vala
   var connection = session.manager.config.connections.get(session.manager.default_model_usage.connection);
   ```
   - This is the proper way to get connection (no `session.client` needed)

### Architecture Context

- **Chat lifecycle**: Chat is created per request by AgentHandler, but the Agent's Chat instance is reused and stored on `agent.chat`
- **Message lifecycle**: Messages stored in `session.messages` don't have `message_interface` set until they're used in a Chat context
- **Session activation**: When a session is loaded, `agent` may not exist until `activate_agent()` is called or the session is activated
- **Agent creation**: Agent is created lazily via `ensure_agent_handler()` when needed (Session line 455)

### Consequences of Change

**Positive:**
- Removes unreliable dependency on `message.message_interface`
- Simplifies code by using the authoritative source (`session.agent.chat`)
- Aligns with architecture where Chat comes from Agent
- Makes the code path clearer and more maintainable

**Recommended Approach:**
1. Remove `message.message_interface` check entirely
2. **Ensure agent exists (create if needed)** - This fixes the bug where agent doesn't exist when loading history
3. Get Chat from `session.agent.chat`
4. Get connection from `session.model_usage.connection` (preferred) or `session.manager.default_model_usage.connection` (fallback)

**Note**: This change will also fix the underlying bug where Chat is not set up correctly when restoring from history. The agent will be created when needed for rendering messages.

## Action

- Remove dependency on `message.message_interface` entirely
- Ensure `session.agent` exists (may need to call `ensure_agent_handler()` or activate agent)
- Get Chat directly from `session.agent.chat` (the authoritative source)
- Update connection retrieval to prefer `session.model_usage.connection` over `default_model_usage`
- Update error handling to be more informative if agent/chat is unavailable

## Implementation Details

### Step 1: Remove Chat/Response.Chat Dependency from append_complete_assistant_message()

**File**: `libollmchatgtk/ChatView.vala` (lines 625-688)

**Goal**: Remove the dependency on `message_interface` (Chat object) and Response.Chat wrapper. Work directly with Message objects.

#### Step 1a: Create New Direct Methods

**Current code:**
```vala
// Get client and chat from message or session
// FIXME - we want to get rid of this message_interface klduget
var call = message.message_interface as OLLMchat.Call.Chat;
if (call == null) {
    // Fallback: try to get chat from session's agent
    if (session.agent != null && session.agent.chat != null) {
        call = session.agent.chat;
    } else {
        GLib.warning("ChatView.append_complete_assistant_message: cannot get Chat from message or session");
        return;
    }
}
// Get connection from default_model_usage
var connection = session.manager.config.connections.get(session.manager.default_model_usage.connection);
```

**Proposed code:**
```vala
// Work directly with Message object - no Chat/Response.Chat needed
// Determine thinking state from message.thinking content
bool is_thinking = message.thinking != "";

// Initialize assistant message state
this.is_assistant_message = true;
this.last_chunk_start = 0;
this.content_state = ContentState.NONE;
this.is_thinking = is_thinking;

// Process thinking content first if present
if (message.thinking != "") {
    this.process_new_chunk_direct(message.thinking, true);  // true = is_thinking
    // Ensure thinking block is finalized
    if (this.content_state != ContentState.NONE) {
        this.end_block_direct(true);  // true = is_thinking
    }
}

// Process regular content
if (message.content != "") {
    this.is_thinking = false;
    this.process_new_chunk_direct(message.content, false);  // false = is_thinking
}

// Finalize the message (no response needed - metrics will be in messages array as "ui" messages after Step 1b)
this.finalize_assistant_message_direct();
```

#### Step 1b: Store Performance Metrics as UI Message on Completion

**This step is REQUIRED** - Performance metrics must be stored as "ui" messages so they're available when loading history. Without this, `append_complete_assistant_message()` would need Response.Chat to recreate metrics.

**File**: `libollmchat/History/Session.vala` (lines 193-231, `finalize_streaming()` method)

**Issue**: Currently, `finalize_streaming()` creates a "done" message with summary (line 224) but doesn't add it to the messages array. Performance metrics need to be stored as a "ui" role message so they're available when loading history.

**Current code** (line 222-224):
```vala
// Create a "done" message after the real message with summary
var summary = response.get_summary();
var done_msg = new Message(this.agent.chat, "done", summary);
// Note: done_msg is created but not added to messages array
```

**Proposed code**:
```vala
// Create a "ui" message with performance metrics summary (for history display)
// This will be stored in messages array and displayed when loading history
var summary = response.get_summary();
if (summary != "") {
    var metrics_msg = new Message(this.agent.chat, "ui", summary);
    this.messages.add(metrics_msg);
    // Relay to Manager for UI (metrics should be displayed)
    this.manager.message_added(metrics_msg, this);
}

// Create a "done" message after the real message with summary (keep existing behavior)
var done_msg = new Message(this.agent.chat, "done", summary);
this.messages.add(done_msg);
// Note: "done" messages are filtered out in on_message_created() but still stored for signal compatibility
```

**Note**: 
- "ui" role messages are already handled by the UI rendering code (ChatWidget line 329-330)
- This ensures performance metrics are available when loading history, so `append_complete_assistant_message()` doesn't need Response.Chat to recreate them

#### Step 1c: Update append_complete_assistant_message() to Use Direct Methods

**Required refactoring**:
1. Create `process_new_chunk_direct(string text, bool is_thinking)` - version that doesn't need Response.Chat
2. Create `end_block_direct(bool is_thinking)` - version that doesn't need Response.Chat  
3. Create `finalize_assistant_message_direct()` - version that doesn't need Response.Chat (metrics already in messages array)
4. Update `append_complete_assistant_message()` to use the new direct methods (replacing the Response.Chat-based code)

#### Step 1d: Remove or Refactor Old Methods

**File**: `libollmchatgtk/ChatView.vala`

**Goal**: After new direct methods are working, remove or refactor the old methods that depend on Response.Chat.

**Options**:
1. **Remove old methods entirely** - If they're only used by `append_complete_assistant_message()`, remove them after Step 1c
2. **Refactor old methods to use new direct methods** - If they're used elsewhere (e.g., `append_assistant_chunk()` for streaming), refactor them to call the new direct methods internally

**Methods to review**:
- `process_new_chunk(OLLMchat.Response.Chat response)` - Check if used by `append_assistant_chunk()` for streaming
- `end_block(OLLMchat.Response.Chat response)` - Check if used elsewhere
- `finalize_assistant_message(OLLMchat.Response.Chat? response = null)` - Check if used elsewhere

**Note**: 
- If these methods are used for streaming (live responses), they may still need Response.Chat for other purposes
- In that case, refactor them to extract `is_thinking` from response and call the direct methods

**Note**: 
- This removes the need for Chat object entirely for history rendering
- Performance metrics need to be stored as "ui" role messages in the messages array when saving (see Step 1b)
- This simplifies the code and removes the FIXME about message_interface

### Step 2: Add is_active Checks to Prevent Inactive Sessions from Relaying

**Files**: `libollmchat/History/Session.vala`, `libollmchat/History/SessionBase.vala`

**Issue**: Currently, deactivated sessions still emit messages and streaming to Manager, which can cause UI to display messages from inactive sessions.

**Changes**:
1. **Session.on_message_created()** - Only relay to Manager if `is_active`
2. **Session.handle_stream_chunk()** - Only relay to Manager if `is_active` (still increment unread_count if inactive)
3. **SessionBase.add_message()** - Only relay to Manager if `is_active`

**Proposed code for Session.on_message_created()** (line 146):
```vala
// Relay to Manager for UI - pass this session, not content_interface
// Only relay if session is active (prevents inactive sessions from updating UI)
if (this.is_active) {
    this.manager.message_added(m, this);
}
```

**Proposed code for Session.handle_stream_chunk()** (lines 158-187):
**Note**: This change is separate from Step 1 and unrelated to `ensure_agent_handler()`. It's about preventing inactive sessions from relaying streaming chunks to the UI.

```vala
public override void handle_stream_chunk(string new_text, bool is_thinking, Response.Chat response)
{
    // If session is inactive, increment unread count and don't relay
    // This prevents inactive sessions from updating the UI with streaming output
    if (!this.is_active) {
        this.unread_count++;  // Auto-property setter automatically emits property change notification
        // Don't relay to Manager - inactive sessions shouldn't update UI
        return;
    }
    
    // Capture streaming output (existing code - unchanged)
    if (new_text.length > 0) {
        // ... existing streaming capture code ...
    }
    
    // When response is done, finalize streaming (existing code - unchanged)
    if (response.done) {
        this.finalize_streaming(response);
    }
    
    // Relay to Manager signals (base class handles this)
    base.handle_stream_chunk(new_text, is_thinking, response);
}
```

**Proposed code for SessionBase.add_message()** (line 277):
```vala
// Relay to UI via Manager's message_added signal - pass this session, not content_interface
// Only relay if session is active
if (this.is_active) {
    this.manager.message_added(message, this);
}
```

### Files to Modify

1. **`libollmchat/History/Session.vala`** - Store performance metrics as "ui" message in `finalize_streaming()` (Step 1b)
2. **`libollmchat/History/Session.vala`** - Add `is_active` check in `on_message_created()` and `handle_stream_chunk()` (Step 2)
3. **`libollmchat/History/Session.vala`** - Notify `css_classes` when `unread_count` changes (Step 3a)
4. **`libollmchat/History/Session.vala`** - Set `is_running` flag in `send()` and `finalize_streaming()` (Step 4b)
5. **`libollmchat/History/SessionBase.vala`** - Add `is_active` check in `add_message()` (Step 2)
6. **`libollmchat/History/SessionBase.vala`** - Add `css_classes` computed property (Step 3a)
7. **`libollmchat/History/SessionBase.vala`** - Notify `css_classes` in `activate()` when clearing unread_count (Step 3a)
8. **`libollmchat/History/SessionBase.vala`** - Add `is_running` property (Step 4a)
9. **`libollmchatgtk/ChatView.vala`** - Create new methods: `process_new_chunk_direct()`, `end_block_direct()`, `finalize_assistant_message_direct()` (Step 1a)
10. **`libollmchatgtk/ChatView.vala`** - Update `append_complete_assistant_message()` to use new direct methods (Step 1c)
11. **`libollmchatgtk/ChatView.vala`** - Remove or refactor old methods that depend on Response.Chat (Step 1d)
12. **`libollmchatgtk/HistoryBrowser.vala`** - Bind `css_classes` to row_box widget classes (Step 3b)
13. **`libollmchatgtk/HistoryBrowser.vala`** - Add spinner widget to factory and bind `is_running` (Step 4c)

### Dependencies

- Step 2 requires `is_active` property to be properly maintained (already done in activate/deactivate)
- No dependencies on Chat/agent for history rendering after Step 1

### Step 3: Add Unread Count Display to History Browser

**Files**: `libollmchat/History/SessionBase.vala`, `libollmchat/History/Session.vala`, `libollmchatgtk/HistoryBrowser.vala`

**Goal**: Display unread_count in the history browser UI to show when sessions have unread messages. The unread count will be shown via a separate "unread" label widget with CSS styling (not in `display_info` text).

#### Step 3a: Add css_classes Property to SessionBase

**File**: `libollmchat/History/SessionBase.vala`

**Add computed property** that generates CSS classes based on session state:

```vala
// CSS classes for styling session rows in history browser
// Not serialized - computed property based on session state
public string[] css_classes {
    owned get {
        var classes = new string[] {};
        if (this.unread_count > 0) {
            classes += "oc-has-unread";
        }
        return classes;
    }
    set { }  // Empty setter - read-only computed property
}
```

**Update unread_count handling** to notify css_classes when unread_count changes:

**File**: `libollmchat/History/Session.vala` (line 162-163)

**Current code**:
```vala
if (!this.is_active) {
    this.unread_count++;  // Auto-property setter automatically emits property change notification
}
```

**Proposed code**:
```vala
if (!this.is_active) {
    this.unread_count++;  // Auto-property setter automatically emits property change notification
    this.notify_property("css_classes");  // Notify css_classes change when unread_count changes
}
```

**Also update** `SessionBase.activate()` (line 199) to notify css_classes when unread_count is cleared:
```vala
this.unread_count = 0; // Clear unread count when activated
this.notify_property("css_classes");  // Notify css_classes change when unread_count cleared
```

**Note**: 
- Property is not serialized (exclude from JSON serialization in `serialize_property()`)
- CSS class "oc-has-unread" will be applied to row widget when `unread_count > 0`
- CSS can style background color and make the info label text red/bold

#### Step 3c: Add Unread Label Widget to HistoryBrowser

**File**: `libollmchatgtk/HistoryBrowser.vala`

**Update `on_setup_row()`** to:
1. Store reference to row_box widget
2. Create a separate "unread" label for displaying unread status

```vala
// Create unread label (visibility controlled by CSS)
var unread_label = new Gtk.Label("unread") {
    halign = Gtk.Align.START,
    css_classes = {"list-chat-unread", "caption"}
};

// Add unread label to secondary_box (after info_label, before date_label)
secondary_box.append(unread_label);

// Store widget references
list_item.set_data<Gtk.Box>("row_box", row_box);
list_item.set_data<Gtk.Label>("title_label", title_label);
list_item.set_data<Gtk.Label>("info_label", info_label);
list_item.set_data<Gtk.Label>("date_label", date_label);
list_item.set_data<Gtk.Label>("unread_label", unread_label);
```

**Update `on_bind_row()`** to:
1. Bind css_classes property to row_box
2. Bind css_classes to unread_label (so it gets the oc-has-unread class when parent has it)

```vala
// Retrieve widgets
var row_box = list_item.get_data<Gtk.Box>("row_box");
var title_label = list_item.get_data<Gtk.Label>("title_label");
var info_label = list_item.get_data<Gtk.Label>("info_label");
var date_label = list_item.get_data<Gtk.Label>("date_label");
var unread_label = list_item.get_data<Gtk.Label>("unread_label");

// ... existing bindings ...

// Bind css_classes to row_box widget classes
session.bind_property("css_classes", row_box, "css-classes", BindingFlags.SYNC_CREATE);

// Bind css_classes to unread_label as well (so it can be styled/hidden via CSS)
session.bind_property("css_classes", unread_label, "css-classes", BindingFlags.SYNC_CREATE);
```

**CSS styling** (add to CSS file):
```css
.oc-has-unread {
    background-color: rgba(255, 0, 0, 0.1);  /* Light red background */
}

/* Hide unread label by default */
.list-chat-unread {
    visibility: hidden;
    color: red;
    font-weight: bold;
}

/* Show unread label when parent has oc-has-unread class */
.oc-has-unread .list-chat-unread {
    visibility: visible;
}
```

**Note**: See `docs/reference-gtk-css.md` for GTK CSS property reference and examples. GTK CSS does **not** support `::after` pseudo-elements or the `content` property (these are web CSS features). Instead, we use a separate label widget with CSS `visibility` property to show/hide it based on the parent's `oc-has-unread` class. The CSS styling will provide visual highlighting with background color and red/bold text for the unread label.

### Step 4: Add Running State Indicator to History Browser

**Files**: `libollmchat/History/SessionBase.vala`, `libollmchat/History/Session.vala`, `libollmchatgtk/HistoryBrowser.vala`

**Goal**: Show a spinner in the history browser when a session is actively processing a request.

#### Step 4a: Add is_running Property to SessionBase

**File**: `libollmchat/History/SessionBase.vala`

**Add property**:
```vala
public bool is_running { get; private set; default = false; }
```

**Note**: Property is not serialized (exclude from JSON serialization in `serialize_property()`)

#### Step 4b: Set is_running Flag in Session

**File**: `libollmchat/History/Session.vala`

**Update `Session.send()`** (line 554) to set `is_running = true`:
```vala
public override async void send(Message message, GLib.Cancellable? cancellable = null) throws Error
{
    // Add to session history
    this.messages.add(message);
    
    // Emit message_added signal to notify UI
    this.manager.message_added(message, this);
    
    // If not user message, we're done
    if (message.role != "user") {
        return;
    }
    
    // User message - ensure agent handler is set (create if needed)
    this.ensure_agent_handler();
    
    // Set running state to true when starting request
    this.is_running = true;
    
    // Session has reference to AgentHandler
    if (this.agent != null) {
        yield this.agent.send_async(message, cancellable);
    } else {
        this.is_running = false;  // Reset if agent not available
        throw new OllamaError.INVALID_ARGUMENT("No agent available for session");
    }
}
```

**Update `Session.finalize_streaming()`** (line 193) to set `is_running = false`:
```vala
private void finalize_streaming(Response.Chat response)
{
    // ... existing code ...
    
    // Set running state to false when response is done
    this.is_running = false;
    
    this.save_async.begin();
    this.notify_property("display_info");  // Reply count changes when message is added
    // Note: title notification removed - title only changes in async save_async() if empty
}
```

#### Step 4c: Add Spinner Widget to HistoryBrowser Factory

**File**: `libollmchatgtk/HistoryBrowser.vala`

**Update `on_setup_row()`** to add spinner widget:
```vala
// Secondary line box (horizontal)
var secondary_box = new Gtk.Box(Gtk.Orientation.HORIZONTAL, 8);

// Model and reply count label (left side, small, grey)
var info_label = new Gtk.Label("") {
    halign = Gtk.Align.START,
    hexpand = true,
    css_classes = {"list-chat-model", "caption", "dim-label"}
};

// Spinner widget for running state (between info and date)
var spinner = new Gtk.Spinner() {
    halign = Gtk.Align.CENTER,
    visible = false,  // Hidden by default
    spinning = false
};

// Date label (right side, small, grey)
var date_label = new Gtk.Label("") {
    halign = Gtk.Align.END,
    css_classes = {"list-chat-date", "caption", "dim-label"}
};

secondary_box.append(info_label);
secondary_box.append(spinner);  // Add spinner between info and date
secondary_box.append(date_label);

// ... existing code ...

// Store widget references
list_item.set_data<Gtk.Box>("row_box", row_box);
list_item.set_data<Gtk.Label>("title_label", title_label);
list_item.set_data<Gtk.Label>("info_label", info_label);
list_item.set_data<Gtk.Label>("date_label", date_label);
list_item.set_data<Gtk.Spinner>("spinner", spinner);  // Store spinner reference
```

**Update `on_bind_row()`** to bind is_running to spinner:
```vala
// Retrieve widgets
var row_box = list_item.get_data<Gtk.Box>("row_box");
var title_label = list_item.get_data<Gtk.Label>("title_label");
var info_label = list_item.get_data<Gtk.Label>("info_label");
var date_label = list_item.get_data<Gtk.Label>("date_label");
var spinner = list_item.get_data<Gtk.Spinner>("spinner");

// ... existing bindings ...

// Bind is_running to spinner visibility and spinning state
session.bind_property("is_running", spinner, "visible", BindingFlags.SYNC_CREATE);
session.bind_property("is_running", spinner, "spinning", BindingFlags.SYNC_CREATE);
```

**Note**: 
- Spinner is positioned between info_label and date_label in the secondary_box
- Spinner visibility and spinning state are both bound to `session.is_running`
- When `is_running == true`, spinner is visible and spinning
- When `is_running == false`, spinner is hidden and not spinning

## Summary

This plan fixes two related issues:

1. **Restores agent (and Chat) when switching to historical session**: When `Manager.switch_to_session()` activates a session (including historical sessions), the agent is now created immediately. This ensures `agent.chat` exists when `load_messages()` tries to render history messages. The agent is created using the stored `agent_name` from the session.

2. **Cleans up Chat retrieval**: Removes the unreliable dependency on `message.message_interface` and uses the authoritative source (`session.agent.chat`) for Chat access.

The changes:

1. **Restores agent and Chat when switching to historical session**: Agent is created in `Session.activate()`, so `session.agent.chat` is available when `load_messages()` calls `append_complete_assistant_message()`. This fixes the bug where historical sessions didn't have Chat set up correctly.
2. **Simplifies the code path** by removing the primary check that often fails
3. **Uses the correct architecture** where Chat comes from Agent
4. **Improves connection retrieval** by preferring session's model_usage over default

The implementation aligns with the refactoring goals of plan 1.2.7 and fixes the underlying bug where Chat wasn't set up correctly when restoring from history.

## Related Plans

- [1.2.7. Move Remaining Signals from Client to Chat](./1.2.7-DONE-move-signals-to-chat.md) - Parent plan
- [1.2.7.7. Remove Client from Session](./1.2.7.7-DONE-remove-client-from-session.md) - Already removed `session.client` (referenced in plan but already done)
- [1.2.7.8. Cleanup Items](./1.2.7.8-cleanup-items.md) - Related cleanup item

