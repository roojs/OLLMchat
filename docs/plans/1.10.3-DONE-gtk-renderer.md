# Table support Phase 3: GTK renderer (markdowngtk) (1.10.3)

**Status: done** – implemented (table relay, Grid, cell TextViews).

Part of the phased implementation for markdown table support; see **1.8.2-table-support-current-design.md** for the overall design and phase order. Depends on **1.10.1-renderer-interface.md** and **1.10.2-html-dummy.md**.

---

## Context (from 1.8.2)

- **Parser design**
  - Block state: `current_block` (FormatType); block detection: BlockMap.peek() at line start.
  - When BlockMap returns TABLE: parser consumes a 3-line block (header, separator, first body row) and passes lines to **handle_table_line(line)**.
  - Subsequent table rows (4th, 5th, …): passed one line at a time.
  - See 1.8.2 sections 3.0, 3.1a, 3.2.
- **Table detection**
  - We do *not* emit table start until we have the 3rd line (first body row).
  - Parser buffers: line 1 (header), line 2 (separator/alignment).
  - On line 3: emit **on_table(true)**, then header row (tr + hcells with align per cell), then that body row (tr + cells with align per cell). Parser passes **align** on each cell from a column map built when parsing line 2 (separator).
  - Rows 4+: same per-line path: tr start → cells (with format.eat()) → tr end.
  - See 1.8.2 §3.1a.
- **Cell content**
  - Same inline formatting as paragraph text: formatmap.eat() and same format handlers (on_text, on_strong, on_em, etc.) between cell start and cell end.
  - No new FormatMap; reuse existing path.
  - See 1.8.2 §3.6.

---

## Renderer interface (from 1.8.2 §6)

- **API** (RenderBase; 1.10.1 + align param below):
  - **on_table(bool start)** – table start (true) or table end (false).
  - **on_table_row(bool start)** – table row (tr) start or end.
  - **on_table_hcell(bool start, int align)** – header cell start or end (first row only). **align**: -1 = left (default), 0 = center, 1 = right.
  - **on_table_cell(bool start, int align)** – body cell start or end. **align**: -1 = left (default), 0 = center, 1 = right.
- **Cell content**
  - Sent via same path as paragraph text (on_text, on_strong, on_em, etc.) **between** cell start and cell end.

---

## Callback sequence (parser contract)

- **Order of calls** (from 1.8.2 §3.1a):
  1. **Table start**: `on_table(true)` – once, when parser has seen 3 lines (header, separator, first body row).
  2. **Header row**: `on_table_row(true)` → `on_table_hcell(true, align)` → (cell content) → `on_table_hcell(false, align)` [repeat for each header cell; parser passes **align** for that column] → `on_table_row(false)`.
  3. **Alignment**
     - Parser parses line 2 (separator) and builds a **hashmap**: column index → align (-1 left, 0 center, 1 right).
     - Parser passes **align** on each table cell (on_table_hcell and on_table_cell). No separate alignment callback.
  4. **Body rows**: For each body row (including first, line 3): `on_table_row(true)` → `on_table_cell(true, align)` → (cell content) → `on_table_cell(false, align)` [repeat per cell; parser passes align for that column] → `on_table_row(false)`.
  5. **Table end**: When next line does *not* look like a table row, parser calls `do_block(false, TABLE)` → `on_table(false)`.
- **Implications**
  - **Table** must handle alternating row/cell start–end; header row uses hcell, body rows use cell.
  - **Table** keeps **current_row** and **current_cell** only. Grid does not need total rows/columns: on cell start we **attach** a new TextView at (current_cell, current_row) and create the cell. Alignment from parser (align param on each cell).

---

## Goal

- Add table support in markdowngtk **Render** so table callbacks manage a table (Grid of cells).
- Tables render **onto the box** like other content:
  - Not nested into a textarea; no frame/child-anchor.
- **Render**: relay the four table callbacks into **Table** only.
- **Table**: handle everything, including switching the renderer's target so cell content goes to each cell's TextView.

---

## Assumptions

- **Existing code**
  - Do **not** rely on any existing Table/TableCell code (e.g. frame, child anchor, `store_cell_content`, `build_and_insert_table`).
  - When implementing: remove or replace that code.
  - Table = **Gtk.Grid** added to the box; each cell = **TextView** with its own buffer; no frame (render onto box, not into textarea).
- **Grid layout**
  - Table keeps **current_row** and **current_cell**; no need for total rows/columns.
  - On cell start: create TextView, **grid.attach**(child, current_cell, current_row, 1, 1). Row/cell indices updated on row start and cell end (e.g. on cell end increment current_cell; on row start reset current_cell, optionally increment current_row).
  - If a row has fewer/more cells than another: we just attach what we get; Grid lays out by position.
- **Alignment**
  - Parser builds column→align hashmap when parsing line 2 (separator); passes **align** (-1/0/1) on each on_table_hcell and on_table_cell.
  - Table applies align to each cell (e.g. halign on the TextView or child).

---

## Files

- **Modify:** `libocmarkdowngtk/Render.vala` – add `current_table`, override the four table methods and relay to Table.
- **Create or rewrite:** `libocmarkdowngtk/Table.vala` – owns Grid and cell TextViews; when in a cell, switches renderer's `current_buffer` / `current_textview` so all on_XXX and text go to that cell's TextView.

---

## Render.vala: relay only

- **State:** Add `Table? current_table = null`.
- **on_table(bool is_start):**
  - If start: create `Table(renderer)` (no col_count; Table uses current_row/current_cell and attach on each cell start).
  - If end: set `current_table = null` (grid was appended to box at table start).
- **on_table_row(bool is_start):** Relay to `current_table.on_row(is_start)` (or equivalent). Table handles it.
- **on_table_hcell(bool is_start, int align):** Relay to `current_table.on_hcell(is_start, align)`. Table handles it.
- **on_table_cell(bool is_start, int align):** Relay to `current_table.on_cell(is_start, align)`. Table handles it.

No cell buffering in Render – no `current_cell_text`, no `store_cell_content`. All logic lives in Table.

---

## Table: own the Grid and switch renderer target when in a cell

- **Table** owns a **Gtk.Grid**. State: **current_row**, **current_cell** (that's it; Grid does not need total rows/columns).
- When we enter a cell (on_hcell(true, align) or on_cell(true, align)):
  - Create a **TextView** for this cell; apply **align** (-1 left, 0 center, 1 right).
  - **grid.attach**(child, current_cell, current_row, 1, 1).
  - Table **sets the renderer's current_buffer and current_textview** to that cell's buffer/TextView (save previous to restore).
  - From then on, all **on_XXX** and text go to the **cell's TextView**.
- When we leave the cell (on_hcell(false, align) or on_cell(false, align)):
  - Table **restores** the renderer's `current_buffer` and `current_textview`.
  - Increment **current_cell** (next cell in same row).
- On **row start** (on_table_row(true)): reset **current_cell** to 0; if not first row, increment **current_row** (or increment current_row on row end – pick one convention).
- On table end: add the Grid to the box. No frame; no child anchor in a text area.

**Row vs header vs body:** First row after on_table(true) is header (on_table_row + on_table_hcell); subsequent rows are body (on_table_row + on_table_cell). Table only needs current_row and current_cell to know where to attach; no separate "column count" or total dimensions.

---

## Phased implementation (from 1.8.2 §7)

| Phase | Plan file | Summary |
|-------|-----------|---------|
| 1.10.1 | 1.10.1-DONE-renderer-interface.md | Add table methods to RenderBase. |
| 1.10.2 | 1.10.2-DONE-html-dummy.md | HtmlRender and DummyRenderer (tags / log). |
| **1.10.3** | **1.10.3-gtk-renderer.md** | **markdowngtk Render: Grid, Table, cell TextViews, relay.** |
| 1.10.4 | 1.10.4-table-handling.md | handle_table_line(line) in Parser. |
| 1.10.5 | 1.10.5-calling-code-types.md | handle_block_result TABLE; add() TABLE branch; handle_line_break and do_block. |
| 1.10.6 | 1.10.6-blockmap-parser.md | Table detection in BlockMap.peek(). |

---

## Proposed code (for review and approval)

Concrete Vala class definitions and Render changes. Table and TableCell are in `libocmarkdowngtk/`; Render changes are in the same library. **TableCell** is no longer used in this design (each cell is a plain **Gtk.TextView** created and attached by Table); the existing `TableCell.vala` can be removed or kept as an empty stub so the build list does not need to change.

---

### 1. Table class (`libocmarkdowngtk/Table.vala`)

Replace the existing Table (frame, anchor, store_cell_content, build_and_insert_table) with this implementation. No `col_count`; no frame; no child anchor. Grid is appended to the box at table start so the container is in the flow immediately; rows and cells are then attached to it.

```vala
namespace MarkdownGtk
{
	internal class Table
	{
		private Render renderer;
		private Gtk.Grid grid;
		private int current_row = 0;
		private int current_cell = 0;

		// Fake stack and buffer when inside table but not in a cell (avoids nulls; add() never sees null)
		private Gtk.TextView table_fake_textview;
		private Gtk.TextBuffer table_fake_buffer;
		private TopState table_fake_top_state;

		public Table(Render renderer)
		{
			this.renderer = renderer;
			this.table_fake_textview = new Gtk.TextView();
			this.table_fake_buffer = this.table_fake_textview.buffer;
			this.table_fake_top_state = new TopState(this.renderer);
			this.table_fake_top_state.initialize();
			this.renderer.current_textview = this.table_fake_textview;
			this.renderer.current_buffer = this.table_fake_buffer;
			this.renderer.top_state = this.table_fake_top_state;
			this.renderer.current_state = this.table_fake_top_state;

			this.grid = new Gtk.Grid() {
				column_homogeneous = false,
				row_homogeneous = false,
				column_spacing = 4,
				row_spacing = 4,
				margin_start = 2,
				margin_end = 2,
				margin_top = 2,
				margin_bottom = 2
			};
			if (this.renderer.box == null) {
				return;
			}
			this.renderer.box.append(this.grid);
		}

		private void set_renderer_to_fake()
		{
			this.renderer.current_textview = this.table_fake_textview;
			this.renderer.current_buffer = this.table_fake_buffer;
			this.renderer.top_state = this.table_fake_top_state;
			this.renderer.current_state = this.table_fake_top_state;
		}

		public void on_row(bool is_start)
		{
			if (is_start) {
				this.current_cell = 0;
				return;
			}
			this.current_row++;
		}

		public void on_hcell(bool is_start, int align)
		{
			if (is_start) {
				this.create_cell(align);
				return;
			}
			this.set_renderer_to_fake();
			this.current_cell++;
		}

		public void on_cell(bool is_start, int align)
		{
			if (is_start) {
				this.create_cell(align);
				return;
			}
			this.set_renderer_to_fake();
			this.current_cell++;
		}

		private void create_cell(int align)
		{
			var cell_view = new Gtk.TextView() {
				editable = false,
				cursor_visible = false,
				wrap_mode = Gtk.WrapMode.WORD,
				hexpand = true,
				vexpand = false
			};

			switch (align) {
				case 0:
					cell_view.halign = Gtk.Align.CENTER;
					break;
				case 1:
					cell_view.halign = Gtk.Align.END;
					break;
				default:
					cell_view.halign = Gtk.Align.START;
					break;
			}

			this.grid.attach(cell_view, this.current_cell, this.current_row, 1, 1);
			this.renderer.current_textview = cell_view;
			this.renderer.current_buffer = cell_view.buffer;
			this.renderer.top_state = new TopState(this.renderer);
			this.renderer.top_state.initialize();
			this.renderer.current_state = this.renderer.top_state;
		}
	}
}
```

**Render must expose** `current_textview`, `current_buffer`, `top_state`, `current_state` as **internal set** (or public set) so Table can assign them. Table does not append the fake view to the box; the grid is appended at construction. Each cell gets a new TopState(renderer) so formatting state is empty per cell.

---

### 2. TableCell (`libocmarkdowngtk/TableCell.vala`)

**Implementation choice:** Not used in the attach-per-cell design. **TableCell.vala was removed** from the tree and from `libocmarkdowngtk/meson.build` (no stub). Table cells are plain `Gtk.TextView` instances created and attached by `Table.create_cell()`.

- **meson.build:** `ocmarkdowngtk_src` lists only `Render.vala`, `RenderSourceView.vala`, `State.vala`, `TopState.vala`, `Table.vala` — no `TableCell.vala`.

---

### 3. Render changes (`libocmarkdowngtk/Render.vala`)

**3a. New state for current table**

Add after the list stack / code block handler fields (e.g. after `current_list_indentation`):

```vala
		// Table: current table when inside on_table(true)..on_table(false)
		internal Table? current_table { get; private set; default = null; }
```

**3b. Enter table**

When we enter a table, current_table = new Table(this). Table’s constructor creates the **fake** stack and buffer (table_fake_textview, table_fake_buffer, table_fake_top_state), sets renderer.current_* to them, then creates the grid and appends it to the box. So add() never sees null while inside a table.

**3c. Leaving a cell: back to fake**

When leaving a cell, Table calls its private set_renderer_to_fake() (sets renderer.current_* to Table’s table_fake_*). So we never have null while current_table != null. Entering a cell is done in Table: Table sets renderer.current_textview, current_buffer, creates TopState(renderer), initializes it, sets renderer.top_state and current_state.

**3d. Exit table**

In on_table(false): call `this.clear()`, then `this.current_table = null`, then **`this.create_textview()`** so that content after the table flows into a new TextView (same pattern as after horizontal rule or code block). Table and its fake view/buffer/state are discarded.

**3e. Table callbacks – relay to current_table**

Replace the current empty overrides with (exact implementation):

```vala
		public override void on_table(bool is_start)
		{
			if (is_start) {
				this.current_table = new Table(this);
				return;
			}
			this.clear();
			this.current_table = null;
			// Create new textview for content after the table (like on_hr / code block)
			this.create_textview();
		}

		public override void on_table_row(bool is_start)
		{
			if (this.current_table == null) {
				return;
			}
			this.current_table.on_row(is_start);
		}

		public override void on_table_hcell(bool is_start, int align)
		{
			if (this.current_table == null) {
				return;
			}
			this.current_table.on_hcell(is_start, align);
		}

		public override void on_table_cell(bool is_start, int align)
		{
			if (this.current_table == null) {
				return;
			}
			this.current_table.on_cell(is_start, align);
		}
```

**3f. add() guard**
Today `add()` errors if `current_textview == null && current_source_view_handler == null`. We avoid nulls inside a table by using a **fake stack and fake buffer**: Table's constructor sets renderer.current_* to the fake (Table owns table_fake_textview/buffer/top_state); when we leave a cell Table sets renderer.current_* back to its fake. So add() never sees null while current_table != null. No change to the add() guard is required.

---

### 4. Summary of proposed edits

| File | Action |
|------|--------|
| `Table.vala` | Replace with new class: Grid; current_row/current_cell; table_fake_textview/buffer/top_state (fake stack/buffer). Constructor creates fake, sets renderer.current_* to fake, creates grid, appends to renderer.box. On cell start set renderer.current_* to cell (new TopState); on cell end set_renderer_to_fake(). on_row/on_hcell/on_cell, create_cell. |
| `TableCell.vala` | Stub or remove (cells are plain Gtk.TextView; no TableCell instance). |
| `Render.vala` | Add current_table only. On table start current_table = new Table(this); on table end clear() and current_table = null; relay table callbacks. Render must expose current_textview, current_buffer, top_state, current_state settable. Fake stack/buffer lives in Table. |

---

## Open issues / TBD

*(Use this section to work out issues before or during implementation.)*

1. *(Add more as we work through implementation.)*

---

## Summary

| Who        | Responsibility |
|-----------|----------------|
| **Render** | Hold `current_table` only. On table start current_table = new Table(this); on table end clear() and current_table = null. Relay table callbacks to current_table. Expose current_textview, current_buffer, top_state, current_state settable. |
| **Table**  | Own Grid; **table_fake_textview**, **table_fake_buffer**, **table_fake_top_state** (fake stack/buffer); current_row, current_cell. Constructor creates fake, sets renderer.current_* to fake, creates grid, appends to box. On cell start: create TextView, grid.attach, set renderer.current_* to cell (new TopState). On cell end: set_renderer_to_fake(), increment current_cell. On row start: reset current_cell; advance current_row. Header row = hcells, body rows = cells. |
