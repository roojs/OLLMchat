# 2.1.1. File Access for Tools Using OCFiles

## Overview

Migrate all file read and write operations in tools to use the `libocfiles` library, ensuring consistent buffer-based file access, proper project context handling, and backup management for file writes.

## Status

⏳ **PLANNING** - Not yet implemented.

### Todo List

- [x] **Phase 1: FileBuffer Interface Refactor**
  - [x] Create `FileBuffer` interface in `libocfiles`
  - [x] Create `DummyFileBuffer` class in `libocfiles`
  - [x] Create `GtkSourceFileBuffer` class in `liboccoder`
  - [x] Update `File` class (add buffer property, remove read_async/write)
  - [x] Simplify `BufferProviderBase` (keep only detect_language and create_buffer)
  - [x] Simplify `BufferProvider` (GTK) (keep only detect_language and create_buffer)
  - [x] Add buffer cleanup/management logic (age check, keep top 10)
  - [x] Update `SourceView` to use file.buffer directly

- [x] **Phase 2: Fake File Support**
  - [x] Add `File.new_fake()` constructor
  - [x] Update `FileBase` to handle fake files (skip DB operations when `id < 0`)
  - [x] Ensure buffer provider works with fake files

- [x] **Phase 3: Project Context in Tools**
  - [x] Create `liboctools/` directory and `meson.build`
  - [x] Move `libollmchat/Tools/*` to `liboctools/` (change namespace to `OLLMtools`)
  - [x] Update `libollmchat/meson.build` (remove tools sources)
  - [x] Update `ollmchat/Window.vala` (import from `OLLMtools`)
  - [x] Add `ProjectManager` property to tool classes (ReadFile, EditMode, etc.)
  - [x] Update permission system to skip prompts for files in active project

- [x] **Phase 4: File Backup System**
  - [x] Add backup directory creation (`~/.cache/ollmchat/edited/`)
  - [x] Update `FileBuffer.write()` in `GtkSourceFileBuffer` (with backup logic)
  - [x] Update `FileBuffer.write()` in `DummyFileBuffer` (with backup logic)
  - [x] Add cleanup method for old backups (>3 days)

- [x] **Phase 5: Migrate RequestReadFile**
  - [x] Get/create File object from path
  - [x] Ensure buffer exists (create if needed)
  - [x] Use `file.buffer.read_async()` for entire file
  - [x] Use `file.buffer.get_text()` for line ranges
  - [x] Remove direct file I/O code

- [ ] **Phase 6: Migrate RequestEditMode**
  - [ ] Get/create File object from path
  - [ ] Ensure buffer exists (create if needed)
  - [ ] Use `file.buffer.read_async()` for reading current content
  - [ ] Use `file.buffer.write()` for writing (handles backup)
  - [ ] Remove direct file I/O code

- [ ] **Phase 7: Migrate RequestCodebaseSearch**
  - [ ] Remove custom file_cache and FileCacheEntry class
  - [ ] Use `file.buffer.get_text()` instead of custom get_code_snippet()
  - [ ] Remove get_lines() method

- [ ] **Phase 8: Testing and Validation**
  - [ ] Test file reading with line ranges
  - [ ] Test file writing with backups
  - [ ] Test fake file creation and access
  - [ ] Test project context detection
  - [ ] Test cleanup of old backups
  - [ ] Test buffer cleanup/management
  - [ ] Verify permissions are skipped for active project files

- [ ] **Phase 9: Buffer System Documentation**
  - [ ] Create `docs/buffer-system.md` documenting final architecture

## Goals

1. **Unified File Access**: All tools should access files through the `libocfiles` library using buffers
2. **Buffer-Based Operations**: File reads/writes should use buffer providers (either real GTK buffers or fake buffers)
3. **Project Context Awareness**: Tools should know which project they're working in
4. **File Backup System**: Automatic backups for files in database when writing
5. **Fake File Support**: Support for files that don't exist in the database
6. **Method Consolidation**: Move line range extraction methods back to buffers where they belong

## Current State

### Tools Using Direct File Access

1. **RequestReadFile** (`liboctools/RequestReadFile.vala`)
   - Currently uses `GLib.FileUtils.get_contents()` and `GLib.DataInputStream` directly
   - Reads line ranges manually with file streams
   - Does not use `libocfiles` File objects or buffers

2. **RequestEditMode** (`liboctools/RequestEditMode.vala`)
   - Uses `GLib.File` and `GLib.DataInputStream/DataOutputStream` directly
   - Creates temporary files in system temp directory
   - Does not use `libocfiles` File objects or buffers
   - Does not create backups before writing

3. **RequestCodebaseSearch** (`libocvector/Tool/RequestCodebaseSearch.vala`)
   - Uses `file.read_async()` from `libocfiles` (good!)
   - Has its own file cache implementation (duplicates BufferProviderBase cache)
   - Implements `get_code_snippet()` method that should be in buffers

### Buffer System Architecture

The buffer system in `libocfiles` provides:

1. **BufferProviderBase** (`libocfiles/BufferProviderBase.vala`)
   - Base class with default implementations
   - **Simplified to two methods**:
     - `detect_language(File file)` - Detect language from file extension
     - `create_buffer(File file)` - Create FileBuffer instance (no-op in base, creates DummyFileBuffer in implementation)
   - File cache: `file_cache` (path => FileCacheEntry with lines array) - can be moved to DummyFileBuffer or kept shared
   - **Removed methods** (moved to FileBuffer interface):
     - `get_buffer_text()`, `get_buffer_line_count()`, `get_buffer_line()`, `get_buffer_selection()`, `get_buffer_cursor()`, `has_buffer()`

2. **BufferProvider** (`liboccoder/BufferProvider.vala`)
   - GTK implementation
   - **Simplified to two methods**:
     - `detect_language(File file)` - Uses GtkSource.LanguageManager
     - `create_buffer(File file)` - Creates GtkSourceFileBuffer, stores in `file.buffer`
   - **Removed methods** (moved to FileBuffer interface):
     - All methods that accessed `GtkSource.Buffer` via `get_data`

3. **File Class** (`libocfiles/File.vala`)
   - Has `public FileBuffer? buffer { get; set; }` property
   - Has `manager.buffer_provider` reference (for creating buffers)
   - **Read/write operations moved to FileBuffer**:
     - `read_async()` - **REMOVED** - Use `file.buffer.read_async()` instead
     - `write(string contents)` - **REMOVED** - Use `file.buffer.write()` instead
   - Methods that use buffers (via `file.buffer`):
     - `get_contents(int max_lines = 0)` - Uses `file.buffer.get_text()`
     - `get_line_count()` - Uses `file.buffer.get_line_count()`
     - `get_line_content(int line)` - Uses `file.buffer.get_line()`
     - `get_selected_code()` - Uses `file.buffer.get_selection()`
     - `get_cursor_position()` - Uses `file.buffer.get_cursor()`

### Issues to Address

1. **Line Range Methods Scattered**
   - `RequestCodebaseSearch.get_code_snippet()` duplicates buffer functionality
   - `RequestReadFile` manually reads line ranges
   - Should be consolidated in `BufferProviderBase.get_buffer_text()`

2. **No Project Context in Tools**
   - Tools don't know which project they're working in
   - Files in active project should not require read/write permissions
   - Need to pass `ProjectManager` to tools (better than `active_project` - tools can access current active project without needing notifications when it changes)

3. **No File Backup System**
   - `File.write()` directly overwrites files
   - No backup before writing
   - Need backup location: `~/.cache/ollmchat/edited/{id}-{date YY-MM-DD}-{basename}`
   - Need cleanup method for old backups (>3 days)

4. **Fake File Support Missing**
   - No way to create File objects for files not in database
   - Tools may need to access files outside the project
   - Need constructor or factory method for fake files

## Implementation Plan

### Phase 1: FileBuffer Interface Refactor (OPTIONAL BUT RECOMMENDED)

**Goal**: Create FileBuffer interface for cleaner buffer architecture

**Decision**: This refactor improves the architecture significantly but adds complexity. Consider doing this before Phase 2-9, or defer to a later phase.

**Tasks**:
1. Create `FileBuffer` interface in `libocfiles`:
   - Methods: `get_text()`, `get_line_count()`, `get_line()`, `get_cursor()`, `get_selection()`, `has_content()`
2. Create `DummyFileBuffer` class in `libocfiles`:
   - Implements `FileBuffer` interface
   - Uses in-memory lines array (can share cache or have per-buffer cache)
   - No GTK dependencies
3. Create `GtkSourceFileBuffer` class in `liboccoder`:
   - Implements `FileBuffer` interface
   - Wraps `GtkSource.Buffer`
   - Provides access to underlying GTK buffer for GTK-specific features
4. Update `File` class:
   - Add `public FileBuffer? buffer { get; set; }` property
   - **Remove methods**: `read_async()` and `write()` - move to FileBuffer interface
   - Update methods to use `file.buffer` instead of `buffer_provider` methods:
     - `get_contents()` → `file.buffer.get_text()`
     - `get_line_count()` → `file.buffer.get_line_count()`
     - `get_line_content()` → `file.buffer.get_line()`
     - `get_selected_code()` → `file.buffer.get_selection()`
     - `get_cursor_position()` → `file.buffer.get_cursor()`
   - For read/write operations: Use `file.buffer.read_async()` and `file.buffer.write()`
5. **Simplify `BufferProviderBase`**:
   - **Keep only**: `detect_language(File file)` and `create_buffer(File file)`
   - **Remove all access methods**: `get_buffer_text()`, `get_buffer_line_count()`, `get_buffer_line()`, `get_buffer_selection()`, `get_buffer_cursor()`, `has_buffer()`
   - `create_buffer()` creates `DummyFileBuffer` instance and stores in `file.buffer`
   - **Add buffer cleanup logic**: Before creating new buffer, cleanup old buffers (see below)
   - File cache can be moved to `DummyFileBuffer` or kept in `BufferProviderBase` (shared cache)
6. **Simplify `BufferProvider` (GTK)**:
   - **Keep only**: `detect_language(File file)` and `create_buffer(File file)`
   - **Remove all access methods**: All methods that accessed `GtkSource.Buffer` via `get_data`
   - `create_buffer()` creates `GtkSourceFileBuffer` instance and stores in `file.buffer`
   - **Add buffer cleanup logic**: Before creating new buffer, cleanup old buffers (see below)
   - Remove `set_data/get_data` usage completely
7. **Add buffer cleanup/management**:
   - When `create_buffer()` is called, perform age check on existing buffers
   - Get `ProjectManager` from file: `file.manager`
   - Track open files: Add `Gee.HashMap<string, File> open_files` to `ProjectManager` (or use existing tracking)
   - Files have `last_viewed` (int64 Unix timestamp) - use this as `last_used` datetime
   - **Cleanup logic**:
     - Get all files with buffers from `ProjectManager.file_cache` where `file.buffer != null`
     - Filter out open files (files where `file.is_open == true` or in `open_files` hashmap)
     - Sort remaining files by `last_viewed` (most recent first)
     - Keep buffers for top 10 most recently used files
     - Set `file.buffer = null` for all other files (frees memory)
   - **Update `last_viewed`**: When buffer is accessed (read/write), update `file.last_viewed = DateTime.now_local().to_unix()`
7. Update `SourceView`:
   - Access `file.buffer` directly
   - Cast to `GtkSourceFileBuffer` when GTK-specific features needed (e.g., `(file.buffer as GtkSourceFileBuffer).gtk_buffer`)

**Files**:
- `libocfiles/FileBuffer.vala` (new interface)
- `libocfiles/DummyFileBuffer.vala` (new class)
- `liboccoder/GtkSourceFileBuffer.vala` (new class)
- `libocfiles/File.vala` (add buffer property, update methods, update last_viewed on buffer access)
- `libocfiles/BufferProviderBase.vala` (create DummyFileBuffer instances, add buffer cleanup)
- `liboccoder/BufferProvider.vala` (create GtkSourceFileBuffer instances, add buffer cleanup)
- `libocfiles/ProjectManager.vala` (optional: add open_files hashmap for tracking, or use file.is_open)
- `liboccoder/SourceView.vala` (use file.buffer directly)

**Alternative: Phase 1A - Enhance BufferProviderBase (Without Interface)**

If deferring the interface refactor, just enhance the current system:

**Tasks**:
1. Add method to get line range (1-based to 0-based conversion helper)
2. Ensure `get_buffer_text()` properly handles 1-based line numbers (if needed)
3. Add method to check if file exists in buffer cache
4. Document buffer lifecycle (create, use, cache, clear)

**Note**: Even without the interface refactor, consider simplifying BufferProvider to just `create_buffer()` and `detect_language()` methods, moving access methods to File class or a helper.

**Files**:
- `libocfiles/BufferProviderBase.vala`

### Phase 3: Fake File Support

**Goal**: Support File objects for files not in database

**Tasks**:
1. Add constructor or factory method to create File without database entry
   - `File.new_fake(ProjectManager manager, string path)` or similar
   - Sets `id = 0` or negative value to indicate not in database
   - Does not call `saveToDB()`
2. Update `FileBase` to handle fake files (skip DB operations when `id < 1`)
3. Ensure buffer provider works with fake files

**Files**:
- `libocfiles/File.vala`
- `libocfiles/FileBase.vala`

### Phase 4: Project Context in Tools

**Goal**: Tools know which project they're working in

**Tasks**:
1. **Create `liboctools` library**:
   - **Rationale**: Tools need `ProjectManager` from `libocfiles`, but `libollmchat` core doesn't need file system dependencies
   - **Benefits**:
     - Keeps `libollmchat` lean and focused on LLM/chat operations
     - Better separation of concerns
     - Tools can have their own dependencies without polluting core library
     - More modular architecture
   - **Structure**:
     - Create `liboctools/` directory
     - Move `libollmchat/Tools/*` to `liboctools/` (directly, no subdirectory)
     - Change namespace from `OLLMchat.Tools` to `OLLMtools`
     - Keep `libollmchat/Tool/` (base classes: Interface, RequestBase, Function, etc.) - these are core infrastructure
     - `liboctools` depends on: `libollmchat` (for `Tool.Interface`), `libocfiles` (for `ProjectManager`)
   - **Build order**: `libocfiles` → `libollmchat` → `liboctools`
2. Add `ProjectManager` reference to tool classes:
   - Pass `ProjectManager` to tool constructors (similar to `CodebaseSearchTool`)
   - Store as `project_manager` property on tool
   - Make `project_manager` optional (nullable) to maintain backward compatibility
   - Request objects access via `(this.tool as ToolType).project_manager`
   - Tools can access current active project via `project_manager.active_project` (no need to notify tools when it changes)
3. Update permission system to skip prompts for files in active project:
   - Modify `build_perm_question()` in tools
   - Check project membership before requesting permission using direct hashmap lookup:
     - `project_manager?.active_project?.project_files.child_map.has_key(file_path)` (nullable chain)

**Files**:
- `liboctools/meson.build` - **NEW**: Create build file with dependencies on libollmchat and libocfiles
- `libollmchat/meson.build` - Remove `ollmchat_tools_src` from sources, keep `Tool/` namespace files
- `liboctools/ReadFile.vala` - Add project_manager property and constructor parameter (moved from libollmchat, namespace `OLLMtools`)
- `liboctools/EditMode.vala` - Add project_manager property and constructor parameter (moved from libollmchat, namespace `OLLMtools`)
- `ollmchat/Window.vala` - Import tools from `liboctools` (namespace `OLLMtools`) instead of `libollmchat`
- Tool request classes (update permission logic to use project_manager, handle nullable case)

### Phase 5: File Backup System

**Goal**: Automatic backups before writing files in database

**Tasks**:
1. Add backup directory creation:
   - `~/.cache/ollmchat/edited/` (create if doesn't exist)
2. Update `FileBuffer.write()` method (in both GtkSourceFileBuffer and DummyFileBuffer):
   - Check if file has `id > 0` (in database) - access via File object reference
   - If in database, create backup before writing
   - Backup path: `{id}-{date YY-MM-DD}-{basename(filename)}`
   - Only create backup if doesn't exist for today (don't overwrite)
   - Update `file.last_approved_copy_path` property with backup path
   - Save file to database after backup
   - Then write to buffer and file on disk
3. Add cleanup method:
   - `ProjectManager.cleanup_old_backups()` or static method
   - Remove files older than 3 days from `~/.cache/ollmchat/edited/`
   - Call on startup or periodically

**Files**:
- `libocfiles/DummyFileBuffer.vala` (implement `write()` with backup logic)
- `liboccoder/GtkSourceFileBuffer.vala` (implement `write()` with backup logic)
- `libocfiles/ProjectManager.vala` (add cleanup method)
- `libocfiles/FileBase.vala` (ensure `last_approved_copy_path` is in DB schema)

### Phase 6: Migrate RequestReadFile

**Goal**: Use libocfiles and buffers for file reading

**Tasks**:
1. Get or create File object from path:
   - Use `ProjectManager.file_cache` or create fake file
   - Check if file exists in active project first
2. Ensure buffer exists:
   - If `file.buffer == null`, call `buffer_provider.create_buffer(file)`
3. Use buffer for reading:
   - For entire file: `yield file.buffer.read_async()` (handles file modtime checking for GTK buffers)
   - For line ranges: `file.buffer.get_text(start_line - 1, end_line - 1)` (convert 1-based to 0-based)
4. Remove direct file I/O code (`GLib.FileUtils.get_contents()`, `DataInputStream`, etc.)
5. Update error handling for files not found

**Files**:
- `liboctools/RequestReadFile.vala`

### Phase 7: Migrate RequestEditMode

**Goal**: Use libocfiles and buffers for file writing

**Tasks**:
1. Get or create File object from path:
   - Use `ProjectManager.file_cache` or create fake file
   - If file exists in database, use that File object
2. Ensure buffer exists:
   - If `file.buffer == null`, call `buffer_provider.create_buffer(file)`
3. Use buffer for reading current content:
   - `yield file.buffer.read_async()` to get current file content (handles modtime checking)
   - Use `file.buffer.get_text()` for line range operations
4. Use `file.buffer.write()` for writing:
   - This will automatically create backup if file is in database
   - Updates buffer contents and writes to file
   - No need for temporary files in system temp
5. Remove direct file I/O code (`GLib.File`, `DataInputStream`, `DataOutputStream`, etc.)
6. Update to use buffer-based line counting: `file.buffer.get_line_count()`

**Files**:
- `liboctools/RequestEditMode.vala`

### Phase 8: Migrate RequestCodebaseSearch

**Goal**: Use buffer provider instead of custom cache

**Tasks**:
1. Remove custom `file_cache` and `FileCacheEntry` class
2. Use `buffer_provider.get_buffer_text()` instead of `get_code_snippet()`
3. Remove `get_lines()` method (use buffer provider)
4. Update `get_code_snippet()` to use buffer provider:
   - Convert 1-based line numbers to 0-based
   - Use `buffer_provider.get_buffer_text(file, start_line - 1, end_line - 1)`

**Files**:
- `libocvector/Tool/RequestCodebaseSearch.vala`

### Phase 9: Testing and Validation

**Tasks**:
1. Test file reading with line ranges
2. Test file writing with backups
3. Test fake file creation and access
4. Test project context detection
5. Test cleanup of old backups
6. Test buffer cleanup/management (age check, keep top 10)
7. Verify permissions are skipped for active project files

### Phase 10: Buffer System Documentation

**Goal**: Document how the buffer system works (after all changes are complete)

**Tasks**:
1. Create documentation explaining:
   - FileBuffer interface and implementations (GtkSourceFileBuffer vs DummyFileBuffer)
   - How buffers are stored (via `file.buffer` property)
   - When to use real buffers vs dummy buffers
   - Buffer cleanup/management (age check, keep top 10 most recent)
   - How line range extraction works in buffers
   - Read/write operations in buffers (modtime checking for GTK buffers)
   - BufferProvider simplification (only `create_buffer()` and `detect_language()`)

**Files**:
- `docs/buffer-system.md` (new file)

## Technical Details

### Buffer System Architecture

#### Current Structure (Before Refactor)

**BufferProviderBase** (libocfiles):
- **One shared file cache** for all files: `file_cache` (path => FileCacheEntry)
- Methods operate on File objects but don't store buffers per-file
- Uses `get_lines()` which reads from disk and caches in shared cache
- No GTK dependencies

**BufferProvider** (liboccoder):
- Extends BufferProviderBase
- Creates **one GtkSource.Buffer per file**
- Stores buffers via `file.set_data<GtkSource.Buffer>("buffer", buffer)`
- Each file has its own GTK buffer instance

**Current Issues**:
- Buffers stored via `set_data/get_data` (not type-safe, not visible in File API)
- No unified interface - GTK buffers vs cache-based access
- File objects don't have direct `buffer` property
- Mixed responsibilities: BufferProvider manages both creation and access

#### Proposed Structure: FileBuffer Interface

**FileBuffer Interface** (libocfiles):
```vala
public interface FileBuffer : Object {
    // Read operations
    public abstract async string read_async() throws Error;  // Read file, update buffer if needed
    public abstract string get_text(int start_line = 0, int end_line = -1);
    public abstract int get_line_count();
    public abstract string get_line(int line);
    public abstract void get_cursor(out int line, out int offset);
    public abstract string get_selection(out int cursor_line, out int cursor_offset);
    public abstract bool has_content();
    
    // Write operations
    public abstract void write(string contents) throws Error;  // Write to buffer and file
}
```

**GtkSourceFileBuffer** (liboccoder):
- Wraps `GtkSource.Buffer`
- Implements `FileBuffer` interface
- Provides access to GTK buffer features (syntax highlighting, undo/redo)
- **Read behavior**: 
  - Tracks last read timestamp
  - Compares file modtime vs last read timestamp
  - If file modified since last read, reloads buffer from disk: `buffer.text = yield file.read_async()`
  - Returns buffer contents
- **Write behavior**:
  - Updates `GtkSource.Buffer.text` with new contents
  - Writes to file on disk
  - Updates last read timestamp
- One instance per file

**DummyFileBuffer** (libocfiles):
- Implements `FileBuffer` interface
- Uses in-memory lines array (can use shared cache or per-buffer cache)
- **Read behavior**:
  - Always reads file directly from disk (no timestamp checking needed)
  - Updates lines array cache
- **Write behavior**:
  - Updates lines array
  - Writes to file on disk
- No GTK dependencies
- One instance per file

**File Class Changes**:
- Add `public FileBuffer? buffer { get; set; }` property
- **Remove methods**: `read_async()` and `write()` - these move to FileBuffer interface
- Methods like `get_contents()`, `get_line_count()`, etc. use `file.buffer` directly
- For read/write: Use `file.buffer.read_async()` and `file.buffer.write()` instead

**BufferProvider Simplification**:
- **Single method**: `create_buffer(File file)` - creates and stores `FileBuffer` instance
- **Removed methods**: All access methods (`get_buffer_text()`, `get_buffer_line_count()`, etc.) move to `FileBuffer` interface
- `BufferProvider` (GTK): Creates `GtkSourceFileBuffer` wrapping `GtkSource.Buffer`, stores in `file.buffer`
- `BufferProviderBase`: Creates `DummyFileBuffer` with lines array, stores in `file.buffer`
- **Language detection**: Keep `detect_language(File file)` method (used for buffer creation)

**Benefits**:
- ✅ Type-safe buffer access (no `set_data/get_data`)
- ✅ Unified interface for GTK and non-GTK contexts
- ✅ Direct `file.buffer` property (visible in API)
- ✅ Each file has its own buffer object
- ✅ Clear separation: BufferProvider creates, FileBuffer provides access

**Migration Impact**:
- File.vala: Add `buffer` property, update methods to use `file.buffer` instead of `buffer_provider`, update `last_viewed` when buffer accessed
- BufferProviderBase: Create `DummyFileBuffer` instances, add buffer cleanup logic
- BufferProvider (GTK): Create `GtkSourceFileBuffer` instances, add buffer cleanup logic
- SourceView: Access `file.buffer` directly (cast to `GtkSourceFileBuffer` for GTK-specific features)
- Tools: Access `file.buffer` directly (works with both types via interface)
- ProjectManager: Optional - add `open_files` hashmap, or use existing `file.is_open` property

**Buffer Cleanup Logic**:
```vala
private void cleanup_old_buffers(File current_file) {
    var manager = current_file.manager;
    var files_with_buffers = new Gee.ArrayList<File>();
    
    // Collect all files with buffers
    foreach (var file_base in manager.file_cache.values) {
        if (file_base is File) {
            var file = (File) file_base;
            if (file.buffer != null && file != current_file) {
                files_with_buffers.add(file);
            }
        }
    }
    
    // Filter out open files (keep their buffers)
    var not_open_files = new Gee.ArrayList<File>();
    foreach (var file in files_with_buffers) {
        if (!file.is_open) {  // Use existing is_open property
            not_open_files.add(file);
        }
    }
    
    // Sort by last_viewed (most recent first)
    not_open_files.sort((a, b) => {
        if (a.last_viewed > b.last_viewed) return -1;
        if (a.last_viewed < b.last_viewed) return 1;
        return 0;
    });
    
    // Keep top 10, clear buffers for the rest
    for (int i = 10; i < not_open_files.size; i++) {
        not_open_files[i].buffer = null;
    }
}
```

### File Backup Format

**Path**: `~/.cache/ollmchat/edited/{id}-{date YY-MM-DD}-{basename}`

**Example**: `~/.cache/ollmchat/edited/123-25-01-15-MainWindow.vala`

**Rules**:
- Only create backup if file has `id > 0` (in database)
- Check if backup exists for today before creating
- If backup exists for today, skip (don't overwrite)
- Update `file.last_approved_copy_path` with backup path
- Save file to database after backup created

### Project Context Detection

**Method**: Direct hashmap lookup - no helper method needed

**Usage in Tools**:
- Tools have `project_manager` property (set in constructor)
- Request objects access via: `(this.tool as ReadFile).project_manager` or similar
- Before requesting permission, check directly:
  ```vala
  var in_project = project_manager?.active_project?.project_files.child_map.has_key(file_path) ?? false;
  ```
- If in active project (`in_project == true`), skip permission prompt
- If not in active project, request permission as normal
- Tools can always access current active project via `project_manager.active_project` without needing notifications

### Fake File Creation

**Constructor**:
```vala
public File.new_fake(ProjectManager manager, string path) {
    base(manager);
    this.base_type = "f";
    this.path = path;
    this.id = -1; // Indicates not in database (fake file)
}
```

**Behavior**:
- `id = -1` indicates fake file (not in database)
- `id = 0` indicates new file (will be inserted)
- `id > 0` indicates existing file (will be updated)
- `saveToDB()` should skip if `id < 0`
- Buffer provider works normally (uses file cache)
- Can be converted to real file if added to project later

## Files to Modify

### Core Library Files
- `libocfiles/FileBuffer.vala` - **NEW**: FileBuffer interface (if doing Phase 1 refactor)
- `libocfiles/DummyFileBuffer.vala` - **NEW**: Dummy buffer implementation (if doing Phase 1 refactor)
- `liboccoder/GtkSourceFileBuffer.vala` - **NEW**: GTK buffer wrapper (if doing Phase 1 refactor)
- `libocfiles/BufferProviderBase.vala` - Enhance buffer methods OR create DummyFileBuffer instances
- `libocfiles/File.vala` - Add fake file constructor, update write() with backup, add buffer property (if doing Phase 1)
- `libocfiles/FileBase.vala` - Handle fake files in DB operations
- `libocfiles/ProjectManager.vala` - Add project context helpers, cleanup method
- `liboccoder/BufferProvider.vala` - Create GtkSourceFileBuffer instances (if doing Phase 1)
- `liboccoder/SourceView.vala` - Use file.buffer directly (if doing Phase 1)
- `liboctools/meson.build` - **NEW**: Create build file with dependencies on libollmchat and libocfiles

### Tool Files
- `liboctools/ReadFile.vala` - Add project_manager property and constructor parameter (moved from libollmchat, namespace `OLLMtools`)
- `liboctools/EditMode.vala` - Add project_manager property and constructor parameter (moved from libollmchat, namespace `OLLMtools`)
- `liboctools/RequestReadFile.vala` - Migrate to use buffers, access project_manager from tool (moved from libollmchat, namespace `OLLMtools`)
- `liboctools/RequestEditMode.vala` - Migrate to use buffers and backups, access project_manager from tool (moved from libollmchat, namespace `OLLMtools`)
- `liboctools/meson.build` - **NEW**: Create build file with dependencies on libollmchat and libocfiles
- `libocvector/Tool/RequestCodebaseSearch.vala` - Use buffer provider instead of custom cache

### Documentation
- `docs/buffer-system.md` - New file documenting buffer architecture

## Dependencies

### Current Dependency Tree
```
libocsqlite (no deps)
  └─ libocfiles (depends on libocsqlite)
  └─ libocagent (no deps)
  └─ libollmchat (depends on libocsqlite, libocagent)
      └─ libocvector (depends on libocsqlite, libollmchat, libocfiles)
      └─ liboccoder (depends on libocsqlite, libocagent, libocfiles, libocvector, libollmchat)
```

### Required Changes

**Create `liboctools` Library**

**Rationale**: Tools need `ProjectManager` from `libocfiles`, but `libollmchat` core doesn't need file system dependencies. Separating tools into their own library provides better separation of concerns.

**New Dependency Tree**:
```
libocsqlite (no deps)
  └─ libocfiles (depends on libocsqlite)
  └─ libocagent (no deps)
  └─ libollmchat (depends on libocsqlite, libocagent)
      └─ liboctools (depends on libollmchat, libocfiles)  ← NEW
      └─ libocvector (depends on libocsqlite, libollmchat, libocfiles)
      └─ liboccoder (depends on libocsqlite, libocagent, libocfiles, libocvector, libollmchat)
```

**Changes Required**:
1. **Create `liboctools/` directory**:
   - Move `libollmchat/Tools/*` to `liboctools/` (directly, no subdirectory)
   - Change namespace from `OLLMchat.Tools` to `OLLMtools`
   - Keep `libollmchat/Tool/` (base classes stay in core library)
   - Create `liboctools/meson.build` with dependencies on `libollmchat` and `libocfiles`
2. **Update `libollmchat/meson.build`**:
   - Remove `ollmchat_tools_src` from sources
   - Keep `Tool/` namespace files (these are core infrastructure)
3. **Update `ollmchat/Window.vala`**:
   - Import tools from `liboctools` (namespace `OLLMtools`) instead of `libollmchat` (namespace `OLLMchat.Tools`)
4. **Dependency Safety**:
   - ✅ **SAFE**: No circular dependencies
   - ✅ **SAFE**: `libocfiles` doesn't depend on `libollmchat`
   - ✅ **SAFE**: `libollmchat` doesn't need file system dependencies
   - ✅ **SAFE**: Tools can evolve independently

**Build Order**:
- `libocfiles` → `libollmchat` → `liboctools`

### Other Dependencies

- Existing `libocfiles` library (dependency for `liboctools`)
- `liboccoder` for GTK buffer provider (optional, for GUI - already depends on `libocfiles`)
- File system access for backups (`~/.cache/ollmchat/edited/`)

## Testing Checklist

- [ ] File reading with line ranges works via buffers
- [ ] File writing creates backups for database files
- [ ] Fake files can be created and accessed
- [ ] Files in active project skip permission prompts
- [ ] Backup cleanup removes files older than 3 days
- [ ] Line range extraction works correctly (1-based to 0-based conversion)
- [ ] Buffer cache works for multiple file reads
- [ ] Codebase search uses buffer provider correctly

## Notes

### Buffer Architecture Decision

**Current State**:
- One shared file cache in `BufferProviderBase` (for all files)
- One `GtkSource.Buffer` per file in `BufferProvider` (stored via `set_data`)
- No unified interface - mixed access patterns

**Proposed: FileBuffer Interface**:
- Each file has its own `FileBuffer` instance (via `file.buffer` property)
- `GtkSourceFileBuffer` wraps GTK buffers for GUI contexts
- `DummyFileBuffer` provides non-GTK buffer for tools/CLI
- Unified interface makes code cleaner and more maintainable

**Recommendation**: Consider implementing Phase 1 (FileBuffer interface) before other phases, as it will simplify the rest of the implementation. However, it can be deferred if time is limited.

### Architectural Decision: liboctools Library

**Decision: Create `liboctools` Library**

**Benefits**:
- ✅ Keeps `libollmchat` lean and focused on LLM/chat operations
- ✅ Better separation of concerns (tools are separate from core chat functionality)
- ✅ Tools can evolve independently with their own dependencies
- ✅ Easier to add more tools without bloating core library
- ✅ Clear dependency boundaries
- ✅ More modular architecture

### Other Notes

- Buffer system is already partially implemented but not fully utilized
- Some methods were moved out of buffers but should be moved back
- Backup system is minimal (just file copy, no diff/merge)
- Cleanup runs on startup or can be called manually
- Fake files allow tools to work with files outside the project scope

### Review: File Class Methods

**TODO: Review whether File class methods should be moved to FileBuffer**

The following methods in `File.vala` currently delegate to `file.buffer` but may be better placed directly in the buffer:

- `get_contents(int max_lines = 0)` - Delegates to `buffer.get_text()`
- `get_line_count()` - Delegates to `buffer.get_line_count()`
- `get_selected_code()` - Delegates to `buffer.get_selection()` and updates cursor position
- `get_line_content(int line)` - Delegates to `buffer.get_line()`
- `get_cursor_position()` - Delegates to `buffer.get_cursor()` and updates cursor position

**Consideration**: These methods add database persistence logic (saving cursor position, etc.) on top of buffer operations. Should this logic:
1. Stay in File class (current approach - File manages persistence)
2. Move to FileBuffer (buffer manages its own persistence)
3. Be split - buffer operations in FileBuffer, persistence logic in File

**Decision needed**: Review after Phase 1 completion to determine best architecture.

### Optimization: Diff-Based SourceView Rendering

**TODO: Use diff tool to only update changed lines in SourceView**

Currently, when updating the SourceView (e.g., when applying edits or refreshing), the entire buffer content is replaced. For better performance, especially with large files, we should:

1. Compare new buffer contents with current displayed contents
2. Use a diff tool to identify changed lines
3. Only update the changed lines in the SourceView, preserving unchanged portions

This would be particularly beneficial for:
- Large files where only small portions change
- Reducing UI rendering overhead
- Maintaining cursor position and scroll state more accurately
- Better user experience with smoother updates

**Implementation considerations**:
- Add diff calculation in `SourceView` when updating buffer contents
- Use a lightweight diff algorithm (e.g., Myers diff algorithm)
- Fall back to full replacement if diff calculation fails or is too complex
- Consider caching displayed contents for comparison

**Files to modify**:
- `liboccoder/SourceView.vala` - Add diff-based rendering logic when updating buffer

