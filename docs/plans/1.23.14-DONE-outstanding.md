# 1.23.14 Outstanding — existing skill code

**Parent:** 1.23.14. **Dependencies:** 1.23.11, 1.23.13, 1.23.15, 1.23.17.

**Coding standards:** `.cursor/rules/CODING_STANDARDS.md`. Before implementing any section, verify the checklist (nullable types, null checks, string interpolation, temporaries, braces, `this.`, GLib prefix, property init, line length, StringBuilder/string-in-loops, string arrays, continue-in-loops, no underscore prefix, get_* vs properties, etc.).

---

## 1. Definition fetching — DONE

- **Manager methods:** **fetch(Task)** — skill name from `task.task_data.get("Skill").to_markdown().strip()`, return `by_name.get(skill_name)` (Definition; always present after validate). **validate(Task)** — return **bool** (true if skill exists, false otherwise); **caller** generates the error message.
- **Invariant:** Any call to fetch(Task) happens after validate; no null checks needed at call sites.
- **Caller:** Task (Details) uses **this.skill_manager.fetch(this)** and **this.skill_manager.validate(this)**. **Details** has **skill_manager** as a public alias to **runner.sr_factory.skill_manager**. Runner: **sr_factory** is public.
- **Definition API used:** `definition.skill_input_requirements()` (refine), `definition.header`, `definition.full_content`. **skill_input_requirements()** on Definition — **DONE**.

---

## 2. Task naming and output references

- **Moved to 1.23.18-tail-end-issues** (§1). Task naming, output reference format (`#slug-number-results`), and resolution of task output refs.

---

## 3. Resolving references — DONE

- **Reference in:** Task list "References" → Details **reference_targets** (Gee.ArrayList<Format>, from `task_data.get("References").links()`). Href forms: `#anchor`, `output:task` (or `#slug-number-results`), http(s), absolute path.
- **Who resolves:** Details **reference_contents()** (private) loops reference_targets; for each href: if not absolute path → **runner.reference_content(href)**; if absolute → project_manager.get_file_from_active_project / File.new_fake + buffer_provider.create_buffer + get_contents(0).
- **Runner.reference_content(href):** **DONE.** Resolves #anchor from user_request.headings; output:/http(s) return "". File refs in Details (project manager).
- **validate_reference_targets()** (Details): Validates href forms (#, output:, http, absolute path exists); does not fetch content. **FIXME:** validate #anchor format and existence — see **1.23.18-tail-end-issues** §2.

**Implemented: reference_content + reference_link_contents**

**1. Runner (liboccoder/Skill/Runner.vala)** — add public method `reference_content(string href)`:

- Inline: if `href.has_prefix("#")` and `user_request != null` and `user_request.headings.has_key(anchor)` (anchor = `href.substring(1)`), return that block’s content; otherwise return `""`. **output:** / **http(s)** deferred.
- **Why `to_markdown_with_content()`:** We need the heading plus the section body (full section). `to_markdown()` on the block would be only the heading line; `to_markdown_with_content()` is “heading line plus section body” (Block.vala).

```vala
/** Resolve non-file reference content for task refs. #anchor → user_request section; output:/http(s) deferred. */
public string reference_content(string href)
{
	var anchor = href.has_prefix("#") ? href.substring(1) : "";
	if (anchor != "" && this.user_request != null && this.user_request.headings.has_key(anchor)) {
		return this.user_request.headings.get(anchor).to_markdown_with_content();
	}
	return "";
}
```

**2. Details (liboccoder/Task/Details.vala)** — add **reference_link_contents(link, contents)** and use it in **reference_contents()**.

**New helper** — `reference_link_contents(Markdown.Document.Format link, string contents)`:

- Output:
  - **Reference information for** `link.title`
  - **The contents of** `link.href`
  - Fenced code block with `contents` (use tildes when content has line-start ```, else backticks, same as current reference_block).
- Skip (return "") when `contents == ""`.

```vala
private string reference_link_contents(Markdown.Document.Format link, string contents)
{
	if (contents == "") {
		return "";
	}
	var fence = (contents.contains("\n```") || contents.has_prefix("```")) ? "~~~~" : "```";
	return "Reference information for " + link.title + "\n\nThe contents of " + link.href + "\n\n" + fence + "\n" + contents + "\n" + fence + "\n\n";
}
```

**reference_contents()** — use it for every link (non-absolute and absolute):

Replace the loop body so both branches use `reference_link_contents(link, …)`:

```vala
if (!GLib.Path.is_absolute(link.href)) {
	ret += this.reference_link_contents(link, this.runner.reference_content(link.href));
	continue;
}
var found = this.runner.sr_factory.project_manager.get_file_from_active_project(link.href);
if (found == null) {
	found = new OLLMfiles.File.new_fake(this.runner.sr_factory.project_manager, link.href);
}
this.runner.sr_factory.project_manager.buffer_provider.create_buffer(found);
ret += this.reference_link_contents(link, found.get_contents(0));
```

Keep **reference_block(string target, string content)** for executor_precursor (Tool call / Tool call Output); only the reference_targets loop uses **reference_link_contents**.

**Completion:** Runner has `reference_content(string href)` (#anchor → user_request.headings, else ""). Details has `reference_link_contents(link, contents)` (output: "Reference information for " + link.title + "\n\nThe contents of " + link.href + fenced contents). reference_contents() uses reference_link_contents for both non-absolute and absolute links. Build verified.

---

## 4. Current file issues — DONE

- **Where used:** Runner **task_creation()** fills placeholder "current_file" — currently empty string. Details **refine()** fill passes current file content (stubbed `""`).
- **Public property forbidden:** Use a method that returns **File or null** instead of a string property.
- **Do not check if project_manager exists** — it will always exist (see "We must fix" at end of plan).
- **project_manager on sr_factory, not Runner:** Move **project_manager** to **Skill.Factory** (sr_factory). Runner and Details get it via `this.runner.sr_factory` (or factory). We must fix all project_manager references to use the factory.

**Design:**

- **Skill.Factory** holds **project_manager** (required). **Factory** has a method **`current_file()`** returning **`OLLMfiles.File?`** (null when no active file). The method ensures the buffer is there: call **`this.project_manager.buffer_provider.create_buffer(file)`** before returning the file (so callers can safely call `file.get_contents(200)`).
- **Call site (Runner.task_creation and Details.refine):** Get file from factory, then format with header:
  - `var file = this.sr_factory.current_file();`
  - `"current_file", file == null ? "" : tpl.header("Current File - " + file.path, file.get_contents(200))`

**Concrete code:**

**1. Skill.Factory (liboccoder/Skill/Factory.vala)** — add project_manager and current_file():

```vala
public class Factory : OLLMchat.Agent.Factory
{
	public OLLMfiles.ProjectManager project_manager { get; private set; }
	public Manager skill_manager { get; private set; }
	public string skill_name { get; private set; }

	public Factory(OLLMfiles.ProjectManager project_manager, Gee.ArrayList<string> skills_directories, string skill_name = "")
	{
		this.name = "skill-runner";
		this.title = "Skills Agent";
		this.project_manager = project_manager;
		this.skill_manager = new Manager(skills_directories);
		this.skill_name = skill_name != "" ? skill_name : "task_creator";
	}

	/** Returns active file; ensures buffer exists so caller can call get_contents(). */
	public OLLMfiles.File? current_file()
	{
		var file = this.project_manager.active_file;
		if (file == null) {
			return null;
		}
		this.project_manager.buffer_provider.create_buffer(file);
		return file;
	}

	public override OLLMchat.Agent.Base create_agent(OLLMchat.History.SessionBase session)
	{
		return new Runner(this, session);
	}
}
```

Call site that creates Factory (e.g. Window.vala) must pass project_manager: `new OLLMcoder.Skill.Factory(this.project_manager, skills_dirs, "")`.

**2. Runner (liboccoder/Skill/Runner.vala)** — remove project_manager property; use sr_factory:

- Delete: `public OLLMfiles.ProjectManager? project_manager { get; set; default = null; }`
- In **env()**: replace `this.project_manager` with `this.sr_factory.project_manager` (e.g. `this.sr_factory.project_manager.active_project`).
- In **task_creation()**:

```vala
var file = this.sr_factory.current_file();
var open_files_list = "";
tpl.fill(
	"user_prompt", tpl.header("User Prompt", user_prompt),
	"environment", tpl.header("Environment", this.env(), false),
	"project_description", "",
	"current_file", file == null ? "" : tpl.header("Current File - " + file.path, file.get_contents(200)),
	"open_files", open_files_list,
	"previous_proposal", previous_proposal == "" ? "" : tpl.header("Previous Proposal", previous_proposal),
	"previous_proposal_issues", previous_proposal_issues == "" ? "" : tpl.header("Previous Proposal Issues", previous_proposal_issues),
	"skill_catalog", this.sr_factory.skill_manager.to_markdown());
```

**3. Details (liboccoder/Task/Details.vala)** — use runner.sr_factory:

- In **refine()** fill:

```vala
var file = this.runner.sr_factory.current_file();
"current_file", file == null ? "" : tpl.header("Current File - " + file.path, file.get_contents(200)),
```

- In **reference_contents()**: replace `this.runner.project_manager` with `this.runner.sr_factory.project_manager`:

```vala
var found = this.runner.sr_factory.project_manager.get_file_from_active_project(link.href);
if (found == null) {
	found = new OLLMfiles.File.new_fake(this.runner.sr_factory.project_manager, link.href);
}
this.runner.sr_factory.project_manager.buffer_provider.create_buffer(found);
ret += this.reference_block(link.href, found.get_contents(0));
```

**Completion (implemented):** Skill.Factory now has `project_manager` and `current_file()`; constructor takes `(OLLMfiles.ProjectManager, Gee.ArrayList<string>, string)`. Runner no longer has `project_manager`; `env()` and `task_creation()` use `sr_factory.project_manager` and `sr_factory.current_file()`. Details.refine() and reference_contents() use `runner.sr_factory.current_file()` and `runner.sr_factory.project_manager`. Window.vala creates Factory with `new OLLMcoder.Skill.Factory(this.project_manager, skills_dirs, "")`. Build verified.

---

## 5. Validate tasks — DONE

- **Manager.validate(Task):** Returns **bool** (true = valid). Caller builds the error message when false. **DONE.**
- **List.validate_skills():** **DONE.** Implemented in List.vala; called from Runner.send_async after parse (flow uncommented).
- **5.1 flow:** Uncommented. **sr_factory.current_file()**, project_manager on Factory, and **Runner.reference_content(href)** are **DONE** (§4, §3).

---

## 5.1 Call sites for Manager.validate — DONE

- **Current state:** **Manager.validate(Task)** and **List.validate_skills()** are implemented. **Runner.send_async** task-list flow (parse → validate_skills → task_list → handle_task_list) is **uncommented**. **Runner.task_list** property added; **request_writer_approval** and **run_task_list_iteration** implemented on Runner so the flow compiles.
- All 5.1 items implemented (§3 reference_content, §4 current_file/project_manager on Factory).

**List (`liboccoder/Task/List.vala`)** — implemented (per CODING_STANDARDS: `continue` in loop). For reference:

```vala
/**
 * For each task (steps → children), call task.skill_manager.validate(task).
 * When false, add issue line: skill must be one of the available skills.
 * Returns combined issues string; "" when all tasks' skills exist.
 */
public string validate_skills()
{
	var issues = "";
	foreach (var step in this.steps) {
		foreach (var t in step.children) {
			if (t.skill_manager.validate(t)) {
				continue;
			}
			 
			var skill_name = t.task_data.get("Skill").to_markdown().strip();
			issues += "Task references skill \"" + skill_name + "\", which is not in the available skills list.\n";
		}
	}
	return issues;
}
```

**Runner.send_async** — (uncommented.) After `parser.parse_task_list()` and when `parser.issues == ""`:

- Call **var skill_issues = parser.task_list.validate_skills();**
- If **skill_issues != ""**, set **parser.issues = skill_issues** (or append), then continue the retry loop (previous_proposal / previous_proposal_issues).
- If **skill_issues == ""**, then assign **this.task_list = parser.task_list**, yield **handle_task_list()**, and return.

*(So validate_skills runs only when parse succeeded; when it fails, the existing retry path with previous_proposal_issues is used.)*

---

## 6. Skill catalog — DONE

- **Manager.to_markdown()** — Implemented. Not “catalog string”. Returns a string: one line per skill, format **`**Skillname** - description`**. Name and description from each Definition’s header. That’s all it returns.

- **Caller:** Runner `task_creation()` fills `"skill_catalog"` with `this.sr_factory.skill_manager.to_markdown()` (no header wrapper; template has "Available Skills" heading and intro paragraph before `{skill_catalog}`).
- **Template:** task_creation_initial.md has the heading, intro text, and placeholder; skills without descriptions never load (Definition validates).

---

## FIXME list (code commented out until implemented)

**What is skill input requirements?** It is the **piece of the skill file** that describes how to invoke that skill: parameter schema, call format, required/optional arguments (the skill’s execution spec). It is **input to the refine stage**, not the output. At refine we already have the skill name (from the coarse task). We **inject** that skill’s input-requirements block into the refinement prompt via `{skill_input_requirements}` so the refiner knows exactly what arguments and syntax to produce. The refiner **outputs** the refined task including the **Skill call** (concrete arguments). So: skill input requirements = “how to call this skill” (from the skill file); used only at **refine** (Details.refine() → template placeholder `{skill_input_requirements}`). See 1.23.4.

- **Definition.skill_input_requirements()** — **DONE.** Implemented on Definition; used in Details.refine() for `{skill_input_requirements}`.
- **sr_factory.current_file()** — **DONE.** Method on Skill.Factory returning File?; project_manager on Factory. §4 implemented; Runner.task_creation() and Details.refine() now fill `{current_file}` from factory.current_file().
- **Runner.reference_content(href)** — **DONE.** Implemented on Runner; Details.reference_contents() uses it and reference_link_contents(link, contents) for all refs. §3 implemented.
- **ListItem.key_value(Block)** and **List.to_key_map()** — **DONE.** Implemented in libocmarkdown (ListItem.vala, List.vala). ResultParser uses **list_block.to_key_map()** in parse_task_list and extract_refinement.
- **Factory access:** ResultParser builds Details with the runner’s factory. `OLLMchat.Agent.Base.factory` is protected, so `this.runner.factory` was denied. **Fix:** use **this.runner.sr_factory** (public on Runner, returns `Skill.Factory` which is an `Agent.Factory`). Details constructor accepts `OLLMchat.Agent.Factory`, so passing `runner.sr_factory` is correct. *(Already fixed in code; nothing to uncomment.)*

**Can we uncomment yet?** 5.1 flow is uncommented. All items below implemented.

**Remaining to be added (stub at call site only until implemented):**

| Item | Where to add | Call site (currently stubbed) |
|------|----------------|-------------------------------|
| ~~`current_file()` (method on Factory) + project_manager on Factory~~ | ~~Factory.vala~~ | **DONE** §4 |
| ~~`reference_content(href)` + reference_link_contents(link, contents)~~ | ~~Runner.vala, Details.vala~~ | **DONE** §3 |

---

## to_key_map — one approved format (List + ListItem) — DONE

**Document model:** A ListItem does not have a paragraph wrapper. Its **children** are the content directly — typically **Format**/inline nodes (BOLD, TEXT, LINK, etc.). A **List**'s children are **ListItems**. One list item = one row (e.g. **What is needed** — text, or **Skill** — text).

- **ListItem.key_value(Block value)** — instance method on **this** ListItem. Caller creates the value block and passes it in; we append the rest of this.children (tail) to value.children. **Return value is the key** (string). Only checks first child; only **BOLD_ASTERISK**. If first child is not BOLD_ASTERISK → return "". No copy, no adopt — just append to value's child array.
- **List.to_key_map()** — run on a **List** block. The List's children are ListItems. It just iterates this.children and for each ListItem calls key_value(value), then result.set(key, value). Caller creates a new Block for each item and passes it to key_value.

**Implementation (for review).** No copy, no adopt — just append each tail node to value's child array.

```vala
/**
 * Get key from this list item and fill value with the rest (operates on this).
 * Caller creates value and passes it in. Only checks first child; only BOLD_ASTERISK.
 * If first child is not BOLD_ASTERISK → return "". Else return first child's text and append tail to value.children.
 */
public string key_value(Block value)
{
	if (this.children.size == 0) {
		return "";
	}
	var first = this.children.get(0);
	if (!(first is Format) || ((Format) first).kind != FormatType.BOLD_ASTERISK) {
		return "";
	}
	var key = ((Format) first).text_content().strip();
	for (var i = 1; i < this.children.size; i++) {
		value.children.add(this.children.get(i));
	}
	return key;
}

}
```

**Add to `libocmarkdown/document/List.vala`:**

```vala
/**
 * Build a map from this list: children are ListItems. Iterate and call key_value on each; key = return value, value = caller-created block.
 */
public Gee.Map<string, Block> to_key_map()
{
	var result = new Gee.HashMap<string, Block>();
	foreach (var node in this.children) {
		var item = node as ListItem;
		if (item == null) {
			continue;
		}
		var v = new Block(FormatType.PARAGRAPH);
		var k = item.key_value(v);
		if (k == "") {
			continue;
		}
		result.set(k, v);
	}
	return result;
}
```

---

## Remaining tasks → 1.23.18-tail-end-issues

- **Task naming and output references**, **validate_reference_targets #anchor**, **validate_task_list_reference_lengths**, **Naming / other** (run_until_writer, has_writer_tasks, etc.): see **docs/plans/1.23.18-tail-end-issues.md**.

---

## We must fix: project_manager references — DONE

- **project_manager** now lives on **sr_factory** (Skill.Factory), not on Runner. Factory is constructed with project_manager (required). Implemented §4; Window.vala passes `this.project_manager` to Factory.
- Call sites (Runner, Details) get it via **this.sr_factory.project_manager** or **this.runner.sr_factory.project_manager**, and use **sr_factory.current_file()** for current file. All references updated.
