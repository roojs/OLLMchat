# 2.6.1.2. File Monitor Support

## Overview

Implement filesystem monitoring using inotify to track file changes during command execution. This phase creates the monitoring infrastructure that will be used by overlay systems in later phases.

## Status

⏳ **PLANNING** - Design phase.

## Prerequisites

- Phase 1 (2.6.1.1) must be completed
- See main plan: `2.6.1-code-exec-improvements.md` for general architecture

## Goals

1. Create `Monitor` class for inotify-based filesystem monitoring
2. Implement directory monitoring for overlay subdirectories
3. Track files/folders that were written/added during execution
4. Provide simple HashMaps of changes (path => FileBase, not detailed event logs)

## Implementation Details

### Files to Create

- `liboctools/RunCommand/Monitor.vala` - inotify-based filesystem change detection

### Monitor Class Design

The `Monitor` class provides filesystem change detection using GLib's FileMonitor API (which uses inotify on Linux). It tracks file and directory changes during command execution and maintains simple HashMaps of changes (path => FileBase).

#### Class Structure

```vala
namespace OLLMtools.RunCommand
{
    public class Monitor : Object
    {
        // Properties
        public Gee.HashMap<string, OLLMfiles.FileBase> added { get; private set; }
        public Gee.HashMap<string, OLLMfiles.FileBase> removed { get; private set; }
        public Gee.HashMap<string, OLLMfiles.FileBase> updated { get; private set; }
        
        // Private fields
        private OLLMfiles.Folder project_folder;
        private string base_path;
        private Gee.HashMap<string, string> overlay_map;
        private Gee.HashMap<OLLMfiles.Folder, GLib.FileMonitor> monitors;
        private Gee.HashMap<GLib.FileMonitor, ulong> signal_handlers;
        private bool is_monitoring;
        
        // Constructor
        public Monitor(OLLMfiles.Folder project_folder, string base_path, Gee.HashMap<string, string> overlay_map) throws Error;
        
        // Public methods
        public void start() throws Error;
        public async void stop();
        
        // Private methods
        private void on_file_changed(GLib.File file, GLib.File? other_file, GLib.FileMonitorEvent event);
        private void handle_directory_created(string dir_path);
        private void handle_file_created(string file_path);
        private void handle_file_modified(string file_path);
        private void handle_file_deleted(string file_path);
        private OLLMfiles.File? create_filebase_from_path(string file_path);
        private string to_real_path(string overlay_path);
    }
}
```

#### Constructor: `Monitor(OLLMfiles.Folder project_folder, string base_path, Gee.HashMap<string, string> overlay_map)`

**Purpose**: Initialize a Monitor instance for a specific directory with overlay path mapping support.

**Parameters**:
- `project_folder` (OLLMfiles.Folder): Project folder (provides access to `project_files` property for looking up existing files)
- `base_path` (string): Base path of the overlay (e.g., `/home/alan/.cache/ollmchat/overlay-12345/upper`)
- `overlay_map` (Gee.HashMap<string, string>): Maps overlay path segments to real project paths (e.g., `"overlay1" -> "/home/alan/project"`)

**Implementation**:
1. Store `project_folder` reference
2. Store `base_path` reference
3. Store `overlay_map` reference

**Note**: All properties (`added`, `removed`, `updated`, `monitors`) are automatically initialized by Vala property getters with default values, so no explicit initialization is needed. Since we're monitoring an overlay filesystem that starts empty, there are no known paths initially.

**Note**: No validation is performed - the Folder object is assumed to be valid and already verified by the system that created it.

**Example**:
```vala
var overlay_map = new Gee.HashMap<string, string>();
overlay_map.set("overlay1", "/home/alan/project");
var monitor = new Monitor(project_folder, "/home/alan/.cache/ollmchat/overlay-12345/upper", overlay_map);
```

#### Method: `start()`

**Purpose**: Begin monitoring the overlay subdirectories for filesystem changes.

**Implementation**:
1. Iterate over `overlay_map` entries:
   - For each entry (overlay_key, real_path), construct overlay subdirectory path: `base_path + "/" + overlay_key` (e.g., `base_path + "/overlay1"`)
   - Get `GLib.File` object for the overlay subdirectory path
   - Create `GLib.FileMonitor` using `file.monitor_directory()` with flags:
     - `GLib.FileMonitorFlags.WATCH_MOVES` (to detect move/rename operations)
   - Connect to `changed` signal and store handler ID:
     - `ulong handler_id = monitor.changed.connect(on_file_changed)`
     - Store in `signal_handlers` HashMap: `signal_handlers.set(monitor, handler_id)`
   - Create a Folder object for the real project path (not the overlay path):
     - Look up Folder in `project_folder.project_files.folder_map.get(real_path)`
     - If not found, create new Folder: `var folder = new Folder(project_folder.manager)` and set `folder.path = real_path`
   - Add FileMonitor to `monitors` HashMap: `monitors.set(folder, monitor)`
2. Set `is_monitoring = true`

**Throws**: `GLib.IOError` if monitoring cannot be started

**Usage**:
```vala
monitor.start();
// ... execute command ...
yield monitor.stop();
```

#### Method: `stop()`

**Purpose**: Stop all monitoring and finalize change lists. Uses async/await with idle callback to ensure all pending inotify events are processed before cancellation.

**Implementation**:
1. Set `is_monitoring = false` (prevents new events from being processed)
2. Defer actual cancellation to idle callback to allow pending events to be processed:
   - Create `SourceFunc callback = stop.callback` to get async continuation
   - Use `Idle.add()` to schedule cancellation after event loop processes pending events:
     ```vala
     Idle.add(() => {
         // Disconnect all signal handlers and cancel all FileMonitors:
         // Iterate over monitors.values (FileMonitors)
         // For each FileMonitor:
         //   Get handler ID from signal_handlers
         //   Disconnect signal: monitor.disconnect(handler_id)
         //   Call cancel() on FileMonitor
         // Clear monitors HashMap
         // Clear signal_handlers HashMap
         // Finalize change HashMaps (no deduplication needed)
         callback(); // Resume async method
         return false; // Don't repeat
     });
     ```
3. `yield` to wait for idle callback to complete

**Note**: After `stop()` completes, the properties (`added`, `removed`, `updated`) contain the final change HashMaps. All pending inotify events will have been processed before cancellation.

**Usage**:
```vala
yield monitor.stop();
var added_files = monitor.added; // Now available
```

#### Private Method: `on_file_changed(GLib.File file, GLib.File? other_file, GLib.FileMonitorEvent event)`

**Purpose**: Event handler for filesystem change events from GLib.FileMonitor.

**Parameters**:
- `file` (GLib.File): The file or directory that changed
- `other_file` (GLib.File?): For move/rename events, the destination file
- `event` (GLib.FileMonitorEvent): The type of event that occurred

**Implementation**:
1. Check if monitoring (`is_monitoring`), if not:
   - Emit `GLib.warning()` and return (events may arrive after stop, but should be handled by then)
2. Get absolute path from `file.get_path()` (or `file.get_uri()` if path is null) - this is the overlay path
3. Convert overlay path to real path using `to_real_path(path)`
4. Switch on `event` type:
   - `G_FILE_MONITOR_EVENT_CREATED`:
     - Check if real path is a directory using `GLib.FileUtils.test(real_path, GLib.FileTest.IS_DIR)`
     - If directory: call `handle_directory_created(real_path)`
     - If file: call `handle_file_created(real_path)`
   - `G_FILE_MONITOR_EVENT_CHANGED`:
     - Check if real path is a file (not directory) using `GLib.FileUtils.test(real_path, GLib.FileTest.IS_REGULAR)`
     - If file: call `handle_file_modified(real_path)`
   - `G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED`:
     - Check if real path is a file (not directory) using `GLib.FileUtils.test(real_path, GLib.FileTest.IS_REGULAR)`
     - If file: call `handle_file_modified(real_path)` (treat permission changes same as modifications)
     - TODO: Track permission changes (chmod +x) - currently treated as modification
   - `G_FILE_MONITOR_EVENT_DELETED`:
     - Call `handle_file_deleted(real_path)`
   - `G_FILE_MONITOR_EVENT_MOVED`:
     - Handle as delete + create operation:
       - Get source path from `file.get_path()` and convert to real path
       - Get destination path from `other_file.get_path()` (if not null) and convert to real path
       - Call `handle_file_deleted(real_source_path)` for source
       - If destination path is valid, call `handle_file_created(real_dest_path)` for destination
5. Ignore other event types (attributes changed, etc.)

**Note**: This method is called asynchronously by GLib's event loop when inotify events occur. Overlay paths are converted to real paths before processing. Move operations are emulated as delete + create.

#### Private Method: `handle_directory_created(string dir_path)`

**Purpose**: Handle creation of a new directory. Track it in `added` if it doesn't exist in ProjectFiles. Create a new FileMonitor for the directory since GLib.FileMonitor doesn't monitor recursively.

**Parameters**:
- `dir_path` (string): Absolute path to the newly created directory

**Implementation**:
1. Normalize path (resolve any symlinks, ensure absolute)
2. Check if folder exists in ProjectFiles:
   - Use `project_folder.project_files.folder_map.get(dir_path)` to check if folder exists
   - If folder found in ProjectFiles:
     - Return (folder already exists, don't add to `added`)
3. Query FileInfo for the directory:
   - Create `GLib.File` object from `dir_path`
   - Query FileInfo with attributes: `TIME_MODIFIED`
4. Create Folder object using `Folder.new_from_info()`:
   - Get manager from `project_folder.manager` (required for Folder constructor)
   - `new Folder.new_from_info(project_folder.manager, project_folder, folder_info, dir_path)`
   - This creates a Folder with `id = 0` (not in database)
5. Add Folder to `added` HashMap: `added.set(dir_path, new_folder)`
6. Create a new FileMonitor for the directory:
   - Create `GLib.File` object from `dir_path`
   - Create FileMonitor: `var monitor = file.monitor_directory(GLib.FileMonitorFlags.NONE, null)`
   - Connect `changed` signal: `var handler_id = monitor.changed.connect(on_file_changed)`
   - Store monitor in `monitors` HashMap: `monitors.set(new_folder, monitor)`
   - Store handler ID in `signal_handlers` HashMap: `signal_handlers.set(monitor, handler_id)`
7. Handle any errors gracefully (log warning, continue monitoring)


#### Private Method: `handle_file_created(string file_path)`

**Purpose**: Track creation of a new file. If file exists in ProjectFiles, add to `updated` instead of `added`.

**Parameters**:
- `file_path` (string): Absolute path to the newly created file

**Implementation**:
1. Normalize path (resolve any symlinks, ensure absolute)
2. Check if file exists in ProjectFiles:
   - Use `project_folder.project_files.child_map.get(file_path)` to get existing ProjectFile
   - If ProjectFile found:
     - Get File from ProjectFile: `var existing_file = project_file.file`
     - Add to `updated` HashMap: `updated.set(file_path, existing_file)`
     - Return (file exists, treat as modification)
3. Create File object using `create_filebase_from_path(file_path)`
4. If File created successfully:
   - Add to `added` HashMap: `added.set(file_path, new_file)`

#### Private Method: `handle_file_modified(string file_path)`

**Purpose**: Track modification of an existing file. If already in `added` or `updated`, do nothing (NOOP). If in `removed`, move to `updated`.

**Parameters**:
- `file_path` (string): Absolute path to the modified file

**Implementation**:
1. Normalize path (resolve any symlinks, ensure absolute)
2. Check if file is already in `added` HashMap:
   - If `added.has_key(file_path)`: return (NOOP - new file, modification already tracked)
3. Check if file is already in `updated` HashMap:
   - If `updated.has_key(file_path)`: return (NOOP - already tracking modification)
4. Check if file is in `removed` HashMap:
   - If `removed.has_key(file_path)`:
     - Get FileBase from `removed`: `var filebase = removed.get(file_path)`
     - Remove from `removed`: `removed.unset(file_path)`
     - Add to `updated` HashMap: `updated.set(file_path, filebase)`
     - Return (file was deleted then modified)
5. Look up file in ProjectFiles:
   - Use `project_folder.project_files.child_map.get(file_path)` to get existing ProjectFile
   - If ProjectFile found:
     - Get File from ProjectFile: `var existing_file = project_file.file`
     - Add to `updated` HashMap: `updated.set(file_path, existing_file)`
6. If not found in ProjectFiles:
   - Return (file not in ProjectFiles, so not tracked in `updated` - `updated` only contains files from ProjectFiles)

#### Private Method: `handle_file_deleted(string file_path)`

**Purpose**: Track deletion of a file. Remove from `added` or `updated` and add to `removed` if from ProjectFiles.

**Parameters**:
- `file_path` (string): Absolute path to the deleted file

**Implementation**:
1. Normalize path (resolve any symlinks, ensure absolute)
2. Check if file is in `added` HashMap:
   - If `added.has_key(file_path)`:
     - Remove from `added`: `added.unset(file_path)`
     - Return (file was created then deleted - wasn't in ProjectFiles, so don't add to `removed`)
3. Check if file is in `updated` HashMap:
   - If `updated.has_key(file_path)`:
     - Get FileBase from `updated`: `var filebase = updated.get(file_path)`
     - Remove from `updated`: `updated.unset(file_path)`
     - Add to `removed` HashMap: `removed.set(file_path, filebase)`
     - Return (file was in ProjectFiles, now deleted)
4. Look up file in ProjectFiles:
   - Use `project_folder.project_files.child_map.get(file_path)` to get existing ProjectFile
   - If ProjectFile found:
     - Get FileBase from ProjectFile: `var existing_filebase = project_file.file`
     - Add to `removed` HashMap: `removed.set(file_path, existing_filebase)`
5. If not found in ProjectFiles:
   - Return (not tracked - `removed` only contains files from ProjectFiles)

#### Private Method: `to_real_path(string overlay_path)`

**Purpose**: Convert an overlay filesystem path to the corresponding real project path.

**Parameters**:
- `overlay_path` (string): Absolute path in the overlay filesystem

**Returns**: `string` - Real project path

**Implementation**:
1. Check if `overlay_path` starts with `base_path`
2. If not, return `overlay_path` as-is (path is not in overlay, use as-is)
3. Remove `base_path` prefix from `overlay_path` to get relative path
4. Get the first path component from the relative path (e.g., "overlay1" from "overlay1/subdir/file.txt")
5. Look up the first component in `overlay_map` to get the real base path
6. If not found in `overlay_map`, return `overlay_path` as-is
7. Construct real path by replacing the first component with the mapped real path
8. Return the real path

**Example**:
```
base_path = "/home/alan/.cache/ollmchat/overlay-12345/upper"
overlay_map = {"overlay1" -> "/home/alan/project"}
overlay_path = "/home/alan/.cache/ollmchat/overlay-12345/upper/overlay1/src/main.c"
→ relative = "overlay1/src/main.c"
→ first_component = "overlay1"
→ real_base = "/home/alan/project"
→ real_path = "/home/alan/project/src/main.c"
```

#### Private Method: `create_filebase_from_path(string file_path)`

**Purpose**: Create a File object from a filesystem path. Used for tracking files that don't exist in ProjectFiles. The file is known to exist from the inotify event, so no existence checks are needed.

**Parameters**:
- `file_path` (string): Absolute path to the file (known to exist from inotify event)

**Returns**: `File` - File object (always succeeds)

**Implementation**:
1. Try to query FileInfo from disk:
   - Create `GLib.File` object from path
   - Query FileInfo with attributes: `STANDARD_CONTENT_TYPE`, `TIME_MODIFIED`
   - If query succeeds, create File using `File.new_from_info()`:
     - Get manager from `project_folder.manager` (required for File constructor)
     - `new File.new_from_info(project_folder.manager, project_folder, file_info, file_path)`
     - This creates a File with `id = 0` (not in database)
2. If FileInfo query fails (e.g., permission error, race condition):
   - Create minimal File object with just the path:
     - `var file = new File(project_folder.manager)`
     - `file.path = file_path`
     - `file.id = 0` (not in database)
     - `file.parent = project_folder` (optional, for context)
3. Return created File object

**Note**: This method is only used for files. Folders are created directly in `handle_directory_created()` using `Folder.new_from_info()`. These objects are created for tracking purposes only. They are NOT saved to the database. For `updated` items, use existing files from ProjectFiles instead.

### Dynamic Directory Monitoring

The Monitor class implements dynamic directory monitoring to handle directories that are created during command execution. Since GLib.FileMonitor does not monitor directories recursively, we create new FileMonitors for each newly created directory.

#### How It Works

1. **Initial State**: When `start()` is called, FileMonitors are created for each overlay subdirectory (overlay1, overlay2, etc.) from `overlay_map`. Each subdirectory gets its own FileMonitor stored in `monitors` HashMap.

2. **Directory Creation Detection**: When a directory creation event is detected (`G_FILE_MONITOR_EVENT_CREATED` for a directory):
   - The `on_file_changed()` handler calls `handle_directory_created()`
   - A new Folder object is created for the new directory
   - A new GLib.FileMonitor is created for the subdirectory path
   - The new FileMonitor is added to `monitors` HashMap with the new Folder as key
   - The new FileMonitor will detect changes in that subdirectory (but not its subdirectories - those will be detected when created)

3. **Nested Directory Behavior**: When a new subdirectory is created:
   - The parent directory's FileMonitor detects the creation event
   - `handle_directory_created()` is called for the new subdirectory
   - A new Folder object is created for the subdirectory
   - A new GLib.FileMonitor is created for the subdirectory path
   - The new FileMonitor is added to `monitors` HashMap with the new Folder as key
   - This creates a tree of FileMonitors, one per directory, all stored in the same `monitors` HashMap

4. **Cleanup**: When `stop()` is called:
   - All directory monitors are stopped
   - The `monitors` HashMap is cleared
   - All monitors are properly cancelled and signal handlers disconnected

#### Data Structure

- **`monitors`**: `Gee.HashMap<OLLMfiles.Folder, GLib.FileMonitor>`
  - Key: Folder object representing the directory being monitored
  - Value: GLib.FileMonitor instance for that directory
  - Used to track all active FileMonitors (overlay subdirectories and their nested subdirectories) for cleanup
  - Initially contains FileMonitors for each overlay subdirectory (overlay1, overlay2, etc.)
  - New FileMonitors are added when subdirectories are created within monitored directories

#### Example Flow

```
1. Monitor created for overlay subdirectories
2. start() called → monitors added to monitors HashMap for overlay1, overlay2, etc.
3. Command creates /base_path/overlay1/subdir/
4. Event detected by overlay1 monitor → handle_directory_created("/real_path/subdir")
5. Folder object created for /real_path/subdir
6. New FileMonitor created for /base_path/overlay1/subdir
7. New monitor added to monitors HashMap with new Folder as key
8. Command creates /base_path/overlay1/subdir/nested/
9. Event detected by subdir monitor → handle_directory_created("/real_path/subdir/nested")
10. Folder object created for /real_path/subdir/nested
11. New FileMonitor created for /base_path/overlay1/subdir/nested
12. New monitor added to monitors HashMap with new Folder as key
13. stop() called → all monitors stopped, signal handlers disconnected, HashMap cleared
```

### Simple Change Tracking

The Monitor class maintains simple HashMaps of FileBase objects (keyed by path) rather than detailed event logs. This approach is sufficient for the use case and easier to work with.

#### Change HashMaps

- **`added`**: `Gee.HashMap<string, OLLMfiles.FileBase>`
  - Key: Normalized absolute path
  - Value: File or Folder object that was created during monitoring
  - **Contains only files/folders NOT in ProjectFiles** (new files)
  - Objects are created but NOT inserted into database (id = 0)
  - Files and directories are both tracked here
  - Objects are removed from this HashMap if they're later deleted

- **`removed`**: `Gee.HashMap<string, OLLMfiles.FileBase>`
  - Key: Normalized absolute path
  - Value: File or Folder object that was deleted during monitoring
  - **Contains only files/folders FROM ProjectFiles** (existing files that were deleted)
  - Uses existing FileBase from ProjectFiles
  - Does NOT contain files that were created then deleted (those are removed from `added`)

- **`updated`**: `Gee.HashMap<string, OLLMfiles.FileBase>`
  - Key: Normalized absolute path
  - Value: File object that was modified during monitoring
  - **Contains only files FROM ProjectFiles** (existing files that were modified)
  - Objects come from ProjectFiles (existing files in database)
  - Does NOT contain new files (those go in `added`)

#### Tracking Logic

1. **File/Directory Creation**: When a file or directory is created:
   - Normalize path
   - Check ProjectFiles: If file/folder exists, don't add to `added` (it's not new)
   - If folder exists in ProjectFiles, return (just monitor it, don't track in `added`)
   - If not in ProjectFiles: Create FileBase object and add to `added` HashMap (new file/folder)

2. **File Modification**: When a file is modified:
   - Normalize path
   - If already in `added` HashMap: NOOP (return - new file, modification already tracked)
   - If already in `updated` HashMap: NOOP (return - already tracking modification)
   - If in `removed` HashMap: Remove from `removed`, add to `updated` (file was deleted then modified)
   - If not in any HashMap: Look up file in ProjectFiles
   - If found in ProjectFiles: Add existing FileBase to `updated` HashMap
   - If not found in ProjectFiles: Return (not tracked - `updated` only contains files from ProjectFiles)

3. **File/Directory Deletion**: When a file or directory is deleted:
   - Normalize path
   - If in `added` HashMap: Remove from `added`, return (don't add to `removed` - wasn't in ProjectFiles)
   - If in `updated` HashMap: Remove from `updated`, add to `removed` HashMap (was in ProjectFiles)
   - If not in either: Look up in ProjectFiles
   - If found in ProjectFiles: Add existing FileBase to `removed` HashMap
   - If not found in ProjectFiles: Return (not tracked - `removed` only contains files from ProjectFiles)

4. **No Deduplication Needed**: HashMaps automatically ensure unique paths (keys).

#### FileBase Object Creation

- **For `added`**: Objects are created using `create_filebase_from_path()` but NOT saved to database (id = 0)
- **For `removed` and `updated`**: Objects come from ProjectFiles (existing files in database with id > 0)
- All FileBase objects have `path` set to absolute normalized path
- Objects can be File, Folder, or FileAlias depending on filesystem type

### inotify Events

The Monitor class uses `GLib.FileMonitor` which provides a Vala-friendly API over inotify (on Linux).

#### Event Types Monitored

- **`G_FILE_MONITOR_EVENT_CREATED`**: 
  - File or directory creation
  - Handled by checking if path is directory or file
  - Triggers `handle_directory_created()` or `handle_file_created()`

- **`G_FILE_MONITOR_EVENT_CHANGED`**:
  - File modification (content changed)
  - Only handled for files (not directories)
  - Triggers `handle_file_modified()`

- **`G_FILE_MONITOR_EVENT_DELETED`**:
  - File or directory deletion
  - Handled by `handle_file_deleted()`
  - Note: Directory deletion will stop the subdirectory monitor automatically

#### Event Handling Considerations

1. **Event Queue**: Events may arrive after `stop()` is called. The `stop()` method should process any pending events before finalizing.

2. **Rapid Changes**: Multiple events for the same file may arrive quickly. The implementation should handle this gracefully (deduplication in lists).

3. **Event Ordering**: Events may not arrive in chronological order. The implementation should be resilient to this.

4. **Missing Events**: Some events may be missed if the system is under heavy load. This is acceptable for the use case - we're tracking changes, not creating an audit log.

#### GLib.FileMonitor API

```vala
// Create monitor
var file = GLib.File.new_for_path(base_path);
var monitor = file.monitor_directory(
    GLib.FileMonitorFlags.WATCH_MOVES
);

// Connect to changed signal
monitor.changed.connect(on_file_changed);

// Cancel monitor
monitor.cancel();
```

**FileMonitorFlags**:
- `WATCH_MOVES`: Monitor for move/rename events (optional, for future use)
- Default flags are sufficient for basic monitoring

## Integration and Usage

### Integration with RunCommand

The Monitor class will be integrated with the RunCommand tool in Phase 3 (overlay support). For Phase 2, it can be tested independently.

#### Future Integration (Phase 3)

```vala
// In Bubble.exec() or Request.execute_tool_async()
var overlay = new Overlay(project);
// Create overlay map (maps overlay path segments to real project paths)
var overlay_map = new Gee.HashMap<string, string>();
overlay_map.set("overlay1", project.path);
var monitor = new Monitor(project, overlay.upper_directory_path, overlay_map);

monitor.start();
var output = yield bubble.exec(command);
yield monitor.stop();

// Access change lists
var added = monitor.added;
var removed = monitor.removed;
var updated = monitor.updated;
// ... use change lists for file copying ...
```

#### Standalone Testing (Phase 2)

```vala
// Test example
var overlay_map = new Gee.HashMap<string, string>();
overlay_map.set("test", "/tmp/test-monitor");
var monitor = new Monitor(project, "/tmp/test-monitor", overlay_map);
monitor.start();

// Execute test command that creates/modifies files
// ...

yield monitor.stop();

// Check results
print("Added files: %d\n", monitor.added.size);
foreach (var filebase in monitor.added) {
    print("  %s (%s)\n", filebase.path, filebase.base_type);
}
```

### Error Handling

#### Constructor Errors

- **No errors**: Constructor assumes Folder object is valid (validation done by system that created it)

#### start() Errors

- **Monitoring already started**: Return early (idempotent)
- **Cannot create monitor**: Throw `GLib.IOError.FAILED` with descriptive message
- **Permission denied**: Throw `GLib.IOError.PERMISSION_DENIED`

#### Event Handler Errors

- **File operations fail**: Log warning, continue monitoring (don't crash)
- **Subdirectory monitor creation fails**: Log warning, continue monitoring parent
- **Path resolution fails**: Skip event, log warning

#### stop() Behavior

- **Already stopped**: Return early (idempotent)
- **Monitor cancellation fails**: Log warning, continue cleanup
- **Subdirectory stop fails**: Log warning, continue with other monitors

### Edge Cases and Considerations

#### Rapid File Changes

- **Multiple events for same file**: HashMaps handle duplicates automatically (keys are unique)
- **Create-then-delete quickly**: File removed from `added`, added to `removed`
- **Modify-then-delete**: File removed from `updated`, added to `removed`

#### Large Numbers of Files

- **Memory usage**: HashMaps grow with number of changes (acceptable for typical use)
- **Event processing**: GLib's event loop handles events efficiently
- **Performance**: inotify is efficient even with many files

#### Deep Directory Structures

- **Dynamic directory monitoring**: New FileMonitors are created for directories as they're created (GLib.FileMonitor doesn't monitor recursively)
- **Path length limits**: Handle very long paths gracefully
- **Nested directory creation**: Automatically detected by existing FileMonitors

#### Concurrent Access

- **Thread safety**: Monitor is not thread-safe (use from single thread)
- **Event handler**: Called from GLib's main event loop (thread-safe)
- **Property access**: Properties should only be accessed after `stop()` is called

#### Filesystem Limitations

- **inotify limits**: System may have limits on number of watches (handle gracefully)
- **Network filesystems**: May not support inotify (fall back gracefully)
- **Symlinks**: Resolve to real paths for consistent tracking

## Implementation Tasks

- [ ] Create `Monitor` class skeleton with constructor
- [ ] Implement `start()` method with GLib.FileMonitor setup
- [ ] Implement `stop()` method with cleanup logic
- [ ] Implement `on_file_changed()` event handler
- [ ] Implement `handle_directory_created()` (track directory, no new monitor needed)
- [ ] Implement `handle_file_created()` with HashMap management (check ProjectFiles first)
- [ ] Implement `handle_file_modified()` with HashMap management (NOOP if already in updated)
- [ ] Implement `handle_file_deleted()` with HashMap management (remove from added/updated, add to removed)
- [ ] Implement `create_filebase_from_path()` helper method
- [ ] Implement `to_real_path()` method for overlay path conversion
- [ ] Add path normalization logic
- [ ] Add error handling throughout
- [ ] Add logging for debugging
- [ ] Test inotify monitoring on empty directory
- [ ] Test dynamic directory creation and monitoring
- [ ] Test file creation/modification/deletion detection
- [ ] Test error handling (permissions, missing directories, etc.)
- [ ] Test edge cases (rapid changes, large numbers of files, deep structures)

## Implementation Sequence

### Step-by-Step Implementation

1. **Create basic class structure**
   - Define namespace and class
   - Add properties (lists and private fields)
   - Implement constructor (no validation needed - Folder is already validated)

2. **Implement basic monitoring**
   - Implement `start()` method
   - Create GLib.FileMonitor
   - Connect to `changed` signal
   - Implement basic `on_file_changed()` handler

3. **Implement file change tracking**
   - Implement `handle_file_created()`
   - Implement `handle_file_modified()`
   - Implement `handle_file_deleted()`
   - Test with simple file operations

4. **Implement directory monitoring**
   - Implement `handle_directory_created()`
   - Test with directory creation

5. **Implement directory monitoring**
   - Create FileMonitors for overlay subdirectories in `start()`
   - Track directory creation in `handle_directory_created()` (no new monitors needed)
   - Test with nested directory creation (new monitors created for each directory)

6. **Implement FileBase object creation**
   - Implement `create_filebase_from_path()` method
   - Create File/Folder objects for `added` and `removed` HashMaps
   - Look up files in ProjectFiles for `updated` HashMap
   - Test with various file types

7. **Implement cleanup**
   - Implement `stop()` method
   - Disconnect all signal handlers and cancel all FileMonitors in `monitors` HashMap
   - Finalize change HashMaps (no deduplication needed - HashMaps ensure unique paths)

7. **Add error handling**
   - Add error handling to constructor
   - Add error handling to `start()`
   - Add error handling to event handlers
   - Add logging for debugging

8. **Add overlay path conversion**
   - Implement `to_real_path()` method
   - Convert overlay paths in event handlers before processing
   - Test path conversion with various overlay structures

9. **Add path normalization**
   - Normalize all paths to absolute
   - Handle symlinks consistently
   - Ensure path format consistency

### Data Flow

```
1. Monitor created with project_folder, base_path, overlay_map → Constructor stores references
2. start() called → GLib.FileMonitor created for each overlay subdirectory (overlay1, overlay2, etc.), signals connected
3. FileMonitors added to monitors HashMap with Folder objects as keys
4. Command executes → Filesystem events occur in overlay
5. Events arrive → on_file_changed() called by GLib with overlay path
6. Event handler → Converts overlay path to real path using to_real_path()
7. Event handler → Routes to appropriate handle_*() method with real path
8. Handle method → Updates change lists (added/removed/updated) and known_paths using real paths
9. Directory created → Folder object created, added to `added` HashMap (no new monitor needed)
11. stop() called → All FileMonitors stopped, HashMaps finalized
12. Properties accessed → Change HashMaps (FileBase objects with real paths as keys) available for use
```

### State Transitions

```
[Uninitialized]
    ↓ (Constructor)
[Initialized] (is_monitoring = false)
    ↓ (start())
[Monitoring] (is_monitoring = true, FileMonitor active, in monitors HashMap with Folder key)
    ↓ (Directory created)
[Monitoring] (monitors HashMap contains FileMonitors for overlay subdirectories, which automatically monitor nested directories)
    ↓ (stop())
[Stopped] (is_monitoring = false, HashMaps finalized)
```

## Testing

### Unit Tests

#### Test 1: Basic File Creation
- Create Monitor for empty directory
- Start monitoring
- Create a file in the directory
- Stop monitoring
- Verify File object appears in `added` HashMap with correct path as key

#### Test 2: File Modification
- Create Monitor for directory with existing file (in ProjectFiles)
- Start monitoring
- Modify the existing file
- Stop monitoring
- Verify File object from ProjectFiles appears in `updated` HashMap

#### Test 3: File Deletion
- Create Monitor for directory with existing file (in ProjectFiles)
- Start monitoring
- Delete the file
- Stop monitoring
- Verify File object appears in `removed` HashMap

#### Test 4: Directory Creation
- Create Monitor for empty directory
- Start monitoring
- Create a subdirectory
- Stop monitoring
- Verify Folder object appears in `added` HashMap
- Verify directory was tracked (no new monitor needed - existing monitor covers it)

#### Test 5: Nested Directory Creation
- Create Monitor for empty directory
- Start monitoring
- Create nested directories: `subdir/nested/deep/`
- Stop monitoring
- Verify all Folder objects appear in `added` HashMap
- Verify monitors were created for each level in `monitors` HashMap

#### Test 6: Rapid File Changes
- Create Monitor for empty directory
- Start monitoring
- Rapidly create, modify, and delete files
- Stop monitoring
- Verify HashMaps are correct (no duplicates, proper state)

#### Test 7: Large Number of Files
- Create Monitor for empty directory
- Start monitoring
- Create 1000 files
- Stop monitoring
- Verify all File objects appear in `added` HashMap
- Verify performance is acceptable

#### Test 8: Deep Directory Structure
- Create Monitor for empty directory
- Start monitoring
- Create directory structure 10 levels deep
- Create files at various levels
- Stop monitoring
- Verify all directories and files are tracked correctly

#### Test 9: Error Handling
- Test constructor with non-existent directory (should throw)
- Test constructor with file path (should throw)
- Test start() with permission denied (should throw)
- Test event handler with invalid paths (should handle gracefully)

#### Test 10: Edge Cases
- Create file, modify it, then delete it (verify proper HashMap state: in `removed`, not in `added` or `updated`)
- Create directory, create file in it, delete directory (verify cleanup)
- Modify file multiple times (verify single entry in `updated` HashMap - NOOP on subsequent modifications)
- Create and delete same file multiple times (verify final state: in `removed` if was in ProjectFiles)

### Integration Tests

#### Test 1: With Command Execution
- Create Monitor for test directory
- Start monitoring
- Execute shell command that creates/modifies files
- Stop monitoring
- Verify change HashMaps match expected files

#### Test 2: With Overlay (Phase 3)
- Create Overlay instance
- Create Monitor for overlay upper directory
- Start monitoring
- Execute command in overlay
- Stop monitoring
- Verify change HashMaps contain real project paths (converted from overlay paths)

### Performance Tests

- Test with 10,000 file operations
- Test with 100-level deep directory structure
- Test with rapid event bursts (1000 events/second)
- Measure memory usage with large change HashMaps
- Measure CPU usage during monitoring

## Summary

### What This Phase Implements

This phase creates a standalone `Monitor` class that uses inotify (via GLib.FileMonitor) to track filesystem changes during command execution. The class:

1. **Monitors a directory** for file and directory changes
2. **Monitors overlay subdirectories** - FileMonitors are created for each overlay subdirectory (overlay1, overlay2, etc.)
3. **Maintains simple change HashMaps** of FileBase objects keyed by path (`added`, `removed`, `updated`)
4. **Provides a clean API** for starting/stopping monitoring and accessing results

### Key Design Decisions

1. **FileBase Objects vs. Paths**: We maintain HashMaps of FileBase objects (File, Folder, FileAlias) keyed by path rather than just paths. This provides richer information and integrates with ProjectManager.

2. **Three Change Lists**: 
   - `added`: Files/directories created during monitoring (id = 0, not in database)
   - `removed`: Files/directories deleted during monitoring (from ProjectFiles or created)
   - `updated`: Files modified during monitoring (from ProjectFiles, existing in database)

3. **Dynamic Directory Monitoring**: GLib.FileMonitor does not monitor directories recursively. We create FileMonitors for the overlay subdirectories (overlay1, overlay2, etc.) in `start()`, and create additional FileMonitors for newly created directories in `handle_directory_created()`. All directories we care about will be notified to us via inotify events.

4. **Folder-based Design**: Monitor uses Folder objects instead of paths. The project Folder provides access to `project_files` property, which is used to look up existing files in ProjectFiles for `updated` list.

5. **Overlay Path Mapping**: Monitor supports overlay filesystem paths by converting them to real project paths using `base_path` and `overlay_map`. When file change events occur, overlay paths are converted to real paths before processing.

5. **Path Normalization**: All paths are normalized to absolute paths for consistency and easier path manipulation in later phases.

6. **Idempotent Operations**: `start()` and `stop()` are idempotent - they can be called multiple times safely.

7. **Error Resilience**: Event handlers are designed to handle errors gracefully without crashing the monitoring system.

### Integration Points

- **Phase 2 (Current)**: Standalone Monitor class, tested independently
- **Phase 3**: Monitor integrated with Overlay class to track changes in overlay upper directory
- **Phase 4**: Change lists used to determine which files to copy from overlay to live system

### Dependencies

- **GLib.FileMonitor**: Provided by GLib (part of Vala standard library)
- **GLib.FileUtils**: Used for path testing (IS_DIR, IS_REGULAR, EXISTS)
- **Gee Collections**: Used for lists and maps (HashMap, ArrayList, HashSet)
- **OLLMfiles.Folder**: Required for Monitor constructor (project_folder). Project Folder provides access to `project_files` property for looking up files in ProjectFiles. Also provides access to `manager` property (required for creating FileBase objects via `new_from_info()` constructors)
- **OLLMfiles.FileBase/File/Folder**: Used for change list objects

### Future Enhancements (Not in This Phase)

- Move/rename event handling (for Phase 4+)
- Event filtering (ignore certain file patterns)
- Change statistics (count of changes, total bytes changed)
- Event replay/debugging (detailed event logs for troubleshooting)

## Notes

- This phase only implements monitoring - no overlay support yet
- Monitor will be integrated with overlay in Phase 3
- Change HashMaps (FileBase objects keyed by path) will be used for file copying in Phase 3
- The Monitor class is designed to be reusable and testable independently
- All paths are normalized to absolute paths for consistency
- `added` and `removed` HashMaps contain FileBase objects created but not inserted into database (id = 0)
- `updated` HashMap contains FileBase objects from ProjectFiles (existing files in database with id > 0)
- HashMaps ensure unique paths automatically (no deduplication needed)
- All monitors (root and subdirectories) are stored in a single `monitors` HashMap for unified management

