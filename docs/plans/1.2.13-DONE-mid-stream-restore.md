# 1.2.13 - Mid-Stream Restore Visual Break

## Problem

When restoring a session that's still streaming (mid-block), there's a visual break:

1. `load_messages()` renders all messages including the last streaming message ("content-stream" or "think-stream")
2. When streaming resumes, new chunks start appending
3. This creates a visual gap/break in the output

## Solution

Move message restoration logic to the session layer. When a session is activated and it's still running, the session should restore messages via `restore_messages()` which emits them through the `message_created` signal. If the last message is a streaming message ("content-stream" or "think-stream"), trigger the streaming callback with that message's content by calling `handle_stream_chunk()`. This will set up `current_stream_message` and emit it to the UI immediately. When streaming resumes, the existing `handle_stream_chunk()` logic will naturally append new chunks to `current_stream_message`.

This approach:
- Keeps logic in the session layer where it belongs
- Works automatically for session switching (session restores its own messages when activated)
- UI just listens to signals (already does via `on_message_created`)
- Better separation of concerns
- Uses existing streaming infrastructure - no manual prepending needed

## Implementation

### File: `libollmchat/History/Session.vala`

**1. Add `restore_messages()` method** (after `activate()` method):

- Iterate through all messages except the last one (i < messages.size - 1) and emit them via `message_created` signal
- After the loop, check the last message:
  - If it's a stream message ("content-stream" or "think-stream") AND session is still running (`this.is_running == true`):
    - Determine `is_thinking` from message role ("think-stream" → true, "content-stream" → false)
    - Call `handle_stream_chunk(message.content, is_thinking, null)` to trigger streaming callback
    - This will set up `current_stream_message` and emit it to the UI via streaming infrastructure
  - Otherwise, emit it normally via `message_created` signal

**2. No changes needed to `handle_stream_chunk()` method**:

- The existing logic already handles `current_stream_message` correctly
- If `current_stream_message` exists and stream type matches, it appends to it (line 171)
- This naturally handles the restored message when streaming resumes

**4. Call `restore_messages()` from `activate()` method**:

- After activation completes, if session has messages, call `restore_messages()` to emit them to UI
- This ensures messages are restored when session becomes active

### File: `libollmchatgtk/ChatWidget.vala`

**1. Update streaming state handling** - Block UI during restoration, then set correct state:

- **What `set_streaming()` does** (ChatInput.vala line 192):
  - Sets internal `is_streaming` flag
  - Changes button label: `true` → "Stop", `false` → "Send"
  - Makes text view editable/sensitive: `true` → disabled, `false` → enabled
  - **Does NOT block any callbacks or signals** - purely UI state
- **Current behavior**: Always sets `this.chat_input.set_streaming(false)` at line 190 (before switching)
- **New approach**:
  1. **Before restoration**: Set `this.chat_input.set_streaming(true)` at line 190 (or right before `manager.switch_to_session()`) to block UI interaction during restoration
  2. **After restoration**: In ChatWidget, connect to `manager.session_activated` signal (add connection if not exists):
     - In the handler, check `session.is_running`:
       - If `is_running == true`: Keep `set_streaming(true)` (button shows "Stop", input disabled)
       - If `is_running == false`: Set `set_streaming(false)` (button shows "Send", input enabled)
  3. This ensures UI is blocked during restoration, then set to correct state based on actual session state
  4. No new signals needed, uses existing `session_activated` signal
  5. Note: ChatInput already connects to `session_activated` for model dropdown updates (ChatInput.vala line 479), so we can add the streaming state check in ChatWidget's handler

**2. Remove or simplify `load_messages()` method**:

- Since session now emits messages via `message_created` signal in `restore_messages()`, `load_messages()` may no longer be needed
- Or keep it as a fallback but session's `restore_messages()` should be the primary method
- **Note**: `clear_chat()` is already called in `switch_to_session()` (line 194) BEFORE `manager.switch_to_session()`
  - `clear_chat()` calls `chat_view.clear()` which removes all message widgets from the UI
  - This is what resets/clears the UI interface and removes existing messages
  - After UI is cleared, `restore_messages()` emits messages via signals to repopulate the UI

## Details

### Detecting Last Streaming Message

In `restore_messages()`, we need to:

1. Iterate through all messages except the last one (i < messages.size - 1) and emit them via `message_created` signal
2. After the loop, check the last message:
   - If session is still running (`this.is_running == true`) AND last message has role "content-stream" or "think-stream":
     - Determine `is_thinking` from message role ("think-stream" → true, "content-stream" → false)
     - Call `handle_stream_chunk(message.content, is_thinking, null)` to trigger streaming callback
     - This will set up `current_stream_message` and emit it to the UI via streaming infrastructure
   - Otherwise, emit the last message normally via `message_created` signal

### Using Existing Streaming Infrastructure

When we call `handle_stream_chunk()` with the restored message content:

- It will create or set `current_stream_message` with the existing content
- It will emit the message to the UI via the streaming infrastructure (`base.handle_stream_chunk()` → Manager → ChatWidget)
- When new chunks arrive from the actual stream, `handle_stream_chunk()` will see `current_stream_message` exists and append to it (line 171)
- This ensures seamless continuation - the restored content appears immediately, then new chunks append to it

### Session Activation Flow

When a session is activated:
1. `Session.activate()` is called (or `SessionBase.activate()`)
2. After activation completes, if session has messages, call `restore_messages()`
3. `restore_messages()` emits messages via `message_created` signal
4. ChatWidget's `on_message_created()` handler receives and renders them
5. If last message is a streaming message and session is running:
   - Call `handle_stream_chunk(message.content, is_thinking, null)` to trigger streaming callback
   - This sets up `current_stream_message` and emits it to the UI via streaming infrastructure
6. When streaming resumes, `handle_stream_chunk()` sees `current_stream_message` exists and appends new chunks to it naturally

### Flow from History Item Click to Message Restoration

When user clicks on a history item:

1. **HistoryBrowser.session_selected signal** is emitted (HistoryBrowser.vala line 108)
2. **ChatWidget.switch_to_session()** is called (ChatWidget.vala line 184):
   - Finalizes any active streaming (line 189)
   - **Sets streaming state to true** (line 190) - **Changed from false to true** to block UI interaction during restoration
   - Locks input (line 191)
   - **Calls `clear_chat()`** (line 194) - **This clears/resets the UI**:
     - `clear_chat()` calls `chat_view.clear()` (ChatWidget.vala line 368)
     - `chat_view.clear()` (ChatView.vala line 795):
       - Removes all message widgets from `text_view_box` (lines 805-810)
       - Clears renderer state (`renderer.clear()`)
       - Resets internal flags (has_displayed_user_message, is_assistant_message, content_state, etc.)
       - **This removes all existing messages from the UI display**
   - Disables scrolling (line 198)
3. **Manager.switch_to_session()** is called (ChatWidget.vala line 203):
   - Deactivates current session (Manager.vala line 225)
   - Loads new session if needed (line 230) - for SessionPlaceholder, this loads JSON and creates Session
   - Activates new session (line 241) - calls `session.activate()`
   - Emits `session_activated` signal (line 244)
4. **Session.activate()** is called (SessionBase.vala line 266):
   - Sets `is_active = true` (line 271)
   - Clears unread count (line 272)
   - **Calls `restore_messages()` here** (to be added) - UI is blocked (streaming=true) during this
5. **Session.restore_messages()** (to be added):
   - Emits all messages except last via `message_created` signal
   - If last message is streaming and session is running, calls `handle_stream_chunk()` with existing content
6. **After session activation completes** - `session_activated` signal handler in ChatWidget:
   - Check `session.is_running`:
     - If `is_running == true`: Keep `set_streaming(true)` (button shows "Stop", input disabled)
     - If `is_running == false`: Set `set_streaming(false)` (button shows "Send", input enabled)
   - This sets the correct state based on actual session state
7. **ChatWidget.load_messages()** is called (ChatWidget.vala line 213):
   - **This may no longer be needed** if `restore_messages()` handles everything via signals
   - Currently iterates through `session.messages` and renders them directly
   - With new approach, messages are already emitted via signals, so this may be redundant

**Key Points:**
- **UI Reset**: `clear_chat()` is called BEFORE session switching (line 194), which:
  - Calls `chat_view.clear()` to remove all message widgets from the UI
  - Clears renderer state and resets internal flags
  - **This is what clears/resets the UI interface and removes existing messages**
- **Message Restoration**: After UI is cleared, `restore_messages()` is called from `activate()` which emits messages via `message_created` signal
- **UI Updates**: ChatWidget's `on_message_created()` handler receives these signals and renders the restored messages
- `activate()` is called during `manager.switch_to_session()`
- `load_messages()` may need to be removed or simplified since `restore_messages()` emits via signals

## Edge Cases

- If session stops running between restore and first chunk, `current_stream_message` should be cleared and the message should be emitted via `message_created` signal
- If no chunks arrive (session stops), `current_stream_message` should be cleared and the message should be emitted on finalization or when session stops
- Need to handle the case where `current_stream_message` exists but streaming never resumes (should emit it when session stops)
- When switching sessions, the old session's `current_stream_message` should be cleared (or emitted) on deactivation
- When a session is deactivated and then reactivated, `restore_messages()` should be called again
- Need to ensure `current_stream_message` is already in `messages` list (it should be, since it came from `messages`)

## Testing

- Restore a session that's mid-stream
- Verify no visual break appears
- Verify content flows seamlessly
- Verify finalization works correctly if streaming stops before chunks arrive

