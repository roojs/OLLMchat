# 1.2.7.10. Move Tool Execution to Agent Handler

## Overview

Move tool execution logic from `Chat.toolsReply()` to `AgentHandler`. The agent should handle all tool execution concerns. Chat should delegate tool execution to the agent when available, and emit a placeholder signal for non-agent usage.

**Parent Plan**: [1.2.7. Move Remaining Signals from Client to Chat](./1.2.7-move-signals-to-chat.md)

## Status

⏳ **TODO** - Move tool execution responsibility to agent handler.

## Goal

Agent handlers should own and manage all tool execution. Chat should delegate tool execution to the agent when an agent is present, and emit a signal for non-agent usage.

**Current Flow**:
- Chat detects tool calls → Chat executes tools directly → Chat continues conversation

**New Flow (Agent Usage)**:
- Chat detects tool calls → Chat calls agent method → Agent executes tools → Agent returns results → Chat continues conversation

**New Flow (Non-Agent Usage)**:
- Chat detects tool calls → Chat emits signal → External code handles tool execution → External code calls Chat method to continue

## Implementation Steps

### Step 1: Add Tool Execution Method to AgentHandler

**Goal**: Agent handler should have a method to execute a single tool call.

**Changes**:
1. Add to `libollmchat/Prompt/AgentHandler.vala`:
   ```vala
   /**
    * Executes a tool call and returns the result.
    * 
    * Called by Chat when tool calls are detected. Agent handler manages
    * tool execution, including permission handling, UI messages, and error handling.
    * 
    * @param tool_call The tool call to execute
    * @return The tool execution result string
    * @throws Error if tool execution fails
    */
   public virtual async string execute_tool(Tool.Call tool_call) throws Error
   {
       // Get tool from chat.tools
       if (this.chat.tools == null || !this.chat.tools.has_key(tool_call.function.name)) {
           var available_tools_str = "";
           if (this.chat.tools != null) {
               available_tools_str = string.joinv("', '", this.chat.tools.keys.to_array());
           }
           if (available_tools_str != "") {
               available_tools_str = "'" + available_tools_str + "'";
           }
           
           var err_message = "ERROR: You requested a tool called '" + tool_call.function.name + 
               "', however we only have these tools: " + available_tools_str;
           
           var error_msg = new Message(this.chat, "ui", err_message);
           this.handle_tool_message(error_msg);
           
           throw new GLib.IOError.NOT_FOUND(err_message);
       }
       
       var tool = this.chat.tools.get(tool_call.function.name);
       
       // Show message that tool is being executed
       var exec_msg = new Message(this.chat, "ui", "Executing tool: `" + tool_call.function.name + "`");
       this.handle_tool_message(exec_msg);
       
       // Execute the tool - tool.execute() will set request.agent = chat_call.agent
       var result = yield tool.execute(this.chat, tool_call.function.arguments);
       
       // Log result summary (truncate if too long)
       var result_summary = result.length > 100 ? result.substring(0, 100) + "..." : result;
       
       // Check if result is an error and display it in UI
       if (result.has_prefix("ERROR:")) {
           GLib.debug("AgentHandler.execute_tool: Tool '%s' returned error result: %s",
               tool_call.function.name, result);
           var error_msg = new Message(this.chat, "ui", result);
           this.handle_tool_message(error_msg);
       } else {
           GLib.debug("AgentHandler.execute_tool: Tool '%s' executed successfully, result length: %zu, preview: %s",
               tool_call.function.name, result.length, result_summary);
       }
       
       return result;
   }
   ```

**Result**: Agent handler can execute individual tool calls.

### Step 2: Add Tool Execution Signal to Chat

**Goal**: Add a signal for non-agent usage to handle tool execution.

**Changes**:
1. Add to `libollmchat/Call/Chat.vala` signal declarations:
   ```vala
   /**
    * Emitted when a tool call is detected and needs to be executed.
    * 
    * For non-agent usage: Connect to this signal to handle tool execution.
    * The handler should execute the tool and call continue_with_tool_result()
    * with the result.
    * 
    * For agent usage: This signal is not used - agent.execute_tool() is called directly.
    * 
    * @param tool_call The tool call that needs to be executed
    */
   public signal void tool_call_requested(Tool.Call tool_call);
   ```

2. Add method to continue conversation with tool result:
   ```vala
   /**
    * Continues the conversation after a tool has been executed (for non-agent usage).
    * 
    * Call this method after handling tool_call_requested signal and executing the tool.
    * This adds the tool result message and continues the conversation automatically.
    * 
    * @param tool_call The original tool call
    * @param result The tool execution result
    * @throws Error if continuing the conversation fails
    */
   public async void continue_with_tool_result(Tool.Call tool_call, string result) throws Error
   {
       // Create tool reply message
       var tool_reply = new Message.tool_reply(
           this, tool_call.id, 
           tool_call.function.name,
           result
       );
       this.messages.add(tool_reply);
       
       // Automatically continue the conversation by sending tool results back to the server
       Response.Chat next_response;
       if (this.stream) {
           next_response = yield this.execute_streaming();
       } else {
           next_response = yield this.execute_non_streaming();
       }
       
       // Recursively handle tool calls if the next response also has them and is done
       if (next_response.done && 
           next_response.message.tool_calls.size > 0) {
           yield this.toolsReply(next_response);
       }
   }
   ```

**Result**: Chat has a signal for non-agent tool execution and a method to continue after execution.

### Step 3: Update Chat.toolsReply() to Delegate to Agent

**Goal**: Chat should delegate tool execution to agent when available, or emit signal for non-agent usage.

**Changes**:
1. Update `libollmchat/Call/Chat.vala` `toolsReply()` method:
   ```vala
   // Execute each tool call and add tool reply messages directly
   foreach (var tool_call in response.message.tool_calls) {
       GLib.debug("Chat.toolsReply: Executing tool '%s' (id='%s')",
           tool_call.function.name, tool_call.id);
       
       string result;
       try {
           if (this.agent != null) {
               // Agent usage: delegate to agent handler
               result = yield this.agent.execute_tool(tool_call);
           } else {
               // Non-agent usage: emit signal and wait for external handler
               // Note: This is a placeholder - external code must handle tool_call_requested signal
               // and call continue_with_tool_result() when done
               this.tool_call_requested(tool_call);
               // For now, throw error if no agent (non-agent usage not fully supported yet)
               throw new GLib.IOError.NOT_SUPPORTED(
                   "Tool execution without agent is not yet fully supported. " +
                   "Connect to tool_call_requested signal and call continue_with_tool_result()."
               );
           }
       } catch (Error e) {
           GLib.debug("Chat.toolsReply: Error executing tool '%s' (id='%s'): %s", 
               tool_call.function.name, tool_call.id, e.message);
           var error_msg = new Message(this, "ui", "Error executing tool '" + tool_call.function.name + "': " + e.message);
           this.tool_message(error_msg);
           if (this.agent != null) {
               this.agent.handle_tool_message(error_msg);
           }
           this.messages.add(new Message.tool_call_fail(this, tool_call, e));
           continue;
       }
       
       // Create tool reply message
       var tool_reply = new Message.tool_reply(
           this, tool_call.id, 
           tool_call.function.name,
           result
       );
       GLib.debug("Chat.toolsReply: Created tool reply message: role='%s', tool_call_id='%s', name='%s', content length=%zu",
           tool_reply.role, tool_reply.tool_call_id, tool_reply.name, tool_reply.content.length);
       this.messages.add(tool_reply);
   }
   ```

**Result**: Chat delegates tool execution to agent when available.

### Step 4: Remove Direct Tool Execution from Chat

**Goal**: Remove the direct tool execution code from Chat.toolsReply() - agent handles it all.

**Changes**:
1. Remove from `libollmchat/Call/Chat.toolsReply()`:
   - Remove direct `tools_map.get().execute()` call
   - Remove tool lookup and validation (moved to agent)
   - Remove tool execution UI messages (moved to agent)
   - Keep only the delegation logic and tool reply message creation

**Result**: Chat no longer directly executes tools - agent owns all tool execution.

### Step 5: Remove Client Property from Tool.BaseTool

**Goal**: Remove the `client` property from `Tool.BaseTool` since tools now access everything through the agent (via `request.agent` in RequestBase). Tools don't need direct client access.

**Changes**:
1. Remove from `libollmchat/Tool/Tool.vala`:
   - Remove `public Client? client { get; set; default = null; }` property (line 72-73, marked with FIXME)
   - Remove `Client? client = null` parameter from `BaseTool` constructor
   - Remove `this.client = client;` assignment in constructor

2. Update `register_all_tools()` method:
   - Remove `Client client` parameter from `BaseTool.register_all_tools()`
   - Remove `"client", client` from `Object.new()` call (line 618)
   - Update method signature: `public static Gee.HashMap<string, BaseTool> register_all_tools()`

3. Update `Manager.register_all_tools()`:
   - Remove `this.base_client` argument from `BaseTool.register_all_tools()` call
   - Update call: `var tools = OLLMchat.Tool.BaseTool.register_all_tools();`

4. Check for any remaining uses of `tool.client` or `this.client` in tool code:
   - `liboctools/RequestEditMode.vala` - Check if `this.tool.client` references need updating (lines 193, 199)
   - Any other tool implementations that might reference `this.client`

**Note**: Tools now get agent access through `RequestBase.agent` property (set in `BaseTool.execute()` at line 491). Tools access chat via `agent.chat` and connection via `agent.chat.connection`. The client property on BaseTool is no longer needed.

**Result**: `Tool.BaseTool` no longer has a `client` property - tools access everything through the agent.

### Step 6: Update Tools When Tool Config Changes

**Goal**: When tool configuration changes (user updates tool config in settings), the agent should rebuild tools for its Chat instance.

**Issue**: 
- Tools are stored on Manager and copied to Chat when AgentHandler is created (in constructor)
- If tool config changes after AgentHandler is created, Chat's tools are not updated
- Tool config changes affect tool.active state and tool configuration
- Need to rebuild tools on Chat when config changes

**Current State**:
- `AgentHandler` constructor copies tools from `session.manager.tools` to `chat.tools` (lines 116-120)
- Tools are stored on Manager and accessed via Session
- When tool config changes, Manager.tools are updated, but existing Chat instances don't get updated
- Config changes emit `config.changed()` signal

**Changes**:
1. Add to `libollmchat/Prompt/AgentHandler.vala`:
   ```vala
   /**
    * Rebuilds tools for this agent's Chat instance.
    * 
    * Called when tool configuration changes. Clears existing tools from Chat
    * and re-adds them from Manager, allowing agent to reconfigure/filter.
    * 
    * This ensures Chat always has the latest tool configuration.
    */
   public void rebuild_tools()
   {
       // Clear existing tools from Chat
       this.chat.tools.clear();
       
       // Re-add tools from Manager (they may have updated config/active state)
       foreach (var tool in this.session.manager.tools.values) {
           this.chat.add_tool(tool);
       }
       
       // Agent can reconfigure/filter tools if needed
       this.agent.configure_tools(this.chat);
   }
   ```

2. Add to `libollmchat/History/Session.vala`:
   - Connect to `manager.config.changed` signal in constructor or `load()` method
   - When config changes, call `agent.rebuild_tools()` if agent exists
   - This ensures all sessions update their tools when config changes

**Note**: Tool config changes are session-level (stored in Config2.tools), so we should tell the agent to rebuild tools for the session's Chat instance. This is different from model/options updates which are also session-level.

**Result**: When tool config changes, all active sessions' agents rebuild their tools, ensuring Chat always has the latest tool configuration.

## Files to Modify

- `libollmchat/Prompt/AgentHandler.vala` - Add `execute_tool()` method, add `rebuild_tools()` method
- `libollmchat/Call/Chat.vala` - Add `tool_call_requested` signal, add `continue_with_tool_result()` method, update `toolsReply()` to delegate to agent
- `libollmchat/Tool/Tool.vala` - Remove `client` property and constructor parameter from `BaseTool`, update `register_all_tools()` to not take Client parameter
- `libollmchat/History/Manager.vala` - Update `register_all_tools()` to not pass `base_client` to `BaseTool.register_all_tools()`
- `libollmchat/History/Session.vala` - Connect to `config.changed` signal and call `agent.rebuild_tools()` when tool config changes
- `liboctools/RequestEditMode.vala` - Check and update any `this.tool.client` references (if still present)

## Testing Checklist

- [ ] AgentHandler has `execute_tool()` method
- [ ] AgentHandler.execute_tool() handles tool lookup and validation
- [ ] AgentHandler.execute_tool() sends UI messages via handle_tool_message()
- [ ] AgentHandler.execute_tool() executes tool and returns result
- [ ] Chat has `tool_call_requested` signal
- [ ] Chat has `continue_with_tool_result()` method
- [ ] Chat.toolsReply() delegates to agent.execute_tool() when agent is present
- [ ] Chat.toolsReply() emits tool_call_requested signal when agent is not present
- [ ] Tool execution still works correctly for agent usage
- [ ] Tool execution error handling still works correctly
- [ ] Tool reply messages are still created correctly
- [ ] Conversation continues automatically after tool execution
- [ ] `Tool.BaseTool` no longer has `client` property
- [ ] `Tool.BaseTool` constructor no longer takes `client` parameter
- [ ] `BaseTool.register_all_tools()` no longer takes `Client` parameter
- [ ] `Manager.register_all_tools()` no longer passes `base_client` to tool registration
- [ ] All tools access connection/chat via `agent.chat` (through RequestBase.agent)
- [ ] No remaining references to `tool.client` or `this.client` in tool code
- [ ] AgentHandler has `rebuild_tools()` method
- [ ] `rebuild_tools()` clears Chat tools and re-adds from Manager
- [ ] `rebuild_tools()` calls `agent.configure_tools()` after rebuilding
- [ ] Session connects to `config.changed` signal
- [ ] Session calls `agent.rebuild_tools()` when config changes
- [ ] Tool config changes update Chat tools correctly

## Related Plans

- [1.2.7. Move Remaining Signals from Client to Chat](./1.2.7-move-signals-to-chat.md) - Parent plan
- [1.2.7.4. Migrate Tool Signal Connections to Direct Method Calls](./1.2.7.4-DONE-migrate-non-agent-signals.md) - Previous phase (tools now use agent property)
- [1.2.7.9. Move Permission Provider to Agent](./1.2.7.9-move-permission-provider-to-agent.md) - Related (permission provider on agent)

