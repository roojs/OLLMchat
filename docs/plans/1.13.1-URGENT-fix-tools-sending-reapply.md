# 1.13.1. DONE - Re-apply Tools Fix After Merge

## Overview

After merging the conflicting branch, the tools fix from commit `9caccf34` needs to be re-applied. The codebase structure has changed (Phase 3: Chat no longer uses Client, tools moved to Manager), so the fixes need to be adapted to the new architecture.

## Status

✅ **COMPLETED** - All steps (1, 2, 3, and 4) have been successfully re-applied.

## Changes Required

### Step 1: Re-apply Model Capability Checking in Chat.vala

**File**: `libollmchat/Call/Chat.vala`

**Location**: `serialize_property()` method, case "tools" (around line 231-255)

**Status**: ✅ **COMPLETED**

**Current State**: 
- ✅ Model capability checking implemented
- ✅ Uses `agent.session.manager.connection_models.find_model()` to check model support
- ✅ Tools are only serialized when model supports tools (`can_call = true`)

**Change Applied**:
Add model capability checking using `ConnectionModels.find_model()` accessed via `agent.session.manager.connection_models`.

**Implementation**:
```vala
case "tools":
    // Only serialize tools if tools exist
    if (this.tools.size == 0) {
        return null;
    }
    
    // Check if model supports tools using ConnectionModels
    // Access via agent.session.manager.connection_models (Phase 3: no Client)
    bool model_supports_tools = true;
    
    if (this.agent != null) {
        var model_usage = this.agent.session.manager.connection_models.find_model(
            this.connection.url, 
            this.model
        );
        
        if (model_usage != null) {
            model_supports_tools = model_usage.model_obj.can_call;
        }
    }
    
    // Only exclude tools if we know the model explicitly doesn't support them
    if (!model_supports_tools) {
        return null;
    }
    
    var tools_node = new Json.Node(Json.NodeType.ARRAY);
    tools_node.init_array(new Json.Array());
    var tools_array = tools_node.get_array();
    foreach (var tool in this.tools.values) {
        // Only include active tools
        if (!tool.active) {
            continue;
        }
        var tool_node = Json.gobject_serialize(tool);
        var tool_obj = tool_node.get_object();
        // Add "type" field for Ollama API compatibility (tool-type is excluded from serialization)
        tool_obj.set_string_member("type", tool.tool_type);
        tools_array.add_element(tool_node);
    }
    return tools_node;
```

**Key Differences from Original**:
- Original used `this.client.connection_models` (Client no longer exists in Phase 3)
- New approach uses `this.agent.session.manager.connection_models`
- Only checks if `agent` is null (per coding standards: avoid excessive null checks)
- If `agent` is null, defaults to `model_supports_tools = true` (tools will be sent)
- Uses `this.connection.url` directly (Chat has connection property, not client)

---

### Step 2: Re-apply Tool Initialization Method in Tool.vala

**File**: `libollmchat/Tool/Tool.vala`

**Location**: After constructor (around line 145), and in methods that use `Object.new()`

**Status**: ✅ **COMPLETED**

**Current State**:
- ✅ `init()` method implemented (lines 145-220)
- ✅ Constructor calls `init()` (line 132)
- ✅ `tool.init()` called after all `Object.new()` usages (lines 600, 652, 687)
- ✅ Tools created via `Object.new()` are properly initialized

**Changes Applied**:

#### 2a. Add `init()` method

Add after the constructor (around line 199):

```vala
/**
 * Initialization method that ensures tools are properly initialized.
 * 
 * This method is called:
 * - In the constructor (for normal instantiation)
 * - After Object.new() calls (for tools created with named parameters)
 * 
 * Ensures tools created via Object.new() are properly initialized even
 * when constructors might not be called correctly.
 */
protected void init()
{
    if (this.function != null) {
        return; // Already initialized
    }
    
    this.function = new Function(this);
    
    // Parse parameter description in two passes:
    // 1. Collect @type and @property declarations
    // 2. Parse @param declarations, resolving types
    
    var type_definitions = new Gee.HashMap<string, ParamObject>();
    var lines = this.parameter_description.split("\n");
    var current_decl = "";
    
    // First pass: collect @type and @property declarations
    foreach (var line in lines) {
        var stripped = line.strip();
        if (stripped == "") {
            continue;
        }
        
        if (stripped.has_prefix("@")) {
            // Process previous declaration if we have one
            if (current_decl != "") {
                this.parse_type_or_property(current_decl, type_definitions);
            }
            // Start new declaration
            current_decl = stripped;
            continue;
        }
        
        // Continuation of current declaration
        if (current_decl == "") {
            continue;
        }
        current_decl += " " + stripped;
    }
    
    // Process any leftover declaration at the end
    if (current_decl != "" && (current_decl.has_prefix("@type") || current_decl.has_prefix("@property"))) {
        this.parse_type_or_property(current_decl, type_definitions);
    }
    
    // Second pass: parse @param declarations
    current_decl = "";
    foreach (var line in lines) {
        var stripped = line.strip();
        if (stripped == "") {
            continue;
        }
        
        if (stripped.has_prefix("@param")) {
            // Process previous parameter if we have one
            if (current_decl != "") {
                this.parse_parameter_description_string(current_decl, type_definitions);
            }
            // Start new parameter
            current_decl = stripped;
            continue;
        }
        
        // Continuation of current parameter
        if (current_decl == "" || !current_decl.has_prefix("@param")) {
            continue;
        }
        current_decl += " " + stripped;
    }
    
    // Process any leftover parameter at the end
    if (current_decl != "" && current_decl.has_prefix("@param")) {
        this.parse_parameter_description_string(current_decl, type_definitions);
    }
}
```

#### 2b. Call `init()` in constructor

Modify the constructor to call `init()` at the end (around line 199):

```vala
protected BaseTool()
{
    // Call init() to ensure proper initialization
    this.init();
}
```

**Note**: Since the constructor already has all the initialization code, we can either:
- Option A: Move all initialization code to `init()` and call it from constructor
- Option B: Keep constructor code as-is and have `init()` check if already initialized

**Recommended**: Option B (defensive) - keep existing constructor code, add `init()` that checks if already initialized.

#### 2c. Call `init()` after `Object.new()` calls

Add `tool.init();` calls after each `Object.new()` usage:

**Location 1**: `setup_tool_config()` method (around line 562)
```vala
// Create config instance using config_class() - works for all tool config types
var tool_config = Object.new(this.config_class()) as Settings.BaseToolConfig;
config.tools.set(this.name, tool_config);
```

**Note**: This is creating a config, not a tool, so no `init()` needed here.

**Location 2**: `setup_all_tool_configs()` method (around line 579)
```vala
foreach (var tool_type in discover_classes()) {
    // Create tool instance without parameters - works because constructors are nullable
    // Call setup_tool_config() on the instance
    // Simple tools will use the default implementation, complex tools will use their overrides
    var tool = Object.new(tool_type) as Tool.BaseTool;
    tool.init(); // Ensure tool is properly initialized
    tool.setup_tool_config(config);
}
```

**Location 3**: `register_config()` method (around line 629)
```vala
foreach (var tool_type in tool_classes) {
    // Create tool instance without parameters - works because constructors are nullable
    // Constructors handle null values gracefully (for Phase 1, we only need config_class())
    var tool = Object.new(tool_type) as Tool.BaseTool;
    tool.init(); // Ensure tool is properly initialized
    
    // Register config type with Config2
    Settings.Config2.register_tool_type(tool.name, tool.config_class());
}
```

**Location 4**: `register_all_tools()` method (around line 663)
```vala
foreach (var tool_type in tool_classes) {
    // Use Object.new() to create tool instance without parameters
    // Tools are metadata - they don't need Client or project_manager
    // Tool handlers need project_manager, provided when handlers are created
    // Tools get config from agent.session.manager.config when executing
    var tool = Object.new(tool_type) as Tool.BaseTool;
    tool.init(); // Ensure tool is properly initialized
    
    GLib.debug("register_all_tools: creating tool '%s'", tool.name);
    tools_map.set(tool.name, tool);
}
```

---

### Step 3: Re-apply Google Search Permission Fix (Commit bc973f89)

**Files**: 
- `liboctools/GoogleSearchRequest.vala`
- `liboctools/WebFetchTool.vala`

**Status**: ✅ **COMPLETED**

**Current State**:

1. **GoogleSearchRequest.vala** (lines 156-160):
   - ✅ **Permission check removed**
   - `build_perm_question()` method now returns `false` without setting permission properties
   - Fix applied: Changed to return `false` with comment explaining removal

2. **WebFetchTool.vala**:
   - ✅ **Typo already fixed** (description uses "and" correctly on line 25)
   - No "are" typo found in current description

**Changes Applied**:

**GoogleSearchRequest.vala**: Changed `build_perm_question()` method to return `false`:

```vala
protected override bool build_perm_question()
{
    // Permission check removed - Google Search no longer requires permission
    return false;
}
```

**WebFetchTool.vala**: 
- ✅ No changes needed - typo already fixed

**Original Changes**:
- `GoogleSearchRequest.vala`: Remove permission check code (change `build_perm_question()` to return `false` without setting permission properties) ✅ **APPLIED**
- `WebFetchTool.vala`: Typo already fixed (no action needed) ✅ **VERIFIED**

---

### Step 4: Re-apply Test CLI Changes (Commit fd596313)

**File**: `examples/oc-test-cli.vala`

**Status**: ✅ **COMPLETED**

**Current State**:
- ✅ `--stats` option added (static variable, option entry, reset, usage text, handler)
- ✅ `--list-models` option added (static variable, option entry, reset, usage text, early handler)
- ✅ `connection_models` setup code added (after client creation, with refresh call)
- ✅ `connection.is_working = true;` assignment added (after connection test)
- ✅ `list_models()` method implemented
- ✅ `write_stats()` method implemented

**Action Required**:

#### 4a. Add Command Line Options

Add static variables (around line 22-25):

```vala
private static string? opt_stats = null;
private static bool opt_list_models = false;
```

Add to `options` array (around line 29-35):

```vala
const OptionEntry[] options = {
    { "debug", 'd', 0, OptionArg.NONE, ref opt_debug, "Enable debug output", null },
    { "url", 0, 0, OptionArg.STRING, ref opt_url, "Ollama server URL", "URL" },
    { "api-key", 0, 0, OptionArg.STRING, ref opt_api_key, "API key (optional)", "KEY" },
    { "model", 'm', 0, OptionArg.STRING, ref opt_model, "Model name", "MODEL" },
    { "stats", 0, 0, OptionArg.STRING, ref opt_stats, "Output statistics from last message to file", "FILE" },
    { "list-models", 0, 0, OptionArg.NONE, ref opt_list_models, "List available models and exit", null },
    { null }
};
```

Reset in `command_line()` method (around line 60-64):

```vala
opt_debug = false;
opt_url = null;
opt_api_key = null;
opt_model = null;
opt_stats = null;
opt_list_models = false;
```

Update usage text (around line 100-115) to include new options:

```vala
var usage = @"Usage: $(args[0]) [OPTIONS] <query>

Send a query to the LLM and display the response.

Options:
  -d, --debug          Enable debug output
  --url=URL           Ollama server URL (required if config not found)
  --api-key=KEY       API key (optional)
  -m, --model=MODEL    Model name (overrides config)
  --stats=FILE         Output statistics from last message to file
  --list-models        List available models and exit

Examples:
  $(args[0]) \"What is the capital of France?\"
  $(args[0]) --model llama2 \"Write a hello world program\"
  $(args[0]) --debug --url http://localhost:11434/api \"Tell me a joke\"
";
```

#### 4b. Handle --list-models Early

Add handler in `command_line()` method (after debug setup, around line 88-100):

```vala
// Handle --list-models early (before query processing)
if (opt_list_models) {
    this.hold();
    this.list_models.begin(command_line, (obj, res) => {
        try {
            this.list_models.end(res);
        } catch (Error e) {
            command_line.printerr("Error: %s\n", e.message);
        } finally {
            this.release();
            this.quit();
        }
    });
    return 0;
}
```

#### 4c. Add ConnectionModels Setup and is_working Flag

In `run_test()` method, after connection is tested (around line 186-189), add:

```vala
// Mark connection as working so ConnectionModels will process it
connection.is_working = true;
```

Then after client is created (around line 220-229), add:

```vala
// Create and initialize ConnectionModels for model information lookup
var connection_models = new OLLMchat.Settings.ConnectionModels(this.config);
// Refresh to load model details (needed for tool capability checks)
try {
    yield connection_models.refresh();
} catch (GLib.Error e) {
    GLib.warning("Failed to refresh connection models: %s", e.message);
}
```

**Note**: In Phase 3, we don't assign `connection_models` to client (Client no longer has this property). The ConnectionModels is created for model information lookup, but Chat accesses it via `agent.session.manager.connection_models` instead.

#### 4d. Implement list_models() Method

Add new method (after `run_test()` method, around line 269):

```vala
private async void list_models(ApplicationCommandLine command_line) throws Error
{
    OLLMchat.Client client;
    
    // Create client connection
    if (this.config.loaded) {
        var model_usage = this.config.usage.get("default_model") as OLLMchat.Settings.ModelUsage;
        if (model_usage == null || model_usage.connection == "" || 
            !this.config.connections.has_key(model_usage.connection)) {
            throw new GLib.IOError.NOT_FOUND("default_model not configured in config.2.json");
        }
        client = new OLLMchat.Client(this.config.connections.get(model_usage.connection));
    } else {
        // Config not loaded - check if URL provided
        if (opt_url == null || opt_url == "") {
            command_line.printerr("Error: Config not found and --url not provided.\n");
            command_line.printerr("Please set up the server first or provide --url option.\n");
            throw new GLib.IOError.NOT_FOUND("Config not found and --url not provided");
        }
        
        // Create connection from command line args
        var connection = new OLLMchat.Settings.Connection() {
            name = "CLI",
            url = opt_url,
            api_key = opt_api_key ?? "",
            is_default = true
        };
        
        // Add connection to config
        this.config.connections.set(opt_url, connection);
        
        // Test connection
        var test_client = new OLLMchat.Client(connection);
        try {
            yield test_client.version();
        } catch (GLib.Error e) {
            throw new GLib.IOError.FAILED("Failed to connect to server: %s", e.message);
        }
        
        client = test_client;
    }
    
    // List models
    var models = yield client.models();
    foreach (var model in models) {
        stdout.printf("%s\n", model.name);
    }
}
```

#### 4e. Implement write_stats() Method and Handle --stats Option

Add new method (after `list_models()` method):

```vala
private void write_stats(OLLMchat.Response.Chat response, string file_path) throws Error
{
    var file = GLib.File.new_for_path(file_path);
    
    // Serialize response to JSON (no pretty printing)
    var json_node = Json.gobject_serialize(response);
    var generator = new Json.Generator();
    generator.pretty = false;  // No pretty printing
    generator.set_root(json_node);
    var json_str = generator.to_data(null);
    
    try {
        file.replace_contents(
            json_str.data,
            null,
            false,
            GLib.FileCreateFlags.NONE,
            null
        );
    } catch (GLib.Error e) {
        throw new GLib.IOError.FAILED("Failed to write stats to file: %s", e.message);
    }
}
```

Add handler in `run_test()` method (after response is received, around line 265):

```vala
// Handle --stats option
if (opt_stats != null && opt_stats != "") {
    this.write_stats(response, opt_stats);
}
```

**Key Differences from Original**:
- Original used `client.connection_models = connection_models` (Client no longer has this property in Phase 3)
- New approach creates `ConnectionModels` instance directly: `new OLLMchat.Settings.ConnectionModels(this.config)`
- Still uses explicit `connection.is_working = true;` after testing connection (as in original)
- Uses `connection_models.refresh()` to load models from all working connections
- `--stats` option takes a file path and writes response JSON to file (not connection statistics)
- `--list-models` uses `client.models()` to list model names (simple list, not detailed info)
- `list_models()` method handles the `--list-models` option separately (early exit before query processing)

---

## Testing Checklist

After re-applying all changes, verify:

- [ ] Tools are properly serialized when model supports tools (`can_call = true`)
- [ ] Tools are NOT serialized when model doesn't support tools (`can_call = false`)
- [ ] Tools are properly initialized when created via `Object.new()`
- [ ] Tools can be serialized correctly (no null function errors)
- [ ] Model capability checking works reliably across different connections
- [ ] Google search permission check works correctly (if applicable)
- [ ] Test CLI functions as expected (if changes were applied)

## Implementation Order

1. **Step 2** (Tool initialization) - Do this first, as it's independent
2. **Step 1** (Model capability checking) - Depends on Step 2 being complete
3. **Step 3** (Google Search) - Verify and apply if needed
4. **Step 4** (Test CLI) - Verify and apply if needed

## Notes

- The original fix used `client.connection_models`, but Phase 3 architecture removed Client from Chat
- New approach uses `agent.session.manager.connection_models` to access ConnectionModels
- Tool initialization is critical for tools created via `Object.new()` (used in static methods)
- Model capability checking prevents sending tools to models that don't support them

## Related Files

- Original fix commit: `9caccf34`
- Google search fix commit: `bc973f89`
- Test CLI fix commit: `fd596313`
- Related plan: `1.13-URGENT-fix-tools-sending.md`

