# 2.1.1. File Access for Tools Using OCFiles

## Overview

Migrate all file read and write operations in tools to use the `libocfiles` library, ensuring consistent buffer-based file access, proper project context handling, and backup management for file writes.

## Status

✅ **COMPLETE** - All phases implemented and tested. Test suite integrated into meson build system.

### Todo List

- [x] **Phase 1: FileBuffer Interface Refactor**
  - [x] Create `FileBuffer` interface in `libocfiles`
  - [x] Create `DummyFileBuffer` class in `libocfiles`
  - [x] Create `GtkSourceFileBuffer` class in `liboccoder`
  - [x] Update `File` class (add buffer property, remove read_async/write)
  - [x] Simplify `BufferProviderBase` (keep only detect_language and create_buffer)
  - [x] Simplify `BufferProvider` (GTK) (keep only detect_language and create_buffer)
  - [x] Add buffer cleanup/management logic (age check, keep top 10)
  - [x] Update `SourceView` to use file.buffer directly

- [x] **Phase 2: Fake File Support**
  - [x] Add `File.new_fake()` constructor
  - [x] Update `FileBase` to handle fake files (skip DB operations when `id < 0`)
  - [x] Ensure buffer provider works with fake files

- [x] **Phase 3: Project Context in Tools**
  - [x] Create `liboctools/` directory and `meson.build`
  - [x] Move `libollmchat/Tools/*` to `liboctools/` (change namespace to `OLLMtools`)
  - [x] Update `libollmchat/meson.build` (remove tools sources)
  - [x] Update `ollmchat/Window.vala` (import from `OLLMtools`)
  - [x] Add `ProjectManager` property to tool classes (ReadFile, EditMode, etc.)
  - [x] Update permission system to skip prompts for files in active project

- [x] **Phase 4: File Backup System**
  - [x] Add backup directory creation (`~/.cache/ollmchat/edited/`)
  - [x] Update `FileBuffer.write()` in `GtkSourceFileBuffer` (with backup logic)
  - [x] Update `FileBuffer.write()` in `DummyFileBuffer` (with backup logic)
  - [x] Add cleanup method for old backups (>3 days)

- [x] **Phase 5: Migrate RequestReadFile**
  - [x] Get/create File object from path
  - [x] Ensure buffer exists (create if needed)
  - [x] Use `file.buffer.read_async()` for entire file
  - [x] Use `file.buffer.get_text()` for line ranges
  - [x] Remove direct file I/O code

- [x] **Phase 6: Migrate RequestEditMode**
  - [x] Get/create File object from path
  - [x] Ensure buffer exists (create if needed)
  - [x] Use `file.buffer.read_async()` for reading current content
  - [x] Use `file.buffer.write()` for writing (handles backup)
  - [x] Remove direct file I/O code

- [x] **Phase 7: Migrate RequestCodebaseSearch**
  - [x] Remove custom file_cache and FileCacheEntry class
  - [x] Use `file.buffer.get_text()` instead of custom get_code_snippet()
  - [x] Remove get_lines() method

- [x] **Phase 8: Testing and Validation**
  - [x] Refactor `oc-test-files` to extend `TestAppBase`
    - [x] Change class to extend `TestAppBase` instead of standalone `Application`
    - [x] Implement `run_test()` method (abstract from `TestAppBase`)
    - [x] Add command-line options using `get_options()` override
    - [x] `--help` is automatically provided by `TestAppBase` via `OptionContext.set_help_enabled(true)`
    - [x] Add `--test-db` option: Specify test database path (optional, for testing only)
      - [x] Usage: `--test-db=PATH` (optional - only use when specified)
      - [x] **Default behavior**: Uses main/real database (same as normal ollmchat operation)
      - [x] **When `--test-db` is specified**: All database operations use the test database instead of main database
      - [x] **Critical**: Only use test database when `--test-db` is explicitly provided
  - [x] Add `--ls` option (current scan/print functionality)
    - [x] Move existing `run_scan()` logic to `--ls` command
    - [x] Output format: `%y %Ts %p is_ignored is_repo\n` (same as current)
    - [x] Scan current directory or specified path
  - [x] Add `--read` option: Read file with line ranges (action only, no verification)
    - [x] Usage: `--read=PATH [--start-line=N] [--end-line=M] [--output=FILE] [--backend=sourceview|dummy]`
    - [x] `--backend` option: Choose buffer backend (`sourceview` = GtkSourceFileBuffer, `dummy` = DummyFileBuffer, default: `dummy`)
    - [x] Perform `file.buffer.read_async()` for entire file (if no line range)
    - [x] Perform `file.buffer.get_text(start_line, end_line)` for line ranges
    - [x] Convert 1-based to 0-based line numbers internally
    - [x] Support files in project and fake files
    - [x] Output: Write read content to stdout or specified file
    - [x] Output metadata: File path, line range (if specified), line count, buffer type, backend used
  - [x] Add `--write` option: Write file with backups (action only, no verification)
    - [x] Usage: `--write=PATH [--content=TEXT] [--content-file=FILE] [--backup-dir=DIR] [--backend=sourceview|dummy]`
    - [x] Content source priority: `--content-file` > `--content` > stdin (if none provided, read from stdin)
    - [x] `--backend` option: Choose buffer backend (`sourceview` = GtkSourceFileBuffer, `dummy` = DummyFileBuffer, default: `dummy`)
    - [x] Note: `sourceview` backend requires GTK dependencies but should work without `gtk.init()` (use GtkSourceFileBuffer directly)
    - [x] Perform `file.buffer.write()` (creates backup automatically for database files)
    - [x] Output: Backup path (if created), file path written, file ID, backup status, backend used
    - [x] Output format: Machine-readable (e.g., `BACKUP: /path/to/backup` or `NO_BACKUP: fake_file`, `BACKEND: dummy`)
  - [x] Add `--create-fake` option: Create fake file (action only, no verification)
    - [x] Usage: `--create-fake=PATH`
    - [x] Perform `File.new_fake(manager, path)` constructor
    - [x] Output: File path, file ID (should be -1), buffer status, fake file properties
  - [x] Add `--check-project` option: Check if file is in active project (action only, no verification)
    - [x] Usage: `--check-project=PATH`
    - [x] Perform `project_manager.active_project.project_files.child_map.has_key(path)` check
    - [x] Output: File path, project membership status (IN_PROJECT or NOT_IN_PROJECT), project path
  - [x] Add `--cleanup-backups` option: Cleanup old backups (action only, no verification)
    - [x] Usage: `--cleanup-backups [--backup-dir=DIR] [--age-days=N]`
    - [x] Call `ProjectManager.cleanup_old_backups()` or static cleanup method
    - [x] Output: List of backup files removed (one per line), backup directory path, age threshold
  - [x] Add `--list-buffers` option: List current buffers (action only, no verification)
    - [x] Usage: `--list-buffers [--max-buffers=N]`
    - [x] Output: List of files with buffers (path, last_viewed timestamp, is_open status)
    - [x] Output format: Machine-readable (e.g., `BUFFER: /path/to/file TIMESTAMP: 1234567890 OPEN: true`)
  - [x] Add `--create-project` option: Create test project (action only, no verification)
    - [x] Usage: `--create-project=PATH [--test-db=DB]`
    - [x] If `--test-db` is specified: Use test database for ProjectManager
    - [x] If `--test-db` is NOT specified: Use main database (normal operation)
    - [x] Create Folder with is_project=true
    - [x] Scan directory and populate project files
    - [x] Output: Project path, database path, file count, project ID
  - [x] Add `--info` option: Show file information (action only, no verification)
    - [x] Usage: `--info=PATH`
    - [x] Output: File path, file ID, is_fake status, buffer status, in_project status, backup path (if any)

**Test Scripts in `/tests` Folder:**

- [x] Create `/tests` directory structure
  - [x] Create `tests/test-file-ops.sh` shell script
  - [x] Script runs series of `oc-test-files` commands
  - [x] Uses `diff` and other Unix commands to verify operations
  - [x] **Test file location**: Uses `~/.cache/ollmchat/testing/*` for all test files, directories, and databases
  - [x] Each test scenario:
    - Sets up test environment in `~/.cache/ollmchat/testing/` (temp directories, test files)
    - Runs `oc-test-files` commands to perform actions
    - Captures output from `oc-test-files`
    - Uses verification commands (`diff`, `test`, `grep`, etc.) to check results
    - **Cleanup behavior**:
      - If test succeeds: Deletes all files in `~/.cache/ollmchat/testing/*` (clean up completely)
      - If test fails: Leaves files in `~/.cache/ollmchat/testing/*` for debugging (don't clean up)
    - Reports pass/fail status
  - [x] Script accepts build directory as first argument (for meson integration)
  - [x] Uses `--backend sourceview` for critical tests (GTK source buffer) instead of dummy backend

- [x] **Meson Integration**
  - [x] Create `tests/meson.build` file
  - [x] Define test using `test()` function
  - [x] Pass build directory to test script
  - [x] Add dependency on `oc-test-files` executable
  - [x] Add `subdir('tests')` to main `meson.build`
  - [x] Test runs with `meson test -C build --suite file-ops`
  - [x] All 7 tests pass successfully

**Test Scenarios for `test-file-ops.sh` (All Implemented):**

- [x] **Test 1: File reading with line ranges**
  - Creates test file with known content in `~/.cache/ollmchat/testing/`
  - Runs `oc-test-files --read ~/.cache/ollmchat/testing/test.txt --start-line 2 --end-line 5 --output ~/.cache/ollmchat/testing/read_output.txt --backend sourceview`
  - Uses `diff` to compare `read_output.txt` with expected content
  - Verifies line count matches expected (handles 7 or 8 depending on trailing newline)
  - Uses GTK source buffer backend (critical test)
  - Cleans up on success, leaves files on failure

- [x] **Test 2: File writing with backups**
  - Creates test file in project (database file with `id > 0`) in `~/.cache/ollmchat/testing/`
  - Runs `oc-test-files --write ~/.cache/ollmchat/testing/test.txt --content "new content" --backend sourceview --test-db ~/.cache/ollmchat/testing/test.db`
  - Parses output for backup path (e.g., `BACKUP: /path/to/backup`) or finds backup file if path not in output
  - Uses `test -f` to verify backup file exists
  - Uses `diff` to compare backup with original content (saved before write)
  - Verifies backup path format matches `{id}-{date YY-MM-DD}-{basename}`
  - Uses GTK source buffer backend (critical test)
  - Cleans up on success, leaves files on failure

- [x] **Test 3: Fake file creation and access**
  - Runs `oc-test-files --create-fake ~/.cache/ollmchat/testing/fake.txt --test-db ~/.cache/ollmchat/testing/test.db`
  - Parses output to verify `file ID: -1`
  - Runs `oc-test-files --read ~/.cache/ollmchat/testing/fake.txt --test-db ~/.cache/ollmchat/testing/test.db` and verifies it works
  - Runs `oc-test-files --write ~/.cache/ollmchat/testing/fake.txt --content "test" --test-db ~/.cache/ollmchat/testing/test.db` and verifies no backup created
  - Cleans up on success, leaves files on failure

- [x] **Test 4: Project context detection**
  - Creates test project with `oc-test-files --create-project ~/.cache/ollmchat/testing/testproj --test-db ~/.cache/ollmchat/testing/test.db`
  - Project is automatically activated after creation
  - Runs `oc-test-files --check-project ~/.cache/ollmchat/testing/testproj/file.txt --test-db ~/.cache/ollmchat/testing/test.db`
  - Parses output to verify `IN_PROJECT` status
  - Runs `oc-test-files --check-project ~/.cache/ollmchat/testing/outside.txt --test-db ~/.cache/ollmchat/testing/test.db`
  - Parses output to verify `NOT_IN_PROJECT` status
  - Cleans up on success, leaves files on failure

- [x] **Test 5: Backup cleanup**
  - Creates test backup files with various ages in `~/.cache/ollmchat/edited/` (using `touch -t` to set dates)
  - Runs `oc-test-files --cleanup-backups`
  - Parses output for backup directory and age threshold
  - Uses `test -f` to verify old backups removed (if applicable)
  - Uses `test -f` to verify recent backups kept
  - Cleans up on success, leaves files on failure

- [x] **Test 6: Buffer cleanup/management**
  - Creates multiple files in `~/.cache/ollmchat/testing/` and accesses them to create buffers
  - Runs `oc-test-files --list-buffers --test-db ~/.cache/ollmchat/testing/test.db` to verify command works
  - Verifies buffer count is non-zero when buffers exist
  - Note: Buffers don't persist across separate `oc-test-files` invocations (each run creates new ProjectManager)
  - Cleans up on success, leaves files on failure

- [x] **Test 7: Permissions skipped for project files**
  - Creates test project with files in `~/.cache/ollmchat/testing/` using `--test-db ~/.cache/ollmchat/testing/test.db`
  - Verifies file accessibility for project files
  - Cleans up on success, leaves files on failure

**Proposed Command-Line Options Structure for `oc-test-files`:**

```vala
protected const OptionEntry[] local_options = {
    { "ls", 0, 0, OptionArg.NONE, ref opt_ls, "List files in directory (current scan/print functionality)", null },
    { "read", 0, 0, OptionArg.STRING, ref opt_read, "Read file with optional line ranges", "PATH" },
    { "start-line", 0, 0, OptionArg.INT, ref opt_start_line, "Start line number (1-based) for reading", "N" },
    { "end-line", 0, 0, OptionArg.INT, ref opt_end_line, "End line number (1-based) for reading", "M" },
    { "output", 'o', 0, OptionArg.STRING, ref opt_output, "Output file path (default: stdout)", "FILE" },
    { "write", 0, 0, OptionArg.STRING, ref opt_write, "Write file (creates backup for database files)", "PATH" },
    { "content", 0, 0, OptionArg.STRING, ref opt_content, "Content to write to file", "TEXT" },
    { "content-file", 0, 0, OptionArg.STRING, ref opt_content_file, "File containing content to write", "FILE" },
    { "backend", 0, 0, OptionArg.STRING, ref opt_backend, "Buffer backend: sourceview or dummy (default: dummy)", "TYPE" },
    { "backup-dir", 0, 0, OptionArg.STRING, ref opt_backup_dir, "Backup directory path", "DIR" },
    { "create-fake", 0, 0, OptionArg.STRING, ref opt_create_fake, "Create fake file (not in database)", "PATH" },
    { "check-project", 0, 0, OptionArg.STRING, ref opt_check_project, "Check if file is in active project", "PATH" },
    { "cleanup-backups", 0, 0, OptionArg.NONE, ref opt_cleanup_backups, "Cleanup old backup files", null },
    { "age-days", 0, 0, OptionArg.INT, ref opt_age_days, "Age in days for backup cleanup (default: 3)", "N" },
    { "list-buffers", 0, 0, OptionArg.NONE, ref opt_list_buffers, "List current file buffers", null },
    { "max-buffers", 0, 0, OptionArg.INT, ref opt_max_buffers, "Maximum buffers to keep (default: 10)", "N" },
    { "create-project", 0, 0, OptionArg.STRING, ref opt_create_project, "Create test project from directory", "PATH" },
    { "test-db", 0, 0, OptionArg.STRING, ref opt_test_db, "Test database path (optional - use test DB instead of main DB)", "DB" },
    { "info", 0, 0, OptionArg.STRING, ref opt_info, "Show file information", "PATH" },
    { null }
};
```

**Implementation Notes for `oc-test-files`:**
- Extend `TestAppBase` class (provides `--help`, `--debug`, `--url`, `--api-key`, `--model` automatically)
- Override `get_options()` to combine `base_options` with `local_options`
- Override `run_test()` to handle command dispatch based on options
- Use `validate_args()` to ensure at least one action option is specified (or `--ls`)
- **Action-oriented design**: Commands perform actions and output results, but do NOT verify correctness
- **Machine-readable output**: Use consistent prefixes (e.g., `BACKUP:`, `NO_BACKUP:`, `IN_PROJECT:`, `NOT_IN_PROJECT:`, `BUFFER:`, `FILE_ID:`, `BACKEND:`) for easy parsing by shell scripts
- Output should be structured to enable verification via `diff`, `grep`, `test`, and other Unix commands
- Each command should output what it did, not whether it was correct
- **`--write` content source**: Priority order: `--content-file` > `--content` > stdin (read from stdin if neither provided)
- **`--backend` option**: 
  - `dummy` (default): Uses `DummyFileBuffer` (no GTK dependencies)
  - `sourceview`: Uses `GtkSourceFileBuffer` (requires GTK/gtksourceview dependencies)
  - Note: `sourceview` backend should work without calling `gtk.init()` - use `GtkSourceFileBuffer` directly
  - Add GTK and gtk-sourceview as optional dependencies (only needed when `--backend=sourceview` is used)
- **`--test-db` option**: 
  - **Optional**: Only use test database when `--test-db` is explicitly specified
  - **Default behavior**: Uses main/real database (normal ollmchat operation)
  - **When `--test-db` is specified**: All database operations (ProjectManager creation, file operations, etc.) use the test database
  - Test database should be created/initialized if it doesn't exist
  - Allows `oc-test-files` to work with real projects by default, or isolated test environment when `--test-db` is used

**Implementation Notes for `tests/test-file-ops.sh`:**
- Shell script that orchestrates testing using `oc-test-files` commands
- Uses standard Unix tools (`diff`, `oc-diff`, `test`, `grep`, `awk`, etc.) for verification
- **Test file location**: All test files, directories, and databases should be created in `~/.cache/ollmchat/testing/`
- **Test database**: **Always use `--test-db=~/.cache/ollmchat/testing/test.db`** for all `oc-test-files` commands in test scripts
- **Database safety**: Test scripts must always pass `--test-db` to ensure they never touch live/main database files
- **Note**: `oc-test-files` itself can run on real database by default, but test scripts should always use `--test-db` for safety
- Each test function should:
  1. Set up test environment in `~/.cache/ollmchat/testing/` (temp dirs, test files, expected outputs)
  2. Run `oc-test-files` command(s) and capture output
  3. Parse output and verify using Unix commands
  4. Compare actual results with expected results using `diff`
  5. **Cleanup behavior**:
     - If test succeeds: Delete all files in `~/.cache/ollmchat/testing/*` (complete cleanup)
     - If test fails: Leave all files in `~/.cache/ollmchat/testing/*` for debugging (no cleanup)
  6. Return exit code (0 = pass, non-zero = fail)
- Script should support running individual tests or all tests
- Use `set -e` for error handling and `set -u` for undefined variable detection
- Provide clear test output showing which tests passed/failed
- At script start: Create `~/.cache/ollmchat/testing/` directory if it doesn't exist
- At script end (if all tests pass): Remove `~/.cache/ollmchat/testing/` directory completely

- [x] **Phase 9: Buffer System Documentation**
  - [x] Create `docs/buffer-system.md` documenting final architecture

## Goals

1. **Unified File Access**: All tools should access files through the `libocfiles` library using buffers
2. **Buffer-Based Operations**: File reads/writes should use buffer providers (either real GTK buffers or fake buffers)
3. **Project Context Awareness**: Tools should know which project they're working in
4. **File Backup System**: Automatic backups for files in database when writing
5. **Fake File Support**: Support for files that don't exist in the database
6. **Method Consolidation**: Move line range extraction methods back to buffers where they belong

## Current State

### Tools Using Direct File Access

1. **RequestReadFile** (`liboctools/RequestReadFile.vala`)
   - Currently uses `GLib.FileUtils.get_contents()` and `GLib.DataInputStream` directly
   - Reads line ranges manually with file streams
   - Does not use `libocfiles` File objects or buffers

2. **RequestEditMode** (`liboctools/RequestEditMode.vala`)
   - Uses `GLib.File` and `GLib.DataInputStream/DataOutputStream` directly
   - Creates temporary files in system temp directory
   - Does not use `libocfiles` File objects or buffers
   - Does not create backups before writing

3. **RequestCodebaseSearch** (`libocvector/Tool/RequestCodebaseSearch.vala`)
   - Uses `file.read_async()` from `libocfiles` (good!)
   - Has its own file cache implementation (duplicates BufferProviderBase cache)
   - Implements `get_code_snippet()` method that should be in buffers

### Buffer System Architecture

The buffer system in `libocfiles` provides:

1. **BufferProviderBase** (`libocfiles/BufferProviderBase.vala`)
   - Base class with default implementations
   - **Simplified to two methods**:
     - `detect_language(File file)` - Detect language from file extension
     - `create_buffer(File file)` - Create FileBuffer instance (no-op in base, creates DummyFileBuffer in implementation)
   - File cache: `file_cache` (path => FileCacheEntry with lines array) - can be moved to DummyFileBuffer or kept shared
   - **Removed methods** (moved to FileBuffer interface):
     - `get_buffer_text()`, `get_buffer_line_count()`, `get_buffer_line()`, `get_buffer_selection()`, `get_buffer_cursor()`, `has_buffer()`

2. **BufferProvider** (`liboccoder/BufferProvider.vala`)
   - GTK implementation
   - **Simplified to two methods**:
     - `detect_language(File file)` - Uses GtkSource.LanguageManager
     - `create_buffer(File file)` - Creates GtkSourceFileBuffer, stores in `file.buffer`
   - **Removed methods** (moved to FileBuffer interface):
     - All methods that accessed `GtkSource.Buffer` via `get_data`

3. **File Class** (`libocfiles/File.vala`)
   - Has `public FileBuffer? buffer { get; set; }` property
   - Has `manager.buffer_provider` reference (for creating buffers)
   - **Read/write operations moved to FileBuffer**:
     - `read_async()` - **REMOVED** - Use `file.buffer.read_async()` instead
     - `write(string contents)` - **REMOVED** - Use `file.buffer.write()` instead
   - Methods that use buffers (via `file.buffer`):
     - `get_contents(int max_lines = 0)` - Uses `file.buffer.get_text()`
     - `get_line_count()` - Uses `file.buffer.get_line_count()`
     - `get_line_content(int line)` - Uses `file.buffer.get_line()`
     - `get_selected_code()` - Uses `file.buffer.get_selection()`
     - `get_cursor_position()` - Uses `file.buffer.get_cursor()`

### Issues to Address

1. **Line Range Methods Scattered**
   - `RequestCodebaseSearch.get_code_snippet()` duplicates buffer functionality
   - `RequestReadFile` manually reads line ranges
   - Should be consolidated in `BufferProviderBase.get_buffer_text()`

2. **No Project Context in Tools**
   - Tools don't know which project they're working in
   - Files in active project should not require read/write permissions
   - Need to pass `ProjectManager` to tools (better than `active_project` - tools can access current active project without needing notifications when it changes)

3. **No File Backup System**
   - `File.write()` directly overwrites files
   - No backup before writing
   - Need backup location: `~/.cache/ollmchat/edited/{id}-{date YY-MM-DD}-{basename}`
   - Need cleanup method for old backups (>3 days)

4. **Fake File Support Missing**
   - No way to create File objects for files not in database
   - Tools may need to access files outside the project
   - Need constructor or factory method for fake files

## Implementation Plan

### Phase 1: FileBuffer Interface Refactor (OPTIONAL BUT RECOMMENDED)

**Goal**: Create FileBuffer interface for cleaner buffer architecture

**Decision**: This refactor improves the architecture significantly but adds complexity. Consider doing this before Phase 2-9, or defer to a later phase.

**Tasks**:
1. Create `FileBuffer` interface in `libocfiles`:
   - Methods: `get_text()`, `get_line_count()`, `get_line()`, `get_cursor()`, `get_selection()`, `has_content()`
2. Create `DummyFileBuffer` class in `libocfiles`:
   - Implements `FileBuffer` interface
   - Uses in-memory lines array (can share cache or have per-buffer cache)
   - No GTK dependencies
3. Create `GtkSourceFileBuffer` class in `liboccoder`:
   - Implements `FileBuffer` interface
   - Wraps `GtkSource.Buffer`
   - Provides access to underlying GTK buffer for GTK-specific features
4. Update `File` class:
   - Add `public FileBuffer? buffer { get; set; }` property
   - **Remove methods**: `read_async()` and `write()` - move to FileBuffer interface
   - Update methods to use `file.buffer` instead of `buffer_provider` methods:
     - `get_contents()` → `file.buffer.get_text()`
     - `get_line_count()` → `file.buffer.get_line_count()`
     - `get_line_content()` → `file.buffer.get_line()`
     - `get_selected_code()` → `file.buffer.get_selection()`
     - `get_cursor_position()` → `file.buffer.get_cursor()`
   - For read/write operations: Use `file.buffer.read_async()` and `file.buffer.write()`
5. **Simplify `BufferProviderBase`**:
   - **Keep only**: `detect_language(File file)` and `create_buffer(File file)`
   - **Remove all access methods**: `get_buffer_text()`, `get_buffer_line_count()`, `get_buffer_line()`, `get_buffer_selection()`, `get_buffer_cursor()`, `has_buffer()`
   - `create_buffer()` creates `DummyFileBuffer` instance and stores in `file.buffer`
   - **Add buffer cleanup logic**: Before creating new buffer, cleanup old buffers (see below)
   - File cache can be moved to `DummyFileBuffer` or kept in `BufferProviderBase` (shared cache)
6. **Simplify `BufferProvider` (GTK)**:
   - **Keep only**: `detect_language(File file)` and `create_buffer(File file)`
   - **Remove all access methods**: All methods that accessed `GtkSource.Buffer` via `get_data`
   - `create_buffer()` creates `GtkSourceFileBuffer` instance and stores in `file.buffer`
   - **Add buffer cleanup logic**: Before creating new buffer, cleanup old buffers (see below)
   - Remove `set_data/get_data` usage completely
7. **Add buffer cleanup/management**:
   - When `create_buffer()` is called, perform age check on existing buffers
   - Get `ProjectManager` from file: `file.manager`
   - Track open files: Add `Gee.HashMap<string, File> open_files` to `ProjectManager` (or use existing tracking)
   - Files have `last_viewed` (int64 Unix timestamp) - use this as `last_used` datetime
   - **Cleanup logic**:
     - Get all files with buffers from `ProjectManager.file_cache` where `file.buffer != null`
     - Filter out open files (files where `file.is_open == true` or in `open_files` hashmap)
     - Sort remaining files by `last_viewed` (most recent first)
     - Keep buffers for top 10 most recently used files
     - Set `file.buffer = null` for all other files (frees memory)
   - **Update `last_viewed`**: When buffer is accessed (read/write), update `file.last_viewed = DateTime.now_local().to_unix()`
7. Update `SourceView`:
   - Access `file.buffer` directly
   - Cast to `GtkSourceFileBuffer` when GTK-specific features needed (e.g., `(file.buffer as GtkSourceFileBuffer).gtk_buffer`)

**Files**:
- `libocfiles/FileBuffer.vala` (new interface)
- `libocfiles/DummyFileBuffer.vala` (new class)
- `liboccoder/GtkSourceFileBuffer.vala` (new class)
- `libocfiles/File.vala` (add buffer property, update methods, update last_viewed on buffer access)
- `libocfiles/BufferProviderBase.vala` (create DummyFileBuffer instances, add buffer cleanup)
- `liboccoder/BufferProvider.vala` (create GtkSourceFileBuffer instances, add buffer cleanup)
- `libocfiles/ProjectManager.vala` (optional: add open_files hashmap for tracking, or use file.is_open)
- `liboccoder/SourceView.vala` (use file.buffer directly)

**Alternative: Phase 1A - Enhance BufferProviderBase (Without Interface)**

If deferring the interface refactor, just enhance the current system:

**Tasks**:
1. Add method to get line range (1-based to 0-based conversion helper)
2. Ensure `get_buffer_text()` properly handles 1-based line numbers (if needed)
3. Add method to check if file exists in buffer cache
4. Document buffer lifecycle (create, use, cache, clear)

**Note**: Even without the interface refactor, consider simplifying BufferProvider to just `create_buffer()` and `detect_language()` methods, moving access methods to File class or a helper.

**Files**:
- `libocfiles/BufferProviderBase.vala`

### Phase 3: Fake File Support

**Goal**: Support File objects for files not in database

**Tasks**:
1. Add constructor or factory method to create File without database entry
   - `File.new_fake(ProjectManager manager, string path)` or similar
   - Sets `id = 0` or negative value to indicate not in database
   - Does not call `saveToDB()`
2. Update `FileBase` to handle fake files (skip DB operations when `id < 1`)
3. Ensure buffer provider works with fake files

**Files**:
- `libocfiles/File.vala`
- `libocfiles/FileBase.vala`

### Phase 4: Project Context in Tools

**Goal**: Tools know which project they're working in

**Tasks**:
1. **Create `liboctools` library**:
   - **Rationale**: Tools need `ProjectManager` from `libocfiles`, but `libollmchat` core doesn't need file system dependencies
   - **Benefits**:
     - Keeps `libollmchat` lean and focused on LLM/chat operations
     - Better separation of concerns
     - Tools can have their own dependencies without polluting core library
     - More modular architecture
   - **Structure**:
     - Create `liboctools/` directory
     - Move `libollmchat/Tools/*` to `liboctools/` (directly, no subdirectory)
     - Change namespace from `OLLMchat.Tools` to `OLLMtools`
     - Keep `libollmchat/Tool/` (base classes: Interface, RequestBase, Function, etc.) - these are core infrastructure
     - `liboctools` depends on: `libollmchat` (for `Tool.Interface`), `libocfiles` (for `ProjectManager`)
   - **Build order**: `libocfiles` → `libollmchat` → `liboctools`
2. Add `ProjectManager` reference to tool classes:
   - Pass `ProjectManager` to tool constructors (similar to `CodebaseSearchTool`)
   - Store as `project_manager` property on tool
   - Make `project_manager` optional (nullable) to maintain backward compatibility
   - Request objects access via `(this.tool as ToolType).project_manager`
   - Tools can access current active project via `project_manager.active_project` (no need to notify tools when it changes)
3. Update permission system to skip prompts for files in active project:
   - Modify `build_perm_question()` in tools
   - Check project membership before requesting permission using direct hashmap lookup:
     - `project_manager?.active_project?.project_files.child_map.has_key(file_path)` (nullable chain)

**Files**:
- `liboctools/meson.build` - **NEW**: Create build file with dependencies on libollmchat and libocfiles
- `libollmchat/meson.build` - Remove `ollmchat_tools_src` from sources, keep `Tool/` namespace files
- `liboctools/ReadFile.vala` - Add project_manager property and constructor parameter (moved from libollmchat, namespace `OLLMtools`)
- `liboctools/EditMode.vala` - Add project_manager property and constructor parameter (moved from libollmchat, namespace `OLLMtools`)
- `ollmchat/Window.vala` - Import tools from `liboctools` (namespace `OLLMtools`) instead of `libollmchat`
- Tool request classes (update permission logic to use project_manager, handle nullable case)

### Phase 5: File Backup System

**Goal**: Automatic backups before writing files in database

**Tasks**:
1. Add backup directory creation:
   - `~/.cache/ollmchat/edited/` (create if doesn't exist)
2. Update `FileBuffer.write()` method (in both GtkSourceFileBuffer and DummyFileBuffer):
   - Check if file has `id > 0` (in database) - access via File object reference
   - If in database, create backup before writing
   - Backup path: `{id}-{date YY-MM-DD}-{basename(filename)}`
   - Only create backup if doesn't exist for today (don't overwrite)
   - Update `file.last_approved_copy_path` property with backup path
   - Save file to database after backup
   - Then write to buffer and file on disk
3. Add cleanup method:
   - `ProjectManager.cleanup_old_backups()` or static method
   - Remove files older than 3 days from `~/.cache/ollmchat/edited/`
   - Call on startup or periodically

**Files**:
- `libocfiles/DummyFileBuffer.vala` (implement `write()` with backup logic)
- `liboccoder/GtkSourceFileBuffer.vala` (implement `write()` with backup logic)
- `libocfiles/ProjectManager.vala` (add cleanup method)
- `libocfiles/FileBase.vala` (ensure `last_approved_copy_path` is in DB schema)

### Phase 6: Migrate RequestReadFile

**Goal**: Use libocfiles and buffers for file reading

**Tasks**:
1. Get or create File object from path:
   - Use `ProjectManager.file_cache` or create fake file
   - Check if file exists in active project first
2. Ensure buffer exists:
   - If `file.buffer == null`, call `buffer_provider.create_buffer(file)`
3. Use buffer for reading:
   - For entire file: `yield file.buffer.read_async()` (handles file modtime checking for GTK buffers)
   - For line ranges: `file.buffer.get_text(start_line - 1, end_line - 1)` (convert 1-based to 0-based)
4. Remove direct file I/O code (`GLib.FileUtils.get_contents()`, `DataInputStream`, etc.)
5. Update error handling for files not found

**Files**:
- `liboctools/RequestReadFile.vala`

### Phase 7: Migrate RequestEditMode

**Goal**: Use libocfiles and buffers for file writing

**Tasks**:
1. Get or create File object from path:
   - Use `ProjectManager.file_cache` or create fake file
   - If file exists in database, use that File object
2. Ensure buffer exists:
   - If `file.buffer == null`, call `buffer_provider.create_buffer(file)`
3. Use buffer for reading current content:
   - `yield file.buffer.read_async()` to get current file content (handles modtime checking)
   - Use `file.buffer.get_text()` for line range operations
4. Use `file.buffer.write()` for writing:
   - This will automatically create backup if file is in database
   - Updates buffer contents and writes to file
   - No need for temporary files in system temp
5. Remove direct file I/O code (`GLib.File`, `DataInputStream`, `DataOutputStream`, etc.)
6. Update to use buffer-based line counting: `file.buffer.get_line_count()`

**Files**:
- `liboctools/RequestEditMode.vala`

### Phase 8: Migrate RequestCodebaseSearch

**Goal**: Use buffer provider instead of custom cache

**Tasks**:
1. Remove custom `file_cache` and `FileCacheEntry` class
2. Use `buffer_provider.get_buffer_text()` instead of `get_code_snippet()`
3. Remove `get_lines()` method (use buffer provider)
4. Update `get_code_snippet()` to use buffer provider:
   - Convert 1-based line numbers to 0-based
   - Use `buffer_provider.get_buffer_text(file, start_line - 1, end_line - 1)`

**Files**:
- `libocvector/Tool/RequestCodebaseSearch.vala`

### Phase 9: Testing and Validation

**Tasks**:
1. Test file reading with line ranges
2. Test file writing with backups
3. Test fake file creation and access
4. Test project context detection
5. Test cleanup of old backups
6. Test buffer cleanup/management (age check, keep top 10)
7. Verify permissions are skipped for active project files

### Phase 10: Buffer System Documentation

**Goal**: Document how the buffer system works (after all changes are complete)

**Tasks**:
1. Create documentation explaining:
   - FileBuffer interface and implementations (GtkSourceFileBuffer vs DummyFileBuffer)
   - How buffers are stored (via `file.buffer` property)
   - When to use real buffers vs dummy buffers
   - Buffer cleanup/management (age check, keep top 10 most recent)
   - How line range extraction works in buffers
   - Read/write operations in buffers (modtime checking for GTK buffers)
   - BufferProvider simplification (only `create_buffer()` and `detect_language()`)

**Files**:
- `docs/buffer-system.md` (new file)

## Technical Details

### Buffer System Architecture

#### Current Structure (Before Refactor)

**BufferProviderBase** (libocfiles):
- **One shared file cache** for all files: `file_cache` (path => FileCacheEntry)
- Methods operate on File objects but don't store buffers per-file
- Uses `get_lines()` which reads from disk and caches in shared cache
- No GTK dependencies

**BufferProvider** (liboccoder):
- Extends BufferProviderBase
- Creates **one GtkSource.Buffer per file**
- Stores buffers via `file.set_data<GtkSource.Buffer>("buffer", buffer)`
- Each file has its own GTK buffer instance

**Current Issues**:
- Buffers stored via `set_data/get_data` (not type-safe, not visible in File API)
- No unified interface - GTK buffers vs cache-based access
- File objects don't have direct `buffer` property
- Mixed responsibilities: BufferProvider manages both creation and access

#### Proposed Structure: FileBuffer Interface

**FileBuffer Interface** (libocfiles):
```vala
public interface FileBuffer : Object {
    // Read operations
    public abstract async string read_async() throws Error;  // Read file, update buffer if needed
    public abstract string get_text(int start_line = 0, int end_line = -1);
    public abstract int get_line_count();
    public abstract string get_line(int line);
    public abstract void get_cursor(out int line, out int offset);
    public abstract string get_selection(out int cursor_line, out int cursor_offset);
    public abstract bool has_content();
    
    // Write operations
    public abstract void write(string contents) throws Error;  // Write to buffer and file
}
```

**GtkSourceFileBuffer** (liboccoder):
- Wraps `GtkSource.Buffer`
- Implements `FileBuffer` interface
- Provides access to GTK buffer features (syntax highlighting, undo/redo)
- **Read behavior**: 
  - Tracks last read timestamp
  - Compares file modtime vs last read timestamp
  - If file modified since last read, reloads buffer from disk: `buffer.text = yield file.read_async()`
  - Returns buffer contents
- **Write behavior**:
  - Updates `GtkSource.Buffer.text` with new contents
  - Writes to file on disk
  - Updates last read timestamp
- One instance per file

**DummyFileBuffer** (libocfiles):
- Implements `FileBuffer` interface
- Uses in-memory lines array (can use shared cache or per-buffer cache)
- **Read behavior**:
  - Always reads file directly from disk (no timestamp checking needed)
  - Updates lines array cache
- **Write behavior**:
  - Updates lines array
  - Writes to file on disk
- No GTK dependencies
- One instance per file

**File Class Changes**:
- Add `public FileBuffer? buffer { get; set; }` property
- **Remove methods**: `read_async()` and `write()` - these move to FileBuffer interface
- Methods like `get_contents()`, `get_line_count()`, etc. use `file.buffer` directly
- For read/write: Use `file.buffer.read_async()` and `file.buffer.write()` instead

**BufferProvider Simplification**:
- **Single method**: `create_buffer(File file)` - creates and stores `FileBuffer` instance
- **Removed methods**: All access methods (`get_buffer_text()`, `get_buffer_line_count()`, etc.) move to `FileBuffer` interface
- `BufferProvider` (GTK): Creates `GtkSourceFileBuffer` wrapping `GtkSource.Buffer`, stores in `file.buffer`
- `BufferProviderBase`: Creates `DummyFileBuffer` with lines array, stores in `file.buffer`
- **Language detection**: Keep `detect_language(File file)` method (used for buffer creation)

**Benefits**:
- ✅ Type-safe buffer access (no `set_data/get_data`)
- ✅ Unified interface for GTK and non-GTK contexts
- ✅ Direct `file.buffer` property (visible in API)
- ✅ Each file has its own buffer object
- ✅ Clear separation: BufferProvider creates, FileBuffer provides access

**Migration Impact**:
- File.vala: Add `buffer` property, update methods to use `file.buffer` instead of `buffer_provider`, update `last_viewed` when buffer accessed
- BufferProviderBase: Create `DummyFileBuffer` instances, add buffer cleanup logic
- BufferProvider (GTK): Create `GtkSourceFileBuffer` instances, add buffer cleanup logic
- SourceView: Access `file.buffer` directly (cast to `GtkSourceFileBuffer` for GTK-specific features)
- Tools: Access `file.buffer` directly (works with both types via interface)
- ProjectManager: Optional - add `open_files` hashmap, or use existing `file.is_open` property

**Buffer Cleanup Logic**:
```vala
private void cleanup_old_buffers(File current_file) {
    var manager = current_file.manager;
    var files_with_buffers = new Gee.ArrayList<File>();
    
    // Collect all files with buffers
    foreach (var file_base in manager.file_cache.values) {
        if (file_base is File) {
            var file = (File) file_base;
            if (file.buffer != null && file != current_file) {
                files_with_buffers.add(file);
            }
        }
    }
    
    // Filter out open files (keep their buffers)
    var not_open_files = new Gee.ArrayList<File>();
    foreach (var file in files_with_buffers) {
        if (!file.is_open) {  // Use existing is_open property
            not_open_files.add(file);
        }
    }
    
    // Sort by last_viewed (most recent first)
    not_open_files.sort((a, b) => {
        if (a.last_viewed > b.last_viewed) return -1;
        if (a.last_viewed < b.last_viewed) return 1;
        return 0;
    });
    
    // Keep top 10, clear buffers for the rest
    for (int i = 10; i < not_open_files.size; i++) {
        not_open_files[i].buffer = null;
    }
}
```

### File Backup Format

**Path**: `~/.cache/ollmchat/edited/{id}-{date YY-MM-DD}-{basename}`

**Example**: `~/.cache/ollmchat/edited/123-25-01-15-MainWindow.vala`

**Rules**:
- Only create backup if file has `id > 0` (in database)
- Check if backup exists for today before creating
- If backup exists for today, skip (don't overwrite)
- Update `file.last_approved_copy_path` with backup path
- Save file to database after backup created

### Project Context Detection

**Method**: Direct hashmap lookup - no helper method needed

**Usage in Tools**:
- Tools have `project_manager` property (set in constructor)
- Request objects access via: `(this.tool as ReadFile).project_manager` or similar
- Before requesting permission, check directly:
  ```vala
  var in_project = project_manager?.active_project?.project_files.child_map.has_key(file_path) ?? false;
  ```
- If in active project (`in_project == true`), skip permission prompt
- If not in active project, request permission as normal
- Tools can always access current active project via `project_manager.active_project` without needing notifications

### Fake File Creation

**Constructor**:
```vala
public File.new_fake(ProjectManager manager, string path) {
    base(manager);
    this.base_type = "f";
    this.path = path;
    this.id = -1; // Indicates not in database (fake file)
}
```

**Behavior**:
- `id = -1` indicates fake file (not in database)
- `id = 0` indicates new file (will be inserted)
- `id > 0` indicates existing file (will be updated)
- `saveToDB()` should skip if `id < 0`
- Buffer provider works normally (uses file cache)
- Can be converted to real file if added to project later

## Files to Modify

### Core Library Files
- `libocfiles/FileBuffer.vala` - **NEW**: FileBuffer interface (if doing Phase 1 refactor)
- `libocfiles/DummyFileBuffer.vala` - **NEW**: Dummy buffer implementation (if doing Phase 1 refactor)
- `liboccoder/GtkSourceFileBuffer.vala` - **NEW**: GTK buffer wrapper (if doing Phase 1 refactor)
- `libocfiles/BufferProviderBase.vala` - Enhance buffer methods OR create DummyFileBuffer instances
- `libocfiles/File.vala` - Add fake file constructor, update write() with backup, add buffer property (if doing Phase 1)
- `libocfiles/FileBase.vala` - Handle fake files in DB operations
- `libocfiles/ProjectManager.vala` - Add project context helpers, cleanup method
- `liboccoder/BufferProvider.vala` - Create GtkSourceFileBuffer instances (if doing Phase 1)
- `liboccoder/SourceView.vala` - Use file.buffer directly (if doing Phase 1)
- `liboctools/meson.build` - **NEW**: Create build file with dependencies on libollmchat and libocfiles

### Tool Files
- `liboctools/ReadFile.vala` - Add project_manager property and constructor parameter (moved from libollmchat, namespace `OLLMtools`)
- `liboctools/EditMode.vala` - Add project_manager property and constructor parameter (moved from libollmchat, namespace `OLLMtools`)
- `liboctools/RequestReadFile.vala` - Migrate to use buffers, access project_manager from tool (moved from libollmchat, namespace `OLLMtools`)
- `liboctools/RequestEditMode.vala` - Migrate to use buffers and backups, access project_manager from tool (moved from libollmchat, namespace `OLLMtools`)
- `liboctools/meson.build` - **NEW**: Create build file with dependencies on libollmchat and libocfiles
- `libocvector/Tool/RequestCodebaseSearch.vala` - Use buffer provider instead of custom cache

### Documentation
- `docs/buffer-system.md` - New file documenting buffer architecture

## Dependencies

### Current Dependency Tree
```
libocsqlite (no deps)
  └─ libocfiles (depends on libocsqlite)
  └─ libocagent (no deps)
  └─ libollmchat (depends on libocsqlite, libocagent)
      └─ libocvector (depends on libocsqlite, libollmchat, libocfiles)
      └─ liboccoder (depends on libocsqlite, libocagent, libocfiles, libocvector, libollmchat)
```

### Required Changes

**Create `liboctools` Library**

**Rationale**: Tools need `ProjectManager` from `libocfiles`, but `libollmchat` core doesn't need file system dependencies. Separating tools into their own library provides better separation of concerns.

**New Dependency Tree**:
```
libocsqlite (no deps)
  └─ libocfiles (depends on libocsqlite)
  └─ libocagent (no deps)
  └─ libollmchat (depends on libocsqlite, libocagent)
      └─ liboctools (depends on libollmchat, libocfiles)  ← NEW
      └─ libocvector (depends on libocsqlite, libollmchat, libocfiles)
      └─ liboccoder (depends on libocsqlite, libocagent, libocfiles, libocvector, libollmchat)
```

**Changes Required**:
1. **Create `liboctools/` directory**:
   - Move `libollmchat/Tools/*` to `liboctools/` (directly, no subdirectory)
   - Change namespace from `OLLMchat.Tools` to `OLLMtools`
   - Keep `libollmchat/Tool/` (base classes stay in core library)
   - Create `liboctools/meson.build` with dependencies on `libollmchat` and `libocfiles`
2. **Update `libollmchat/meson.build`**:
   - Remove `ollmchat_tools_src` from sources
   - Keep `Tool/` namespace files (these are core infrastructure)
3. **Update `ollmchat/Window.vala`**:
   - Import tools from `liboctools` (namespace `OLLMtools`) instead of `libollmchat` (namespace `OLLMchat.Tools`)
4. **Dependency Safety**:
   - ✅ **SAFE**: No circular dependencies
   - ✅ **SAFE**: `libocfiles` doesn't depend on `libollmchat`
   - ✅ **SAFE**: `libollmchat` doesn't need file system dependencies
   - ✅ **SAFE**: Tools can evolve independently

**Build Order**:
- `libocfiles` → `libollmchat` → `liboctools`

### Other Dependencies

- Existing `libocfiles` library (dependency for `liboctools`)
- `liboccoder` for GTK buffer provider (optional, for GUI - already depends on `libocfiles`)
- File system access for backups (`~/.cache/ollmchat/edited/`)

## Testing Checklist

- [ ] File reading with line ranges works via buffers
- [ ] File writing creates backups for database files
- [ ] Fake files can be created and accessed
- [ ] Files in active project skip permission prompts
- [ ] Backup cleanup removes files older than 3 days
- [ ] Line range extraction works correctly (1-based to 0-based conversion)
- [ ] Buffer cache works for multiple file reads
- [ ] Codebase search uses buffer provider correctly

## Notes

### Buffer Architecture Decision

**Current State**:
- One shared file cache in `BufferProviderBase` (for all files)
- One `GtkSource.Buffer` per file in `BufferProvider` (stored via `set_data`)
- No unified interface - mixed access patterns

**Proposed: FileBuffer Interface**:
- Each file has its own `FileBuffer` instance (via `file.buffer` property)
- `GtkSourceFileBuffer` wraps GTK buffers for GUI contexts
- `DummyFileBuffer` provides non-GTK buffer for tools/CLI
- Unified interface makes code cleaner and more maintainable

**Recommendation**: Consider implementing Phase 1 (FileBuffer interface) before other phases, as it will simplify the rest of the implementation. However, it can be deferred if time is limited.

### Architectural Decision: liboctools Library

**Decision: Create `liboctools` Library**

**Benefits**:
- ✅ Keeps `libollmchat` lean and focused on LLM/chat operations
- ✅ Better separation of concerns (tools are separate from core chat functionality)
- ✅ Tools can evolve independently with their own dependencies
- ✅ Easier to add more tools without bloating core library
- ✅ Clear dependency boundaries
- ✅ More modular architecture

### Other Notes

- Buffer system is already partially implemented but not fully utilized
- Some methods were moved out of buffers but should be moved back
- Backup system is minimal (just file copy, no diff/merge)
- Cleanup runs on startup or can be called manually
- Fake files allow tools to work with files outside the project scope

### Review: File Class Methods

**TODO: Review whether File class methods should be moved to FileBuffer**

The following methods in `File.vala` currently delegate to `file.buffer` but may be better placed directly in the buffer:

- `get_contents(int max_lines = 0)` - Delegates to `buffer.get_text()`
- `get_line_count()` - Delegates to `buffer.get_line_count()`
- `get_selected_code()` - Delegates to `buffer.get_selection()` and updates cursor position
- `get_line_content(int line)` - Delegates to `buffer.get_line()`
- `get_cursor_position()` - Delegates to `buffer.get_cursor()` and updates cursor position

**Consideration**: These methods add database persistence logic (saving cursor position, etc.) on top of buffer operations. Should this logic:
1. Stay in File class (current approach - File manages persistence)
2. Move to FileBuffer (buffer manages its own persistence)
3. Be split - buffer operations in FileBuffer, persistence logic in File

**Decision needed**: Review after Phase 1 completion to determine best architecture.

### Optimization: Diff-Based SourceView Rendering

**TODO: Use diff tool to only update changed lines in SourceView**

Currently, when updating the SourceView (e.g., when applying edits or refreshing), the entire buffer content is replaced. For better performance, especially with large files, we should:

1. Compare new buffer contents with current displayed contents
2. Use a diff tool to identify changed lines
3. Only update the changed lines in the SourceView, preserving unchanged portions

This would be particularly beneficial for:
- Large files where only small portions change
- Reducing UI rendering overhead
- Maintaining cursor position and scroll state more accurately
- Better user experience with smoother updates

**Implementation considerations**:
- Add diff calculation in `SourceView` when updating buffer contents
- Use a lightweight diff algorithm (e.g., Myers diff algorithm)
- Fall back to full replacement if diff calculation fails or is too complex
- Consider caching displayed contents for comparison

**Files to modify**:
- `liboccoder/SourceView.vala` - Add diff-based rendering logic when updating buffer

