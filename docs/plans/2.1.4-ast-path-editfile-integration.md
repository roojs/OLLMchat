# 2.1.4. AST Path Support for EditFile Integration

## Overview

Add AST path support to EditFile/EditMode tool, allowing LLMs to reference code blocks using AST paths like `ast-path: Namespace-Class-Method` instead of line numbers in edit operations. This enables more intuitive code editing commands that work even when code changes.

## Status

ðŸš§ **IN PROGRESS** - Phases 1 and 2 complete. Core infrastructure and AST path resolution method implemented.

## Related Plans

- **2.1.2** - AST Path Support for ReadFile and EditFile (infrastructure and ReadFile integration)
- **2.1.5** - AST Path Comment Support (optional enhancement)
- **2.4** - Edit File and Edit Mode Tool (current line-based implementation)
- **2.4.1** - Edit Tool Migrate to Buffer (buffer-based editing)

## Purpose

Enable LLMs to use AST paths in edit operations:
- `ast-path: Namespace-Class-Method` - Replace/edit a method
- `ast-path: Namespace-Class` - Replace/edit an entire class
- `ast-path: Namespace-Class-Property` - Replace/edit a property

Instead of requiring precise line numbers:
- `replace lines 45-67 with ...` â†’ `replace ast-path: MyClass/myMethod with ...`
- `insert after line 89` â†’ `insert after ast-path: MyClass/myMethod`

## Implementation Phases

### Phase 1: Core Infrastructure and File Reference
- [x] Get File object early in `execute_request()` (similar to ReadFile)
- [x] Store in `this.file` property for AST path resolution
- [x] Create fake file if not in project (after AST path check, since AST doesn't work on fake files)
- [x] Ensure AST path resolution only works for files in active project (same as ReadFile)

### Phase 2: AST Path Resolution Method
- [ ] Add `resolve_ast_path()` method to RequestEditMode similar to ReadFile's implementation
  ```vala
  private async bool resolve_ast_path(string ast_path, out int start_line, out int end_line) throws GLib.Error
  {
      if (ast_path == "" || this.file == null) {
          return false;
      }
      
      var project_manager = ((Tool) this.tool).project_manager;
      
      // Get Tree instance and parse
      var tree = project_manager.tree_factory(this.file);
      yield tree.parse();
      
      // Lookup AST path
      if (tree.lookup_path(ast_path, out start_line, out end_line)) {
          return true;
      }
      
      return false;
  }
  ```
- [ ] Use same resolution pattern: `project_manager.tree_factory(file)` â†’ `tree.parse()` â†’ `tree.lookup_path()`

### Phase 3: Code Block Format Support
- [ ] Update `try_parse_code_block_opener()` to detect `ast-path:` prefix
- [ ] Support AST paths in code block format: `type:ast-path:Namespace-Class-Method` (alternative to `type:startline:endline`)
- [ ] Support both formats - AST path takes precedence if both provided
- [ ] Resolve AST path to line range before calling `enter_code_block()`
- [ ] Error handling: if AST path not found, show error and skip code block

### Phase 4: Edit Operation Types with AST Paths
- [ ] **Replace Operation:**
  - [ ] Format: `type:ast-path:Namespace-Class-Method` with replacement content
  - [ ] Resolve AST path to `start_line` and `end_line`
  - [ ] Create FileChange: `start=start_line, end=end_line, replacement=content`
  - [ ] Replaces the entire AST element with new content
  
- [ ] **Insert Before Operation:**
  - [ ] Format: `type:ast-path:Namespace-Class-Method:before` or similar marker
  - [ ] Resolve AST path to `start_line` (use start of element)
  - [ ] Create FileChange: `start=start_line, end=start_line, replacement=content`
  - [ ] Inserts new content before the AST element
  
- [ ] **Insert After Operation:**
  - [ ] Format: `type:ast-path:Namespace-Class-Method:after` or similar marker
  - [ ] Resolve AST path to `end_line` (use end of element)
  - [ ] Create FileChange: `start=end_line, end=end_line, replacement=content`
  - [ ] Inserts new content after the AST element
  
- [ ] **Delete Operation:**
  - [ ] Format: `type:ast-path:Namespace-Class-Method` with empty replacement
  - [ ] Resolve AST path to `start_line` and `end_line`
  - [ ] Create FileChange: `start=start_line, end=end_line, replacement=""`
  - [ ] Deletes the entire AST element

**Note:** The current EditMode implementation uses FileChange objects with `start`, `end`, and `replacement` properties. All operation types are supported through this model:
- Replace: `start != end` with content
- Insert: `start == end` with content  
- Delete: `start != end` with empty string

### Phase 5: AST Cache Invalidation
- [ ] Add `needs_reparse` flag to `Tree` class (boolean property)
  ```vala
  // In Tree class
  public bool needs_reparse { get; set; default = false; }
  ```
- [ ] Update `Tree.parse()` to check `needs_reparse` flag in addition to mtime check
  ```vala
  // In Tree.parse() - check flag before mtime check
  if (this.needs_reparse || file_mtime != this.last_parsed) {
      // Force reparse
      this.needs_reparse = false; // Clear flag after reparse
      // ... existing parse logic ...
  }
  ```
- [ ] Mark Tree instance as needing reparse after each AST path-based change is applied
  ```vala
  // In EditMode after applying AST path change
  var tree = project_manager.tree_factory(this.file);
  tree.needs_reparse = true; // Mark for reparse on next lookup
  ```
- [ ] Ensure subsequent AST path lookups in the same session use updated line numbers

### Phase 6: Incremental Change Application
- [ ] **Streaming Application:**
  - [ ] Apply each code block change immediately when it's captured (in `add_linebreak()` when code block closes)
  - [ ] This allows AST path resolution to work correctly for subsequent edits in the same session
  - [ ] Changes are applied to the buffer immediately, but file is not synced to disk until end of session
  - [ ] **Implementation:** Add `skip_sync` parameter to `FileBuffer.apply_edits()` method, OR
  - [ ] **Alternative:** Create `apply_edits_incremental()` method that applies edits without syncing, OR
  - [ ] **Alternative:** Manually apply edits using buffer operations (delete/insert) without calling `apply_edits()`
  - [ ] For incremental AST edits, apply to buffer but skip the sync step (sync only at end of session)

- [ ] **File History Backup (Before First Modification):**
  - [ ] Add `file_history_created` flag to Request class
  - [ ] Create file history backup BEFORE applying the first AST path-based change
  - [ ] On first AST path change:
    - [ ] Check if file exists (if not, skip backup - it's a new file)
    - [ ] If file exists and backup not yet created:
      - [ ] Get or create File object
      - [ ] Create FileHistory with `change_type = "modified"`
      - [ ] Call `FileHistory.commit()` async (creates backup before modification)
      - [ ] Set `file_history_created = true`
  - [ ] Subsequent AST path changes in same session skip backup creation (already done)
  - [ ] Implementation:
    ```vala
    // In Request class
    private bool file_history_created = false;
    
    // In add_linebreak() when AST path code block closes (first time only)
    if (!this.file_history_created && this.file != null) {
        var file_exists = GLib.FileUtils.test(this.normalized_path, GLib.FileTest.IS_REGULAR);
        if (file_exists) {
            yield this.create_file_history(project_manager, this.file, "modified");
            this.file_history_created = true;
        }
    }
    // Then apply the change to buffer
    ```
  
- [ ] **Delayed Disk Write:**
  - [ ] Do NOT sync buffer to disk after each incremental change
  - [ ] Accumulate all changes in memory (buffer)
  - [ ] At end of session (`on_message_completed()` â†’ `apply_all_changes()`), if file was modified, sync buffer to disk once
  - [ ] This matches current behavior: `file.buffer.sync_to_file()` is called at the end
  - [ ] Only write to disk once, not after each AST path change
  - [ ] The buffer's `sync_to_file()` method handles backup creation and actual file write

### Phase 7: UI Messages and Validation
- [ ] Show AST path in UI messages when code blocks use AST paths
- [ ] Include resolved line range in UI output (e.g., "Edit: ast-path: OLLMchat-Client-chat (lines 45-67)")
- [ ] Permission questions already handled by existing file permission system
- [ ] Validate AST path exists before creating FileChange
- [ ] If AST path not found, show error message and skip the code block
- [ ] Ensure resolved line range is valid (start_line >= 1, end_line >= start_line)
- [ ] Use resolved line range for FileChange (same as line-number-based edits)

### Phase 8: Documentation and Testing
- [ ] Update `liboctools/EditMode/Tool.vala` - Document AST path support in parameter_description
- [ ] Test all edit operation types (replace, insert before, insert after, delete)
- [ ] Test incremental edits in same session
- [ ] Test error handling (path not found, parse errors)
- [ ] Test with files in project and fake files

## Files to Modify

### EditFile Tool
- [ ] `liboctools/EditMode/Request.vala` - Add AST path support to edit operations
- [ ] `liboctools/EditMode/Tool.vala` - Document AST path support in parameter_description
- [ ] `libocfiles/Tree.vala` - Add `needs_reparse` flag for cache invalidation
- [ ] `libocfiles/FileBuffer.vala` - Add incremental edit support (skip sync option)

## Example Usage

### EditFile with AST Path - Replace
```
Tool: edit_mode
Code block:
```vala:ast-path:OLLMchat-Client-chat
public void chat() {
    // new implementation
}
```
```

**Result**: Replaces the `chat` method with new content.

### EditFile with AST Path - Insert Before
```
Tool: edit_mode
Code block:
```vala:ast-path:OLLMchat-Client-chat:before
// New helper method before chat()
public void helper() {
    // implementation
}
```
```

**Result**: Inserts new code before the `chat` method.

### EditFile with AST Path - Insert After
```
Tool: edit_mode
Code block:
```vala:ast-path:OLLMchat-Client-chat:after
// New method after chat()
public void cleanup() {
    // implementation
}
```
```

**Result**: Inserts new code after the `chat` method.

### EditFile with AST Path - Delete
```
Tool: edit_mode
Code block:
```vala:ast-path:OLLMchat-Client-chat

```
```

**Result**: Deletes the `chat` method (empty replacement = delete).

## Error Handling

**Path Not Found:**
- Return clear error message
- Show resolved line range if available
- Skip the code block and continue with other changes

**Multiple Matches:**
- For partial `ast-path:` (e.g., just method name), return first match with warning
- For full `ast-path:`, require complete path to disambiguate

**Parse Errors:**
- Fall back to line numbers if AST parsing fails
- Log parse error for debugging
- Continue with partial AST if possible
