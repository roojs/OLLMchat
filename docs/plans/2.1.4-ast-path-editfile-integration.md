# 2.1.4. AST Path Support for EditFile Integration

## Overview

Add AST path support to EditFile/EditMode tool, allowing LLMs to reference code blocks using AST paths like `ast-path: Namespace-Class-Method` instead of line numbers in edit operations. This enables more intuitive code editing commands that work even when code changes.

## Status

ðŸš§ **IN PROGRESS** - Phases 1, 2, 3, 4, and 5 complete. Core infrastructure, AST path resolution method, code block format support, all edit operation types (replace, insert before, insert after, delete), and AST cache invalidation infrastructure implemented.

## Related Plans

- **2.1.2** - AST Path Support for ReadFile and EditFile (infrastructure and ReadFile integration)
- **2.1.5** - AST Path Comment Support (optional enhancement)
- **2.4** - Edit File and Edit Mode Tool (current line-based implementation)
- **2.4.1** - Edit Tool Migrate to Buffer (buffer-based editing)

## Purpose

Enable LLMs to use AST paths in edit operations:
- `ast-path: Namespace-Class-Method` - Replace/edit a method
- `ast-path: Namespace-Class` - Replace/edit an entire class
- `ast-path: Namespace-Class-Property` - Replace/edit a property

Instead of requiring precise line numbers:
- `replace lines 45-67 with ...` â†’ `replace ast-path: MyClass/myMethod with ...`
- `insert after line 89` â†’ `insert after ast-path: MyClass/myMethod`

## Implementation Phases

### Phase 1: Core Infrastructure and File Reference
- [x] Get File object early in `execute_request()` (similar to ReadFile)
- [x] Store in `this.file` property for AST path resolution
- [x] Create fake file if not in project (after AST path check, since AST doesn't work on fake files)
- [x] Ensure AST path resolution only works for files in active project (same as ReadFile)

### Phase 2: AST Path Resolution Method
- [x] Add `resolve_ast_path()` method to RequestEditMode similar to ReadFile's implementation
  ```vala
  private async bool resolve_ast_path(string ast_path, out int start_line, out int end_line) throws GLib.Error
  {
      if (ast_path == "" || this.file == null) {
          return false;
      }
      
      var project_manager = ((Tool) this.tool).project_manager;
      
      // Get Tree instance and parse
      var tree = project_manager.tree_factory(this.file);
      yield tree.parse();
      
      // Lookup AST path
      if (tree.lookup_path(ast_path, out start_line, out end_line)) {
          return true;
      }
      
      return false;
  }
  ```
- [x] Use same resolution pattern: `project_manager.tree_factory(file)` â†’ `tree.parse()` â†’ `tree.lookup_path()`

### Phase 3: Code Block Format Support
- [x] Update `try_parse_code_block_opener()` to detect `ast-path:` prefix
- [x] Support AST paths in code block format: `type:ast-path:Namespace-Class-Method` (alternative to `type:startline:endline`)
- [x] Support both formats - AST path takes precedence if both provided
- [x] Resolve AST path to line range before calling `enter_code_block()`
- [x] Error handling: if AST path not found, show error and skip code block
- [ ] **Note:** Phase 6 will add mode enforcement - `use_line_numbers` parameter will prevent mixing formats

### Phase 4: Edit Operation Types with AST Paths
- [x] **Replace Operation:**
  - [x] Format: `type:ast-path:Namespace-Class-Method` with replacement content
  - [x] Resolve AST path to `start_line` and `end_line`
  - [x] Create FileChange: `start=start_line, end=end_line, replacement=content`
  - [x] Replaces the entire AST element with new content
  
- [x] **Insert Before Operation:**
  - [x] Format: `type:ast-path:Namespace-Class-Method:before` or similar marker
  - [x] Resolve AST path to `start_line` (use start of element)
  - [x] Create FileChange: `start=start_line, end=start_line, replacement=content`
  - [x] Inserts new content before the AST element
  
- [x] **Insert After Operation:**
  - [x] Format: `type:ast-path:Namespace-Class-Method:after` or similar marker
  - [x] Resolve AST path to `end_line` (use end of element)
  - [x] Create FileChange: `start=end_line, end=end_line, replacement=content`
  - [x] Inserts new content after the AST element
  
- [x] **Delete Operation:**
  - [x] Format: `type:ast-path:Namespace-Class-Method` with empty replacement
  - [x] Resolve AST path to `start_line` and `end_line`
  - [x] Create FileChange: `start=start_line, end=end_line, replacement=""`
  - [x] Deletes the entire AST element

**Note:** The current EditMode implementation uses FileChange objects with `start`, `end`, and `replacement` properties. All operation types are supported through this model:
- Replace: `start != end` with content
- Insert: `start == end` with content  
- Delete: `start != end` with empty string

### Phase 5: AST Cache Invalidation
- [x] Add `needs_reparse` flag to `Tree` class (boolean property)
  ```vala
  // In Tree class
  public bool needs_reparse { get; set; default = false; }
  ```
- [x] Update `Tree.parse()` to check `needs_reparse` flag in addition to mtime check
  ```vala
  // In Tree.parse() - check flag before mtime check
  if (file_mtime > 0 && file_mtime == this.last_parsed && !this.needs_reparse) {
      // Skip parsing - file unchanged and no reparse flag
      return;
  }
  // Clear reparse flag if it was set
  if (this.needs_reparse) {
      this.needs_reparse = false;
  }
  // ... existing parse logic ...
  ```
- [x] **Note:** Phase 5 only adds the infrastructure (flag and parse() check). The actual marking of `tree.needs_reparse = true` will be done in Phase 6 when incremental changes are applied to the buffer.
- [x] **Note:** When the file is synced to disk at the end of the session, the mtime update will naturally trigger reparse. The `needs_reparse` flag is needed for incremental edits that are applied to the buffer but not yet synced to disk (so mtime hasn't changed yet).

### Phase 6: Line Number Mode (Legacy)
- [ ] **Mode Selection Parameter:**
  - [ ] Add `use_line_numbers` boolean parameter to Request class (default = false)
  - [ ] When `use_line_numbers = true`: Use line number mode (legacy behavior)
    - [ ] Line numbers are required, changes accumulate in `changes` array
    - [ ] If AST path format is detected, show error and reject the code block
    - [ ] All changes in session must use line numbers
    - [ ] Changes are applied at end of session (no incremental application)
  - [ ] **Rationale:** Prevents mixing AST path and line number changes in same session, which would cause inconsistencies
  - [ ] Update Tool parameter_description to document `use_line_numbers` parameter
  - [ ] Update error messages to indicate which mode is active when wrong format is detected
  - [ ] Update `try_parse_code_block_opener()` to check mode:
    - [ ] If `use_line_numbers = true` and AST path format detected: reject with error
    - [ ] Set mode on first code block (based on format detected), then enforce for all subsequent blocks
  - [ ] **Behavior:** Use existing legacy behavior - accumulate all changes in `changes` array, apply at end via `apply_all_changes()`
  - [ ] File history is created in `apply_all_changes()` before applying changes (existing behavior)

### Phase 7: AST Path Mode (Incremental Application)
- [ ] **Mode Selection Parameter:**
  - [ ] When `use_line_numbers = false` (default): Use AST path mode
    - [ ] AST paths are preferred and changes are applied incrementally to buffer
    - [ ] If line number format is detected, show error and reject the code block
    - [ ] All changes in session must use AST paths
  - [ ] Update `try_parse_code_block_opener()` to check mode:
    - [ ] If `use_line_numbers = false` and line number format detected: reject with error
    - [ ] Set mode on first code block (based on format detected), then enforce for all subsequent blocks

- [ ] **Streaming Application:**
  - [ ] **Only when `use_line_numbers = false`:** Apply each code block change immediately when it's captured (in `add_linebreak()` when code block closes)
  - [ ] This allows AST path resolution to work correctly for subsequent edits in the same session
  - [ ] Changes are applied to the buffer immediately, but file is not synced to disk until end of session
  - [ ] **Implementation:** Add `skip_sync` parameter to `FileBuffer.apply_edits()` method, OR
  - [ ] **Alternative:** Create `apply_edits_incremental()` method that applies edits without syncing, OR
  - [ ] **Alternative:** Manually apply edits using buffer operations (delete/insert) without calling `apply_edits()`
  - [ ] For incremental AST edits, apply to buffer but skip the sync step (sync only at end of session)
  - [ ] **Tree Reparse Marking:** After each AST path-based change is applied to the buffer (but before sync to disk), mark the tree as needing reparse:
    ```vala
    // In add_linebreak() after applying incremental AST path change to buffer
    if (this.used_ast_paths && this.file != null && this.file.id > 0) {
        var project_manager = ((Tool) this.tool).project_manager;
        var tree = project_manager.tree_factory(this.file);
        tree.needs_reparse = true; // Mark for reparse on next AST path lookup
    }
    ```
  - [ ] **Note:** Since changes are applied to buffer but not synced to disk, mtime won't change. The `needs_reparse` flag (from Phase 5) forces reparse on next AST path lookup. When file is synced to disk at end of session, mtime update will naturally trigger reparse.

- [ ] **File History Backup (Before First Modification):**
  - [ ] Add `file_history_created` flag to Request class
  - [ ] Add `incremental_changes_applied` flag to Request class (tracks if any incremental changes were applied to buffer)
  - [ ] Create file history backup BEFORE applying the first AST path-based change
  - [ ] On first AST path change:
    - [ ] Check if file exists (if not, skip backup - it's a new file)
    - [ ] If file exists and backup not yet created:
      - [ ] Get or create File object
      - [ ] Create FileHistory with `change_type = "modified"`
      - [ ] Call `FileHistory.commit()` async (creates backup before modification)
      - [ ] Set `file_history_created = true`
  - [ ] Subsequent AST path changes in same session skip backup creation (already done)
  - [ ] Implementation:
    ```vala
    // In Request class
    private bool file_history_created = false;
    
    // In add_linebreak() when AST path code block closes (first time only)
    if (!this.file_history_created && this.file != null) {
        var file_exists = GLib.FileUtils.test(this.normalized_path, GLib.FileTest.IS_REGULAR);
        if (file_exists) {
            yield this.create_file_history(project_manager, this.file, "modified");
            this.file_history_created = true;
        }
    }
    // Then apply the change to buffer
    ```
  
- [ ] **Delayed Disk Write:**
  - [ ] Apply each AST path-based change to the buffer immediately (in memory) when code block closes
  - [ ] Set `incremental_changes_applied = true` when applying incremental change to buffer
  - [ ] Do NOT sync buffer to disk after each incremental change
  - [ ] All changes accumulate in the buffer (in memory)
  - [ ] **Important:** File history is created BEFORE the first incremental change (see "File History Backup" section above) - this creates backup from original file on disk
  - [ ] At end of session (`on_message_completed()` â†’ `apply_all_changes()`), check `incremental_changes_applied` flag in addition to `changes.size`
  - [ ] **Critical:** Update `apply_all_changes()` early return check:
    ```vala
    // Check if we have changes OR incremental changes were applied
    if (this.changes.size == 0 && !this.incremental_changes_applied) {
        return;
    }
    ```
  - [ ] **For incremental changes path:** If `incremental_changes_applied == true` but `changes.size == 0`:
    - [ ] Get or create File object
    - [ ] Ensure buffer is loaded
    - [ ] **Do NOT create file history again** (already created before first incremental change)
    - [ ] Sync buffer to disk: `yield file.buffer.sync_to_file()`
    - [ ] Update file metadata (is_need_approval, last_change_type, last_modified)
    - [ ] Save to database if needed
  - [ ] **Note:** The buffer's `sync_to_file()` method writes all accumulated changes to disk (backup was already created by FileHistory.commit() before first change)

### Phase 8: UI Messages and Validation
- [ ] Show AST path in UI messages when code blocks use AST paths
- [ ] Include resolved line range in UI output (e.g., "Edit: ast-path: OLLMchat-Client-chat (lines 45-67)")
- [ ] Permission questions already handled by existing file permission system
- [ ] Validate AST path exists before creating FileChange
- [ ] If AST path not found, show error message and skip the code block
- [ ] Ensure resolved line range is valid (start_line >= 1, end_line >= start_line)
- [ ] Use resolved line range for FileChange (same as line-number-based edits)

### Phase 9: Documentation and Testing
- [ ] Update `liboctools/EditMode/Tool.vala` - Document AST path support and `use_line_numbers` parameter in parameter_description
- [ ] Test all edit operation types (replace, insert before, insert after, delete)
- [ ] Test incremental edits in same session (AST path mode)
- [ ] Test mode enforcement: reject line number format when `use_line_numbers = false`
- [ ] Test mode enforcement: reject AST path format when `use_line_numbers = true`
- [ ] Test error handling (path not found, parse errors)
- [ ] Test with files in project and fake files

## Files to Modify

### EditFile Tool
- [x] `liboctools/EditMode/Request.vala` - Add AST path support to edit operations (Phases 1-4 complete)
  - [ ] Add `use_line_numbers` parameter and line number mode enforcement (Phase 6)
  - [ ] Add AST path mode enforcement and incremental application (Phase 7)
- [ ] `liboctools/EditMode/Tool.vala` - Document AST path support and `use_line_numbers` parameter in parameter_description (Phase 6)
- [x] `libocfiles/Tree.vala` - Add `needs_reparse` flag for cache invalidation (Phase 5 complete)
- [ ] `libocfiles/FileBuffer.vala` - Add incremental edit support (skip sync option) (Phase 7)

## Example Usage

### EditFile with AST Path - Replace
```
Tool: edit_mode
Code block:
```vala:ast-path:OLLMchat-Client-chat
public void chat() {
    // new implementation
}
```
```

**Result**: Replaces the `chat` method with new content.

### EditFile with AST Path - Insert Before
```
Tool: edit_mode
Code block:
```vala:ast-path:OLLMchat-Client-chat:before
// New helper method before chat()
public void helper() {
    // implementation
}
```
```

**Result**: Inserts new code before the `chat` method.

### EditFile with AST Path - Insert After
```
Tool: edit_mode
Code block:
```vala:ast-path:OLLMchat-Client-chat:after
// New method after chat()
public void cleanup() {
    // implementation
}
```
```

**Result**: Inserts new code after the `chat` method.

### EditFile with AST Path - Delete
```
Tool: edit_mode
Code block:
```vala:ast-path:OLLMchat-Client-chat

```
```

**Result**: Deletes the `chat` method (empty replacement = delete).

## Error Handling

**Path Not Found:**
- Return clear error message
- Show resolved line range if available
- Skip the code block and continue with other changes

**Multiple Matches:**
- For partial `ast-path:` (e.g., just method name), return first match with warning
- For full `ast-path:`, require complete path to disambiguate

**Parse Errors:**
- Fall back to line numbers if AST parsing fails
- Log parse error for debugging
- Continue with partial AST if possible
