# 1.23.11 Runner Implementation (single plan)

## Overview

Sub-plan of 1.23.2: **single plan** for all Runner (orchestrator) work. **Plans 1.23.8, 1.23.9, and 1.23.10 are merged here** — they were Runner/flow content and do not need separate plans. This plan covers: (Phase 2) single-path flow — task creation (initial) → executor per task → post completion; (Phase 3) refinement — when a task has "skill needed", refinement prompt, Skill call parsing, precursor injection; (Phase 4) multi-round loop — post completion returns full task list, Runner continues or concludes from that list; error handling, re-run with feedback, user-facing messages. Plus parsing (1.23.3–1.23.5 formats), link resolution, precursor injection, executor invocation per 1.23.6. All Runner implementation and flow live in this plan only.

## Status

**PLAN** — Implementation not started. Expand this document with all Runner behaviour (phases 2–4, parsing, link resolution, precursor injection, orchestration) so that prompt plans (1.23.3–1.23.6) only define prompts and formats, and this plan is the single source of Runner changes.

## Dependencies

- Plan 1.23.2 (Three Prompt Types and Orchestration).
- Plans 1.23.3, 1.23.4, 1.23.5, 1.23.6: prompt content and **output formats** the Runner must parse and honour.
- Plan 1.23.7: skill-prompts location, skill catalog shape, executor skills layout.
- Plan 1.23.1 (Skill Runner in occoder): existing Runner, Manager, Definition.

## Scope

All Runner (orchestrator) behaviour belongs in this plan. Former plans 1.23.8, 1.23.9, 1.23.10 are merged here (see Phases 2–4 below).

1. **Task creation (initial) — load prompt and parse output (1.23.3):** Load task creation (initial) prompt from `skill-prompts`. **Prompt template:** system and user sections are split by `---`; the prompt body in 1.23.3 must not use `---` internally (see 1.23.3 Concrete prompt, template note). **Build user message** by replacing placeholders in order: `{environment}`, `{project_description}`, `{current_file}`, `{open_files}`, `{previous_proposal}`, `{previous_proposal_issues}`, `{user_prompt}`. When re-running after a problem with the plan, fill `{previous_proposal}` and `{previous_proposal_issues}`; otherwise omit or leave empty. Definitions in 1.23.3 §1 (Precursor information). **Build system message:** prompt body + `{skill_catalog}` replaced by catalog from executor skills’ frontmatter. One LLM call. **Parse output (1.23.3 §2 and Concrete prompt):** original prompt, goals/summary, general information for all tasks, **Tasks** split into **task sections** (Task section 1, Task section 2, …). Sections run sequentially; tasks within a section may run in parallel. Per task: What is needed, Skill, References (markdown links only — series of links), Expected output. **Link resolution:** file links use **absolute path** (1.23.3); resolve to file contents; project summary and plan section targets per 1.23.3. Inject resolved content into precursor area for downstream steps. Required sections and fields; what to do if format is wrong.
2. **Precursor injection:** When a task (or refinement/executor) references precursor by link, Runner injects the corresponding content (current file body, project description, prior task output, plan section) into the markdown precursor area for that step. How links are resolved (target → content); special targets (e.g. `project_description`, `current_file`, task output ids).
3. **Refinement path (1.23.4):** The Runner **splits** the task list into individual coarse tasks. For **each** coarse task that has "skill needed", it invokes the refinement prompt **once per task** (one refinement call per coarse task). For each such call: load task refinement prompt, build input (that **single** coarse task + skill pre-execution data extracted from the skill + precursor contents only for that task's references). Parse refinement output (one detailed task, one Skill call block). Skill call parsing: extract skill name + parameters, invoke pre-execution skill, append result to reference_files. Tasks without a skill skip refinement and go directly to execution (or are handled per existing rules).
4. **Executor invocation (1.23.6):** For each task ready for execution: build (query, reference_files) including precursor contents for any links; load executor skill from `resources/skills`; one LLM call; parse single-file output.
5. **Post completion (1.23.5):** After executor run, load post-completion prompt, inject full task list + precursor (including completed-task outputs). Parse output as full task list (same format as 1.23.3). If tasks without output remain, feed list back into refinement/executors; if all have output, conclude.
6. **Orchestration logic and mode:** Entry point; how Runner chooses mode (initial creation vs per-task refinement/execution vs post completion). Session/state; loop structure. Implement Phases 2–4 below.
7. **Error handling and re-run:** Parse failures (task list, refinement output); missing skill; executor failure. Re-run refinement with feedback when applicable. User-facing messages. (See Phase 4.)

## 1. Task creation (initial) parsing (to expand)

- **Source of truth:** Full output format, user message template, and reference link types are in **Plan 1.23.3** (§2 Output format, §1 Precursor information, Concrete prompt).
- Required sections: original prompt, goals/summary, general information for all tasks, **Tasks** composed of **task sections** (Task section 1, Task section 2, …). Sections run sequentially; within a section, tasks may run in parallel. Parser must preserve section boundaries for orchestration.
- Per-task fields: What is needed, Skill, References (markdown links only — series of links), Expected output. Parse links `[Title](target)`; file targets are **absolute paths** (1.23.3); title is typically file base name. Resolve targets to content for later injection. Validation: required fields present; link targets recognised (absolute file path, `project_description`, plan section/task output).

## 2. Link resolution and precursor injection (to expand)

- Map link target to content: file path → file contents; `project_description` → project description; plan section or task output id → corresponding content. When building input for refinement or executor, inject resolved content into markdown precursor area. Initial precursor (for creation prompt) built from environment, project description, current file contents, user's prompt — see 1.23.3. When re-running after a problem with the plan, also inject previous_proposal and previous_proposal_issues.

## 3. Refinement and Skill call parsing (to expand)

- **Split tasks:** After parsing the task creation output, the Runner iterates over each coarse task (within each task section). For each task that has a skill: invoke refinement **once for that task only**. Build input: that single coarse task, skill pre-execution data (extracted from the skill definition), and precursor contents restricted to that task's references (same format as 1.23.3 precursor, but only what this task references). Load refinement prompt; fill placeholders; one LLM call per task. Parse refinement output per 1.23.4 (single detailed task, one Skill call block); extract skill name + parameters; map to pre-execution skill; invoke with parameters; append result to reference_files. Re-run refinement with feedback on parse/execution failure.

## 4. Executor and continuation (to expand)

- Executor: (query, reference_files with precursor contents) → load executor skill → one file output. Continuation: completed list + outputs → continuation prompt → parse continue/conclude and optional new tasks.

## 5. Orchestration loop and registration (to expand)

- Where Runner is invoked (e.g. from app/agent); how it loads prompt vs skill; skill catalog assembly; directory layout for `skill-prompts` vs `resources/skills`. Integration with 1.23.1 Runner/Manager.

## 6. Phases (merged from former 1.23.8, 1.23.9, 1.23.10)

- **Phase 2 — Single-path:** Creation (initial) → for each task run pre-execution skill (stub if needed) then executor → post completion with full list + results in precursor. No refinement yet (tasks with "skill needed" use stub params). End-to-end markdown I/O.
- **Phase 3 — Refinement:** Runner **splits** coarse tasks and runs refinement **per task**. When a coarse task has "skill needed", load refinement prompt, build input for **that task only** (single coarse task + skill pre-execution data + precursor contents for that task's links). One refinement call per such task. Parse Skill call block; invoke pre-execution skill; run executor. Multiple coarse tasks are each refined individually (some refined, some direct). Re-run refinement with feedback on parse/execution failure.
- **Phase 4 — Multi-round and robustness:** Post completion returns full task list. Loop: if tasks without output remain, new round = refinement → executors → post completion; else conclude. Error handling: missing skill, unparseable refinement/post-completion output, executor failure; refinement re-run with feedback; user-facing messages. Max rounds/retries. More pre-execution and executor skills as needed.

## Deliverable

- **Single plan** containing all Runner implementation and flow (Phases 2–4): parsing (1.23.3, 1.23.4, 1.23.5 formats), link resolution, precursor injection, refinement, execution, post completion, error/re-run, multi-round loop. Former plans 1.23.8, 1.23.9, 1.23.10 merged here; see redirect stubs in those files.

## References

- Plan 1.23.2 (orchestration, flow).
- Plan 1.23.3 (task creation initial prompt and output format) — Runner must parse this format. **See 1.23.3:** §1 Precursor information (user message placeholders), §2 Output format (task sections, link types), Concrete prompt (system/user template, no `---` in body, user message template, reference link types including absolute file path).
- Plan 1.23.4 (task refinement prompt and Skill call format).
- Plan 1.23.5 (task creation continuation prompt and output format).
- Plan 1.23.6 (task execution prompt and output format).
- Plan 1.23.7 (skill-prompts and catalog).
- Plan 1.23.1 (existing Skill Runner).
