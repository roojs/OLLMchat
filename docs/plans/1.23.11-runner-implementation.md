# 1.23.11 Runner Implementation (single plan)

**Note:** Do not add sentences to this plan unless specifically asked — only bullet points or nested bullet points.

**Coding standards:** All proposed code in this plan must follow `.cursor/rules/CODING_STANDARDS.md`. Before implementation, verify against the checklist there. This plan’s code uses: **this.** for instance members (including in callbacks: this.run_child, this.child_done(), this.wait_until_all_children_done); **var** for initializers where type is not required; **item.children** and **children.get(0)** (Gee .get(), not []); **continue** to avoid else in loops; inline braces for control structures (if/foreach); **GLib.Error**; no underscore names; no get_* for simple accessors.

---

## Overview

- Sub-plan of **1.23.2**. Single plan for all Runner (orchestrator) work; plans 1.23.8, 1.23.9, 1.23.10 merged here.
- Flow: task creation (initial) → run reader tasks (research/plan) → if writer tasks and no approval yet, ask user to approve → run writer tasks (modify) → loop or conclude. No separate "post list" that suggests change tasks; a task that changes something is a normal (writer) task.
- Parsing, Task-built precursor (no PrecursorBuilder), and orchestration are defined in this plan; prompt content and output formats are in 1.23.3–1.23.6.

**Status:** PLAN — Implementation not started.

**Dependencies:** 1.23.2, 1.23.3–1.23.6 (formats), 1.23.1 (existing Runner/Manager/Definition), 1.23.12 (context restriction format). **project_description** source: active project's **summary()** (2.20.5 project-level summaries in vector_metadata); if not completed, summary may be empty.

---

## Classes to change

### Runner (`liboccoder/Skill/Runner.vala`)

- **Prompt templates**
  - Switch to a hashmap to store prompt templates (keyed by prompt type or name).
  - Store a pointer/reference to the active template for the current step.
- **Entry and loop**
  - Entry: task creation, then per-task refinement+execution (reader then writer with approval), post completion.
    - Responsible: Runner (entry and loop).
  - Loop: after post completion, if tasks without output remain → reader tasks → writer approval → writer tasks → post completion again; else conclude.
    - Responsible: Runner (loop control). No Runner step state; each step uses explicit template key or Task handles it.
- **Task creation**
  - Load task-creation (initial) prompt from `skill-prompts`.
    - Responsible: Runner (get from template hashmap); PromptTemplate (load file).
  - Build user message.
    - Responsible: Runner or PromptTemplate.fill(); placeholder set defined in 1.23.3 §1.
  - Build system message (prompt body + skill catalog).
    - Responsible: Runner; Manager (skill catalog string); PromptTemplate.fill().
  - One LLM call.
    - Responsible: Runner (existing agent flow).
  - Parse output.
    - Responsible: TaskListParser.parse(); Runner calls it and stores result (format 1.23.3 §2).
- **Refinement**
  - For each coarse task with "skill needed":
    - Load refinement prompt from `skill-prompts`.
      - Responsible: Runner (template hashmap); PromptTemplate (load file).
    - Build input (single task + skill input requirements + precursor for that task’s references).
      - Responsible: Task (builds own precursor from its references); Definition (skill input requirements); Runner (orchestration).
    - One LLM call.
      - Responsible: Runner.
    - Parse refinement output for one or more Skill/tool call code blocks.
      - Responsible: RefinementOutputParser.parse(); Runner calls it.
    - Invoke each tool/skill; collect all outputs; pass all to executor as precursor.
      - Responsible: Runner (orchestration); Manager (resolve skill by name, run tool); Runner assembles precursor.
  - Tasks without skill skip refinement.
    - Responsible: Runner (branch on task).
  - Re-run refinement with feedback on parse/execution failure.
    - Responsible: Runner (retry + feedback message).
- **Executor**
  - For each task ready to run:
    - Load interpreter prompt from `resources/skill-prompts/task_execution.md`.
      - Responsible: Runner (template hashmap); PromptTemplate (load file).
    - Fill `{query}`, `{skill_definition}`, `{precursor}`.
      - Responsible: Runner; Definition.full_content for skill_definition; PrecursorBuilder for precursor (resolved links + all tool outputs for this task).
    - One LLM call.
      - Responsible: Runner.
    - Parse interpreter output (summary + optional details block).
      - Responsible: ExecutorOutputParser.parse(); Runner calls it.
    - Store result; if details block present, save to file and record for post-completion.
      - Responsible: Runner (persist result + file write).
- **Post completion**
  - Load post-completion prompt.
    - Responsible: Runner (template hashmap); PromptTemplate (load file).
  - Inject full task list + precursor (including completed outputs).
    - Responsible: Runner or TaskList (assemble full task list + completed outputs from this.task_list).
  - Parse output as full task list.
    - Responsible: TaskListParser.parse(); Runner calls it.
  - Decide continue or conclude from that list.
    - Responsible: Runner (branch; may re-enter refinement/executor loop or conclude).
- **Reader vs writer / approval**
  - Tasks are reader (research/plan) or writer (modify). Run reader tasks first; if task list has writer tasks and user has not yet approved running them, stop and ask user to approve; then run writer tasks. No separate "change tasks" list; writer tasks are normal tasks.
    - Responsible: TaskList (run_until_writer, has_writer_tasks, run_all_tasks); Runner (approval gate, ask user).
- **Errors**
  - Handle parse failures (task list, refinement, post-completion), missing skill, executor failure.
    - Responsible: Runner (catch, decide retry or abort); parsers may throw or return error.
  - User-facing messages; max rounds/retries.
    - Responsible: Runner (emit messages; enforce max rounds).
- **Precursor**
  - Inject content for referenced links when building input for refinement or executor.
    - Responsible: LinkResolver/PrecursorBuilder (resolve + build markdown); Runner (call when building input).
  - Optionally filter out content marked no-longer-relevant.
    - Responsible: Task (filter step once 1.23.12 defines format when building its precursor).

---

## Proposed code: Runner + PromptTemplate.template by key

- **PromptTemplate:** Location hard-coded in PromptTemplate (resource:// for skill-prompts). `load_dir()` takes no argument; loads from that resource dir and caches the map inside PromptTemplate. `PromptTemplate.template(key)` returns the cached template for that key. No loading in Runner. Template key passed explicitly where needed (no Runner state).
- **Runner:** No step state. Uses `PromptTemplate.template("task_creation_initial")` etc. by key where needed. Each **Task** is agent-like: connects to parent session, builds its own precursor (no PrecursorBuilder), does its own LLM/message work for refinement and executor.

---

### Runner — proposed changes (full, for review)

#### 1. Fields

- **task_list** — Result from task creation or post completion (1.23.3 format). Type: **TaskList** (contains array of task sections, each with array of **Task**; each Task has what is needed, skill, references, expected output, and when completed an **output** (CompletedTaskResult)). Completed outputs live on the tasks: task.output set when executor finishes. (previous_proposal / previous_proposal_issues are **not** on TaskList; they are locals in **prepare_tasks** only.)
- **writer_approval** — True once user has approved running writer (modify) tasks this run; used so we stop and ask before first writer phase, then run writer tasks.
- **Project manager** — Runner uses project manager (e.g. from Factory or app) for **active_project_summary()**: returns active project's summary from database (vector_metadata, element_type = 'project', per 2.20.5). If 2.20.5 not yet complete or no summary stored, return empty string.
- **Max rounds** — Loop uses literal 5 with a comment (no const or variable). After loop, flag (e.g. hit_max_rounds) to detect "Max rounds reached" when still pending.

```vala
// Default empty so previous_proposal / previous_proposal_issues are available for first run; replaced by parse result
private TaskList task_list { get; set; default = new TaskList(); }
private bool writer_approval = false;
```

#### 2. Entry point and loop

- **Entry:** App/agent calls **run_async** to run the full flow: **prepare_tasks** (loop until valid task list) → rounds (reader tasks, writer approval, writer tasks, continuation) → loop or conclude.
- **Loop:** `for (var i = 0; i < 5; i++)` (comment only; no const/variable for 5). If **this.task_list.no_pending() == 0** break; else **refine(this)** (start refinement for all tasks; does not block), then yield run_until_writer, writer approval gate, run_all_tasks, run_continuation. After loop, if we did not break (hit max rounds) and still pending, add_message "Max rounds reached."
- TaskList API and approval: see **§ TaskList**. **Refinement is started** (non-blocking); run_until_writer and run_all_tasks **wait only until the task(s) they are about to run have been refined**, then run run_tools + post_evaluate. So e.g. with 10 tasks, task 1 can run as soon as task 1 is refined; we do not wait for tasks 2–10 to be refined.

```vala
public async void run_async(string user_prompt, GLib.Cancellable? cancellable = null) throws GLib.Error
{
	this.writer_approval = false;
	yield this.prepare_tasks(user_prompt);  // loop until task list is valid

	var hit_max_rounds = true;
	for (var i = 0; i < 5; i++) {  // max rounds
		if (this.task_list.no_pending() == 0) {
			hit_max_rounds = false;
			break;
		}
		// begin() is async: start refinement for all tasks (non-blocking). Call with .begin or yield; run_until_writer / run_all_tasks wait only until the task they are about to run has been refined.
		yield this.task_list.begin(this);
		// run_until_writer: for each item, wait until that item's task(s) refined, then run_tools + post_evaluate; stop at writer (approval gate)
		yield this.task_list.run_until_writer(this);
		if (this.task_list.has_writer_tasks() && !this.writer_approval) {
			yield this.request_writer_approval();  // sets this.writer_approval when user approves
		}
		// run_all_tasks: run_tools + post_evaluate for all remaining pending (reader + writer in order)
		yield this.task_list.run_all_tasks(this);
		yield this.task_list.run_continuation(this);
	}
	if (hit_max_rounds && this.task_list.no_pending() != 0) {
		// add_message(ui, "Max rounds reached.");
	}
}
```

#### 3. prepare_tasks(user_prompt) — build valid task list before rounds

- **Purpose:** Loop up to 5 times until the task list is valid. Before starting the rounds loop we must have a valid task list; if parse fails or list is invalid, retry with previous_proposal / previous_proposal_issues so the LLM can fix it. TaskListParser (or parse result) should expose the proposer so we can fill previous_proposal / previous_proposal_issues and send again. If still invalid after 5 tries: set **this.task_list = new TaskList()** (empty) and show UI message so parent run_async falls through.
- Use template key **"task_creation_initial"** (no Runner state).
- **User message:** Fill placeholders per 1.23.3 §1: `{environment}`, `{project_description}`, `{current_file}`, `{open_files}`, `{previous_proposal}`, `{previous_proposal_issues}`, `{user_prompt}`. **project_description** from **this.project_manager.active_project.summary()**. **previous_proposal** and **previous_proposal_issues** are **local variables** in prepare_tasks (blank on first iteration; on retry set from parsed.proposal / parsed.issues). Not properties on TaskList.
- **System message:** Prompt body + `{skill_catalog}` from Manager (name + description from executor skills’ frontmatter).
- One LLM call; **parse** with TaskListParser (1.23.3 §2). If valid: store in **this.task_list**, return. If invalid: parser exposes proposer / issues; set **local** previous_proposal and previous_proposal_issues from parsed, then loop (build user content again, send again).
- **Proposed code:** separate method **this.prepare_tasks(user_prompt)** that loops up to 5 times. On success: **this.task_list** = new TaskList from parser. On failure after 5 tries: **this.task_list** = **new TaskList()** (empty) so parent run_async falls through (no_pending() == 0); add UI message (e.g. "Could not build valid task list after 5 tries.").

```vala
private async void prepare_tasks(string user_prompt_text) throws GLib.Error
{
	var previous_proposal = "";
	var previous_proposal_issues = "";
	for (var try_count = 0; try_count < 5; try_count++) {  // max 5 tries
		var tpl = PromptTemplate.template("task_creation_initial");
		var user_content = tpl.fill(
			"environment", this.env(),
			"project_description", this.project_manager.active_project != null ? this.project_manager.active_project.summary() : "",
			"previous_proposal", previous_proposal,
			"previous_proposal_issues", previous_proposal_issues,
			"user_prompt", user_prompt_text);
		var system_content = tpl.system_fill(
			"skill_catalog", this.sr_factory.skill_manager.skill_catalog_string());
		// Build messages, send LLM, get response
		var parsed = TaskListParser.parse(response);  // or parse_with_proposal() that returns (TaskList?, proposal, issues)
		if (parsed.valid) {
			this.task_list = parsed.task_list;  // new TaskList from parser
			return;
		}
		previous_proposal = parsed.proposal;
		previous_proposal_issues = parsed.issues;
	}
	// Failed after 5 tries: set empty task list so parent run_async falls through (no_pending() == 0)
	this.task_list = new TaskList();
	// add_message(ui, "Could not build valid task list after 5 tries.");
}
```

#### 4. Refinement (task.refine(runner))

- Invoked from **TaskList** as **task.refine(runner)**. **Each task is agent-like:** connects to parent session; **Task** builds its own precursor (resolves its references, no PrecursorBuilder), gets Definition for its skill, builds message, LLM call, parse.
- **Input (task's responsibility):** Single coarse task + skill input requirements (from Definition) + precursor. **Task** resolves its references and builds precursor markdown; no PrecursorBuilder.
- One LLM call per task; **parse** with RefinementOutputParser → one detailed task with one or more Skill/tool call code blocks.
- **Run each tool/skill** (Manager resolve by name, run); task stores outputs for executor. On parse or tool failure: re-run refinement with feedback or emit user message.
- No Runner state; template key **"task_refinement"** used by task when building message.

#### 5. Executor (task.post_evaluate(runner))

- Invoked from **TaskList** as **task.post_evaluate(runner)** after **task.run_tools(runner)**. **Task** builds its own precursor (references + all tool outputs from refinement for this task); no PrecursorBuilder.
- **User message:** Task fills `{query}`, `{skill_definition}` (Definition.full_content for task's skill), `{precursor}` (task builds from its references + tool outputs).
- One LLM call; **parse** with ExecutorOutputParser → result summary + optional details block. Store summary as task result; if details block present, save to file and record path. On failure: user message or retry.
- No Runner state; template key **"task_execution"** used by task.

#### 6. Post completion

- Use template key **"task_post_completion"** (no Runner state).
- **Input:** Full task list + completed outputs. Runner or TaskList assembles from **this.task_list** (no PrecursorBuilder).
- One LLM call; **parse** with TaskListParser → full task list again (same format as 1.23.3). Decide: if any task still has no output → next round; else conclude. No separate "change tasks" output; writer tasks are normal tasks in the list.

```vala
private async void run_post_completion() throws GLib.Error
{
	// Build user message: full task list + completed outputs (from this.task_list); template "task_post_completion"
	// LLM call
	this.task_list = TaskListParser.parse(response);
	// If any task without output: next round; else conclude
}
```

#### 7. Errors and user messages

- **Parse failures** (task list in prepare_tasks): use local previous_proposal / previous_proposal_issues for retry; after 5 tries add_message(ui, "Could not build valid task list …"). Refinement/post-completion: retry with feedback or add_message as appropriate.
- **Missing skill:** add_message(ui, "Skill not found: …").
- **Executor failure:** add_message(ui, …); optionally retry refinement or task.
- **Max rounds:** after loop, if we hit max rounds (did not break) and task list still has pending tasks, add_message(ui, "Max rounds reached."). (Loop uses literal 5 with a comment; no const or variable.)

#### 8. Request writer approval

- When **task_list.has_writer_tasks()** and **!writer_approval**: yield **request_writer_approval()** — present list of writer tasks to user (research/plan vs modify); on approve set **this.writer_approval = true** so **run_writer_tasks** can run. Responsible: Runner (callback or UI); app/agent provides approval.

#### 9. Precursor (Task's responsibility)

- **Task** builds its own precursor for refinement and executor: resolves its references (file path → contents, project_description, plan section, task output id), builds markdown; no separate PrecursorBuilder class. Optionally filter content marked no-longer-relevant (per 1.23.12) when 1.23.12 defines format.

#### 10. system_message() and user_prompt() (current call site)

- **Existing send_async path:** If Runner is still used for a single skill run (legacy path), system_message(template_key) and user_prompt(template_key, …) take an explicit template key. The main flow uses run_async and builds messages per step with the right template key and placeholders.
- **Template by key:** Use `PromptTemplate.template(template_key)` with explicit key (no Runner state); then tpl.system_fill(…) and tpl.fill(…) with the placeholders for that key. system_message(template_key) and user_prompt(template_key, …) take the key explicitly.

```vala
// Pattern: template by explicit key (no Runner state). PromptTemplate.template(key) throws if key missing.
private string system_message(string template_key) throws GLib.Error
{
	var tpl = PromptTemplate.template(template_key);
	return tpl.system_fill(/* placeholders for this key */);
}

private string user_prompt(string template_key, string user_query) throws GLib.Error
{
	var tpl = PromptTemplate.template(template_key);
	return tpl.fill(/* placeholders for this key */);
}
```

#### 11. Types to introduce (Runner or New classes)

- **TaskList**, **TaskItem**, **Task** — See **§ TaskList**. TaskItem = wrapper (single task or concurrent set of tasks); top level is always sequential.
- **CompletedTaskResult** — summary string + optional details file path; stored on Task.output when task is completed.
- TaskListParser, RefinementOutputParser, ExecutorOutputParser — as in "New classes" section; Runner or Task calls them. No PrecursorBuilder; Task builds its own precursor.

---

### TaskList (`liboccoder/Skill/TaskList.vala`)

- **One file:** All TaskList (and Task) behaviour lives in this section; one file at a time.
- **Structure**
  - **Top level always sequential.** TaskList holds an ordered list of **TaskItem** (wrapper). Each TaskItem is either a **single Task** or a **set of Tasks** (children) that run **concurrently**.
  - Parser (1.23.3 §2) produces task sections → mapped to TaskItems (e.g. one section = one TaskItem; section with one task = single, section with multiple tasks = concurrent group).
- **TaskItem (wrapper)**
  - Simple wrapper: holds list of Tasks (**children**). Top-level iteration is over TaskItems; within an item, children run concurrently when children.size > 1.
  - API: **children** — public list of Task (size 1 = single, >1 = concurrent). **has_writer_task()** — true if any task in this item is a writer. **wait_refined()** — async; when children.size == 1, blocks until that task has finished refining. For items with children.size > 1, each child runs as soon as that task is refined (per-task wait in run_child).
- **Re-run state**
  - No **previous_proposal** / **previous_proposal_issues** on TaskList; they are local variables in Runner's **prepare_tasks** only (blank first iteration, then set from parser on retry).
- **Reader vs writer**
  - Each task is classified as reader (research/plan) or writer (modify), e.g. from skill type or task list format. No separate "change tasks" list; a task that changes something is a normal writer task.
- **API**
  - **no_pending()** — returns count of tasks without output (0 = none pending). Runner uses this to break the loop.
  - **items()** — top-level list of TaskItem (sequential); each item is single task or concurrent group (children).
  - **refine(Runner runner)** — async. **Start** refinement for all tasks (e.g. launch each task’s refine via **.begin** — do not call async methods directly). **Does not block** on refinement completing; returns once refinement is started. run_until_writer and run_all_tasks will wait only for the task(s) they need before running them.
  - **run_until_writer(Runner runner)** — for each TaskItem: var children = item.children; if children.size == 1 yield run_child(children.get(0), runner); else run_child.begin per child, wait_until_all_children_done(children.size). If item.has_writer_task(), stop (approval gate).
  - **has_writer_tasks()** — true if any task in any item is a writer task (modify). Runner uses this before running writer tasks to gate on approval.
  - **run_all_tasks(Runner runner)** — for each TaskItem: var children = item.children; if children.size == 1 yield run_child(children.get(0), runner); else run_child.begin per child, wait_until_all_children_done(children.size).
  - **run_continuation(Runner runner)** — yield runner.run_post_completion() (LLM call to get updated task list for next round).
  - **run_child(Task t, Runner runner)** — private async: yield t.wait_refined(); yield t.run_tools(runner); yield t.post_evaluate(runner). When children.size == 1: yield run_child(children.get(0), runner). When children.size > 1: run_child.begin(t, runner, …) per task; callback run_child.end(res), child_done().
  - **child_done()** / **wait_until_all_children_done(int n)** — each .begin callback calls child_done(); wait_until_all_children_done(children.size) yields until all n complete.
- **Execution order**
  - **Refinement:** started once (refine); all tasks’ refine runs in parallel (or per-item concurrent). No blocking until “all refined”.
  - **run_until_writer / run_all_tasks:** item.children.size == 1 → yield run_child(children.get(0), runner). size > 1 → run_child.begin per child, wait_until_all_children_done(children.size). Top level sequential; within an item, one task or concurrent children. Execution can overlap with refinement.

**Proposed code — TaskList:**

```vala
/** Start refinement for all tasks (non-blocking). Launch each task's refine via .begin. Use item.children. */
public async void refine(Runner runner) throws GLib.Error
{
	foreach (var item in this.items()) {
		foreach (var t in item.children) {
			t.refine.begin(runner);
		}
	}
}

/** For each TaskItem: item.children; if size == 1 yield run_child(children.get(0), runner); else run_child.begin per child, wait_until_all_children_done(children.size). Stop when item.has_writer_task(). */
public async void run_until_writer(Runner runner) throws GLib.Error
{
	foreach (var item in this.items()) {
		if (item.has_writer_task()) {
			break;
		}
		var children = item.children;
		if (children.size == 1) {
			yield this.run_child(children.get(0), runner);
			continue;
		}
		foreach (var t in children) {
			this.run_child.begin(t, runner, (o, res) => {
				this.run_child.end(res);
				this.child_done();
			});
		}
		yield this.wait_until_all_children_done(children.size);
	}
}

/** One task: yield wait_refined, run_tools, post_evaluate. Used with yield (children.size == 1) or .begin (concurrent). */
private async void run_child(Task t, Runner runner) throws GLib.Error
{
	yield t.wait_refined();
	yield t.run_tools(runner);
	yield t.post_evaluate(runner);
}

public bool has_writer_tasks()
{
	foreach (var item in this.items()) {
		if (item.has_writer_task()) {
			return true;
		}
	}
	return false;
}

/** For each TaskItem: item.children; if size == 1 yield run_child(children.get(0), runner); else run_child.begin per child, wait_until_all_children_done(children.size). */
public async void run_all_tasks(Runner runner) throws GLib.Error
{
	foreach (var item in this.items()) {
		var children = item.children;
		if (children.size == 1) {
			yield this.run_child(children.get(0), runner);
			continue;
		}
		foreach (var t in children) {
			this.run_child.begin(t, runner, (o, res) => {
				this.run_child.end(res);
				this.child_done();
			});
		}
		yield this.wait_until_all_children_done(children.size);
	}
}

public async void run_continuation(Runner runner) throws GLib.Error
{
	yield runner.run_post_completion();
}
```

**Task (same file or `Task.vala`):**

- **is_writer** (or equivalent) — Classified from skill or task list format; used for **reader_tasks_without_output()** vs **writer_tasks_without_output()** and for **has_writer_tasks()**.
- **refine(runner)** — Task (agent-like, connects to parent session) builds its own precursor, gets Definition for skill, builds message (template "task_refinement"), LLM call, RefinementOutputParser; task stores refined tool-call list.
- **run_tools(runner)** — Runner/Manager runs each tool from task's refined list; task stores tool outputs for its executor precursor.
- **post_evaluate(runner)** — Task builds precursor (references + run_tools outputs), builds message (template "task_execution"), LLM call, ExecutorOutputParser; task.output = result.

---

### Factory (`liboccoder/Skill/Factory.vala`)

- Support **skill-prompts** directory as well as **resources/skills**
  - Prompts for creation/refinement/post-completion/execution live in `skill-prompts`.
  - Executor skill files in `resources/skills`.
  - Either add a prompts base path or make Manager/PromptTemplate handle both.
- Ensure Runner can be created for the run_async flow (not only “one skill by name”).
  - Entry from app/agent for planner mode vs current single-skill mode.

---

### Manager (`liboccoder/Skill/Manager.vala`)

- **Skill catalog**
  - Provide a form suitable for task-creation prompt: name + description from each executor skill’s frontmatter (from `resources/skills`).
  - May be a method that returns a single string or structured list for substitution into `{skill_catalog}`.
- **Resolve by name**
  - Already has `by_name`; ensure executor skills in `resources/skills` are scanned and available.
  - Runner can load skill definition by task’s Skill field and run tools by name.

---

### Definition (`liboccoder/Skill/Definition.vala`)

- **Refinement**
  - Expose “skill input requirements” (e.g. a designated section of the body) so Runner can pass it to the refinement prompt for that skill.
  - If already derivable from body/full_content, document it; otherwise add a simple accessor or parse.
- **Executor**
  - Runner uses `full_content` (or body) as `{skill_definition}` for the interpreter.
  - No change if that contract is already satisfied.

---

### PromptTemplate (`liboccoder/Skill/PromptTemplate.vala`)

- **Resource location**
  - Skill-prompts location is hard-coded in PromptTemplate (resource:// or project resource dir for the 4 prompt files). No path argument passed from Runner.
- **Split system/user**
  - For these prompts, content before first `---` = system message, after = user message; fill placeholders in each part.
  - Template must not use `---` inside the body (per 1.23.3).
- **Placeholders**
  - Support the sets required by 1.23.3 (user), 1.23.4 (refinement), 1.23.5 (post completion), 1.23.6 (executor: `{query}`, `{skill_definition}`, `{precursor}`).
- **Add `load_dir()` (no argument)**
  - Loads all .md templates from the hard-coded resource dir; caches them inside PromptTemplate (key = filename without `.md`). Called lazily when needed, not every time Runner runs.
- **Add `template(key)`**
  - Static (or class) method: returns the cached PromptTemplate for key (e.g. `task_creation_initial`, `task_refinement`, `task_post_completion`, `task_execution`). Caller passes key explicitly (no Runner state).

**Proposed code — add to PromptTemplate:**

```vala
// Hard-coded resource path for the 4 skill-prompts (task_creation_initial, task_refinement, task_post_completion, task_execution)
private const string RESOURCE_DIR = "resource:///...";  // or project resource path

private static bool templates_loaded = false;
private static Gee.HashMap<string, PromptTemplate> template_cache = new Gee.HashMap<string, PromptTemplate>();

/** Load all .md templates from RESOURCE_DIR; cache by name (without .md). Called lazily. */
private static void ensure_loaded() throws GLib.Error
{
	if (templates_loaded) {
		return;
	}
	// Enumerate RESOURCE_DIR, for each .md: key = name without ".md", load template, template_cache.set(key, t)
	// (Implementation uses GLib.resources_enumerate_children or equivalent for resource://)
	templates_loaded = true;
}

/** Returns cached template for key. Throws if key missing (no nullable return). */
public static PromptTemplate template(string key) throws GLib.Error
{
	ensure_loaded();
	if (!template_cache.has_key(key)) {
		throw new GLib.IOError.NOT_FOUND("No prompt template for state: " + key);
	}
	return template_cache.get(key);
}
```

---

## New classes (or equivalent)

- **Task list parser**
  - Parse 1.23.3 / 1.23.5 output: required sections (original prompt, goals/summary, general information, Tasks); task sections (Task section 1, 2, …); per-task fields (What is needed, Skill, References as markdown links, Expected output).
  - Preserve section order and boundaries.
  - Validate required fields and link targets (absolute path, `project_description`, plan section, task output id).
  - Can live in Runner or a small helper.
- **Refinement output parser**
  - Parse 1.23.4 output: one detailed task with one or more Skill/tool call blocks.
  - Extract tool call content from code blocks and pass to tool execution.
  - Extract skill/tool name and parameters per skill format.
- **Executor output parser**
  - Parse 1.23.6 output: result summary (required), optional details block (filename + content).
  - Behaviour when format is wrong or summary missing.
- **Task builds precursor**
  - No separate PrecursorBuilder. **Task** resolves its own references (file path → file contents; `project_description` → project description; plan section or task output id → corresponding content) and builds precursor markdown for refinement and executor. Optionally filter by relevance once 1.23.12 defines the format.

---

## Deliverable

- All Runner behaviour in one plan: parsing (1.23.3–1.23.6), Task-built precursor (no PrecursorBuilder), refinement, execution, post completion, loop, errors, context restriction.
- Implementation is done by changing the classes above and adding the new parsing pieces; Task handles precursor.

---

## References

- 1.23.2 (orchestration, conventions); 1.23.3 (task creation format); 1.23.4 (refinement + skill call format); 1.23.5 (post completion format); 1.23.6 (executor format); 1.23.12 (code blocks, context restriction); 1.23.1 (existing Skill Runner).
