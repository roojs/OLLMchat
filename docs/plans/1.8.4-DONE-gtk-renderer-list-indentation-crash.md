# GTK renderer crash: list indentation semantics (space_skip vs 1-based level)

**Context:** Plan 1.8.3 switched the parser to pass **space_skip** (raw number of spaces before the list marker) to `on_ul`/`on_ol` instead of a 1-based list level. The document renderer was updated to use this correctly; the GTK (and Pango/HTML) renderers were not, and they crash when rendering lists.

---

**Process:** Document the issue, cause, and proposed fix here. Get the approach agreed. Only then implement.

---

## The crash

**Stack trace (summary):**
- Crash at `markdown_gtk_render_real_on_ul` in `libocmarkdowngtk/Render.vala:413`:  
  `this.list_stack.set(target_index, 0);`
- Called from `RenderBase.on_ul(is_start, indentation)` with `indentation=0`.
- Triggered when the parser emits `UNORDERED_LIST` start with the new semantics (e.g. for a line like `- Item` with no leading space).

**Root cause:** The GTK renderer (and PangoRender, HtmlRender) were written when the second parameter to `on_ul`/`on_ol` was a **1-based list level** (1 = first level, 2 = nested, etc.). They do:

```c
// Convert indentation (1-based) to array index (0-based)
int target_index = (int)indentation - 1;
// ...
this.list_stack.set(target_index, 0);
```

When the parser sends **space_skip** instead, a top-level list has no leading space, so `indentation == 0`. Then `target_index == -1`, and `list_stack.set(-1, 0)` causes an invalid index (crash or undefined behaviour).

So: **the callback parameter is now space_skip (0 for top-level), but the renderers still treat it as 1-based level and compute a 0-based index as `level - 1`, which is wrong when level is 0.**

---

## Why the document renderer is fine

The document renderer (`libocmarkdown/document/Render.vala`) does **not** interpret the value as “level minus one”. It stores the raw value (space_skip) in `list_stack` and uses it only for **comparison** when handling list items (e.g. pop while stack top indent &gt; current indent, push when nesting). So it never uses `indentation - 1` as an array index and does not crash.

---

## Proposed fix

**Goal:** Make the GTK (and Pango, HTML) renderers work with the **space_skip** semantics without introducing a “level derived from space_skip” formula (as disallowed in 1.8.3). Use the parameter only for stack indexing and depth in a consistent way.

**Approach:** Treat the callback parameter as a **0-based stack index** (so top-level = 0, “one level of indent” = 1, etc.). Do **not** subtract 1.

1. **Stack index**  
   Use `target_index = (int)indentation` (not `indentation - 1`). So when `indentation == 0`, we use index 0 and no longer hit a negative index.

2. **Closing lists**  
   Keep only stack levels `0 .. indentation`. So the stack size must be at most `indentation + 1`. Change `close_lists_to_level(uint level)` to:
   - `while (this.list_stack.size > (int)level + 1) { remove last; }`  
   So we close until `list_stack.size <= indentation + 1`.

3. **Growing the stack**  
   Keep “ensure enough levels” as: `while (this.list_stack.size <= target_index) { this.list_stack.add(0); }` so that `list_stack[target_index]` exists. This is unchanged except that `target_index` is now `(int)indentation`.

4. **`on_li` and “current level”**  
   Do **not** use `current_list_indentation` as a 1-based level. After `on_ul`/`on_ol`, the stack already reflects the current list. So in `on_li`:
   - Use **current depth** = `(uint)this.list_stack.size` (number of open list levels).
   - If `list_stack.size == 0`, treat as “no list context” (add state and return, as today).
   - Otherwise, use `target_index = (int)list_stack.size - 1` for the deepest level (last element in the stack) and use `list_stack.size` for things like “how many indent tabs” (one tab per level).

5. **`current_list_indentation`**  
   Can still be set to `indentation` (space_skip) in `on_ul`/`on_ol` for any code that might compare indents; the important part is that **on_li** must not use it as “1-based level” and must use `list_stack.size` for depth and stack index.

**Files to update:**

- **libocmarkdowngtk/Render.vala**  
  - `close_lists_to_level`: close while `list_stack.size > (int)level + 1`.  
  - `on_ul` / `on_ol`: `target_index = (int)indentation`; keep the rest of the logic (set/reset, `current_list_indentation`, `on_li(true)`).  
  - `on_li`: set `current_level = (uint)this.list_stack.size`; if `current_level == 0` then add state and return; else `target_index = (int)current_level - 1` and use `list_stack.get(target_index)` and `indent_tabs = current_level` as now.

- **libocmarkdown/PangoRender.vala**  
  - Same pattern: `close_lists_to_level` and `on_ul`/`on_ol` use `target_index = (int)indentation` and close while `size > (int)indentation + 1`; `on_li` uses `list_stack.size` for current depth and index.

- **libocmarkdown/HtmlRender.vala**  
  - Same semantics: `handle_list_start` and `close_lists_to_level` must not use `(int)indentation - 1` when that can be negative. Use `target_index = (int)indentation` and close until `list_stack.size <= indentation + 1`. Adjust `close_li_if_needed` if it currently compares “level” in a 1-based way; it should use the same 0-based depth / stack-size notion so that top-level (space_skip=0) is one open list (size 1).

**Comment updates:** In these files, replace comments that say “1-based level” or “indentation level (1-based)” with a short note that the parameter is **space_skip** (raw spaces before the list marker) used as the 0-based stack index for list nesting.

---

## Summary

| Item | Action |
|------|--------|
| **Cause** | Parser now passes `space_skip` (0 for top-level); GTK/Pango/HTML still treat it as 1-based level and compute `target_index = indentation - 1` → -1 and crash. |
| **Fix** | Use `target_index = (int)indentation`; close while `list_stack.size > (int)indentation + 1`; in `on_li` use `list_stack.size` as current depth and for indexing. |
| **Scope** | libocmarkdowngtk/Render.vala, libocmarkdown/PangoRender.vala, libocmarkdown/HtmlRender.vala. |

No parser or API change; only renderer handling of the existing parameter.
