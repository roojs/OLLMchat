# Table support Phase 4: Table handling code (1.10.4)

- Part of the phased implementation for markdown table support:
  - See **1.8.2-table-support-current-design.md**.
  - For the overall design and phase order.
- Depends on **1.10.1**, **1.10.2**, **1.10.3**:
  - Renderer interface and implementations.

**Coding standards:** This plan follows **.cursor/rules/CODING_STANDARDS.md**. All code uses:
- Brace style:
  - Line breaks for namespace/class/method.
  - Inline for control structures.
- `this.` for instance members.
- No one-line if/else with body.
- `GLib.` prefix where applicable.
- No one-use temporaries (inline instead).
- `Gee.ArrayList`/`Gee.HashMap` via `.get()`, `.add()`, `.set()`.
- No `Gee.ArrayList<string>` when building an array of strings just to join it:
  - Use `string[]` arrays (or plain concatenation) instead.
  - (See coding standard.)

---

## Goal

- Implement table line handling via a helper class **TableState**:
  - With **feed_line(string line)**.
  - Every table row is processed one line at a time.
- When the parser receives a 3-line TABLE block from BlockMap:
  - Split that block into 3 lines.
  - Call **table_state.feed_line(line)** three times.
  - (Lines 1, 2, 3.)
- When already in a table (`current_block == TABLE`):
  - Each subsequent line is passed to **table_state.feed_line(line)** once.
- Inside **TableState.feed_line(line)**:

- **Line 1 (header):**
  - Buffer the raw line.
  - Do not emit any callbacks yet.
- **Line 2 (separator):**
  - Parse alignment per column.
  - Store in a column→align map.
  - Do not emit callbacks yet.
- **Line 3:**
  - Emit **on_table(true)**.
  - Emit the header row from buffered line 1.
  - Emit the first body row (line 3).
  - For each row:
    - **on_table_row(true)**.
    - Cells:
      - Parse cells.
      - Run each cell's text through inline format.
      - Emit **on_table_hcell** / **on_table_cell** around content.
    - **on_table_row(false)**.
- **Lines 4+:**
  - Emit **on_table_row(true)**.
  - Cells (same as above).
  - **on_table_row(false)**.

- Table end is handled in phase **1.10.5**:
  - When a non-table line is seen.
  - `do_block(false, TABLE)` is called.
- This plan focuses only on:
  - **TableState** (and **Parser.process_cell_content**).
  - The helpers they need.

---

## Files

- **libocmarkdown/Parser.vala**:
  - Holds **TableState? table_state**.
  - Exposes **renderer** (property or getter) so TableState can use **parser.renderer**.
  - Creates it when entering a table (**new TableState(this)**).
  - Calls **table_state.feed_line(line)** for each line.
  - Clears it when the table ends.
  - Keeps **process_cell_content(string)**.
- **libocmarkdown/TableState.vala** – New helper class:
  - Holds all table state:
    - Header line, alignments, row index.
  - Line parsing:
    - **parse_table_cells**, **parse_separator_cell_align**.
  - **feed_line(string line)** implements the row logic.
  - **feed_line** fires for each cell:
    - **renderer.on_table**, **on_table_row**, **on_table_hcell**, **on_table_cell**.
    - **parser.process_cell_content(cell_text)**.

---

## 1. Types (optional small enum)

- Alignment for a column.
- Can be defined in:
  - **TableState.vala**, or
  - Top of Parser.vala (in `namespace Markdown`), or
  - A small Types file.
- Use integer in callbacks:
  - **-1 = left, 0 = center, 1 = right**.
  - Already used by RenderBase/Table.
- No new public type is strictly required:
  - The renderer API already uses `int align`.
- Internally you can use an enum for clarity, e.g.:

```vala
private enum TableAlign
{
	LEFT = -1,
	CENTER = 0,
	RIGHT = 1
}
```

- **TableState** (or Parser) uses the enum when calling:
  - **this.renderer.on_table_hcell(is_start, (int)align)**.
- Alternatively use `int` everywhere.

---

## 2. TableState helper class – role and constructor

- **TableState** is a helper class that:
  - Owns all table line parsing.
  - Fires the renderer's **on_*** callbacks.
- **Responsibility:**
  - Hold table state (header line, alignments, row index).
  - Parse each line into cells; implement the row/phase logic:
    - Header buffer, separator → alignments.
    - Then emit header row + body rows.
  - Call **renderer.on_table**, **on_table_row**, **on_table_hcell**, **on_table_cell**.
  - For each cell, call **parser.process_cell_content(cell_text)**:
    - So inline formatting stays in Parser.
- **Constructor:** **TableState(Parser parser)**:
  - TableState gets the renderer via the parser (expose **renderer** on Parser if necessary).
  - TableState needs the parser to call **process_cell_content(string)** for each cell.
  - Parser keeps:
    - formatmap, got_format, do_format, add_html, state_stack.
- **Parser** holds **TableState? table_state**:
  - When entering a table (1.10.5):
    - Create **table_state = new TableState(this.renderer, this)**.
    - For each line call **table_state.feed_line(line)**.
  - When the table ends:
    - Call **renderer.on_table(false)**.
    - Set **table_state = null**.

---

## 2b. TableState – internal state

Add to **TableState** (not Parser); all are instance fields:

- **table_header_line: string** – Buffered first line (header row).
  - Yes – we need it: **feed_line** is called one line at a time; on line 3 we must emit the header row from line 1's content.
  - Set when handling line 1 (row_index 0); used when emitting header row on line 3.
- **table_alignments: Gee.ArrayList&lt;int&gt;** – Per-column alignment (-1, 0, 1).
  - Built from line 2 (separator).
  - Used for every row on line 3+.
- **table_row_index: int**:
  - 0 = line 1 (header), 1 = line 2 (separator).
  - 2 = line 3 (first body), 3+ = subsequent body.
  - Incremented after each **feed_line**.

**Concrete code (TableState class skeleton and constructor):**

```vala
private class TableState
{
	private Parser parser;
	private string table_header_line = "";
	private Gee.ArrayList<int> table_alignments = new Gee.ArrayList<int>();
	private int table_row_index = 0;

	internal TableState(Parser parser)
	{
		this.parser = parser;
	}
	// Renderer: access via this.parser.renderer (expose on Parser if necessary).
	// parse_table_cells, parse_separator_cell_align, emit_row, feed_line (see §3, §4, §5, §7)
}
```

---

## 3. TableState – parsing a single line into cells (parse_table_cells)

**Precondition:** Preparser validates that the line starts and ends with `|`.

**Rule:** Just split the columns.
- Strip the leading and trailing `|` (substring to drop first and last char).
- Split by `|`.
- No trim here – cell content handling (e.g. process_cell_content) can trim if needed.

**Concrete code (Vala):**

```vala
private string[] parse_table_cells(string line)
{
	// Preparser guarantees line starts and ends with |
	var inner = line.substring(1, line.length - 2);
	var parts = inner.split("|");
	var result = new string[parts.length];
	for (var i = 0; i < parts.length; i++) {
		result[i] = parts[i];
	}
	return result;
}
```

- **TableState** uses this in **feed_line(line)** for every line.

---

## 4. TableState – parsing alignment from the separator line (parse_separator_cell_align)

- Separator line has cells like `:---`, `:---:`, `---`, `---:`:
  - Left, center, left, right.
- One alignment per column.

**Concrete rule:**

- Cell contains `:` only on the left → left → **-1**.
- Cell contains `:` on both sides → center → **0**.
- Cell contains `:` only on the right → right → **1**.
- Cell with no `:` (e.g. `---`) → left → **-1**.

**Concrete code:**

```vala
private int parse_separator_cell_align(string cell)
{
	var s = cell.strip();
	return s.has_prefix(":") && s.has_suffix(":") ? 0 : (s.has_suffix(":") ? 1 : -1);
}
```

**TableState** builds **table_alignments** when processing line 2 (row_index == 1):

**Concrete code (build alignments from separator line):**

```vala
var cells = this.parse_table_cells(line);
this.table_alignments.clear();
for (var i = 0; i < cells.length; i++) {
	this.table_alignments.add(this.parse_separator_cell_align(cells[i]));
}
```

- If line 2 has a different number of columns than line 1:
  - Use the number of columns from line 2 only.
  - Or align by index.
  - If line 1 has more cells: use -1 for extra columns.
  - If line 2 has more: ignore extra.
- Recommended:
  - Use number of columns from **line 2** for **table_alignments**.
- When emitting header/body cells:
  - Use **min(header_cells.length, table_alignments.size)** or column index.
  - Default -1 if no alignment for that index.

---

## 5. TableState – emitting one row (header or body)

**TableState** emits one row by:

1. Emit **this.renderer.on_table_row(true)**.
2. For each column index `i`:
   - Get alignment:
     - `align = (i < this.table_alignments.size) ? this.table_alignments.get(i) : -1`.
   - If this row is the **header** row:
     - **this.renderer.on_table_hcell(true, align)**.
     - **this.parser.process_cell_content(cells[i])**.
     - **this.renderer.on_table_hcell(false, align)**.
   - If this row is a **body** row:
     - **this.renderer.on_table_cell(true, align)**.
     - **this.parser.process_cell_content(cells[i])**.
     - **this.renderer.on_table_cell(false, align)**.
3. Emit **this.renderer.on_table_row(false)**.

**Concrete code (emit one row):**

```vala
private void emit_row(string[] cells, bool is_header)
{
	this.parser.renderer.on_table_row(true);
	for (var i = 0; i < cells.length; i++) {
		var align = (i < this.table_alignments.size) ? this.table_alignments.get(i) : -1;
		if (is_header) {
			this.parser.renderer.on_table_hcell(true, align);
		} else {
			this.parser.renderer.on_table_cell(true, align);
		}
		this.parser.process_cell_content(cells[i]);
		if (is_header) {
			this.parser.renderer.on_table_hcell(false, align);
		} else {
			this.parser.renderer.on_table_cell(false, align);
		}
	}
	this.parser.renderer.on_table_row(false);
}
```

- Cell content is run through **parser.process_cell_content(cell_text)**.
- Parser owns formatmap and format handlers.
- See §6.

---

## 6. Parser – process_cell_content(string cell_text) (inline format in a cell)

- Cell text must be processed with the **same** inline formatting:
  - As paragraph text.
- Use **this.formatmap.eat()** and the same format handlers:
  - **this.got_format**, **this.do_format**.
  - **on_text** for plain segments.
- We need a helper that:
  - Takes the full cell string.
  - Drives the existing format logic.
- The helper must not touch:
  - **chunk**, **chunk_pos**, **leftover_chunk**.

**Approach:** A private method **process_cell_content(string cell_text)**:
- Note:
  - Position-based loop is required by **formatmap.eat()** API.
- Use **get_char(pos)** only when advancing by one character.
  - Not for manual character-by-character string processing.
- Uses:
  - A local position **pos** (byte offset).
  - A local **str** for plain text.
- **is_end_of_chunks = true**:
  - We have the whole cell; never "need more".
- Loop while **pos < cell_text.length**:
  - Call **this.formatmap.eat(...)**:
    - Args: cell_text, pos, true, out matched_format, out byte_length.
  - If result is **-1**:
    - Treat as "no more match" (we have full cell).
    - Flush **str** to **this.renderer.on_text(str)**.
    - Append current character to str.
    - Advance pos by one character's byte length; continue.
  - If result **0**:
    - Append current character to **str**.
    - Advance **pos** by one character's byte length.
  - If result **> 0**:
    - Flush **str** to **this.renderer.on_text(str)**; clear str.
    - Call **this.got_format(matched_format)**.
    - Advance **pos** by **byte_length**.
- After loop: **this.renderer.on_text(str)**.

**HTML in cells:**
- The main loop's **handle_format_result** handles **FormatType.HTML**:
  - By calling **add_html(chunk.substring(chunk_pos))**.
  - Consumes the tag and returns the remainder.
- For **process_cell_content** we have a single string.
- When **matched_format == FormatType.HTML**:
  - Call **add_html(cell_text.substring(pos))**.
  - Then advance **pos** by the number of bytes consumed.
  - (i.e. **cell_text.length - remainder.length**.)
- Inside the "result > 0" branch:
  - If **matched_format == FormatType.HTML**:
    - Call **add_html(cell_text.substring(pos))**.
    - Then set **pos += sub.length - rest.length** (bytes consumed).
- **add_html** returns the tail not consumed.
- Vala **string.length** is in bytes.
- So **pos += sub.length - rest.length** is correct.

**Concrete signature and structure:**

```vala
private void process_cell_content(string cell_text)
{
	var pos = 0;
	var str = "";
	while (pos < cell_text.length) {
		FormatType matched_format;
		int byte_length;
		var match_len = this.formatmap.eat(
			cell_text, pos, true, out matched_format, out byte_length);
		if (match_len == -1) {
			this.renderer.on_text(str);
			str = "";
			var c = cell_text.get_char(pos);
			this.renderer.on_text(c.to_string());
			pos += c.to_string().length;
			continue;
		}
		if (match_len == 0) {
			var c = cell_text.get_char(pos);
			str += c.to_string();
			pos += c.to_string().length;
			continue;
		}
		this.renderer.on_text(str);
		str = "";
		if (matched_format != FormatType.HTML) {
			this.got_format(matched_format);
			pos += byte_length;
			continue;
		}
		var sub = cell_text.substring(pos);
		pos += sub.length - this.add_html(sub).length;
	}
	if (str != "") {
		this.renderer.on_text(str);
	}
}
```

Note (**this.got_format** and **this.state_stack**):
- **this.got_format** pushes/pops **this.state_stack** for inline formatting (bold, italic, etc.).
- No state is present at start of cell to preserve – all stack entries are from this cell.
- At end of each cell: send closing tags for the whole stack (reverse order), then clear.

**Concrete code (add at end of process_cell_content, before final on_text(str)):**

```vala
for (var i = this.state_stack.size - 1; i >= 0; i--) {
	this.do_format(false, this.state_stack.get(i));
}
this.state_stack.clear();
```

---

## 7. TableState – feed_line(string line) (full logic)

- **feed_line(line)** implements the row/phase logic.
- **table_row_index** is internal to TableState.

1. If **table_row_index == 0** (header):
   - **table_header_line = line** (buffer it).
   - **table_row_index = 1**.
   - Return.

2. If **table_row_index == 1** (separator):
   - **table_alignments.clear()** (or set new list).
   - **cells = this.parse_table_cells(line)**.
  - For each cell:
    - **table_alignments.add(this.parse_separator_cell_align(cells[i]))**.
   - **table_row_index = 2**.
   - Return.

3. If **table_row_index == 2** (first body row):
   - **this.renderer.on_table(true)**.
   - Emit header row:
     - **cells1 = this.parse_table_cells(table_header_line)**.
     - **on_table_row(true)**.
     - For each cell **i**: **align = (i < table_alignments.size) ? table_alignments.get(i) : -1**; **on_table_hcell(true, align)**; **this.parser.process_cell_content(cells1[i])**; **on_table_hcell(false, align)**.
     - **on_table_row(false)**.
   - Emit first body row:
     - **cells3 = this.parse_table_cells(line)**.
     - **on_table_row(true)**.
     - For each cell **i**:
       - Same pattern with **on_table_cell** and **this.parser.process_cell_content(cells3[i])**.
     - **on_table_row(false)**.
   - **table_row_index = 3**.
   - Return.

4. If **table_row_index >= 3** (further body rows):
   - **cells = this.parse_table_cells(line)**.
   - **on_table_row(true)**.
   - For each **i**:
    - **on_table_cell(true, align)**.
    - **this.parser.process_cell_content(cells[i])**.
    - **on_table_cell(false, align)**.
   - **on_table_row(false)**.
   - **table_row_index++**.
   - Return.

**Concrete code (feed_line):**

```vala
internal void feed_line(string line)
{
	if (this.table_row_index == 0) {
		this.table_header_line = line;
		this.table_row_index = 1;
		return;
	}
	if (this.table_row_index == 1) {
		var cells = this.parse_table_cells(line);
		this.table_alignments.clear();
		for (var i = 0; i < cells.length; i++) {
			this.table_alignments.add(this.parse_separator_cell_align(cells[i]));
		}
		this.table_row_index = 2;
		return;
	}
	if (this.table_row_index == 2) {
		this.parser.renderer.on_table(true);
		var cells1 = this.parse_table_cells(this.table_header_line);
		this.emit_row(cells1, true);
		var cells3 = this.parse_table_cells(line);
		this.emit_row(cells3, false);
		this.table_row_index = 3;
		return;
	}
	// table_row_index >= 3
	var cells = this.parse_table_cells(line);
	this.emit_row(cells, false);
	this.table_row_index++;
}
```

**Where TableState is cleared:**
- When the table **ends** (in 1.10.5):
  - Parser calls **this.renderer.on_table(false)**.
  - Parser sets **this.table_state = null**.
  - TableState and its state are discarded.

---

## 8. Summary of code to add

- **TableState** (new class **libocmarkdown/TableState.vala**):
  - Holds table_header_line, table_alignments, table_row_index.
  - **parse_table_cells**, **parse_separator_cell_align**.
  - **feed_line(string line)** implements row/phase logic.
  - Fires **renderer.on_table**, **on_table_row**, **on_table_hcell**, **on_table_cell**.
  - For each cell:
    - Calls **parser.process_cell_content(cell_text)**.

- **table_state** (Parser class field):
  - **TableState? table_state**; created when entering table.
  - **table_state.feed_line(line)** for each line.
  - Set to null when table ends.

- **process_cell_content(string cell_text)**:
  - Parser; internal or called by TableState.
  - Loop over cell_text with formatmap.eat().
  - Flush text with on_text.
  - On match call got_format (or add_html for HTML).
  - TableState calls **parser.process_cell_content(cell_text)** for each cell.
  - At end of process_cell_content: pop all state added in cell and send closing tags (see §6 Note).

---

## 9. Call sites (for 1.10.5; documented here for clarity)

- **handle_block_result**: When **matched_block == FormatType.TABLE**:
  - Set **current_block = TABLE**.
  - Create **table_state = new TableState(this.renderer, this)**.
  - Split the consumed 3-line block into three lines (by `\n`).
  - Call **table_state.feed_line(line1)**.
  - **feed_line(line2)**.
  - **feed_line(line3)**.
  - Advance **chunk_pos** by byte_length.
  - Return false.
- **add()** at line start: If **current_block == TABLE**:
  - Read rest of line (up to `\n`).
  - If line looks like a table row (e.g. contains `|`):
    - Call **table_state.feed_line(line)**.
    - Advance chunk_pos.
  - Else:
    - Call **do_block(false, TABLE)**.
    - Don't advance.
  - (So the line is re-processed as non-table.)
- **handle_line_break**: If **current_block == FormatType.TABLE**:
  - Do **not** call do_block(false).
  - Flush str.
  - Emit `\n` (or nothing, tables are line-based).
  - Set **at_line_start = true**.
  - Advance chunk_pos.
- **do_block**: Add case **FormatType.TABLE** for **is_start == false**:
  - Call **this.renderer.on_table(false)**.
  - Set **this.table_state = null**.

**Concrete code (call-site snippets for 1.10.5):**

```vala
// In handle_block_result when matched_block == FormatType.TABLE:
this.current_block = FormatType.TABLE;
this.table_state = new TableState(this);
var lines = consumed_block.split("\n");
this.table_state.feed_line(lines[0]);
this.table_state.feed_line(lines[1]);
this.table_state.feed_line(lines[2]);
chunk_pos += byte_length;
return false;

// In add() at line start when current_block == FormatType.TABLE:
var line = read_rest_of_line();
if (line.contains("|")) {
	this.table_state.feed_line(line);
	chunk_pos += line_byte_length;
} else {
	this.do_block(false, FormatType.TABLE);
	// don't advance – line re-processed as non-table
}

// In handle_line_break when current_block == FormatType.TABLE:
// Do NOT call do_block(false). Flush str; emit \n or nothing; at_line_start = true; advance chunk_pos.

// In do_block for is_start == false, case FormatType.TABLE:
this.renderer.on_table(false);
this.table_state = null;
```

---

## 10. Edge cases

- **Empty cells:**
  - Preparser guarantees line starts and ends with `|`; we substring and split (see §3).
  - Empty cells in the middle are preserved (e.g. `| | b |` → `["", "b", ""]`).

- **Mismatched column counts:**
  - Use **table_alignments** size as the column count.
  - If a row has fewer cells: use align -1 for missing.
  - If a row has more cells:
    - Use index and default -1 when **i >= table_alignments.size**.

- **process_cell_content state_stack:**
  - At end of each cell: pop all state added in the cell and send closing tags (do_format(false, ft)); see §6 Note.

---

## 11. Files to touch (1.10.4 only)

- **libocmarkdown/TableState.vala** – New helper class:
  - Constructor **TableState(Parser parser)**; renderer via **parser.renderer**.
  - State:
    - table_header_line, table_alignments, table_row_index.
  - **parse_table_cells**, **parse_separator_cell_align**.
  - **feed_line(string line)** implements the row/phase logic.
  - **feed_line** fires for each cell:
    - **renderer.on_***.
    - **parser.process_cell_content(cell_text)**.
- **libocmarkdown/Parser.vala**:
  - Add **TableState? table_state**.
  - Expose **process_cell_content(string)**:
    - Internal or same-assembly so TableState can call it.
  - No **handle_table_line** in Parser.
  - Delegation is **table_state.feed_line(line)**.
  - No change to BlockMap or add()/handle_line_break/do_block in this phase:
    - Those are 1.10.5 and 1.10.6.
- **libocmarkdown/meson.build**:
  - Add **TableState.vala** to the library sources.
  - (If it is a separate file.)
