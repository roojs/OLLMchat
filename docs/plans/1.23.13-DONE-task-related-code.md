# 1.23.13 Task-related code (DONE)

**Note:** Do not add sentences to this plan unless specifically asked — only bullet points or nested bullet points.

**Coding standards:** Follow `.cursor/rules/CODING_STANDARDS.md`. Checklist: nullable avoided where possible; null checks only where design requires; no `@"..."`; no one-use temporaries (inline); braces inline for control flow; **this.**; **GLib.** prefix; default init on properties; **string[]** and **joinv** for string arrays; **continue** in loops; no character loops; try/catch only around minimal throwing code; no leading underscore; no get_* accessors. This plan uses: **step.children**, **children.get(0)** (Gee .get()); **steps** as public property (not steps()).

**Location and namespace:** All in **liboccoder/Task/*.vala**, namespace **OLLMcoder.Task**. Class names with Task prefix stripped: **Task** → **Details**, **TaskList** → **List**, **TaskStep** → **Step**, **TaskResultParser** → **ResultParser**. Files: List.vala, Step.vala, Details.vala, ResultParser.vala.

---

## Overview

- Sub-plan of **1.23.11**. Task-related types and behaviour: List, Step, Details, ResultParser, Details-built precursor.
- One class per file. liboccoder/Task/List.vala, Step.vala, Details.vala, ResultParser.vala.

**Status:** DONE — Implementation complete (List, Step, Details, ResultParser in liboccoder/Task/). Outstanding task-class refinements: **1.23.15**.

- **Runner API (1.23.14):** Details calls **reference_content(href)** for non-file refs. Runner must implement **reference_content** for #section, output:task. File refs are resolved in Details via project manager / File.new_fake.

**Dependencies:** 1.23.11 (parent), 1.23.2, 1.23.3–1.23.6 (formats), 1.23.12 (context restriction format).

---

## List (`liboccoder/Task/List.vala`)

- **One class per file.** **Step** → `Step.vala`; **Details** → `Details.vala`.
- **Structure**
  - **Top level always sequential.** List holds an ordered list of **Step**. Each Step is either a single Details or a set of Details (children) that run concurrently.
  - Parser (1.23.3 §2) produces task sections → mapped to Steps (e.g. one section = one Step; section with one task = single, section with multiple tasks = concurrent group).
- **What we wait for (two different things)**
  - **Design: we do NOT wait for all tasks to be refined before starting execution.** Refinement is started for all (refine); then run_until_user_approval / run_all_tasks run immediately. Refinement and execution overlap: e.g. task 1 can be executing while task 2 is still refining. We only wait for **that task's** refinement when we are about to run it (inside run_child: wait_refined first).
  - **Refinement done (per task):** Before running a task we wait for **that task's refinement** only. Done inside **run_child**: first **yield t.wait_refined()**, then run_tools, then post_evaluate.
  - **Execution done (per step):** When a step has multiple children we start several **run_child** (execution) callbacks with .begin(). **wait_exec_done()** waits until **all those executions** for this step are done (num_exec_running reaches 0). So: waiting for **execution** of the current step's children, not for refinement.
  - **Pending exec = no execution result yet:** **has_pending_exec()** is true if any task has **no output** — i.e. that task's **execution** (run_tools + post_evaluate) has not yet completed. Runner uses it to decide whether to do another round or exit.
- **Re-run state**
  - No **previous_proposal** / **previous_proposal_issues** on List; they are local variables in Runner's **prepare_tasks** only (blank first iteration, then set from parser on retry).
- **User approval**
  - Each task is classified as requiring user approval or not. Tasks that modify files (or otherwise need a gate) require user approval; we stop execution at the first such task so the user can approve before continuing. No separate "change tasks" list.
- **API**
  - **has_pending_exec()** — true if any task has no **execution result** (output) yet; early exit. Runner exits loop when `!has_pending_exec()`.
  - **steps** — public property; top-level list of Step (sequential); each step is single task or concurrent group (children). No getter method.
  - **refine(Runner runner)** — async. **Start** refinement for all tasks (each task.refine via .begin). Does **not** block; returns as soon as all are started. run_until_user_approval / run_all_tasks then run; they wait on **wait_refined** only for the task they are about to run (inside run_child).
  - **run_until_user_approval(Runner runner)** — for each Step: if children.size == 1 yield run_child(…); else num_exec_running = children.size, run_child.begin per child, yield **wait_exec_done()**. Stop at first step that has a task requiring user approval (approval gate).
  - **has_tasks_requiring_approval()** — true if any task in any step requires user approval.
  - **run_all_tasks(Runner runner)** — for each Step: if children.size == 1 yield run_child(…); else num_exec_running = children.size, run_child.begin per child, yield **wait_exec_done()**. After the loop, Runner calls **run_task_list_iteration()** directly (no List method).
  - **run_child(Details t, Runner runner)** — private async: **yield t.wait_refined()**, then yield t.run_tools(), yield t.post_evaluate(). Runner sets task properties and callbacks before starting the round; Details does not call runner. When children.size > 1, each .begin callback does run_child.end(res), num_exec_running--.
  - **wait_exec_done()** — yields until **execution** of the current step's children is done (num_exec_running is 0). Caller sets num_exec_running = children.size before starting the .begin() calls.
  - **Execution order**
  - **Refinement:** started once (refine); no blocking until we run a task — then run_child does wait_refined first.
  - **run_until_user_approval / run_all_tasks:** per step, either one run_child (yield) or several run_child.begin + **wait_exec_done**. Top level sequential; within a step, one task or concurrent children. run_until_user_approval stops at the first step that has a task requiring user approval.

**Implementation:** liboccoder/Task/List.vala (class **List**, namespace **OLLMcoder.Task**). Not yet in build.

---

## Step (`liboccoder/Task/Step.vala`)

- **One class per file.** Wrapper: holds list of Details (**children**). Top-level iteration is over Steps; within a step, children run concurrently when children.size > 1.
- **API:** **children** — public list of Details (size 1 = single, >1 = concurrent). **has_task_requiring_approval()** — true if any task in this step requires user approval. **wait_refined()** — async; when children.size == 1, blocks until that task has finished refining. For steps with children.size > 1, each child runs as soon as that task is refined (per-task wait in run_child).

**Implementation:** liboccoder/Task/Step.vala (class **Step**, namespace **OLLMcoder.Task**). Implemented.

---

## Details (`liboccoder/Task/Details.vala`)

- **One class per file.**
- **requires_user_approval** — True when this task should gate execution (e.g. modifies files); classified from skill or task list format. Used for the approval gate (run_until_user_approval stops at first such step) and for **reader_tasks_without_output()** vs **writer_tasks_without_output()** (or equivalent naming).
- **wait_refined()** — async; blocks until this task's refine has completed (so run_tools/post_evaluate can run). Used by single-task step.wait_refined() and by run_child for concurrent children.
- **Details extends OLLMchat.Agent.Base.** Constructor takes (Runner runner, OLLMchat.Agent.Factory factory, OLLMchat.History.SessionBase session); calls base(factory, session); sets this.runner = runner. Runner creates Details with (this, this.factory, this.session) when building the task list from the parser. Details thus has chat_call and uses the normal agent send path (no Runner.send_system_user).
- **refine()** — Details holds **reference to Runner** for context (env(), project description, current_file, task_definition) and for **reference_content(href)** when building the task reference block (non-file refs only; file refs via project manager in Details). Runner validates all skills and populates task_definition before any refinement (1.23.14). Details fills "task_refinement" template, builds messages (Message("system", system_content), Message("user", user_content)), yields **this.chat_call.send(messages)**; parses response.
- **run_tools()** — Details **emits tool_call_requested** (or equivalent) per tool; Runner is connected and executes, returns output via completion. Details stores tool outputs for executor precursor.
- **post_evaluate()** — Details builds executor precursor (reference_contents() + tool_outputs); reads task_definition from Runner. Details builds system/user messages, yields **this.chat_call.send(messages)**; sets **this.result_parser = new ResultParser(this.runner, response_text)**, calls **result_parser.extract_exec(this)**; on success sets **this.exec_done = true**. Output: **task.result**, **task.result_document**.

- **Implementation:** liboccoder/Task/Details.vala (class **Details**, namespace **OLLMcoder.Task**). Implemented. Outstanding refinements: **1.23.15**.
- **Tool call** — use existing **OLLMchat.Response.ToolCall** (function.name, function.arguments). Parser attaches refinement code blocks to the task (code_blocks); Details parses code_blocks into tool_calls (e.g. when run_tools runs).
- **Runner** holds shared context (env(), project_manager, current_file) and exposes **reference_content(string href)** for non-file refs (#section, output:task). Runner holds per-task **task_definition**. **Details extends OLLMchat.Agent.Base**: Details uses **this.chat_call.send(messages)** for refine and post_evaluate (no send_system_user on Runner). Runner performs tool execution when Details requests it (tool_call_requested or equivalent). Details builds the refinement reference block by looping reference_targets: file paths via project manager (or File.new_fake), non-file via Runner.reference_content; Details builds the **executor** precursor itself (reference_contents() + tool_outputs), not from Runner (see below).

**Building the task reference block (Details' job)**

- Task creation outputs tasks whose **References** field contains link items (e.g. `[Project description](project_description)`, `[Current file](current_file)`, file paths, plan sections). The task list parser turns those into a list of **reference targets** per task (`reference_targets` on Details).
- It is the **Details'** job to **build** the resolved reference block for refinement. The **Details** loops through its `reference_targets`: absolute paths → project manager (or File.new_fake) + get_contents; non-file (#section, output:task) → **Runner.reference_content(href)**. Runner does not build or store the block.
- Details assembles the returned content (in reference order) into a single block and uses it when filling the refinement template (e.g. as `task_reference_contents`). So: Details builds it; Runner is the data source for the individual items. For the **executor** prompt, Details builds the precursor from the **same** reference content (reference_contents()) plus this task's **tool_outputs** (each as a headed code block, same format); info comes from Details (refs already built as in refine, tool_outputs from run_tools). No separate Runner-held task_precursor.
- **Reference content format:** Each resolved reference is output as a **header** (e.g. `### target`) plus the **body in a fenced code block**. So the refinement prompt receives a series of headed code blocks. **Nested code block markers:** If the body itself contains ``` at line start, that would close our fence. Per CommonMark: use a **longer or different fence** for the wrapper — in reference_block: if content has ``` at line start use `~~~~`, otherwise use ```.

---

## Task list output format (headings) — from 1.23.3; prompt updates in 1.23.14

- **Required ## section headings (exact text):** **Original prompt**, **Goals / summary**, **General information for all tasks**, **Tasks**. Optional when rectifying: **Issues with the tasks (rectified)**.
- **Under ## Tasks:** level-3 headings only: **### Task section 1**, **### Task section 2**, … (heading text **Task section 1**, **Task section 2**, etc.). Each such section contains **one list per task with a break between each**: a top-level list where each list item is one task (blank line or structural break between items). Within each list item: a **nested list** with **What is needed**, **Skill**, **References**, **Expected output**. After refinement, section content may be: list, code block, list, code block, … (code block is attached to the previous task). Parser walks section contents; does not stop at first non-list. **1.23.14** must update task-creation and post-completion prompts to require this format (list per task, break between tasks).

---

## New classes (or equivalent)

- **Block.get_links()** — Method on **Markdown.Document.Block**: returns all link nodes in the block (e.g. `Gee.ArrayList<Link>` or equivalent); each link has an **href** (destination). Details uses this to build reference_targets and validate hrefs (no separate collect_link_hrefs on Details).
- **Block.to_markdown()** — Always returns a string, never null.
- **Document.heading_contents(Block heading)** — Returns **only the content nodes** for that section (from after the heading until the next heading of any level; next heading not included). Does not return heading blocks — only content (e.g. List, CodeBlock). Use **document.headings** to get a section by name, then **heading_contents(that_block)** to get that section’s contents.
- **List.to_hashmap()** — Method on **Markdown.Document.List**: for each list item, key = first bold text (e.g. "What is needed"), value = block of remaining elements of that list item. Returns **Gee.Map<string, Markdown.Document.Block>**. Assumes nested list (each item has label then content).
- **ListItem.to_key_map()** — Generic method on **Markdown.Document.ListItem**: returns **Gee.Map<string, Markdown.Document.Block>** (key = first bold label per sub-item or block, value = block of remaining content). Uses nested List.to_hashmap() or parses blocks. Task-list parser and Details use only these exact keys: "What is needed", "Skill", "References", "Expected output", "Requires user approval". No other key format is accepted.
- **Single result parser** — Document is built in the **constructor** from the response string (Markdown.Document.Render). Then **extraction methods** are called to get specific data; they read from the stored document.
  - **Constructor: ResultParser(string response)** — Build the document once: use Markdown.Document.Render, parse(response), store the document. No separate parse step.
  - **parse_task_list(Runner runner)** — Check required sections with **has_key** (Original prompt, Goals / summary, General information for all tasks, Tasks). Iterate **headings** under ## Tasks that start with **Task section**; pass each to **parse_step(runner, heading)**. **parse_step** **walks** **section_heading.contents()** in order: **List** → parse each list item as task (to_key_map), add to step; **CodeBlock** → append to previous task (attach_code_block); other content ignored. Does **not** stop at first non-list. Caller checks **parser.issues == ""** for success (no valid property). **Needs Runner** to build Details instances.
  - **extract_refinement(Details task)** — Update the task from the refinement response (1.23.4). Same pattern as parse_step: (1) Section "Refined task" — heading.contents(), walk for List → first ListItem.to_key_map(), validate required keys (What is needed, Skill, References, Expected output), task.update_props(map). (2) Section "Skill call" — heading.contents(), each Block (FENCED_CODE) → task.attach_code_block(block). Appends to **issues** if sections missing, keys missing, or no fenced blocks. Does not parse into ToolCalls; Details does that. Details.refine() uses: `this.result_parser = new ResultParser(this.runner, response_text); this.result_parser.extract_refinement(this);` then result_parser.issues.
  - **extract_exec(Details task)** — Fill in task.result from "Result summary" section and set task.result_document = this.document. No filename or details parsing. Details.post_evaluate() uses: `this.result_parser = new ResultParser(this.runner, response_text); this.result_parser.extract_exec(this);` then task.result, task.result_document; on success sets this.exec_done = true.
  - One parser instance per response: constructor takes that response and builds the document; caller then calls the relevant extract_* method. Details sets this.result_parser per phase (refine then exec); after exec, task.result and task.result_document hold the output.
  - **Issue messages must include context:** Every string appended to **issues** must tell the LLM **where** in the output the problem is (e.g. "Section \"Task section 1\"", "list item 2", "top-level structure"), **what** is wrong, and **what** to do. Never append a bare error like "Invalid reference" or "No list found" without that context — the LLM cannot guess which section or task is meant.
- **Task list validation (Runner, 1.23.14):** After parse_task_list(), Runner validates (1) **skills** — every task's skill exists; (2) **reference content length** — no task's total resolved reference content may exceed a max; if too long, Runner appends to parser.issues. Runner passes parser.issues as previous_proposal_issues so the task creation prompt receives all errors and can revise the plan accordingly.
- **Template fill**
  - We use the **templating system**: prompt templates define structure; we **fill** placeholders with key-value pairs. **Details** holds a reference to **Runner**. When filling refinement, Details builds the task reference block itself (loops its reference_targets; file refs via project manager, non-file via **reference_content(href)**). Details also reads shared context (env(), project description, current_file) and per-task **task_definition** from Runner; for executor, Details builds precursor from reference_contents() + tool_outputs (see **Building the task reference block**). Header + content helper and fill behaviour (store rendered): see **1.23.17**. Optionally filter by relevance once 1.23.12 defines the format.

**Implementation:** liboccoder/Task/ResultParser.vala (class **ResultParser**, namespace **OLLMcoder.Task**). Implemented. Outstanding refinements: **1.23.15**.

---

## Types to introduce

- **List**, **Step**, **Details** — One class per file (see sections above). Step = wrapper (single task or concurrent set of tasks); top level always sequential.
- **Tool call** — use existing **OLLMchat.Response.ToolCall**; Details parses attached_code_blocks into tool_calls; extract_refinement(Details) only attaches the raw fenced code blocks to the task.
- **Block.contents()** — Method on the section heading (Block) returns content nodes until the next heading. Return type e.g. Gee.ArrayList&lt;Node&gt;. Not on Document.
- **List.to_hashmap()** — Returns Gee.Map&lt;string, Block&gt;: key = first bold text per list item, value = block of remaining elements (nested list structure).
- **ListItem.to_key_map()** — Generic: returns **Gee.Map<string, Markdown.Document.Block>** (key = bold label, value = block). Parser and Details use only these exact keys: "What is needed", "Skill", "References", "Expected output", "Requires user approval". No other format is accepted.
- **Block.get_links()** — Returns all link nodes in the block (each has .href). Details uses this to build reference_targets and validate hrefs.
- **Block.to_markdown()** — Always returns a string, never null.
- **Details(Runner, Factory, Session, Gee.Map<string, Markdown.Document.Block> task_data)** — Constructor stores **this.task_data = task_data**, clears issues, then calls **extract_references()**. **update_props(refined_map)** clears issues, sets each entry from refined_map into task_data, then calls **extract_references()**. **extract_references()** — private; reads task_data.get("References"), get_links(), validates hrefs, fills reference_targets, appends to issues with this.issues += "\n" + msg on invalid. No separate what_is_needed/skill_name etc.; all content read from task_data (getters). **attach_code_block(Block)** / **attached_code_blocks** — parser appends code blocks that follow a task's list in the section (e.g. refinement output).
- **Definition.skill_input_requirements()** — Returns the skill's input-requirements section (e.g. from body under "Input requirements" heading); see 1.23.11 Definition. Details.refine() uses it for `{skill_input_requirements}`.
- **ResultParser** — single class; **constructor(string response)** builds document (Markdown.Document.Render). **issues** is a string; append with this.issues += "\n" + msg on each failure so multiple errors can be reported. **parse_task_list(Runner)** → task_list, proposal, issues. Caller checks parser.issues == "" for success (no **valid** property). **extract_refinement(Details task)** — same walk as parse_step: "Refined task" section → List → first ListItem.to_key_map() → task.update_props(map); Block (FENCED_CODE) → task.attach_code_block. Task reports issues; no requirement for attachments. **extract_exec(Details task)** → task.result, task.result_document; appends to issues if no Result summary section. Runner uses parser.issues for previous_proposal_issues. Task checks result_parser.issues.

---

## References

- 1.23.11 (parent); 1.23.2 (orchestration); 1.23.3 (task creation format); 1.23.4 (refinement); 1.23.5 (post completion format); 1.23.6 (executor format); 1.23.12 (context restriction).
