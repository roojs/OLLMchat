/*
 * Copyright (C) 2026 Alan Knowles <alan@roojs.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

namespace OLLMfiles.SQT
{
	/**
	 * Represents vector metadata stored in SQL database.
	 * 
	 * Maps vector_id (from FAISS) to code location information. This class
	 * provides the link between vector embeddings in FAISS and actual code
	 * locations in source files. Used by both the indexing pipeline (to store
	 * metadata) and search operations (to retrieve code snippets).
	 * 
	 * The class uses SQ.Query for database operations and provides methods
	 * for querying metadata by file_id, element_type, and other filters.
	 * 
	 * == Usage Example ==
	 * 
	 * {{{
	 * // Initialize database schema
	 * VectorMetadata.initDB(sql_db);
	 * 
	 * // Create metadata entry
	 * var metadata = new VectorMetadata() {
	 *     vector_id = 123,
	 *     file_id = file.id,
	 *     start_line = 10,
	 *     end_line = 25,
	 *     element_type = "method",
	 *     element_name = "process_data"
	 * };
	 * metadata.insert(sql_db);
	 * 
	 * // Query metadata
	 * var query = VectorMetadata.query(sql_db);
	 * var results = query.select("SELECT * FROM vector_metadata WHERE file_id = $file_id");
	 * }}}
	 */
	public class VectorMetadata : Object
	{
		/**
		 * ID property for database operations (PRIMARY KEY, auto-increment).
		 * Used by SQ.Query.updateById/deleteId for database operations.
		 * This is automatically generated by the database and should not be set manually.
		 */
		public int64 id { get; set; default = 0; }
		
		/**
		 * Vector ID from FAISS index.
		 * This is the actual property used throughout the codebase for vector operations.
		 * This is separate from the database id and represents the FAISS vector index.
		 */
		public int64 vector_id { get; set; default = 0; }
		
		/**
		 * File ID (references OLLMfiles.File.id).
		 */
		public int64 file_id { get; set; default = 0; }
		
		/**
		 * Starting line number (1-indexed).
		 */
		public int start_line { get; set; default = 0; }
		
		/**
		 * Ending line number (1-indexed).
		 */
		public int end_line { get; set; default = 0; }
		
		/**
		 * Element type (e.g., "class", "method", "function", "property", etc.).
		 */
		public string element_type { get; set; default = ""; }
		
		/**
		 * Element name (e.g., "DatabaseManager", "execute_query", etc.).
		 */
		public string element_name { get; set; default = ""; }
		
		/**
		 * Starting line number of documentation block (1-indexed, optional).
		 * Not stored in database - used for analysis only.
		 * Use -1 to indicate no documentation.
		 */
		public int codedoc_start { get; set; default = -1; }
		
		/**
		 * Ending line number of documentation block (1-indexed, optional).
		 * Not stored in database - used for analysis only.
		 * Use -1 to indicate no documentation.
		 */
		public int codedoc_end { get; set; default = -1; }
		
		/**
		 * Element signature (e.g., "public async void parse() throws GLib.Error").
		 * Not stored in database - used for analysis only.
		 */
		public string signature { get; set; default = ""; }
		
		/**
		 * Namespace that contains this element (e.g., "OLLMvector.Indexing").
		 * Not stored in database - used for analysis only.
		 */
		public string namespace { get; set; default = ""; }
		
		/**
		 * Parent class/struct/interface that contains this element (e.g., "Tree").
		 * Not stored in database - used for analysis only.
		 */
		public string parent_class { get; set; default = ""; }
		
		/**
		 * One-line description generated by LLM analysis.
		 * Stored in database for future rebuild operations.
		 * Empty string if LLM analysis was skipped (e.g., for simple properties, enum types without docs).
		 */
		public string description { get; set; default = ""; }
		
		/**
		 * AST path representing the hierarchical location of the element.
		 * Format: namespace-class-method or namespace-function etc. (using '-' separator).
		 * Empty string for file elements (files don't have AST paths).
		 * Stored in database for search and navigation.
		 */
		public string ast_path { get; set; default = ""; }
		
		/**
		 * MD5 hash of element's code content for change detection.
		 * Empty string for legacy data (before MD5 support was added).
		 * Stored in database for incremental analysis.
		 */
		public string md5_hash { get; set; default = ""; }
		
		/**
		 * Parent VectorMetadata reference (for documentation section hierarchy).
		 * 
		 * Null for document root or code elements (which use parent_class instead).
		 * Used to traverse up the hierarchy to build context headers.
		 */
		public VectorMetadata? parent { get; set; default = null; }
		
		/**
		 * Document category (for documentation files only).
		 * 
		 * Values: "plan", "documentation", "rule", "configuration", "data", "license", "changelog", "other"
		 * Empty string for code elements.
		 */
		public string category { get; set; default = ""; }
		
		/**
		 * Child sections (for documentation files only).
		 * 
		 * Used for top-down traversal during analysis. Empty for leaf sections and code elements.
		 */
		public Gee.ArrayList<VectorMetadata> children { get; private set; default = new Gee.ArrayList<VectorMetadata>(); }
		
		/**
		 * Constructor.
		 */
		public VectorMetadata()
		{
		}
		
		/**
		 * Initialize database table for vector_metadata objects.
		 */
		public static void initDB(SQ.Database db)
		{
			string errmsg;
			// Note: Foreign key constraint removed - file_id references OLLMfiles.File.id
			// but the exact table name/structure may vary. The relationship is maintained
			// at the application level.
			var query = "CREATE TABLE IF NOT EXISTS vector_metadata (" +
				"id INTEGER PRIMARY KEY AUTOINCREMENT, " +
				"vector_id INTEGER NOT NULL, " +
				"file_id INTEGER NOT NULL, " +
				"start_line INTEGER NOT NULL, " +
				"end_line INTEGER NOT NULL, " +
				"element_type TEXT NOT NULL, " +
				"element_name TEXT NOT NULL, " +
				"description TEXT NOT NULL DEFAULT '', " +
				"ast_path TEXT NOT NULL DEFAULT '', " +
				"md5_hash TEXT NOT NULL DEFAULT ''" +
				");";
			if (Sqlite.OK != db.db.exec(query, null, out errmsg)) {
				GLib.warning("Failed to create vector_metadata table: %s", db.db.errmsg());
			}
			
			// Migrate existing databases: add ast_path column if it doesn't exist
			var migrate_ast_path = "ALTER TABLE vector_metadata ADD COLUMN ast_path TEXT NOT NULL DEFAULT ''";
			if (Sqlite.OK != db.db.exec(migrate_ast_path, null, out errmsg)) {
				// Column might already exist, which is fine
				if (!errmsg.contains("duplicate column name")) {
					GLib.debug("Migration note (may be expected): %s", errmsg);
				}
			}
			
			// Migrate existing databases: add md5_hash column if it doesn't exist
			var migrate_md5_hash = "ALTER TABLE vector_metadata ADD COLUMN md5_hash TEXT NOT NULL DEFAULT ''";
			if (Sqlite.OK != db.db.exec(migrate_md5_hash, null, out errmsg)) {
				// Column might already exist, which is fine
				if (!errmsg.contains("duplicate column name")) {
					GLib.debug("Migration note (may be expected): %s", errmsg);
				}
			}
			
			// Migrate: add category column if it doesn't exist
			var migrate_category = "ALTER TABLE vector_metadata ADD COLUMN category TEXT NOT NULL DEFAULT ''";
			if (Sqlite.OK != db.db.exec(migrate_category, null, out errmsg)) {
				if (!errmsg.contains("duplicate column name")) {
					GLib.debug("Migration note (may be expected): %s", errmsg);
				}
			}
			
			// Note: parent and children are not stored in database (runtime-only references)
			// They are reconstructed from ast_path hierarchy during analysis
			
			// Create indexes for efficient lookups
			if (Sqlite.OK != db.db.exec(
				"CREATE INDEX IF NOT EXISTS idx_vector_metadata_file_id ON vector_metadata(file_id);",
				null,
				out errmsg
			)) {
				GLib.warning("Failed to create index: %s", db.db.errmsg());
			}
			if (Sqlite.OK != db.db.exec(
				"CREATE INDEX IF NOT EXISTS idx_vector_metadata_vector_id ON vector_metadata(vector_id);",
				null,
				out errmsg
			)) {
				GLib.warning("Failed to create index: %s", db.db.errmsg());
			}
		}
		
		/**
		 * Create a query object for vector_metadata table.
		 * 
		 * @param db The database instance
		 * @return A configured Query object ready to use
		 */
		public static SQ.Query<VectorMetadata> query(SQ.Database db)
		{
			return new SQ.Query<VectorMetadata>(db, "vector_metadata");
		}
		
		/**
		 * Save this VectorMetadata to the database.
		 * 
		 * @param db The database instance
		 * @param sync Whether to sync database to disk after save
		 */
		public void saveToDB(SQ.Database db, bool sync = false)
		{
			var sq = VectorMetadata.query(db);
			if (this.id <= 0) {
				// Insert new record - id will be auto-generated by database
				this.id = sq.insert(this);
			} else {
				// Update existing record
				sq.updateById(this);
			}
			
			// Backup in-memory database to disk only if sync is true
			if (sync) {
				db.backupDB();
			}
		}
		
		/**
		 * Remove this VectorMetadata from the database.
		 * 
		 * @param db The database instance
		 */
		public void removeFromDB(SQ.Database db)
		{
			if (this.id <= 0) {
				return;
			}
			VectorMetadata.query(db).deleteId(this.id);
		}
		
		/**
		 * Generic lookup method for vector metadata.
		 * 
		 * @param db The database instance
		 * @param key The column name to search (e.g., "id", "vector_id", "file_id")
		 * @param value The value to search for
		 * @return VectorMetadata object, or null if not found
		 */
		public static VectorMetadata? lookup(
			SQ.Database db,
			string key,
			int64 value
		)
		{
			var results = new Gee.ArrayList<VectorMetadata>();
			VectorMetadata.query(db).select("WHERE " + key + " = " + value.to_string(), results);
			if (results.size > 0) {
				return results[0];
			}
			return null;
		}
		
		/**
		 * Lookup metadata for multiple vector_ids (for search results).
		 * 
		 * @param db The database instance
		 * @param vector_ids Array of vector IDs to lookup
		 * @return List of VectorMetadata objects, ordered by id
		 */
		public static Gee.ArrayList<VectorMetadata> lookup_vectors(
			SQ.Database db,
			int64[] vector_ids
		)
		{
			if (vector_ids.length == 0) {
				return new Gee.ArrayList<VectorMetadata>();
			}
			
			// Build WHERE clause with OR conditions
			var conditions = new Gee.ArrayList<string>();
			for (int i = 0; i < vector_ids.length; i++) {
				conditions.add("vector_id = " + vector_ids[i].to_string());
			}
			
			var results = new Gee.ArrayList<VectorMetadata>();
			VectorMetadata.query(db).select(
				"WHERE " + string.joinv(" OR ", conditions.to_array()),
				results
			);
			return results;
		}
		
		/**
		 * Lookup AST path across multiple files (for codebase search).
		 * 
		 * Searches for metadata entries matching the given AST path within the specified files.
		 * Tries exact match first, then falls back to suffix matching (finds paths that end with the search path).
		 * 
		 * @param db The database instance
		 * @param file_ids Array of file IDs to search within (empty array searches all files)
		 * @param ast_path AST path to search for (e.g., "Namespace-Class-Method")
		 * @return List of VectorMetadata objects matching the AST path, ordered by exact matches first
		 */
		public static Gee.ArrayList<VectorMetadata> lookup_path(
			SQ.Database db,
			int64[] file_ids,
			string ast_path
		)
		{
			var results = new Gee.ArrayList<VectorMetadata>();
			
			// Build file_id list for IN clause
			string[] file_id_strings = {};
			foreach (var file_id in file_ids) {
				file_id_strings += file_id.to_string();
			}
			
			// Escape ast_path for SQL (replace single quotes with two single quotes)
			var escaped_path = ast_path.replace("'", "''");
			
			// Use SQ.Query API to execute query and populate objects
			var query = VectorMetadata.query(db);
			var stmt = query.selectPrepare(
				"SELECT * FROM vector_metadata " +
				"WHERE " +
				(file_ids.length > 0 ? "file_id IN (" + string.joinv(",", file_id_strings) + ") AND " : "") +
				"(ast_path = '" + escaped_path + "' OR ast_path LIKE '%" + escaped_path + "%') " +
				"ORDER BY CASE WHEN (ast_path = '" + escaped_path + "') THEN 1 ELSE 0 END DESC"
			);
			query.selectExecute(stmt, results);
			
			return results;
		}
		
		/**
		 * Get all vector_ids from the metadata table.
		 * 
		 * @param db The database instance
		 * @return Set of all vector_ids that have metadata entries
		 */
		public static Gee.HashSet<int64?> get_all_vector_ids(SQ.Database db)
		{
			var results = new Gee.ArrayList<VectorMetadata>();
			VectorMetadata.query(db).select("", results);
			
			var vector_ids = new Gee.HashSet<int64?>();
			foreach (var metadata in results) {
				vector_ids.add(metadata.vector_id);
			}
			return vector_ids;
		}
		
		/**
		 * Gets section context by traversing up the parent chain.
		 * 
		 * Collects descriptions from all parent sections and returns them as a formatted string.
		 * Used to build SECTION CONTEXT headers for documentation chunks.
		 * 
		 * @return Formatted context string, or empty string if no parents
		 */
		public string get_section_context()
		{
			// Early return: no parent
			if (this.parent == null) {
				return "";
			}
			
			// Get parent's context first (recursive call - goes up the chain)
			var parent_context = this.parent.get_section_context();
			
			// Get current parent's description
			var current_desc = this.parent.description;
			
			// Build result: parent context (if any) > current description
			// This builds from outermost to innermost as we recurse back down
			if (parent_context != "" && current_desc != "") {
				return parent_context + " > " + current_desc;
			}
			
			if (current_desc != "") {
				return current_desc;
			}
			
			return parent_context;
		}
		
		/**
		 * Resets the vector database.
		 * 
		 * Deletes the FAISS vector database file (if it exists), deletes all vector metadata,
		 * and resets all file scan dates to -1.
		 * 
		 * @param sql_db The SQLite database
		 * @param vector_db_path Path to the FAISS vector database file
		 */
		public static void reset_database(SQ.Database sql_db, string vector_db_path) throws GLib.Error
		{
			// Delete FAISS vector database file (ignore if doesn't exist)
			var vector_db_file = GLib.File.new_for_path(vector_db_path);
			if (vector_db_file.query_exists()) {
				vector_db_file.delete();
			}
			
			// Delete metadata and reset scan dates
			sql_db.exec("DELETE FROM vector_metadata");
			sql_db.exec("UPDATE filebase SET last_vector_scan = -1 WHERE base_type = 'f'");
			
			// Sync database to disk after reset
			sql_db.backupDB();
		}
		
		/**
		 * Remove vector_metadata entries for all deleted files.
		 * 
		 * Uses a bulk DELETE query to efficiently remove all vector_metadata entries
		 * that reference deleted files. Only removes metadata for files (base_type = 'f'),
		 * not folders.
		 * 
		 * Called automatically via DeleteManager.on_cleanup signal after
		 * DeleteManager.cleanup() completes.
		 * 
		 * Can also be called on startup or periodically to ensure consistency.
		 * 
		 * @param db The database instance
		 */
		public static async void cleanup_all_deleted(SQ.Database db)
		{
			// Bulk DELETE query: remove all vector_metadata entries for deleted files
			// Only delete metadata for files (base_type = 'f'), not folders
			var delete_query = "DELETE FROM vector_metadata WHERE file_id IN (" +
				"SELECT id FROM filebase WHERE delete_id > 0 AND base_type = 'f'" +
				")";
			
			string errmsg;
			if (Sqlite.OK != db.db.exec(delete_query, null, out errmsg)) {
				GLib.warning("VectorMetadata.cleanup_all_deleted: Failed to delete metadata: %s", errmsg);
				return;
			}
			
			// Sync database to disk after cleanup
			db.backupDB();
		}
	}
}
